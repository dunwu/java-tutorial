(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[]]);!function(n){function e(e){for(var a,o,s=e[0],l=e[1],c=e[2],d=0,u=[];d<s.length;d++)o=s[d],Object.prototype.hasOwnProperty.call(r,o)&&r[o]&&u.push(r[o][0]),r[o]=0;for(a in l)Object.prototype.hasOwnProperty.call(l,a)&&(n[a]=l[a]);for(p&&p(e);u.length;)u.shift()();return i.push.apply(i,c||[]),t()}function t(){for(var n,e=0;e<i.length;e++){for(var t=i[e],a=!0,s=1;s<t.length;s++){var l=t[s];0!==r[l]&&(a=!1)}a&&(i.splice(e--,1),n=o(o.s=t[0]))}return n}var a={},r={1:0},i=[];function o(e){if(a[e])return a[e].exports;var t=a[e]={i:e,l:!1,exports:{}};return n[e].call(t.exports,t,t.exports,o),t.l=!0,t.exports}o.e=function(n){var e=[],t=r[n];if(0!==t)if(t)e.push(t[2]);else{var a=new Promise((function(e,a){t=r[n]=[e,a]}));e.push(t[2]=a);var i,s=document.createElement("script");s.charset="utf-8",s.timeout=120,o.nc&&s.setAttribute("nonce",o.nc),s.src=function(n){return o.p+"assets/js/"+({}[n]||n)+"."+{2:"bc9223e0",3:"1f5cc974",4:"d163695c",5:"cf5cb583",6:"d144eb92",7:"f2dc074f",8:"e2e9dd66",9:"9ce755cc",10:"9edf914b",11:"f9f5b03a",12:"5c15bdc6",13:"581f93fb",14:"67210f72",15:"f02a1ad1",16:"e64fab55",17:"e6ca686c",18:"8f0b0ab4",19:"091524f7",20:"b2650a4f",21:"1df4f842",22:"bbf93466",23:"e5a6c9e1",24:"7a6a1ab1",25:"05ce92da",26:"cc0a008a",27:"19032685",28:"b2bb31ab",29:"e89cf580",30:"e72522ac",31:"23bc8c03",32:"b536a066",33:"ebee4849",34:"c85865c5",35:"ebc1fb00",36:"68e02904",37:"674930ad",38:"8d6a8a9f",39:"797eb403",40:"d28b7496",41:"ce6ca6c6",42:"273291d5",43:"5e461285",44:"971cad76",45:"8e0c71aa",46:"f5577b26",47:"f71cc3c9",48:"a8578d32",49:"0e290971",50:"b5439840",51:"3afc4e67",52:"52ce1139",53:"e1cc5362",54:"fd9608e5",55:"632b6016",56:"e9aa4eea",57:"c0d1542e",58:"bc0f7c1c",59:"36b207a0",60:"89446b88",61:"f110e04e",62:"62d349c4",63:"834fb95c",64:"e0fa19b4",65:"ff3773a7",66:"45b99ef4",67:"8ad9ddbe",68:"a0b09a76",69:"bc43b589",70:"38a10912",71:"fe10a220",72:"0c0ade29",73:"fbe5d03a",74:"f058f74c",75:"de33a550",76:"e3fbc3d6",77:"15bc7ae4",78:"c9176f76",79:"a8e94c89",80:"88799756",81:"02a75d13",82:"26bfc230",83:"ef23783d",84:"7768ab87",85:"166bc923",86:"a0082b69",87:"f1a7edaf",88:"280451ae",89:"c22d4323",90:"c3ef04cb",91:"af01336c",92:"6459c6be",93:"366fa5d5",94:"29bb3af2",95:"c8acb7ef",96:"02c8387a",97:"f3fe9a9b",98:"0158ff39",99:"d9478ffd",100:"ccc9a903",101:"183df0d3",102:"72154a73",103:"e83801db",104:"37a7b1ee",105:"2f58df41",106:"a9afdc16",107:"a78ef136",108:"2b5c1e35",109:"3e36e9e8",110:"38a5c579",111:"b42b4984",112:"a6fdaf7c",113:"977f8481",114:"c37d8374",115:"adbb31d7",116:"e53d9383",117:"bc43cd18",118:"80cf3c9b",119:"17d1d3ef",120:"fb2ee254",121:"f36932f6",122:"cf1fe750",123:"7dd5179b",124:"b11f012a",125:"10278b2b",126:"ab14f44c",127:"5ba17976",128:"af3c1a70",129:"ace640fd",130:"f9a86620",131:"45c339b9",132:"4c2730f0",133:"c65beba5",134:"41643697",135:"4c938701",136:"f32614a8",137:"79410813"}[n]+".js"}(n);var l=new Error;i=function(e){s.onerror=s.onload=null,clearTimeout(c);var t=r[n];if(0!==t){if(t){var a=e&&("load"===e.type?"missing":e.type),i=e&&e.target&&e.target.src;l.message="Loading chunk "+n+" failed.\n("+a+": "+i+")",l.name="ChunkLoadError",l.type=a,l.request=i,t[1](l)}r[n]=void 0}};var c=setTimeout((function(){i({type:"timeout",target:s})}),12e4);s.onerror=s.onload=i,document.head.appendChild(s)}return Promise.all(e)},o.m=n,o.c=a,o.d=function(n,e,t){o.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},o.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},o.t=function(n,e){if(1&e&&(n=o(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(o.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var a in n)o.d(t,a,function(e){return n[e]}.bind(null,a));return t},o.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return o.d(e,"a",e),e},o.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},o.p="/java-tutorial/",o.oe=function(n){throw console.error(n),n};var s=window.webpackJsonp=window.webpackJsonp||[],l=s.push.bind(s);s.push=e,s=s.slice();for(var c=0;c<s.length;c++)e(s[c]);var p=l;i.push([126,0]),t()}([function(n,e,t){"use strict";var a="object"==typeof document&&document.all;n.exports=void 0===a&&void 0!==a?function(n){return"function"==typeof n||n===a}:function(n){return"function"==typeof n}},function(n,e,t){"use strict";var a=t(8),r=String,i=TypeError;n.exports=function(n){if(a(n))return n;throw new i(r(n)+" is not an object")}},function(n,e,t){"use strict";var a=function(n){return n&&n.Math===Math&&n};n.exports=a("object"==typeof globalThis&&globalThis)||a("object"==typeof window&&window)||a("object"==typeof self&&self)||a("object"==typeof global&&global)||a("object"==typeof this&&this)||function(){return this}()||Function("return this")()},function(n,e,t){"use strict";n.exports=function(n){try{return!!n()}catch(n){return!0}}},function(n,e,t){"use strict";t(127)},function(n,e,t){"use strict";var a=t(32),r=Function.prototype,i=r.call,o=a&&r.bind.bind(i,i);n.exports=a?o:function(n){return function(){return i.apply(n,arguments)}}},function(n,e,t){"use strict";var a=t(3);n.exports=!a((function(){return 7!==Object.defineProperty({},1,{get:function(){return 7}})[1]}))},function(n,e,t){"use strict";var a=t(0),r=t(48),i=TypeError;n.exports=function(n){if(a(n))return n;throw new i(r(n)+" is not a function")}},function(n,e,t){"use strict";var a=t(0);n.exports=function(n){return"object"==typeof n?null!==n:a(n)}},function(n,e,t){"use strict";var a=t(5),r=t(30),i=a({}.hasOwnProperty);n.exports=Object.hasOwn||function(n,e){return i(r(n),e)}},function(n,e,t){"use strict";var a=t(2),r=t(69).f,i=t(24),o=t(44),s=t(50),l=t(83),c=t(141);n.exports=function(n,e){var t,p,d,u,m,g=n.target,h=n.global,v=n.stat;if(t=h?a:v?a[g]||s(g,{}):a[g]&&a[g].prototype)for(p in e){if(u=e[p],d=n.dontCallGetSet?(m=r(t,p))&&m.value:t[p],!c(h?p:g+(v?".":"#")+p,n.forced)&&void 0!==d){if(typeof u==typeof d)continue;l(u,d)}(n.sham||d&&d.sham)&&i(u,"sham",!0),o(t,p,u,n)}}},function(n,e){var t=Array.isArray;n.exports=t},function(n,e,t){"use strict";var a=t(32),r=Function.prototype.call;n.exports=a?r.bind(r):function(){return r.apply(r,arguments)}},function(n,e,t){var a=t(95),r="object"==typeof self&&self&&self.Object===Object&&self,i=a||r||Function("return this")();n.exports=i},function(n,e,t){"use strict";function a(n,e,t,a,r,i,o,s){var l,c="function"==typeof n?n.options:n;if(e&&(c.render=e,c.staticRenderFns=t,c._compiled=!0),a&&(c.functional=!0),i&&(c._scopeId="data-v-"+i),o?(l=function(n){(n=n||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(n=__VUE_SSR_CONTEXT__),r&&r.call(this,n),n&&n._registeredComponents&&n._registeredComponents.add(o)},c._ssrRegister=l):r&&(l=s?function(){r.call(this,(c.functional?this.parent:this).$root.$options.shadowRoot)}:r),l)if(c.functional){c._injectStyles=l;var p=c.render;c.render=function(n,e){return l.call(e),p(n,e)}}else{var d=c.beforeCreate;c.beforeCreate=d?[].concat(d,l):[l]}return{exports:n,options:c}}t.d(e,"a",(function(){return a}))},function(n,e,t){"use strict";t(148)},function(n,e,t){"use strict";var a=t(2),r=t(76),i=t(9),o=t(77),s=t(73),l=t(72),c=a.Symbol,p=r("wks"),d=l?c.for||c:c&&c.withoutSetter||o;n.exports=function(n){return i(p,n)||(p[n]=s&&i(c,n)?c[n]:d("Symbol."+n)),p[n]}},function(n,e,t){"use strict";t(158)},function(n,e,t){"use strict";var a=t(6),r=t(78),i=t(80),o=t(1),s=t(70),l=TypeError,c=Object.defineProperty,p=Object.getOwnPropertyDescriptor;e.f=a?i?function(n,e,t){if(o(n),e=s(e),o(t),"function"==typeof n&&"prototype"===e&&"value"in t&&"writable"in t&&!t.writable){var a=p(n,e);a&&a.writable&&(n[e]=t.value,t={configurable:"configurable"in t?t.configurable:a.configurable,enumerable:"enumerable"in t?t.enumerable:a.enumerable,writable:!1})}return c(n,e,t)}:c:function(n,e,t){if(o(n),e=s(e),o(t),r)try{return c(n,e,t)}catch(n){}if("get"in t||"set"in t)throw new l("Accessors not supported");return"value"in t&&(n[e]=t.value),n}},function(n,e,t){var a=t(199),r=t(202);n.exports=function(n,e){var t=r(n,e);return a(t)?t:void 0}},function(n,e,t){"use strict";t.d(e,"e",(function(){return a})),t.d(e,"b",(function(){return i})),t.d(e,"j",(function(){return o})),t.d(e,"g",(function(){return l})),t.d(e,"h",(function(){return c})),t.d(e,"i",(function(){return p})),t.d(e,"c",(function(){return d})),t.d(e,"f",(function(){return u})),t.d(e,"l",(function(){return m})),t.d(e,"m",(function(){return g})),t.d(e,"d",(function(){return v})),t.d(e,"k",(function(){return b})),t.d(e,"n",(function(){return f})),t.d(e,"a",(function(){return x}));t(29),t(4),t(15),t(17),t(21);const a=/#.*$/,r=/\.(md|html)$/,i=/\/$/,o=/^[a-z]+:/i;function s(n){return decodeURI(n).replace(a,"").replace(r,"")}function l(n){return o.test(n)}function c(n){return/^mailto:/.test(n)}function p(n){return/^tel:/.test(n)}function d(n){if(l(n))return n;if(!n)return"404";const e=n.match(a),t=e?e[0]:"",r=s(n);return i.test(r)?n:r+".html"+t}function u(n,e){const t=n.hash,r=function(n){const e=n&&n.match(a);if(e)return e[0]}(e);if(r&&t!==r)return!1;return s(n.path)===s(e)}function m(n,e,t){if(l(e))return{type:"external",path:e};t&&(e=function(n,e,t){const a=n.charAt(0);if("/"===a)return n;if("?"===a||"#"===a)return e+n;const r=e.split("/");t&&r[r.length-1]||r.pop();const i=n.replace(/^\//,"").split("/");for(let n=0;n<i.length;n++){const e=i[n];".."===e?r.pop():"."!==e&&r.push(e)}""!==r[0]&&r.unshift("");return r.join("/")}(e,t));const a=s(e);for(let e=0;e<n.length;e++)if(s(n[e].regularPath)===a)return Object.assign({},n[e],{type:"page",path:d(n[e].path)});return console.error(`[vuepress] No matching page found for sidebar item "${e}"`),{}}function g(n,e,t,a){const{pages:r,themeConfig:i}=t,o=a&&i.locales&&i.locales[a]||i;if("auto"===(n.frontmatter.sidebar||o.sidebar||i.sidebar))return h(n);const s=o.sidebar||i.sidebar;if(s){const{base:t,config:a}=function(n,e){if(Array.isArray(e))return{base:"/",config:e};for(const a in e)if(0===(t=n,/(\.html|\/)$/.test(t)?t:t+"/").indexOf(encodeURI(a)))return{base:a,config:e[a]};var t;return{}}(e,s);return"auto"===a?h(n):a?a.map(n=>function n(e,t,a,r=1){if("string"==typeof e)return m(t,e,a);if(Array.isArray(e))return Object.assign(m(t,e[0],a),{title:e[1]});{r>3&&console.error("[vuepress] detected a too deep nested sidebar group.");const i=e.children||[];return 0===i.length&&e.path?Object.assign(m(t,e.path,a),{title:e.title}):{type:"group",path:e.path,title:e.title,sidebarDepth:e.sidebarDepth,initialOpenGroupIndex:e.initialOpenGroupIndex,children:i.map(e=>n(e,t,a,r+1)),collapsable:!1!==e.collapsable}}}(n,r,t)):[]}return[]}function h(n){const e=v(n.headers||[]);return[{type:"group",collapsable:!1,title:n.title,path:null,children:e.map(e=>({type:"auto",title:e.title,basePath:n.path,path:n.path+"#"+e.slug,children:e.children||[]}))}]}function v(n){let e;return(n=n.map(n=>Object.assign({},n))).forEach(n=>{2===n.level?e=n:e&&(e.children||(e.children=[])).push(n)}),n.filter(n=>2===n.level)}function b(n){return Object.assign(n,{type:n.items&&n.items.length?"links":"link"})}function f(n){return Object.prototype.toString.call(n).match(/\[object (.*?)\]/)[1].toLowerCase()}function y(n){let e=n.frontmatter.date||n.lastUpdated||new Date,t=new Date(e);return"Invalid Date"==t&&e&&(t=new Date(e.replace(/-/g,"/"))),t.getTime()}function x(n,e){return y(e)-y(n)}},function(n,e,t){"use strict";t(151)},function(n,e){n.exports=function(n){return null!=n&&"object"==typeof n}},function(n,e,t){"use strict";n.exports=!1},function(n,e,t){"use strict";var a=t(6),r=t(18),i=t(33);n.exports=a?function(n,e,t){return r.f(n,e,i(1,t))}:function(n,e,t){return n[e]=t,n}},function(n,e,t){"use strict";n.exports=function(n){return{iterator:n,next:n.next,done:!1}}},function(n,e,t){var a=t(28),r=t(184),i=t(185),o=a?a.toStringTag:void 0;n.exports=function(n){return null==n?void 0===n?"[object Undefined]":"[object Null]":o&&o in Object(n)?r(n):i(n)}},function(n,e,t){"use strict";var a=t(5),r=a({}.toString),i=a("".slice);n.exports=function(n){return i(r(n),8,-1)}},function(n,e,t){var a=t(13).Symbol;n.exports=a},function(n,e,t){"use strict";var a=t(10),r=t(30),i=t(31),o=t(178),s=t(180);a({target:"Array",proto:!0,arity:1,forced:t(3)((function(){return 4294967297!==[].push.call({length:4294967296},1)}))||!function(){try{Object.defineProperty([],"length",{writable:!1}).push()}catch(n){return n instanceof TypeError}}()},{push:function(n){var e=r(this),t=i(e),a=arguments.length;s(t+a);for(var l=0;l<a;l++)e[t]=arguments[l],t++;return o(e,t),t}})},function(n,e,t){"use strict";var a=t(46),r=Object;n.exports=function(n){return r(a(n))}},function(n,e,t){"use strict";var a=t(139);n.exports=function(n){return a(n.length)}},function(n,e,t){"use strict";var a=t(3);n.exports=!a((function(){var n=function(){}.bind();return"function"!=typeof n||n.hasOwnProperty("prototype")}))},function(n,e,t){"use strict";n.exports=function(n,e){return{enumerable:!(1&n),configurable:!(2&n),writable:!(4&n),value:e}}},function(n,e,t){"use strict";var a=t(65),r=t(46);n.exports=function(n){return a(r(n))}},function(n,e,t){"use strict";var a=t(2),r=t(0),i=function(n){return r(n)?n:void 0};n.exports=function(n,e){return arguments.length<2?i(a[n]):a[n]&&a[n][e]}},function(n,e,t){"use strict";var a=t(5);n.exports=a({}.isPrototypeOf)},function(n,e,t){"use strict";var a=t(7),r=t(47);n.exports=function(n,e){var t=n[e];return r(t)?void 0:a(t)}},function(n,e,t){var a=t(189),r=t(190),i=t(191),o=t(192),s=t(193);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var a=n[e];this.set(a[0],a[1])}}l.prototype.clear=a,l.prototype.delete=r,l.prototype.get=i,l.prototype.has=o,l.prototype.set=s,n.exports=l},function(n,e,t){var a=t(97);n.exports=function(n,e){for(var t=n.length;t--;)if(a(n[t][0],e))return t;return-1}},function(n,e,t){var a=t(19)(Object,"create");n.exports=a},function(n,e,t){var a=t(211);n.exports=function(n,e){var t=n.__data__;return a(e)?t["string"==typeof e?"string":"hash"]:t.map}},function(n,e,t){var a=t(62);n.exports=function(n){if("string"==typeof n||a(n))return n;var e=n+"";return"0"==e&&1/n==-1/0?"-0":e}},function(n,e,t){var a,r;
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */void 0===(r="function"==typeof(a=function(){var n,e,t={version:"0.2.0"},a=t.settings={minimum:.08,easing:"ease",positionUsing:"",speed:200,trickle:!0,trickleRate:.02,trickleSpeed:800,showSpinner:!0,barSelector:'[role="bar"]',spinnerSelector:'[role="spinner"]',parent:"body",template:'<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'};function r(n,e,t){return n<e?e:n>t?t:n}function i(n){return 100*(-1+n)}t.configure=function(n){var e,t;for(e in n)void 0!==(t=n[e])&&n.hasOwnProperty(e)&&(a[e]=t);return this},t.status=null,t.set=function(n){var e=t.isStarted();n=r(n,a.minimum,1),t.status=1===n?null:n;var l=t.render(!e),c=l.querySelector(a.barSelector),p=a.speed,d=a.easing;return l.offsetWidth,o((function(e){""===a.positionUsing&&(a.positionUsing=t.getPositioningCSS()),s(c,function(n,e,t){var r;return(r="translate3d"===a.positionUsing?{transform:"translate3d("+i(n)+"%,0,0)"}:"translate"===a.positionUsing?{transform:"translate("+i(n)+"%,0)"}:{"margin-left":i(n)+"%"}).transition="all "+e+"ms "+t,r}(n,p,d)),1===n?(s(l,{transition:"none",opacity:1}),l.offsetWidth,setTimeout((function(){s(l,{transition:"all "+p+"ms linear",opacity:0}),setTimeout((function(){t.remove(),e()}),p)}),p)):setTimeout(e,p)})),this},t.isStarted=function(){return"number"==typeof t.status},t.start=function(){t.status||t.set(0);var n=function(){setTimeout((function(){t.status&&(t.trickle(),n())}),a.trickleSpeed)};return a.trickle&&n(),this},t.done=function(n){return n||t.status?t.inc(.3+.5*Math.random()).set(1):this},t.inc=function(n){var e=t.status;return e?("number"!=typeof n&&(n=(1-e)*r(Math.random()*e,.1,.95)),e=r(e+n,0,.994),t.set(e)):t.start()},t.trickle=function(){return t.inc(Math.random()*a.trickleRate)},n=0,e=0,t.promise=function(a){return a&&"resolved"!==a.state()?(0===e&&t.start(),n++,e++,a.always((function(){0==--e?(n=0,t.done()):t.set((n-e)/n)})),this):this},t.render=function(n){if(t.isRendered())return document.getElementById("nprogress");c(document.documentElement,"nprogress-busy");var e=document.createElement("div");e.id="nprogress",e.innerHTML=a.template;var r,o=e.querySelector(a.barSelector),l=n?"-100":i(t.status||0),p=document.querySelector(a.parent);return s(o,{transition:"all 0 linear",transform:"translate3d("+l+"%,0,0)"}),a.showSpinner||(r=e.querySelector(a.spinnerSelector))&&u(r),p!=document.body&&c(p,"nprogress-custom-parent"),p.appendChild(e),e},t.remove=function(){p(document.documentElement,"nprogress-busy"),p(document.querySelector(a.parent),"nprogress-custom-parent");var n=document.getElementById("nprogress");n&&u(n)},t.isRendered=function(){return!!document.getElementById("nprogress")},t.getPositioningCSS=function(){var n=document.body.style,e="WebkitTransform"in n?"Webkit":"MozTransform"in n?"Moz":"msTransform"in n?"ms":"OTransform"in n?"O":"";return e+"Perspective"in n?"translate3d":e+"Transform"in n?"translate":"margin"};var o=function(){var n=[];function e(){var t=n.shift();t&&t(e)}return function(t){n.push(t),1==n.length&&e()}}(),s=function(){var n=["Webkit","O","Moz","ms"],e={};function t(t){return t=t.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,(function(n,e){return e.toUpperCase()})),e[t]||(e[t]=function(e){var t=document.body.style;if(e in t)return e;for(var a,r=n.length,i=e.charAt(0).toUpperCase()+e.slice(1);r--;)if((a=n[r]+i)in t)return a;return e}(t))}function a(n,e,a){e=t(e),n.style[e]=a}return function(n,e){var t,r,i=arguments;if(2==i.length)for(t in e)void 0!==(r=e[t])&&e.hasOwnProperty(t)&&a(n,t,r);else a(n,i[1],i[2])}}();function l(n,e){return("string"==typeof n?n:d(n)).indexOf(" "+e+" ")>=0}function c(n,e){var t=d(n),a=t+e;l(t,e)||(n.className=a.substring(1))}function p(n,e){var t,a=d(n);l(n,e)&&(t=a.replace(" "+e+" "," "),n.className=t.substring(1,t.length-1))}function d(n){return(" "+(n.className||"")+" ").replace(/\s+/gi," ")}function u(n){n&&n.parentNode&&n.parentNode.removeChild(n)}return t})?a.call(e,t,e,n):a)||(n.exports=r)},function(n,e,t){"use strict";var a=t(0),r=t(18),i=t(81),o=t(50);n.exports=function(n,e,t,s){s||(s={});var l=s.enumerable,c=void 0!==s.name?s.name:e;if(a(t)&&i(t,c,s),s.global)l?n[e]=t:o(e,t);else{try{s.unsafe?n[e]&&(l=!0):delete n[e]}catch(n){}l?n[e]=t:r.f(n,e,{value:t,enumerable:!1,configurable:!s.nonConfigurable,writable:!s.nonWritable})}return n}},function(n,e,t){"use strict";var a=t(124),r=t(12),i=t(1),o=t(48),s=t(160),l=t(31),c=t(36),p=t(161),d=t(91),u=t(54),m=TypeError,g=function(n,e){this.stopped=n,this.result=e},h=g.prototype;n.exports=function(n,e,t){var v,b,f,y,x,S,w,j=t&&t.that,k=!(!t||!t.AS_ENTRIES),T=!(!t||!t.IS_RECORD),I=!(!t||!t.IS_ITERATOR),C=!(!t||!t.INTERRUPTED),E=a(e,j),A=function(n){return v&&u(v,"normal",n),new g(!0,n)},P=function(n){return k?(i(n),C?E(n[0],n[1],A):E(n[0],n[1])):C?E(n,A):E(n)};if(T)v=n.iterator;else if(I)v=n;else{if(!(b=d(n)))throw new m(o(n)+" is not iterable");if(s(b)){for(f=0,y=l(n);y>f;f++)if((x=P(n[f]))&&c(h,x))return x;return new g(!1)}v=p(n,b)}for(S=T?n.next:v.next;!(w=r(S,v)).done;){try{x=P(w.value)}catch(n){u(v,"throw",n)}if("object"==typeof x&&x&&c(h,x))return x}return new g(!1)}},function(n,e,t){"use strict";var a=t(47),r=TypeError;n.exports=function(n){if(a(n))throw new r("Can't call method on "+n);return n}},function(n,e,t){"use strict";n.exports=function(n){return null==n}},function(n,e,t){"use strict";var a=String;n.exports=function(n){try{return a(n)}catch(n){return"Object"}}},function(n,e,t){"use strict";var a=t(23),r=t(2),i=t(50),o=n.exports=r["__core-js_shared__"]||i("__core-js_shared__",{});(o.versions||(o.versions=[])).push({version:"3.39.0",mode:a?"pure":"global",copyright:"© 2014-2024 Denis Pushkarev (zloirock.ru)",license:"https://github.com/zloirock/core-js/blob/v3.39.0/LICENSE",source:"https://github.com/zloirock/core-js"})},function(n,e,t){"use strict";var a=t(2),r=Object.defineProperty;n.exports=function(n,e){try{r(a,n,{value:e,configurable:!0,writable:!0})}catch(t){a[n]=e}return e}},function(n,e,t){"use strict";var a=t(76),r=t(77),i=a("keys");n.exports=function(n){return i[n]||(i[n]=r(n))}},function(n,e,t){"use strict";n.exports={}},function(n,e,t){"use strict";n.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},function(n,e,t){"use strict";var a=t(12),r=t(1),i=t(37);n.exports=function(n,e,t){var o,s;r(n);try{if(!(o=i(n,"return"))){if("throw"===e)throw t;return t}o=a(o,n)}catch(n){s=!0,o=n}if("throw"===e)throw t;if(s)throw o;return r(o),t}},function(n,e,t){var a=t(183),r=t(22),i=Object.prototype,o=i.hasOwnProperty,s=i.propertyIsEnumerable,l=a(function(){return arguments}())?a:function(n){return r(n)&&o.call(n,"callee")&&!s.call(n,"callee")};n.exports=l},function(n,e,t){var a=t(19)(t(13),"Map");n.exports=a},function(n,e){n.exports=function(n){var e=typeof n;return null!=n&&("object"==e||"function"==e)}},function(n,e,t){var a=t(203),r=t(210),i=t(212),o=t(213),s=t(214);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var a=n[e];this.set(a[0],a[1])}}l.prototype.clear=a,l.prototype.delete=r,l.prototype.get=i,l.prototype.has=o,l.prototype.set=s,n.exports=l},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n){t[++e]=n})),t}},function(n,e){n.exports=function(n){return"number"==typeof n&&n>-1&&n%1==0&&n<=9007199254740991}},function(n,e,t){var a=t(11),r=t(62),i=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,o=/^\w*$/;n.exports=function(n,e){if(a(n))return!1;var t=typeof n;return!("number"!=t&&"symbol"!=t&&"boolean"!=t&&null!=n&&!r(n))||(o.test(n)||!i.test(n)||null!=e&&n in Object(e))}},function(n,e,t){var a=t(26),r=t(22);n.exports=function(n){return"symbol"==typeof n||r(n)&&"[object Symbol]"==a(n)}},function(n,e){n.exports=function(n){return n}},function(n,e,t){"use strict";t(275)},function(n,e,t){"use strict";var a=t(5),r=t(3),i=t(27),o=Object,s=a("".split);n.exports=r((function(){return!o("z").propertyIsEnumerable(0)}))?function(n){return"String"===i(n)?s(n,""):o(n)}:o},function(n,e,t){"use strict";var a,r=t(1),i=t(145),o=t(53),s=t(52),l=t(147),c=t(79),p=t(51),d=p("IE_PROTO"),u=function(){},m=function(n){return"<script>"+n+"<\/script>"},g=function(n){n.write(m("")),n.close();var e=n.parentWindow.Object;return n=null,e},h=function(){try{a=new ActiveXObject("htmlfile")}catch(n){}var n,e;h="undefined"!=typeof document?document.domain&&a?g(a):((e=c("iframe")).style.display="none",l.appendChild(e),e.src=String("javascript:"),(n=e.contentWindow.document).open(),n.write(m("document.F=Object")),n.close(),n.F):g(a);for(var t=o.length;t--;)delete h.prototype[o[t]];return h()};s[d]=!0,n.exports=Object.create||function(n,e){var t;return null!==n?(u.prototype=r(n),t=new u,u.prototype=null,t[d]=n):t=h(),void 0===e?t:i.f(t,e)}},function(n,e){n.exports=function(n){return n.webpackPolyfill||(n.deprecate=function(){},n.paths=[],n.children||(n.children=[]),Object.defineProperty(n,"loaded",{enumerable:!0,get:function(){return n.l}}),Object.defineProperty(n,"id",{enumerable:!0,get:function(){return n.i}}),n.webpackPolyfill=1),n}},function(n,e){var t=/^\s+|\s+$/g,a=/^[-+]0x[0-9a-f]+$/i,r=/^0b[01]+$/i,i=/^0o[0-7]+$/i,o=parseInt,s="object"==typeof global&&global&&global.Object===Object&&global,l="object"==typeof self&&self&&self.Object===Object&&self,c=s||l||Function("return this")(),p=Object.prototype.toString,d=Math.max,u=Math.min,m=function(){return c.Date.now()};function g(n){var e=typeof n;return!!n&&("object"==e||"function"==e)}function h(n){if("number"==typeof n)return n;if(function(n){return"symbol"==typeof n||function(n){return!!n&&"object"==typeof n}(n)&&"[object Symbol]"==p.call(n)}(n))return NaN;if(g(n)){var e="function"==typeof n.valueOf?n.valueOf():n;n=g(e)?e+"":e}if("string"!=typeof n)return 0===n?n:+n;n=n.replace(t,"");var s=r.test(n);return s||i.test(n)?o(n.slice(2),s?2:8):a.test(n)?NaN:+n}n.exports=function(n,e,t){var a,r,i,o,s,l,c=0,p=!1,v=!1,b=!0;if("function"!=typeof n)throw new TypeError("Expected a function");function f(e){var t=a,i=r;return a=r=void 0,c=e,o=n.apply(i,t)}function y(n){return c=n,s=setTimeout(S,e),p?f(n):o}function x(n){var t=n-l;return void 0===l||t>=e||t<0||v&&n-c>=i}function S(){var n=m();if(x(n))return w(n);s=setTimeout(S,function(n){var t=e-(n-l);return v?u(t,i-(n-c)):t}(n))}function w(n){return s=void 0,b&&a?f(n):(a=r=void 0,o)}function j(){var n=m(),t=x(n);if(a=arguments,r=this,l=n,t){if(void 0===s)return y(l);if(v)return s=setTimeout(S,e),f(l)}return void 0===s&&(s=setTimeout(S,e)),o}return e=h(e)||0,g(t)&&(p=!!t.leading,i=(v="maxWait"in t)?d(h(t.maxWait)||0,e):i,b="trailing"in t?!!t.trailing:b),j.cancel=function(){void 0!==s&&clearTimeout(s),c=0,a=l=r=s=void 0},j.flush=function(){return void 0===s?o:w(m())},j}},function(n,e,t){"use strict";var a=t(6),r=t(12),i=t(128),o=t(33),s=t(34),l=t(70),c=t(9),p=t(78),d=Object.getOwnPropertyDescriptor;e.f=a?d:function(n,e){if(n=s(n),e=l(e),p)try{return d(n,e)}catch(n){}if(c(n,e))return o(!r(i.f,n,e),n[e])}},function(n,e,t){"use strict";var a=t(129),r=t(71);n.exports=function(n){var e=a(n,"string");return r(e)?e:e+""}},function(n,e,t){"use strict";var a=t(35),r=t(0),i=t(36),o=t(72),s=Object;n.exports=o?function(n){return"symbol"==typeof n}:function(n){var e=a("Symbol");return r(e)&&i(e.prototype,s(n))}},function(n,e,t){"use strict";var a=t(73);n.exports=a&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},function(n,e,t){"use strict";var a=t(74),r=t(3),i=t(2).String;n.exports=!!Object.getOwnPropertySymbols&&!r((function(){var n=Symbol("symbol detection");return!i(n)||!(Object(n)instanceof Symbol)||!Symbol.sham&&a&&a<41}))},function(n,e,t){"use strict";var a,r,i=t(2),o=t(75),s=i.process,l=i.Deno,c=s&&s.versions||l&&l.version,p=c&&c.v8;p&&(r=(a=p.split("."))[0]>0&&a[0]<4?1:+(a[0]+a[1])),!r&&o&&(!(a=o.match(/Edge\/(\d+)/))||a[1]>=74)&&(a=o.match(/Chrome\/(\d+)/))&&(r=+a[1]),n.exports=r},function(n,e,t){"use strict";var a=t(2).navigator,r=a&&a.userAgent;n.exports=r?String(r):""},function(n,e,t){"use strict";var a=t(49);n.exports=function(n,e){return a[n]||(a[n]=e||{})}},function(n,e,t){"use strict";var a=t(5),r=0,i=Math.random(),o=a(1..toString);n.exports=function(n){return"Symbol("+(void 0===n?"":n)+")_"+o(++r+i,36)}},function(n,e,t){"use strict";var a=t(6),r=t(3),i=t(79);n.exports=!a&&!r((function(){return 7!==Object.defineProperty(i("div"),"a",{get:function(){return 7}}).a}))},function(n,e,t){"use strict";var a=t(2),r=t(8),i=a.document,o=r(i)&&r(i.createElement);n.exports=function(n){return o?i.createElement(n):{}}},function(n,e,t){"use strict";var a=t(6),r=t(3);n.exports=a&&r((function(){return 42!==Object.defineProperty((function(){}),"prototype",{value:42,writable:!1}).prototype}))},function(n,e,t){"use strict";var a=t(5),r=t(3),i=t(0),o=t(9),s=t(6),l=t(131).CONFIGURABLE,c=t(132),p=t(82),d=p.enforce,u=p.get,m=String,g=Object.defineProperty,h=a("".slice),v=a("".replace),b=a([].join),f=s&&!r((function(){return 8!==g((function(){}),"length",{value:8}).length})),y=String(String).split("String"),x=n.exports=function(n,e,t){"Symbol("===h(m(e),0,7)&&(e="["+v(m(e),/^Symbol\(([^)]*)\).*$/,"$1")+"]"),t&&t.getter&&(e="get "+e),t&&t.setter&&(e="set "+e),(!o(n,"name")||l&&n.name!==e)&&(s?g(n,"name",{value:e,configurable:!0}):n.name=e),f&&t&&o(t,"arity")&&n.length!==t.arity&&g(n,"length",{value:t.arity});try{t&&o(t,"constructor")&&t.constructor?s&&g(n,"prototype",{writable:!1}):n.prototype&&(n.prototype=void 0)}catch(n){}var a=d(n);return o(a,"source")||(a.source=b(y,"string"==typeof e?e:"")),n};Function.prototype.toString=x((function(){return i(this)&&u(this).source||c(this)}),"toString")},function(n,e,t){"use strict";var a,r,i,o=t(133),s=t(2),l=t(8),c=t(24),p=t(9),d=t(49),u=t(51),m=t(52),g=s.TypeError,h=s.WeakMap;if(o||d.state){var v=d.state||(d.state=new h);v.get=v.get,v.has=v.has,v.set=v.set,a=function(n,e){if(v.has(n))throw new g("Object already initialized");return e.facade=n,v.set(n,e),e},r=function(n){return v.get(n)||{}},i=function(n){return v.has(n)}}else{var b=u("state");m[b]=!0,a=function(n,e){if(p(n,b))throw new g("Object already initialized");return e.facade=n,c(n,b,e),e},r=function(n){return p(n,b)?n[b]:{}},i=function(n){return p(n,b)}}n.exports={set:a,get:r,has:i,enforce:function(n){return i(n)?r(n):a(n,{})},getterFor:function(n){return function(e){var t;if(!l(e)||(t=r(e)).type!==n)throw new g("Incompatible receiver, "+n+" required");return t}}}},function(n,e,t){"use strict";var a=t(9),r=t(134),i=t(69),o=t(18);n.exports=function(n,e,t){for(var s=r(e),l=o.f,c=i.f,p=0;p<s.length;p++){var d=s[p];a(n,d)||t&&a(t,d)||l(n,d,c(e,d))}}},function(n,e,t){"use strict";var a=t(5),r=t(9),i=t(34),o=t(136).indexOf,s=t(52),l=a([].push);n.exports=function(n,e){var t,a=i(n),c=0,p=[];for(t in a)!r(s,t)&&r(a,t)&&l(p,t);for(;e.length>c;)r(a,t=e[c++])&&(~o(p,t)||l(p,t));return p}},function(n,e,t){"use strict";var a=t(138);n.exports=function(n){var e=+n;return e!=e||0===e?0:a(e)}},function(n,e,t){"use strict";var a=t(9),r=t(0),i=t(30),o=t(51),s=t(143),l=o("IE_PROTO"),c=Object,p=c.prototype;n.exports=s?c.getPrototypeOf:function(n){var e=i(n);if(a(e,l))return e[l];var t=e.constructor;return r(t)&&e instanceof t?t.prototype:e instanceof c?p:null}},function(n,e,t){"use strict";var a,r,i,o=t(3),s=t(0),l=t(8),c=t(66),p=t(86),d=t(44),u=t(16),m=t(23),g=u("iterator"),h=!1;[].keys&&("next"in(i=[].keys())?(r=p(p(i)))!==Object.prototype&&(a=r):h=!0),!l(a)||o((function(){var n={};return a[g].call(n)!==n}))?a={}:m&&(a=c(a)),s(a[g])||d(a,g,(function(){return this})),n.exports={IteratorPrototype:a,BUGGY_SAFARI_ITERATORS:h}},function(n,e,t){"use strict";var a=t(12),r=t(66),i=t(24),o=t(149),s=t(16),l=t(82),c=t(37),p=t(87).IteratorPrototype,d=t(150),u=t(54),m=s("toStringTag"),g=l.set,h=function(n){var e=l.getterFor(n?"WrapForValidIterator":"IteratorHelper");return o(r(p),{next:function(){var t=e(this);if(n)return t.nextHandler();try{var a=t.done?void 0:t.nextHandler();return d(a,t.done)}catch(n){throw t.done=!0,n}},return:function(){var t=e(this),r=t.iterator;if(t.done=!0,n){var i=c(r,"return");return i?a(i,r):d(void 0,!0)}if(t.inner)try{u(t.inner.iterator,"normal")}catch(n){return u(r,"throw",n)}return r&&u(r,"normal"),d(void 0,!0)}})},v=h(!0),b=h(!1);i(b,m,"Iterator Helper"),n.exports=function(n,e){var t=function(t,a){a?(a.iterator=t.iterator,a.next=t.next):a=t,a.type=e?"WrapForValidIterator":"IteratorHelper",a.nextHandler=n,a.counter=0,a.done=!1,g(this,a)};return t.prototype=e?v:b,t}},function(n,e,t){"use strict";var a=t(1),r=t(54);n.exports=function(n,e,t,i){try{return i?e(a(t)[0],t[1]):e(t)}catch(e){r(n,"throw",e)}}},function(n,e,t){"use strict";n.exports={}},function(n,e,t){"use strict";var a=t(92),r=t(37),i=t(47),o=t(90),s=t(16)("iterator");n.exports=function(n){if(!i(n))return r(n,s)||r(n,"@@iterator")||o[a(n)]}},function(n,e,t){"use strict";var a=t(162),r=t(0),i=t(27),o=t(16)("toStringTag"),s=Object,l="Arguments"===i(function(){return arguments}());n.exports=a?i:function(n){var e,t,a;return void 0===n?"Undefined":null===n?"Null":"string"==typeof(t=function(n,e){try{return n[e]}catch(n){}}(e=s(n),o))?t:l?i(e):"Object"===(a=i(e))&&r(e.callee)?"Arguments":a}},function(n,e,t){"use strict";var a=t(168),r=t(8),i=t(46),o=t(169);n.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var n,e=!1,t={};try{(n=a(Object.prototype,"__proto__","set"))(t,[]),e=t instanceof Array}catch(n){}return function(t,a){return i(t),o(a),r(t)?(e?n(t,a):t.__proto__=a,t):t}}():void 0)},function(n,e){n.exports=function(n,e){for(var t=-1,a=e.length,r=n.length;++t<a;)n[r+t]=e[t];return n}},function(n,e){var t="object"==typeof global&&global&&global.Object===Object&&global;n.exports=t},function(n,e,t){var a=t(38),r=t(194),i=t(195),o=t(196),s=t(197),l=t(198);function c(n){var e=this.__data__=new a(n);this.size=e.size}c.prototype.clear=r,c.prototype.delete=i,c.prototype.get=o,c.prototype.has=s,c.prototype.set=l,n.exports=c},function(n,e){n.exports=function(n,e){return n===e||n!=n&&e!=e}},function(n,e,t){var a=t(26),r=t(57);n.exports=function(n){if(!r(n))return!1;var e=a(n);return"[object Function]"==e||"[object GeneratorFunction]"==e||"[object AsyncFunction]"==e||"[object Proxy]"==e}},function(n,e){var t=Function.prototype.toString;n.exports=function(n){if(null!=n){try{return t.call(n)}catch(n){}try{return n+""}catch(n){}}return""}},function(n,e,t){var a=t(215),r=t(22);n.exports=function n(e,t,i,o,s){return e===t||(null==e||null==t||!r(e)&&!r(t)?e!=e&&t!=t:a(e,t,i,o,n,s))}},function(n,e,t){var a=t(102),r=t(218),i=t(103);n.exports=function(n,e,t,o,s,l){var c=1&t,p=n.length,d=e.length;if(p!=d&&!(c&&d>p))return!1;var u=l.get(n),m=l.get(e);if(u&&m)return u==e&&m==n;var g=-1,h=!0,v=2&t?new a:void 0;for(l.set(n,e),l.set(e,n);++g<p;){var b=n[g],f=e[g];if(o)var y=c?o(f,b,g,e,n,l):o(b,f,g,n,e,l);if(void 0!==y){if(y)continue;h=!1;break}if(v){if(!r(e,(function(n,e){if(!i(v,e)&&(b===n||s(b,n,t,o,l)))return v.push(e)}))){h=!1;break}}else if(b!==f&&!s(b,f,t,o,l)){h=!1;break}}return l.delete(n),l.delete(e),h}},function(n,e,t){var a=t(58),r=t(216),i=t(217);function o(n){var e=-1,t=null==n?0:n.length;for(this.__data__=new a;++e<t;)this.add(n[e])}o.prototype.add=o.prototype.push=r,o.prototype.has=i,n.exports=o},function(n,e){n.exports=function(n,e){return n.has(e)}},function(n,e,t){var a=t(228),r=t(234),i=t(108);n.exports=function(n){return i(n)?a(n):r(n)}},function(n,e,t){(function(n){var a=t(13),r=t(230),i=e&&!e.nodeType&&e,o=i&&"object"==typeof n&&n&&!n.nodeType&&n,s=o&&o.exports===i?a.Buffer:void 0,l=(s?s.isBuffer:void 0)||r;n.exports=l}).call(this,t(67)(n))},function(n,e){var t=/^(?:0|[1-9]\d*)$/;n.exports=function(n,e){var a=typeof n;return!!(e=null==e?9007199254740991:e)&&("number"==a||"symbol"!=a&&t.test(n))&&n>-1&&n%1==0&&n<e}},function(n,e,t){var a=t(231),r=t(232),i=t(233),o=i&&i.isTypedArray,s=o?r(o):a;n.exports=s},function(n,e,t){var a=t(98),r=t(60);n.exports=function(n){return null!=n&&r(n.length)&&!a(n)}},function(n,e,t){var a=t(19)(t(13),"Set");n.exports=a},function(n,e,t){var a=t(57);n.exports=function(n){return n==n&&!a(n)}},function(n,e){n.exports=function(n,e){return function(t){return null!=t&&(t[n]===e&&(void 0!==e||n in Object(t)))}}},function(n,e,t){var a=t(113),r=t(42);n.exports=function(n,e){for(var t=0,i=(e=a(e,n)).length;null!=n&&t<i;)n=n[r(e[t++])];return t&&t==i?n:void 0}},function(n,e,t){var a=t(11),r=t(61),i=t(245),o=t(248);n.exports=function(n,e){return a(n)?n:r(n,e)?[n]:i(o(n))}},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){var a=t(181),r=t(186),i=t(257),o=t(265),s=t(274),l=t(125),c=i((function(n){var e=l(n);return s(e)&&(e=void 0),o(a(n,1,s,!0),r(e,2))}));n.exports=c},function(n,e,t){"use strict";
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */var a=/["'&<>]/;n.exports=function(n){var e,t=""+n,r=a.exec(t);if(!r)return t;var i="",o=0,s=0;for(o=r.index;o<t.length;o++){switch(t.charCodeAt(o)){case 34:e="&quot;";break;case 38:e="&amp;";break;case 39:e="&#39;";break;case 60:e="&lt;";break;case 62:e="&gt;";break;default:continue}s!==o&&(i+=t.substring(s,o)),s=o+1,i+=e}return s!==o?i+t.substring(s,o):i}},function(n,e,t){"use strict";t.r(e);var a={name:"CodeBlock",props:{title:{type:String,required:!0},active:{type:Boolean,default:!1}}},r=(t(278),t(14)),i=Object(r.a)(a,(function(){return(0,this._self._c)("div",{staticClass:"theme-code-block",class:{"theme-code-block__active":this.active}},[this._t("default")],2)}),[],!1,null,"4f1e9d0c",null);e.default=i.exports},function(n,e,t){"use strict";t.r(e);t(4),t(15),t(17),t(21);var a={name:"CodeGroup",data:()=>({codeTabs:[],activeCodeTabIndex:-1}),watch:{activeCodeTabIndex(n){this.codeTabs.forEach(n=>{n.elm.classList.remove("theme-code-block__active")}),this.codeTabs[n].elm.classList.add("theme-code-block__active")}},mounted(){this.codeTabs=(this.$slots.default||[]).filter(n=>Boolean(n.componentOptions)).map((n,e)=>(""===n.componentOptions.propsData.active&&(this.activeCodeTabIndex=e),{title:n.componentOptions.propsData.title,elm:n.elm})),-1===this.activeCodeTabIndex&&this.codeTabs.length>0&&(this.activeCodeTabIndex=0)},methods:{changeCodeTab(n){this.activeCodeTabIndex=n}}},r=(t(279),t(14)),i=Object(r.a)(a,(function(){var n=this,e=n._self._c;return e("div",{staticClass:"theme-code-group"},[e("div",{staticClass:"theme-code-group__nav"},[e("ul",{staticClass:"theme-code-group__ul"},n._l(n.codeTabs,(function(t,a){return e("li",{key:t.title,staticClass:"theme-code-group__li"},[e("button",{staticClass:"theme-code-group__nav-tab",class:{"theme-code-group__nav-tab-active":a===n.activeCodeTabIndex},on:{click:function(e){return n.changeCodeTab(a)}}},[n._v("\n            "+n._s(t.title)+"\n          ")])])})),0)]),n._v(" "),n._t("default"),n._v(" "),n.codeTabs.length<1?e("pre",{staticClass:"pre-blank"},[n._v("// Make sure to add code blocks to your code group")]):n._e()],2)}),[],!1,null,"2f5f1757",null);e.default=i.exports},function(n,e,t){"use strict";var a=t(92),r=String;n.exports=function(n){if("Symbol"===a(n))throw new TypeError("Cannot convert a Symbol value to a string");return r(n)}},function(n,e,t){"use strict";var a=t(81),r=t(18);n.exports=function(n,e,t){return t.get&&a(t.get,e,{getter:!0}),t.set&&a(t.set,e,{setter:!0}),r.f(n,e,t)}},function(n,e,t){"use strict";var a=t(159),r=t(7),i=t(32),o=a(a.bind);n.exports=function(n,e){return r(n),void 0===e?n:i?o(n,e):function(){return n.apply(e,arguments)}}},function(n,e){n.exports=function(n){var e=null==n?0:n.length;return e?n[e-1]:void 0}},function(n,e,t){n.exports=t(284)},function(n,e,t){"use strict";var a=t(10),r=t(2),i=t(142),o=t(1),s=t(0),l=t(86),c=t(123),p=t(144),d=t(3),u=t(9),m=t(16),g=t(87).IteratorPrototype,h=t(6),v=t(23),b=m("toStringTag"),f=TypeError,y=r.Iterator,x=v||!s(y)||y.prototype!==g||!d((function(){y({})})),S=function(){if(i(this,g),l(this)===g)throw new f("Abstract class Iterator not directly constructable")},w=function(n,e){h?c(g,n,{configurable:!0,get:function(){return e},set:function(e){if(o(this),this===g)throw new f("You can't redefine this property");u(this,n)?this[n]=e:p(this,n,e)}}):g[n]=e};u(g,b)||w(b,"Iterator"),!x&&u(g,"constructor")&&g.constructor!==Object||w("constructor",S),S.prototype=g,a({global:!0,constructor:!0,forced:x},{Iterator:S})},function(n,e,t){"use strict";var a={}.propertyIsEnumerable,r=Object.getOwnPropertyDescriptor,i=r&&!a.call({1:2},1);e.f=i?function(n){var e=r(this,n);return!!e&&e.enumerable}:a},function(n,e,t){"use strict";var a=t(12),r=t(8),i=t(71),o=t(37),s=t(130),l=t(16),c=TypeError,p=l("toPrimitive");n.exports=function(n,e){if(!r(n)||i(n))return n;var t,l=o(n,p);if(l){if(void 0===e&&(e="default"),t=a(l,n,e),!r(t)||i(t))return t;throw new c("Can't convert object to primitive value")}return void 0===e&&(e="number"),s(n,e)}},function(n,e,t){"use strict";var a=t(12),r=t(0),i=t(8),o=TypeError;n.exports=function(n,e){var t,s;if("string"===e&&r(t=n.toString)&&!i(s=a(t,n)))return s;if(r(t=n.valueOf)&&!i(s=a(t,n)))return s;if("string"!==e&&r(t=n.toString)&&!i(s=a(t,n)))return s;throw new o("Can't convert object to primitive value")}},function(n,e,t){"use strict";var a=t(6),r=t(9),i=Function.prototype,o=a&&Object.getOwnPropertyDescriptor,s=r(i,"name"),l=s&&"something"===function(){}.name,c=s&&(!a||a&&o(i,"name").configurable);n.exports={EXISTS:s,PROPER:l,CONFIGURABLE:c}},function(n,e,t){"use strict";var a=t(5),r=t(0),i=t(49),o=a(Function.toString);r(i.inspectSource)||(i.inspectSource=function(n){return o(n)}),n.exports=i.inspectSource},function(n,e,t){"use strict";var a=t(2),r=t(0),i=a.WeakMap;n.exports=r(i)&&/native code/.test(String(i))},function(n,e,t){"use strict";var a=t(35),r=t(5),i=t(135),o=t(140),s=t(1),l=r([].concat);n.exports=a("Reflect","ownKeys")||function(n){var e=i.f(s(n)),t=o.f;return t?l(e,t(n)):e}},function(n,e,t){"use strict";var a=t(84),r=t(53).concat("length","prototype");e.f=Object.getOwnPropertyNames||function(n){return a(n,r)}},function(n,e,t){"use strict";var a=t(34),r=t(137),i=t(31),o=function(n){return function(e,t,o){var s=a(e),l=i(s);if(0===l)return!n&&-1;var c,p=r(o,l);if(n&&t!=t){for(;l>p;)if((c=s[p++])!=c)return!0}else for(;l>p;p++)if((n||p in s)&&s[p]===t)return n||p||0;return!n&&-1}};n.exports={includes:o(!0),indexOf:o(!1)}},function(n,e,t){"use strict";var a=t(85),r=Math.max,i=Math.min;n.exports=function(n,e){var t=a(n);return t<0?r(t+e,0):i(t,e)}},function(n,e,t){"use strict";var a=Math.ceil,r=Math.floor;n.exports=Math.trunc||function(n){var e=+n;return(e>0?r:a)(e)}},function(n,e,t){"use strict";var a=t(85),r=Math.min;n.exports=function(n){var e=a(n);return e>0?r(e,9007199254740991):0}},function(n,e,t){"use strict";e.f=Object.getOwnPropertySymbols},function(n,e,t){"use strict";var a=t(3),r=t(0),i=/#|\.prototype\./,o=function(n,e){var t=l[s(n)];return t===p||t!==c&&(r(e)?a(e):!!e)},s=o.normalize=function(n){return String(n).replace(i,".").toLowerCase()},l=o.data={},c=o.NATIVE="N",p=o.POLYFILL="P";n.exports=o},function(n,e,t){"use strict";var a=t(36),r=TypeError;n.exports=function(n,e){if(a(e,n))return n;throw new r("Incorrect invocation")}},function(n,e,t){"use strict";var a=t(3);n.exports=!a((function(){function n(){}return n.prototype.constructor=null,Object.getPrototypeOf(new n)!==n.prototype}))},function(n,e,t){"use strict";var a=t(6),r=t(18),i=t(33);n.exports=function(n,e,t){a?r.f(n,e,i(0,t)):n[e]=t}},function(n,e,t){"use strict";var a=t(6),r=t(80),i=t(18),o=t(1),s=t(34),l=t(146);e.f=a&&!r?Object.defineProperties:function(n,e){o(n);for(var t,a=s(e),r=l(e),c=r.length,p=0;c>p;)i.f(n,t=r[p++],a[t]);return n}},function(n,e,t){"use strict";var a=t(84),r=t(53);n.exports=Object.keys||function(n){return a(n,r)}},function(n,e,t){"use strict";var a=t(35);n.exports=a("document","documentElement")},function(n,e,t){"use strict";var a=t(10),r=t(12),i=t(7),o=t(1),s=t(25),l=t(88),c=t(89),p=t(23),d=l((function(){for(var n,e,t=this.iterator,a=this.predicate,i=this.next;;){if(n=o(r(i,t)),this.done=!!n.done)return;if(e=n.value,c(t,a,[e,this.counter++],!0))return e}}));a({target:"Iterator",proto:!0,real:!0,forced:p},{filter:function(n){return o(this),i(n),new d(s(this),{predicate:n})}})},function(n,e,t){"use strict";var a=t(44);n.exports=function(n,e,t){for(var r in e)a(n,r,e[r],t);return n}},function(n,e,t){"use strict";n.exports=function(n,e){return{value:n,done:e}}},function(n,e,t){"use strict";var a=t(10),r=t(152);a({target:"Iterator",proto:!0,real:!0,forced:t(23)},{map:r})},function(n,e,t){"use strict";var a=t(12),r=t(7),i=t(1),o=t(25),s=t(88),l=t(89),c=s((function(){var n=this.iterator,e=i(a(this.next,n));if(!(this.done=!!e.done))return l(n,this.mapper,[e.value,this.counter++],!0)}));n.exports=function(n){return i(this),r(n),new c(o(this),{mapper:n})}},function(n,e,t){"use strict";var a=t(10),r=t(154).left,i=t(155),o=t(74);a({target:"Array",proto:!0,forced:!t(156)&&o>79&&o<83||!i("reduce")},{reduce:function(n){var e=arguments.length;return r(this,n,e,e>1?arguments[1]:void 0)}})},function(n,e,t){"use strict";var a=t(7),r=t(30),i=t(65),o=t(31),s=TypeError,l="Reduce of empty array with no initial value",c=function(n){return function(e,t,c,p){var d=r(e),u=i(d),m=o(d);if(a(t),0===m&&c<2)throw new s(l);var g=n?m-1:0,h=n?-1:1;if(c<2)for(;;){if(g in u){p=u[g],g+=h;break}if(g+=h,n?g<0:m<=g)throw new s(l)}for(;n?g>=0:m>g;g+=h)g in u&&(p=t(p,u[g],g,d));return p}};n.exports={left:c(!1),right:c(!0)}},function(n,e,t){"use strict";var a=t(3);n.exports=function(n,e){var t=[][n];return!!t&&a((function(){t.call(null,e||function(){return 1},1)}))}},function(n,e,t){"use strict";var a=t(157);n.exports="NODE"===a},function(n,e,t){"use strict";var a=t(2),r=t(75),i=t(27),o=function(n){return r.slice(0,n.length)===n};n.exports=o("Bun/")?"BUN":o("Cloudflare-Workers")?"CLOUDFLARE":o("Deno/")?"DENO":o("Node.js/")?"NODE":a.Bun&&"string"==typeof Bun.version?"BUN":a.Deno&&"object"==typeof Deno.version?"DENO":"process"===i(a.process)?"NODE":a.window&&a.document?"BROWSER":"REST"},function(n,e,t){"use strict";var a=t(10),r=t(45),i=t(7),o=t(1),s=t(25);a({target:"Iterator",proto:!0,real:!0},{forEach:function(n){o(this),i(n);var e=s(this),t=0;r(e,(function(e){n(e,t++)}),{IS_RECORD:!0})}})},function(n,e,t){"use strict";var a=t(27),r=t(5);n.exports=function(n){if("Function"===a(n))return r(n)}},function(n,e,t){"use strict";var a=t(16),r=t(90),i=a("iterator"),o=Array.prototype;n.exports=function(n){return void 0!==n&&(r.Array===n||o[i]===n)}},function(n,e,t){"use strict";var a=t(12),r=t(7),i=t(1),o=t(48),s=t(91),l=TypeError;n.exports=function(n,e){var t=arguments.length<2?s(n):e;if(r(t))return i(a(t,n));throw new l(o(n)+" is not iterable")}},function(n,e,t){"use strict";var a={};a[t(16)("toStringTag")]="z",n.exports="[object z]"===String(a)},function(n,e,t){"use strict";t(164)},function(n,e,t){"use strict";var a=t(10),r=t(45),i=t(7),o=t(1),s=t(25),l=TypeError;a({target:"Iterator",proto:!0,real:!0},{reduce:function(n){o(this),i(n);var e=s(this),t=arguments.length<2,a=t?void 0:arguments[1],c=0;if(r(e,(function(e){t?(t=!1,a=e):a=n(a,e,c),c++}),{IS_RECORD:!0}),t)throw new l("Reduce of empty iterator with no initial value");return a}})},function(n,e,t){"use strict";var a=t(10),r=t(2),i=t(166),o=t(167),s=r.WebAssembly,l=7!==new Error("e",{cause:7}).cause,c=function(n,e){var t={};t[n]=o(n,e,l),a({global:!0,constructor:!0,arity:1,forced:l},t)},p=function(n,e){if(s&&s[n]){var t={};t[n]=o("WebAssembly."+n,e,l),a({target:"WebAssembly",stat:!0,constructor:!0,arity:1,forced:l},t)}};c("Error",(function(n){return function(e){return i(n,this,arguments)}})),c("EvalError",(function(n){return function(e){return i(n,this,arguments)}})),c("RangeError",(function(n){return function(e){return i(n,this,arguments)}})),c("ReferenceError",(function(n){return function(e){return i(n,this,arguments)}})),c("SyntaxError",(function(n){return function(e){return i(n,this,arguments)}})),c("TypeError",(function(n){return function(e){return i(n,this,arguments)}})),c("URIError",(function(n){return function(e){return i(n,this,arguments)}})),p("CompileError",(function(n){return function(e){return i(n,this,arguments)}})),p("LinkError",(function(n){return function(e){return i(n,this,arguments)}})),p("RuntimeError",(function(n){return function(e){return i(n,this,arguments)}}))},function(n,e,t){"use strict";var a=t(32),r=Function.prototype,i=r.apply,o=r.call;n.exports="object"==typeof Reflect&&Reflect.apply||(a?o.bind(i):function(){return o.apply(i,arguments)})},function(n,e,t){"use strict";var a=t(35),r=t(9),i=t(24),o=t(36),s=t(93),l=t(83),c=t(171),p=t(172),d=t(173),u=t(174),m=t(175),g=t(6),h=t(23);n.exports=function(n,e,t,v){var b=v?2:1,f=n.split("."),y=f[f.length-1],x=a.apply(null,f);if(x){var S=x.prototype;if(!h&&r(S,"cause")&&delete S.cause,!t)return x;var w=a("Error"),j=e((function(n,e){var t=d(v?e:n,void 0),a=v?new x(n):new x;return void 0!==t&&i(a,"message",t),m(a,j,a.stack,2),this&&o(S,this)&&p(a,this,j),arguments.length>b&&u(a,arguments[b]),a}));if(j.prototype=S,"Error"!==y?s?s(j,w):l(j,w,{name:!0}):g&&"stackTraceLimit"in x&&(c(j,x,"stackTraceLimit"),c(j,x,"prepareStackTrace")),l(j,x),!h)try{S.name!==y&&i(S,"name",y),S.constructor=j}catch(n){}return j}}},function(n,e,t){"use strict";var a=t(5),r=t(7);n.exports=function(n,e,t){try{return a(r(Object.getOwnPropertyDescriptor(n,e)[t]))}catch(n){}}},function(n,e,t){"use strict";var a=t(170),r=String,i=TypeError;n.exports=function(n){if(a(n))return n;throw new i("Can't set "+r(n)+" as a prototype")}},function(n,e,t){"use strict";var a=t(8);n.exports=function(n){return a(n)||null===n}},function(n,e,t){"use strict";var a=t(18).f;n.exports=function(n,e,t){t in n||a(n,t,{configurable:!0,get:function(){return e[t]},set:function(n){e[t]=n}})}},function(n,e,t){"use strict";var a=t(0),r=t(8),i=t(93);n.exports=function(n,e,t){var o,s;return i&&a(o=e.constructor)&&o!==t&&r(s=o.prototype)&&s!==t.prototype&&i(n,s),n}},function(n,e,t){"use strict";var a=t(122);n.exports=function(n,e){return void 0===n?arguments.length<2?"":e:a(n)}},function(n,e,t){"use strict";var a=t(8),r=t(24);n.exports=function(n,e){a(e)&&"cause"in e&&r(n,"cause",e.cause)}},function(n,e,t){"use strict";var a=t(24),r=t(176),i=t(177),o=Error.captureStackTrace;n.exports=function(n,e,t,s){i&&(o?o(n,e):a(n,"stack",r(t,s)))}},function(n,e,t){"use strict";var a=t(5),r=Error,i=a("".replace),o=String(new r("zxcasd").stack),s=/\n\s*at [^:]*:[^\n]*/,l=s.test(o);n.exports=function(n,e){if(l&&"string"==typeof n&&!r.prepareStackTrace)for(;e--;)n=i(n,s,"");return n}},function(n,e,t){"use strict";var a=t(3),r=t(33);n.exports=!a((function(){var n=new Error("a");return!("stack"in n)||(Object.defineProperty(n,"stack",r(1,7)),7!==n.stack)}))},function(n,e,t){"use strict";var a=t(6),r=t(179),i=TypeError,o=Object.getOwnPropertyDescriptor,s=a&&!function(){if(void 0!==this)return!0;try{Object.defineProperty([],"length",{writable:!1}).length=1}catch(n){return n instanceof TypeError}}();n.exports=s?function(n,e){if(r(n)&&!o(n,"length").writable)throw new i("Cannot set read only .length");return n.length=e}:function(n,e){return n.length=e}},function(n,e,t){"use strict";var a=t(27);n.exports=Array.isArray||function(n){return"Array"===a(n)}},function(n,e,t){"use strict";var a=TypeError;n.exports=function(n){if(n>9007199254740991)throw a("Maximum allowed index exceeded");return n}},function(n,e,t){var a=t(94),r=t(182);n.exports=function n(e,t,i,o,s){var l=-1,c=e.length;for(i||(i=r),s||(s=[]);++l<c;){var p=e[l];t>0&&i(p)?t>1?n(p,t-1,i,o,s):a(s,p):o||(s[s.length]=p)}return s}},function(n,e,t){var a=t(28),r=t(55),i=t(11),o=a?a.isConcatSpreadable:void 0;n.exports=function(n){return i(n)||r(n)||!!(o&&n&&n[o])}},function(n,e,t){var a=t(26),r=t(22);n.exports=function(n){return r(n)&&"[object Arguments]"==a(n)}},function(n,e,t){var a=t(28),r=Object.prototype,i=r.hasOwnProperty,o=r.toString,s=a?a.toStringTag:void 0;n.exports=function(n){var e=i.call(n,s),t=n[s];try{n[s]=void 0;var a=!0}catch(n){}var r=o.call(n);return a&&(e?n[s]=t:delete n[s]),r}},function(n,e){var t=Object.prototype.toString;n.exports=function(n){return t.call(n)}},function(n,e,t){var a=t(187),r=t(243),i=t(63),o=t(11),s=t(254);n.exports=function(n){return"function"==typeof n?n:null==n?i:"object"==typeof n?o(n)?r(n[0],n[1]):a(n):s(n)}},function(n,e,t){var a=t(188),r=t(242),i=t(111);n.exports=function(n){var e=r(n);return 1==e.length&&e[0][2]?i(e[0][0],e[0][1]):function(t){return t===n||a(t,n,e)}}},function(n,e,t){var a=t(96),r=t(100);n.exports=function(n,e,t,i){var o=t.length,s=o,l=!i;if(null==n)return!s;for(n=Object(n);o--;){var c=t[o];if(l&&c[2]?c[1]!==n[c[0]]:!(c[0]in n))return!1}for(;++o<s;){var p=(c=t[o])[0],d=n[p],u=c[1];if(l&&c[2]){if(void 0===d&&!(p in n))return!1}else{var m=new a;if(i)var g=i(d,u,p,n,e,m);if(!(void 0===g?r(u,d,3,i,m):g))return!1}}return!0}},function(n,e){n.exports=function(){this.__data__=[],this.size=0}},function(n,e,t){var a=t(39),r=Array.prototype.splice;n.exports=function(n){var e=this.__data__,t=a(e,n);return!(t<0)&&(t==e.length-1?e.pop():r.call(e,t,1),--this.size,!0)}},function(n,e,t){var a=t(39);n.exports=function(n){var e=this.__data__,t=a(e,n);return t<0?void 0:e[t][1]}},function(n,e,t){var a=t(39);n.exports=function(n){return a(this.__data__,n)>-1}},function(n,e,t){var a=t(39);n.exports=function(n,e){var t=this.__data__,r=a(t,n);return r<0?(++this.size,t.push([n,e])):t[r][1]=e,this}},function(n,e,t){var a=t(38);n.exports=function(){this.__data__=new a,this.size=0}},function(n,e){n.exports=function(n){var e=this.__data__,t=e.delete(n);return this.size=e.size,t}},function(n,e){n.exports=function(n){return this.__data__.get(n)}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e,t){var a=t(38),r=t(56),i=t(58);n.exports=function(n,e){var t=this.__data__;if(t instanceof a){var o=t.__data__;if(!r||o.length<199)return o.push([n,e]),this.size=++t.size,this;t=this.__data__=new i(o)}return t.set(n,e),this.size=t.size,this}},function(n,e,t){var a=t(98),r=t(200),i=t(57),o=t(99),s=/^\[object .+?Constructor\]$/,l=Function.prototype,c=Object.prototype,p=l.toString,d=c.hasOwnProperty,u=RegExp("^"+p.call(d).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");n.exports=function(n){return!(!i(n)||r(n))&&(a(n)?u:s).test(o(n))}},function(n,e,t){var a,r=t(201),i=(a=/[^.]+$/.exec(r&&r.keys&&r.keys.IE_PROTO||""))?"Symbol(src)_1."+a:"";n.exports=function(n){return!!i&&i in n}},function(n,e,t){var a=t(13)["__core-js_shared__"];n.exports=a},function(n,e){n.exports=function(n,e){return null==n?void 0:n[e]}},function(n,e,t){var a=t(204),r=t(38),i=t(56);n.exports=function(){this.size=0,this.__data__={hash:new a,map:new(i||r),string:new a}}},function(n,e,t){var a=t(205),r=t(206),i=t(207),o=t(208),s=t(209);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var a=n[e];this.set(a[0],a[1])}}l.prototype.clear=a,l.prototype.delete=r,l.prototype.get=i,l.prototype.has=o,l.prototype.set=s,n.exports=l},function(n,e,t){var a=t(40);n.exports=function(){this.__data__=a?a(null):{},this.size=0}},function(n,e){n.exports=function(n){var e=this.has(n)&&delete this.__data__[n];return this.size-=e?1:0,e}},function(n,e,t){var a=t(40),r=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;if(a){var t=e[n];return"__lodash_hash_undefined__"===t?void 0:t}return r.call(e,n)?e[n]:void 0}},function(n,e,t){var a=t(40),r=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;return a?void 0!==e[n]:r.call(e,n)}},function(n,e,t){var a=t(40);n.exports=function(n,e){var t=this.__data__;return this.size+=this.has(n)?0:1,t[n]=a&&void 0===e?"__lodash_hash_undefined__":e,this}},function(n,e,t){var a=t(41);n.exports=function(n){var e=a(this,n).delete(n);return this.size-=e?1:0,e}},function(n,e){n.exports=function(n){var e=typeof n;return"string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==n:null===n}},function(n,e,t){var a=t(41);n.exports=function(n){return a(this,n).get(n)}},function(n,e,t){var a=t(41);n.exports=function(n){return a(this,n).has(n)}},function(n,e,t){var a=t(41);n.exports=function(n,e){var t=a(this,n),r=t.size;return t.set(n,e),this.size+=t.size==r?0:1,this}},function(n,e,t){var a=t(96),r=t(101),i=t(219),o=t(222),s=t(238),l=t(11),c=t(105),p=t(107),d="[object Object]",u=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,m,g,h){var v=l(n),b=l(e),f=v?"[object Array]":s(n),y=b?"[object Array]":s(e),x=(f="[object Arguments]"==f?d:f)==d,S=(y="[object Arguments]"==y?d:y)==d,w=f==y;if(w&&c(n)){if(!c(e))return!1;v=!0,x=!1}if(w&&!x)return h||(h=new a),v||p(n)?r(n,e,t,m,g,h):i(n,e,f,t,m,g,h);if(!(1&t)){var j=x&&u.call(n,"__wrapped__"),k=S&&u.call(e,"__wrapped__");if(j||k){var T=j?n.value():n,I=k?e.value():e;return h||(h=new a),g(T,I,t,m,h)}}return!!w&&(h||(h=new a),o(n,e,t,m,g,h))}},function(n,e){n.exports=function(n){return this.__data__.set(n,"__lodash_hash_undefined__"),this}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e){n.exports=function(n,e){for(var t=-1,a=null==n?0:n.length;++t<a;)if(e(n[t],t,n))return!0;return!1}},function(n,e,t){var a=t(28),r=t(220),i=t(97),o=t(101),s=t(221),l=t(59),c=a?a.prototype:void 0,p=c?c.valueOf:void 0;n.exports=function(n,e,t,a,c,d,u){switch(t){case"[object DataView]":if(n.byteLength!=e.byteLength||n.byteOffset!=e.byteOffset)return!1;n=n.buffer,e=e.buffer;case"[object ArrayBuffer]":return!(n.byteLength!=e.byteLength||!d(new r(n),new r(e)));case"[object Boolean]":case"[object Date]":case"[object Number]":return i(+n,+e);case"[object Error]":return n.name==e.name&&n.message==e.message;case"[object RegExp]":case"[object String]":return n==e+"";case"[object Map]":var m=s;case"[object Set]":var g=1&a;if(m||(m=l),n.size!=e.size&&!g)return!1;var h=u.get(n);if(h)return h==e;a|=2,u.set(n,e);var v=o(m(n),m(e),a,c,d,u);return u.delete(n),v;case"[object Symbol]":if(p)return p.call(n)==p.call(e)}return!1}},function(n,e,t){var a=t(13).Uint8Array;n.exports=a},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n,a){t[++e]=[a,n]})),t}},function(n,e,t){var a=t(223),r=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,i,o,s){var l=1&t,c=a(n),p=c.length;if(p!=a(e).length&&!l)return!1;for(var d=p;d--;){var u=c[d];if(!(l?u in e:r.call(e,u)))return!1}var m=s.get(n),g=s.get(e);if(m&&g)return m==e&&g==n;var h=!0;s.set(n,e),s.set(e,n);for(var v=l;++d<p;){var b=n[u=c[d]],f=e[u];if(i)var y=l?i(f,b,u,e,n,s):i(b,f,u,n,e,s);if(!(void 0===y?b===f||o(b,f,t,i,s):y)){h=!1;break}v||(v="constructor"==u)}if(h&&!v){var x=n.constructor,S=e.constructor;x==S||!("constructor"in n)||!("constructor"in e)||"function"==typeof x&&x instanceof x&&"function"==typeof S&&S instanceof S||(h=!1)}return s.delete(n),s.delete(e),h}},function(n,e,t){var a=t(224),r=t(225),i=t(104);n.exports=function(n){return a(n,i,r)}},function(n,e,t){var a=t(94),r=t(11);n.exports=function(n,e,t){var i=e(n);return r(n)?i:a(i,t(n))}},function(n,e,t){var a=t(226),r=t(227),i=Object.prototype.propertyIsEnumerable,o=Object.getOwnPropertySymbols,s=o?function(n){return null==n?[]:(n=Object(n),a(o(n),(function(e){return i.call(n,e)})))}:r;n.exports=s},function(n,e){n.exports=function(n,e){for(var t=-1,a=null==n?0:n.length,r=0,i=[];++t<a;){var o=n[t];e(o,t,n)&&(i[r++]=o)}return i}},function(n,e){n.exports=function(){return[]}},function(n,e,t){var a=t(229),r=t(55),i=t(11),o=t(105),s=t(106),l=t(107),c=Object.prototype.hasOwnProperty;n.exports=function(n,e){var t=i(n),p=!t&&r(n),d=!t&&!p&&o(n),u=!t&&!p&&!d&&l(n),m=t||p||d||u,g=m?a(n.length,String):[],h=g.length;for(var v in n)!e&&!c.call(n,v)||m&&("length"==v||d&&("offset"==v||"parent"==v)||u&&("buffer"==v||"byteLength"==v||"byteOffset"==v)||s(v,h))||g.push(v);return g}},function(n,e){n.exports=function(n,e){for(var t=-1,a=Array(n);++t<n;)a[t]=e(t);return a}},function(n,e){n.exports=function(){return!1}},function(n,e,t){var a=t(26),r=t(60),i=t(22),o={};o["[object Float32Array]"]=o["[object Float64Array]"]=o["[object Int8Array]"]=o["[object Int16Array]"]=o["[object Int32Array]"]=o["[object Uint8Array]"]=o["[object Uint8ClampedArray]"]=o["[object Uint16Array]"]=o["[object Uint32Array]"]=!0,o["[object Arguments]"]=o["[object Array]"]=o["[object ArrayBuffer]"]=o["[object Boolean]"]=o["[object DataView]"]=o["[object Date]"]=o["[object Error]"]=o["[object Function]"]=o["[object Map]"]=o["[object Number]"]=o["[object Object]"]=o["[object RegExp]"]=o["[object Set]"]=o["[object String]"]=o["[object WeakMap]"]=!1,n.exports=function(n){return i(n)&&r(n.length)&&!!o[a(n)]}},function(n,e){n.exports=function(n){return function(e){return n(e)}}},function(n,e,t){(function(n){var a=t(95),r=e&&!e.nodeType&&e,i=r&&"object"==typeof n&&n&&!n.nodeType&&n,o=i&&i.exports===r&&a.process,s=function(){try{var n=i&&i.require&&i.require("util").types;return n||o&&o.binding&&o.binding("util")}catch(n){}}();n.exports=s}).call(this,t(67)(n))},function(n,e,t){var a=t(235),r=t(236),i=Object.prototype.hasOwnProperty;n.exports=function(n){if(!a(n))return r(n);var e=[];for(var t in Object(n))i.call(n,t)&&"constructor"!=t&&e.push(t);return e}},function(n,e){var t=Object.prototype;n.exports=function(n){var e=n&&n.constructor;return n===("function"==typeof e&&e.prototype||t)}},function(n,e,t){var a=t(237)(Object.keys,Object);n.exports=a},function(n,e){n.exports=function(n,e){return function(t){return n(e(t))}}},function(n,e,t){var a=t(239),r=t(56),i=t(240),o=t(109),s=t(241),l=t(26),c=t(99),p=c(a),d=c(r),u=c(i),m=c(o),g=c(s),h=l;(a&&"[object DataView]"!=h(new a(new ArrayBuffer(1)))||r&&"[object Map]"!=h(new r)||i&&"[object Promise]"!=h(i.resolve())||o&&"[object Set]"!=h(new o)||s&&"[object WeakMap]"!=h(new s))&&(h=function(n){var e=l(n),t="[object Object]"==e?n.constructor:void 0,a=t?c(t):"";if(a)switch(a){case p:return"[object DataView]";case d:return"[object Map]";case u:return"[object Promise]";case m:return"[object Set]";case g:return"[object WeakMap]"}return e}),n.exports=h},function(n,e,t){var a=t(19)(t(13),"DataView");n.exports=a},function(n,e,t){var a=t(19)(t(13),"Promise");n.exports=a},function(n,e,t){var a=t(19)(t(13),"WeakMap");n.exports=a},function(n,e,t){var a=t(110),r=t(104);n.exports=function(n){for(var e=r(n),t=e.length;t--;){var i=e[t],o=n[i];e[t]=[i,o,a(o)]}return e}},function(n,e,t){var a=t(100),r=t(244),i=t(251),o=t(61),s=t(110),l=t(111),c=t(42);n.exports=function(n,e){return o(n)&&s(e)?l(c(n),e):function(t){var o=r(t,n);return void 0===o&&o===e?i(t,n):a(e,o,3)}}},function(n,e,t){var a=t(112);n.exports=function(n,e,t){var r=null==n?void 0:a(n,e);return void 0===r?t:r}},function(n,e,t){var a=t(246),r=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,i=/\\(\\)?/g,o=a((function(n){var e=[];return 46===n.charCodeAt(0)&&e.push(""),n.replace(r,(function(n,t,a,r){e.push(a?r.replace(i,"$1"):t||n)})),e}));n.exports=o},function(n,e,t){var a=t(247);n.exports=function(n){var e=a(n,(function(n){return 500===t.size&&t.clear(),n})),t=e.cache;return e}},function(n,e,t){var a=t(58);function r(n,e){if("function"!=typeof n||null!=e&&"function"!=typeof e)throw new TypeError("Expected a function");var t=function(){var a=arguments,r=e?e.apply(this,a):a[0],i=t.cache;if(i.has(r))return i.get(r);var o=n.apply(this,a);return t.cache=i.set(r,o)||i,o};return t.cache=new(r.Cache||a),t}r.Cache=a,n.exports=r},function(n,e,t){var a=t(249);n.exports=function(n){return null==n?"":a(n)}},function(n,e,t){var a=t(28),r=t(250),i=t(11),o=t(62),s=a?a.prototype:void 0,l=s?s.toString:void 0;n.exports=function n(e){if("string"==typeof e)return e;if(i(e))return r(e,n)+"";if(o(e))return l?l.call(e):"";var t=e+"";return"0"==t&&1/e==-1/0?"-0":t}},function(n,e){n.exports=function(n,e){for(var t=-1,a=null==n?0:n.length,r=Array(a);++t<a;)r[t]=e(n[t],t,n);return r}},function(n,e,t){var a=t(252),r=t(253);n.exports=function(n,e){return null!=n&&r(n,e,a)}},function(n,e){n.exports=function(n,e){return null!=n&&e in Object(n)}},function(n,e,t){var a=t(113),r=t(55),i=t(11),o=t(106),s=t(60),l=t(42);n.exports=function(n,e,t){for(var c=-1,p=(e=a(e,n)).length,d=!1;++c<p;){var u=l(e[c]);if(!(d=null!=n&&t(n,u)))break;n=n[u]}return d||++c!=p?d:!!(p=null==n?0:n.length)&&s(p)&&o(u,p)&&(i(n)||r(n))}},function(n,e,t){var a=t(255),r=t(256),i=t(61),o=t(42);n.exports=function(n){return i(n)?a(o(n)):r(n)}},function(n,e){n.exports=function(n){return function(e){return null==e?void 0:e[n]}}},function(n,e,t){var a=t(112);n.exports=function(n){return function(e){return a(e,n)}}},function(n,e,t){var a=t(63),r=t(258),i=t(260);n.exports=function(n,e){return i(r(n,e,a),n+"")}},function(n,e,t){var a=t(259),r=Math.max;n.exports=function(n,e,t){return e=r(void 0===e?n.length-1:e,0),function(){for(var i=arguments,o=-1,s=r(i.length-e,0),l=Array(s);++o<s;)l[o]=i[e+o];o=-1;for(var c=Array(e+1);++o<e;)c[o]=i[o];return c[e]=t(l),a(n,this,c)}}},function(n,e){n.exports=function(n,e,t){switch(t.length){case 0:return n.call(e);case 1:return n.call(e,t[0]);case 2:return n.call(e,t[0],t[1]);case 3:return n.call(e,t[0],t[1],t[2])}return n.apply(e,t)}},function(n,e,t){var a=t(261),r=t(264)(a);n.exports=r},function(n,e,t){var a=t(262),r=t(263),i=t(63),o=r?function(n,e){return r(n,"toString",{configurable:!0,enumerable:!1,value:a(e),writable:!0})}:i;n.exports=o},function(n,e){n.exports=function(n){return function(){return n}}},function(n,e,t){var a=t(19),r=function(){try{var n=a(Object,"defineProperty");return n({},"",{}),n}catch(n){}}();n.exports=r},function(n,e){var t=Date.now;n.exports=function(n){var e=0,a=0;return function(){var r=t(),i=16-(r-a);if(a=r,i>0){if(++e>=800)return arguments[0]}else e=0;return n.apply(void 0,arguments)}}},function(n,e,t){var a=t(102),r=t(266),i=t(271),o=t(103),s=t(272),l=t(59);n.exports=function(n,e,t){var c=-1,p=r,d=n.length,u=!0,m=[],g=m;if(t)u=!1,p=i;else if(d>=200){var h=e?null:s(n);if(h)return l(h);u=!1,p=o,g=new a}else g=e?[]:m;n:for(;++c<d;){var v=n[c],b=e?e(v):v;if(v=t||0!==v?v:0,u&&b==b){for(var f=g.length;f--;)if(g[f]===b)continue n;e&&g.push(b),m.push(v)}else p(g,b,t)||(g!==m&&g.push(b),m.push(v))}return m}},function(n,e,t){var a=t(267);n.exports=function(n,e){return!!(null==n?0:n.length)&&a(n,e,0)>-1}},function(n,e,t){var a=t(268),r=t(269),i=t(270);n.exports=function(n,e,t){return e==e?i(n,e,t):a(n,r,t)}},function(n,e){n.exports=function(n,e,t,a){for(var r=n.length,i=t+(a?1:-1);a?i--:++i<r;)if(e(n[i],i,n))return i;return-1}},function(n,e){n.exports=function(n){return n!=n}},function(n,e){n.exports=function(n,e,t){for(var a=t-1,r=n.length;++a<r;)if(n[a]===e)return a;return-1}},function(n,e){n.exports=function(n,e,t){for(var a=-1,r=null==n?0:n.length;++a<r;)if(t(e,n[a]))return!0;return!1}},function(n,e,t){var a=t(109),r=t(273),i=t(59),o=a&&1/i(new a([,-0]))[1]==1/0?function(n){return new a(n)}:r;n.exports=o},function(n,e){n.exports=function(){}},function(n,e,t){var a=t(108),r=t(22);n.exports=function(n){return r(n)&&a(n)}},function(n,e,t){"use strict";var a=t(10),r=t(45),i=t(7),o=t(1),s=t(25);a({target:"Iterator",proto:!0,real:!0},{some:function(n){o(this),i(n);var e=s(this),t=0;return r(e,(function(e,a){if(n(e,t++))return a()}),{IS_RECORD:!0,INTERRUPTED:!0}).stopped}})},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(114)},function(n,e,t){"use strict";t(115)},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(116)},function(n,e,t){"use strict";t(117)},function(n,e,t){"use strict";t.r(e);t(4),t(15),t(21);var a=Object.freeze({}),r=Array.isArray;function i(n){return null==n}function o(n){return null!=n}function s(n){return!0===n}function l(n){return"string"==typeof n||"number"==typeof n||"symbol"==typeof n||"boolean"==typeof n}function c(n){return"function"==typeof n}function p(n){return null!==n&&"object"==typeof n}var d=Object.prototype.toString;function u(n){return"[object Object]"===d.call(n)}function m(n){return"[object RegExp]"===d.call(n)}function g(n){var e=parseFloat(String(n));return e>=0&&Math.floor(e)===e&&isFinite(n)}function h(n){return o(n)&&"function"==typeof n.then&&"function"==typeof n.catch}function v(n){return null==n?"":Array.isArray(n)||u(n)&&n.toString===d?JSON.stringify(n,b,2):String(n)}function b(n,e){return e&&e.__v_isRef?e.value:e}function f(n){var e=parseFloat(n);return isNaN(e)?n:e}function y(n,e){for(var t=Object.create(null),a=n.split(","),r=0;r<a.length;r++)t[a[r]]=!0;return e?function(n){return t[n.toLowerCase()]}:function(n){return t[n]}}y("slot,component",!0);var x=y("key,ref,slot,slot-scope,is");function S(n,e){var t=n.length;if(t){if(e===n[t-1])return void(n.length=t-1);var a=n.indexOf(e);if(a>-1)return n.splice(a,1)}}var w=Object.prototype.hasOwnProperty;function j(n,e){return w.call(n,e)}function k(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var T=/-(\w)/g,I=k((function(n){return n.replace(T,(function(n,e){return e?e.toUpperCase():""}))})),C=k((function(n){return n.charAt(0).toUpperCase()+n.slice(1)})),E=/\B([A-Z])/g,A=k((function(n){return n.replace(E,"-$1").toLowerCase()}));var P=Function.prototype.bind?function(n,e){return n.bind(e)}:function(n,e){function t(t){var a=arguments.length;return a?a>1?n.apply(e,arguments):n.call(e,t):n.call(e)}return t._length=n.length,t};function B(n,e){e=e||0;for(var t=n.length-e,a=new Array(t);t--;)a[t]=n[t+e];return a}function M(n,e){for(var t in e)n[t]=e[t];return n}function z(n){for(var e={},t=0;t<n.length;t++)n[t]&&M(e,n[t]);return e}function J(n,e,t){}var R=function(n,e,t){return!1},L=function(n){return n};function D(n,e){if(n===e)return!0;var t=p(n),a=p(e);if(!t||!a)return!t&&!a&&String(n)===String(e);try{var r=Array.isArray(n),i=Array.isArray(e);if(r&&i)return n.length===e.length&&n.every((function(n,t){return D(n,e[t])}));if(n instanceof Date&&e instanceof Date)return n.getTime()===e.getTime();if(r||i)return!1;var o=Object.keys(n),s=Object.keys(e);return o.length===s.length&&o.every((function(t){return D(n[t],e[t])}))}catch(n){return!1}}function O(n,e){for(var t=0;t<n.length;t++)if(D(n[t],e))return t;return-1}function _(n){var e=!1;return function(){e||(e=!0,n.apply(this,arguments))}}function q(n,e){return n===e?0===n&&1/n!=1/e:n==n||e==e}var F=["component","directive","filter"],U=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch","renderTracked","renderTriggered"],N={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:R,isReservedAttr:R,isUnknownElement:R,getTagNamespace:J,parsePlatformTagName:L,mustUseProp:R,async:!0,_lifecycleHooks:U},H=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function $(n){var e=(n+"").charCodeAt(0);return 36===e||95===e}function W(n,e,t,a){Object.defineProperty(n,e,{value:t,enumerable:!!a,writable:!0,configurable:!0})}var V=new RegExp("[^".concat(H.source,".$_\\d]"));var G="__proto__"in{},X="undefined"!=typeof window,Q=X&&window.navigator.userAgent.toLowerCase(),K=Q&&/msie|trident/.test(Q),Z=Q&&Q.indexOf("msie 9.0")>0,Y=Q&&Q.indexOf("edge/")>0;Q&&Q.indexOf("android");var nn=Q&&/iphone|ipad|ipod|ios/.test(Q);Q&&/chrome\/\d+/.test(Q),Q&&/phantomjs/.test(Q);var en,tn=Q&&Q.match(/firefox\/(\d+)/),an={}.watch,rn=!1;if(X)try{var on={};Object.defineProperty(on,"passive",{get:function(){rn=!0}}),window.addEventListener("test-passive",null,on)}catch(n){}var sn=function(){return void 0===en&&(en=!X&&"undefined"!=typeof global&&(global.process&&"server"===global.process.env.VUE_ENV)),en},ln=X&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function cn(n){return"function"==typeof n&&/native code/.test(n.toString())}var pn,dn="undefined"!=typeof Symbol&&cn(Symbol)&&"undefined"!=typeof Reflect&&cn(Reflect.ownKeys);pn="undefined"!=typeof Set&&cn(Set)?Set:function(){function n(){this.set=Object.create(null)}return n.prototype.has=function(n){return!0===this.set[n]},n.prototype.add=function(n){this.set[n]=!0},n.prototype.clear=function(){this.set=Object.create(null)},n}();var un=null;function mn(n){void 0===n&&(n=null),n||un&&un._scope.off(),un=n,n&&n._scope.on()}var gn=function(){function n(n,e,t,a,r,i,o,s){this.tag=n,this.data=e,this.children=t,this.text=a,this.elm=r,this.ns=void 0,this.context=i,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=e&&e.key,this.componentOptions=o,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=s,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1}return Object.defineProperty(n.prototype,"child",{get:function(){return this.componentInstance},enumerable:!1,configurable:!0}),n}(),hn=function(n){void 0===n&&(n="");var e=new gn;return e.text=n,e.isComment=!0,e};function vn(n){return new gn(void 0,void 0,void 0,String(n))}function bn(n){var e=new gn(n.tag,n.data,n.children&&n.children.slice(),n.text,n.elm,n.context,n.componentOptions,n.asyncFactory);return e.ns=n.ns,e.isStatic=n.isStatic,e.key=n.key,e.isComment=n.isComment,e.fnContext=n.fnContext,e.fnOptions=n.fnOptions,e.fnScopeId=n.fnScopeId,e.asyncMeta=n.asyncMeta,e.isCloned=!0,e}"function"==typeof SuppressedError&&SuppressedError;var fn=0,yn=[],xn=function(){function n(){this._pending=!1,this.id=fn++,this.subs=[]}return n.prototype.addSub=function(n){this.subs.push(n)},n.prototype.removeSub=function(n){this.subs[this.subs.indexOf(n)]=null,this._pending||(this._pending=!0,yn.push(this))},n.prototype.depend=function(e){n.target&&n.target.addDep(this)},n.prototype.notify=function(n){var e=this.subs.filter((function(n){return n}));for(var t=0,a=e.length;t<a;t++){0,e[t].update()}},n}();xn.target=null;var Sn=[];function wn(n){Sn.push(n),xn.target=n}function jn(){Sn.pop(),xn.target=Sn[Sn.length-1]}var kn=Array.prototype,Tn=Object.create(kn);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(n){var e=kn[n];W(Tn,n,(function(){for(var t=[],a=0;a<arguments.length;a++)t[a]=arguments[a];var r,i=e.apply(this,t),o=this.__ob__;switch(n){case"push":case"unshift":r=t;break;case"splice":r=t.slice(2)}return r&&o.observeArray(r),o.dep.notify(),i}))}));var In=Object.getOwnPropertyNames(Tn),Cn={},En=!0;function An(n){En=n}var Pn={notify:J,depend:J,addSub:J,removeSub:J},Bn=function(){function n(n,e,t){if(void 0===e&&(e=!1),void 0===t&&(t=!1),this.value=n,this.shallow=e,this.mock=t,this.dep=t?Pn:new xn,this.vmCount=0,W(n,"__ob__",this),r(n)){if(!t)if(G)n.__proto__=Tn;else for(var a=0,i=In.length;a<i;a++){W(n,s=In[a],Tn[s])}e||this.observeArray(n)}else{var o=Object.keys(n);for(a=0;a<o.length;a++){var s;zn(n,s=o[a],Cn,void 0,e,t)}}}return n.prototype.observeArray=function(n){for(var e=0,t=n.length;e<t;e++)Mn(n[e],!1,this.mock)},n}();function Mn(n,e,t){return n&&j(n,"__ob__")&&n.__ob__ instanceof Bn?n.__ob__:!En||!t&&sn()||!r(n)&&!u(n)||!Object.isExtensible(n)||n.__v_skip||qn(n)||n instanceof gn?void 0:new Bn(n,e,t)}function zn(n,e,t,a,i,o,s){void 0===s&&(s=!1);var l=new xn,c=Object.getOwnPropertyDescriptor(n,e);if(!c||!1!==c.configurable){var p=c&&c.get,d=c&&c.set;p&&!d||t!==Cn&&2!==arguments.length||(t=n[e]);var u=i?t&&t.__ob__:Mn(t,!1,o);return Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){var e=p?p.call(n):t;return xn.target&&(l.depend(),u&&(u.dep.depend(),r(e)&&Ln(e))),qn(e)&&!i?e.value:e},set:function(e){var a=p?p.call(n):t;if(q(a,e)){if(d)d.call(n,e);else{if(p)return;if(!i&&qn(a)&&!qn(e))return void(a.value=e);t=e}u=i?e&&e.__ob__:Mn(e,!1,o),l.notify()}}}),l}}function Jn(n,e,t){if(!_n(n)){var a=n.__ob__;return r(n)&&g(e)?(n.length=Math.max(n.length,e),n.splice(e,1,t),a&&!a.shallow&&a.mock&&Mn(t,!1,!0),t):e in n&&!(e in Object.prototype)?(n[e]=t,t):n._isVue||a&&a.vmCount?t:a?(zn(a.value,e,t,void 0,a.shallow,a.mock),a.dep.notify(),t):(n[e]=t,t)}}function Rn(n,e){if(r(n)&&g(e))n.splice(e,1);else{var t=n.__ob__;n._isVue||t&&t.vmCount||_n(n)||j(n,e)&&(delete n[e],t&&t.dep.notify())}}function Ln(n){for(var e=void 0,t=0,a=n.length;t<a;t++)(e=n[t])&&e.__ob__&&e.__ob__.dep.depend(),r(e)&&Ln(e)}function Dn(n){return On(n,!0),W(n,"__v_isShallow",!0),n}function On(n,e){if(!_n(n)){Mn(n,e,sn());0}}function _n(n){return!(!n||!n.__v_isReadonly)}function qn(n){return!(!n||!0!==n.__v_isRef)}function Fn(n,e,t){Object.defineProperty(n,t,{enumerable:!0,configurable:!0,get:function(){var n=e[t];if(qn(n))return n.value;var a=n&&n.__ob__;return a&&a.dep.depend(),n},set:function(n){var a=e[t];qn(a)&&!qn(n)?a.value=n:e[t]=n}})}"".concat("watcher"," callback"),"".concat("watcher"," getter"),"".concat("watcher"," cleanup");var Un;var Nn=function(){function n(n){void 0===n&&(n=!1),this.detached=n,this.active=!0,this.effects=[],this.cleanups=[],this.parent=Un,!n&&Un&&(this.index=(Un.scopes||(Un.scopes=[])).push(this)-1)}return n.prototype.run=function(n){if(this.active){var e=Un;try{return Un=this,n()}finally{Un=e}}else 0},n.prototype.on=function(){Un=this},n.prototype.off=function(){Un=this.parent},n.prototype.stop=function(n){if(this.active){var e=void 0,t=void 0;for(e=0,t=this.effects.length;e<t;e++)this.effects[e].teardown();for(e=0,t=this.cleanups.length;e<t;e++)this.cleanups[e]();if(this.scopes)for(e=0,t=this.scopes.length;e<t;e++)this.scopes[e].stop(!0);if(!this.detached&&this.parent&&!n){var a=this.parent.scopes.pop();a&&a!==this&&(this.parent.scopes[this.index]=a,a.index=this.index)}this.parent=void 0,this.active=!1}},n}();function Hn(n){var e=n._provided,t=n.$parent&&n.$parent._provided;return t===e?n._provided=Object.create(t):e}var $n=k((function(n){var e="&"===n.charAt(0),t="~"===(n=e?n.slice(1):n).charAt(0),a="!"===(n=t?n.slice(1):n).charAt(0);return{name:n=a?n.slice(1):n,once:t,capture:a,passive:e}}));function Wn(n,e){function t(){var n=t.fns;if(!r(n))return Ee(n,null,arguments,e,"v-on handler");for(var a=n.slice(),i=0;i<a.length;i++)Ee(a[i],null,arguments,e,"v-on handler")}return t.fns=n,t}function Vn(n,e,t,a,r,o){var l,c,p,d;for(l in n)c=n[l],p=e[l],d=$n(l),i(c)||(i(p)?(i(c.fns)&&(c=n[l]=Wn(c,o)),s(d.once)&&(c=n[l]=r(d.name,c,d.capture)),t(d.name,c,d.capture,d.passive,d.params)):c!==p&&(p.fns=c,n[l]=p));for(l in e)i(n[l])&&a((d=$n(l)).name,e[l],d.capture)}function Gn(n,e,t){var a;n instanceof gn&&(n=n.data.hook||(n.data.hook={}));var r=n[e];function l(){t.apply(this,arguments),S(a.fns,l)}i(r)?a=Wn([l]):o(r.fns)&&s(r.merged)?(a=r).fns.push(l):a=Wn([r,l]),a.merged=!0,n[e]=a}function Xn(n,e,t,a,r){if(o(e)){if(j(e,t))return n[t]=e[t],r||delete e[t],!0;if(j(e,a))return n[t]=e[a],r||delete e[a],!0}return!1}function Qn(n){return l(n)?[vn(n)]:r(n)?function n(e,t){var a,c,p,d,u=[];for(a=0;a<e.length;a++)i(c=e[a])||"boolean"==typeof c||(p=u.length-1,d=u[p],r(c)?c.length>0&&(Kn((c=n(c,"".concat(t||"","_").concat(a)))[0])&&Kn(d)&&(u[p]=vn(d.text+c[0].text),c.shift()),u.push.apply(u,c)):l(c)?Kn(d)?u[p]=vn(d.text+c):""!==c&&u.push(vn(c)):Kn(c)&&Kn(d)?u[p]=vn(d.text+c.text):(s(e._isVList)&&o(c.tag)&&i(c.key)&&o(t)&&(c.key="__vlist".concat(t,"_").concat(a,"__")),u.push(c)));return u}(n):void 0}function Kn(n){return o(n)&&o(n.text)&&!1===n.isComment}function Zn(n,e){var t,a,i,s,l=null;if(r(n)||"string"==typeof n)for(l=new Array(n.length),t=0,a=n.length;t<a;t++)l[t]=e(n[t],t);else if("number"==typeof n)for(l=new Array(n),t=0;t<n;t++)l[t]=e(t+1,t);else if(p(n))if(dn&&n[Symbol.iterator]){l=[];for(var c=n[Symbol.iterator](),d=c.next();!d.done;)l.push(e(d.value,l.length)),d=c.next()}else for(i=Object.keys(n),l=new Array(i.length),t=0,a=i.length;t<a;t++)s=i[t],l[t]=e(n[s],s,t);return o(l)||(l=[]),l._isVList=!0,l}function Yn(n,e,t,a){var r,i=this.$scopedSlots[n];i?(t=t||{},a&&(t=M(M({},a),t)),r=i(t)||(c(e)?e():e)):r=this.$slots[n]||(c(e)?e():e);var o=t&&t.slot;return o?this.$createElement("template",{slot:o},r):r}function ne(n){return Bt(this.$options,"filters",n,!0)||L}function ee(n,e){return r(n)?-1===n.indexOf(e):n!==e}function te(n,e,t,a,r){var i=N.keyCodes[e]||t;return r&&a&&!N.keyCodes[e]?ee(r,a):i?ee(i,n):a?A(a)!==e:void 0===n}function ae(n,e,t,a,i){if(t)if(p(t)){r(t)&&(t=z(t));var o=void 0,s=function(r){if("class"===r||"style"===r||x(r))o=n;else{var s=n.attrs&&n.attrs.type;o=a||N.mustUseProp(e,s,r)?n.domProps||(n.domProps={}):n.attrs||(n.attrs={})}var l=I(r),c=A(r);l in o||c in o||(o[r]=t[r],i&&((n.on||(n.on={}))["update:".concat(r)]=function(n){t[r]=n}))};for(var l in t)s(l)}else;return n}function re(n,e){var t=this._staticTrees||(this._staticTrees=[]),a=t[n];return a&&!e||oe(a=t[n]=this.$options.staticRenderFns[n].call(this._renderProxy,this._c,this),"__static__".concat(n),!1),a}function ie(n,e,t){return oe(n,"__once__".concat(e).concat(t?"_".concat(t):""),!0),n}function oe(n,e,t){if(r(n))for(var a=0;a<n.length;a++)n[a]&&"string"!=typeof n[a]&&se(n[a],"".concat(e,"_").concat(a),t);else se(n,e,t)}function se(n,e,t){n.isStatic=!0,n.key=e,n.isOnce=t}function le(n,e){if(e)if(u(e)){var t=n.on=n.on?M({},n.on):{};for(var a in e){var r=t[a],i=e[a];t[a]=r?[].concat(r,i):i}}else;return n}function ce(n,e,t,a){e=e||{$stable:!t};for(var i=0;i<n.length;i++){var o=n[i];r(o)?ce(o,e,t):o&&(o.proxy&&(o.fn.proxy=!0),e[o.key]=o.fn)}return a&&(e.$key=a),e}function pe(n,e){for(var t=0;t<e.length;t+=2){var a=e[t];"string"==typeof a&&a&&(n[e[t]]=e[t+1])}return n}function de(n,e){return"string"==typeof n?e+n:n}function ue(n){n._o=ie,n._n=f,n._s=v,n._l=Zn,n._t=Yn,n._q=D,n._i=O,n._m=re,n._f=ne,n._k=te,n._b=ae,n._v=vn,n._e=hn,n._u=ce,n._g=le,n._d=pe,n._p=de}function me(n,e){if(!n||!n.length)return{};for(var t={},a=0,r=n.length;a<r;a++){var i=n[a],o=i.data;if(o&&o.attrs&&o.attrs.slot&&delete o.attrs.slot,i.context!==e&&i.fnContext!==e||!o||null==o.slot)(t.default||(t.default=[])).push(i);else{var s=o.slot,l=t[s]||(t[s]=[]);"template"===i.tag?l.push.apply(l,i.children||[]):l.push(i)}}for(var c in t)t[c].every(ge)&&delete t[c];return t}function ge(n){return n.isComment&&!n.asyncFactory||" "===n.text}function he(n){return n.isComment&&n.asyncFactory}function ve(n,e,t,r){var i,o=Object.keys(t).length>0,s=e?!!e.$stable:!o,l=e&&e.$key;if(e){if(e._normalized)return e._normalized;if(s&&r&&r!==a&&l===r.$key&&!o&&!r.$hasNormal)return r;for(var c in i={},e)e[c]&&"$"!==c[0]&&(i[c]=be(n,t,c,e[c]))}else i={};for(var p in t)p in i||(i[p]=fe(t,p));return e&&Object.isExtensible(e)&&(e._normalized=i),W(i,"$stable",s),W(i,"$key",l),W(i,"$hasNormal",o),i}function be(n,e,t,a){var i=function(){var e=un;mn(n);var t=arguments.length?a.apply(null,arguments):a({}),i=(t=t&&"object"==typeof t&&!r(t)?[t]:Qn(t))&&t[0];return mn(e),t&&(!i||1===t.length&&i.isComment&&!he(i))?void 0:t};return a.proxy&&Object.defineProperty(e,t,{get:i,enumerable:!0,configurable:!0}),i}function fe(n,e){return function(){return n[e]}}function ye(n){return{get attrs(){if(!n._attrsProxy){var e=n._attrsProxy={};W(e,"_v_attr_proxy",!0),xe(e,n.$attrs,a,n,"$attrs")}return n._attrsProxy},get listeners(){n._listenersProxy||xe(n._listenersProxy={},n.$listeners,a,n,"$listeners");return n._listenersProxy},get slots(){return function(n){n._slotsProxy||we(n._slotsProxy={},n.$scopedSlots);return n._slotsProxy}(n)},emit:P(n.$emit,n),expose:function(e){e&&Object.keys(e).forEach((function(t){return Fn(n,e,t)}))}}}function xe(n,e,t,a,r){var i=!1;for(var o in e)o in n?e[o]!==t[o]&&(i=!0):(i=!0,Se(n,o,a,r));for(var o in n)o in e||(i=!0,delete n[o]);return i}function Se(n,e,t,a){Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){return t[a][e]}})}function we(n,e){for(var t in e)n[t]=e[t];for(var t in n)t in e||delete n[t]}var je=null;function ke(n,e){return(n.__esModule||dn&&"Module"===n[Symbol.toStringTag])&&(n=n.default),p(n)?e.extend(n):n}function Te(n){if(r(n))for(var e=0;e<n.length;e++){var t=n[e];if(o(t)&&(o(t.componentOptions)||he(t)))return t}}function Ie(n,e,t,a,d,u){return(r(t)||l(t))&&(d=a,a=t,t=void 0),s(u)&&(d=2),function(n,e,t,a,l){if(o(t)&&o(t.__ob__))return hn();o(t)&&o(t.is)&&(e=t.is);if(!e)return hn();0;r(a)&&c(a[0])&&((t=t||{}).scopedSlots={default:a[0]},a.length=0);2===l?a=Qn(a):1===l&&(a=function(n){for(var e=0;e<n.length;e++)if(r(n[e]))return Array.prototype.concat.apply([],n);return n}(a));var d,u;if("string"==typeof e){var m=void 0;u=n.$vnode&&n.$vnode.ns||N.getTagNamespace(e),d=N.isReservedTag(e)?new gn(N.parsePlatformTagName(e),t,a,void 0,void 0,n):t&&t.pre||!o(m=Bt(n.$options,"components",e))?new gn(e,t,a,void 0,void 0,n):St(m,t,n,a,e)}else d=St(e,t,n,a);return r(d)?d:o(d)?(o(u)&&function n(e,t,a){e.ns=t,"foreignObject"===e.tag&&(t=void 0,a=!0);if(o(e.children))for(var r=0,l=e.children.length;r<l;r++){var c=e.children[r];o(c.tag)&&(i(c.ns)||s(a)&&"svg"!==c.tag)&&n(c,t,a)}}(d,u),o(t)&&function(n){p(n.style)&&Ne(n.style);p(n.class)&&Ne(n.class)}(t),d):hn()}(n,e,t,a,d)}function Ce(n,e,t){wn();try{if(e)for(var a=e;a=a.$parent;){var r=a.$options.errorCaptured;if(r)for(var i=0;i<r.length;i++)try{if(!1===r[i].call(a,n,e,t))return}catch(n){Ae(n,a,"errorCaptured hook")}}Ae(n,e,t)}finally{jn()}}function Ee(n,e,t,a,r){var i;try{(i=t?n.apply(e,t):n.call(e))&&!i._isVue&&h(i)&&!i._handled&&(i.catch((function(n){return Ce(n,a,r+" (Promise/async)")})),i._handled=!0)}catch(n){Ce(n,a,r)}return i}function Ae(n,e,t){if(N.errorHandler)try{return N.errorHandler.call(null,n,e,t)}catch(e){e!==n&&Pe(e,null,"config.errorHandler")}Pe(n,e,t)}function Pe(n,e,t){if(!X||"undefined"==typeof console)throw n;console.error(n)}var Be,Me=!1,ze=[],Je=!1;function Re(){Je=!1;var n=ze.slice(0);ze.length=0;for(var e=0;e<n.length;e++)n[e]()}if("undefined"!=typeof Promise&&cn(Promise)){var Le=Promise.resolve();Be=function(){Le.then(Re),nn&&setTimeout(J)},Me=!0}else if(K||"undefined"==typeof MutationObserver||!cn(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())Be="undefined"!=typeof setImmediate&&cn(setImmediate)?function(){setImmediate(Re)}:function(){setTimeout(Re,0)};else{var De=1,Oe=new MutationObserver(Re),_e=document.createTextNode(String(De));Oe.observe(_e,{characterData:!0}),Be=function(){De=(De+1)%2,_e.data=String(De)},Me=!0}function qe(n,e){var t;if(ze.push((function(){if(n)try{n.call(e)}catch(n){Ce(n,e,"nextTick")}else t&&t(e)})),Je||(Je=!0,Be()),!n&&"undefined"!=typeof Promise)return new Promise((function(n){t=n}))}function Fe(n){return function(e,t){if(void 0===t&&(t=un),t)return function(n,e,t){var a=n.$options;a[e]=Ct(a[e],t)}(t,n,e)}}Fe("beforeMount"),Fe("mounted"),Fe("beforeUpdate"),Fe("updated"),Fe("beforeDestroy"),Fe("destroyed"),Fe("activated"),Fe("deactivated"),Fe("serverPrefetch"),Fe("renderTracked"),Fe("renderTriggered"),Fe("errorCaptured");var Ue=new pn;function Ne(n){return function n(e,t){var a,i,o=r(e);if(!o&&!p(e)||e.__v_skip||Object.isFrozen(e)||e instanceof gn)return;if(e.__ob__){var s=e.__ob__.dep.id;if(t.has(s))return;t.add(s)}if(o)for(a=e.length;a--;)n(e[a],t);else if(qn(e))n(e.value,t);else for(i=Object.keys(e),a=i.length;a--;)n(e[i[a]],t)}(n,Ue),Ue.clear(),n}var He,$e=0,We=function(){function n(n,e,t,a,r){var i,o;i=this,void 0===(o=Un&&!Un._vm?Un:n?n._scope:void 0)&&(o=Un),o&&o.active&&o.effects.push(i),(this.vm=n)&&r&&(n._watcher=this),a?(this.deep=!!a.deep,this.user=!!a.user,this.lazy=!!a.lazy,this.sync=!!a.sync,this.before=a.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=t,this.id=++$e,this.active=!0,this.post=!1,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new pn,this.newDepIds=new pn,this.expression="",c(e)?this.getter=e:(this.getter=function(n){if(!V.test(n)){var e=n.split(".");return function(n){for(var t=0;t<e.length;t++){if(!n)return;n=n[e[t]]}return n}}}(e),this.getter||(this.getter=J)),this.value=this.lazy?void 0:this.get()}return n.prototype.get=function(){var n;wn(this);var e=this.vm;try{n=this.getter.call(e,e)}catch(n){if(!this.user)throw n;Ce(n,e,'getter for watcher "'.concat(this.expression,'"'))}finally{this.deep&&Ne(n),jn(),this.cleanupDeps()}return n},n.prototype.addDep=function(n){var e=n.id;this.newDepIds.has(e)||(this.newDepIds.add(e),this.newDeps.push(n),this.depIds.has(e)||n.addSub(this))},n.prototype.cleanupDeps=function(){for(var n=this.deps.length;n--;){var e=this.deps[n];this.newDepIds.has(e.id)||e.removeSub(this)}var t=this.depIds;this.depIds=this.newDepIds,this.newDepIds=t,this.newDepIds.clear(),t=this.deps,this.deps=this.newDeps,this.newDeps=t,this.newDeps.length=0},n.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():mt(this)},n.prototype.run=function(){if(this.active){var n=this.get();if(n!==this.value||p(n)||this.deep){var e=this.value;if(this.value=n,this.user){var t='callback for watcher "'.concat(this.expression,'"');Ee(this.cb,this.vm,[n,e],this.vm,t)}else this.cb.call(this.vm,n,e)}}},n.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},n.prototype.depend=function(){for(var n=this.deps.length;n--;)this.deps[n].depend()},n.prototype.teardown=function(){if(this.vm&&!this.vm._isBeingDestroyed&&S(this.vm._scope.effects,this),this.active){for(var n=this.deps.length;n--;)this.deps[n].removeSub(this);this.active=!1,this.onStop&&this.onStop()}},n}();function Ve(n,e){He.$on(n,e)}function Ge(n,e){He.$off(n,e)}function Xe(n,e){var t=He;return function a(){var r=e.apply(null,arguments);null!==r&&t.$off(n,a)}}function Qe(n,e,t){He=n,Vn(e,t||{},Ve,Ge,Xe,n),He=void 0}var Ke=null;function Ze(n){var e=Ke;return Ke=n,function(){Ke=e}}function Ye(n){for(;n&&(n=n.$parent);)if(n._inactive)return!0;return!1}function nt(n,e){if(e){if(n._directInactive=!1,Ye(n))return}else if(n._directInactive)return;if(n._inactive||null===n._inactive){n._inactive=!1;for(var t=0;t<n.$children.length;t++)nt(n.$children[t]);et(n,"activated")}}function et(n,e,t,a){void 0===a&&(a=!0),wn();var r=un,i=Un;a&&mn(n);var o=n.$options[e],s="".concat(e," hook");if(o)for(var l=0,c=o.length;l<c;l++)Ee(o[l],n,t||null,n,s);n._hasHookEvent&&n.$emit("hook:"+e),a&&(mn(r),i&&i.on()),jn()}var tt=[],at=[],rt={},it=!1,ot=!1,st=0;var lt=0,ct=Date.now;if(X&&!K){var pt=window.performance;pt&&"function"==typeof pt.now&&ct()>document.createEvent("Event").timeStamp&&(ct=function(){return pt.now()})}var dt=function(n,e){if(n.post){if(!e.post)return 1}else if(e.post)return-1;return n.id-e.id};function ut(){var n,e;for(lt=ct(),ot=!0,tt.sort(dt),st=0;st<tt.length;st++)(n=tt[st]).before&&n.before(),e=n.id,rt[e]=null,n.run();var t=at.slice(),a=tt.slice();st=tt.length=at.length=0,rt={},it=ot=!1,function(n){for(var e=0;e<n.length;e++)n[e]._inactive=!0,nt(n[e],!0)}(t),function(n){var e=n.length;for(;e--;){var t=n[e],a=t.vm;a&&a._watcher===t&&a._isMounted&&!a._isDestroyed&&et(a,"updated")}}(a),function(){for(var n=0;n<yn.length;n++){var e=yn[n];e.subs=e.subs.filter((function(n){return n})),e._pending=!1}yn.length=0}(),ln&&N.devtools&&ln.emit("flush")}function mt(n){var e=n.id;if(null==rt[e]&&(n!==xn.target||!n.noRecurse)){if(rt[e]=!0,ot){for(var t=tt.length-1;t>st&&tt[t].id>n.id;)t--;tt.splice(t+1,0,n)}else tt.push(n);it||(it=!0,qe(ut))}}function gt(n,e){if(n){for(var t=Object.create(null),a=dn?Reflect.ownKeys(n):Object.keys(n),r=0;r<a.length;r++){var i=a[r];if("__ob__"!==i){var o=n[i].from;if(o in e._provided)t[i]=e._provided[o];else if("default"in n[i]){var s=n[i].default;t[i]=c(s)?s.call(e):s}else 0}}return t}}function ht(n,e,t,i,o){var l,c=this,p=o.options;j(i,"_uid")?(l=Object.create(i))._original=i:(l=i,i=i._original);var d=s(p._compiled),u=!d;this.data=n,this.props=e,this.children=t,this.parent=i,this.listeners=n.on||a,this.injections=gt(p.inject,i),this.slots=function(){return c.$slots||ve(i,n.scopedSlots,c.$slots=me(t,i)),c.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return ve(i,n.scopedSlots,this.slots())}}),d&&(this.$options=p,this.$slots=this.slots(),this.$scopedSlots=ve(i,n.scopedSlots,this.$slots)),p._scopeId?this._c=function(n,e,t,a){var o=Ie(l,n,e,t,a,u);return o&&!r(o)&&(o.fnScopeId=p._scopeId,o.fnContext=i),o}:this._c=function(n,e,t,a){return Ie(l,n,e,t,a,u)}}function vt(n,e,t,a,r){var i=bn(n);return i.fnContext=t,i.fnOptions=a,e.slot&&((i.data||(i.data={})).slot=e.slot),i}function bt(n,e){for(var t in e)n[I(t)]=e[t]}function ft(n){return n.name||n.__name||n._componentTag}ue(ht.prototype);var yt={init:function(n,e){if(n.componentInstance&&!n.componentInstance._isDestroyed&&n.data.keepAlive){var t=n;yt.prepatch(t,t)}else{(n.componentInstance=function(n,e){var t={_isComponent:!0,_parentVnode:n,parent:e},a=n.data.inlineTemplate;o(a)&&(t.render=a.render,t.staticRenderFns=a.staticRenderFns);return new n.componentOptions.Ctor(t)}(n,Ke)).$mount(e?n.elm:void 0,e)}},prepatch:function(n,e){var t=e.componentOptions;!function(n,e,t,r,i){var o=r.data.scopedSlots,s=n.$scopedSlots,l=!!(o&&!o.$stable||s!==a&&!s.$stable||o&&n.$scopedSlots.$key!==o.$key||!o&&n.$scopedSlots.$key),c=!!(i||n.$options._renderChildren||l),p=n.$vnode;n.$options._parentVnode=r,n.$vnode=r,n._vnode&&(n._vnode.parent=r),n.$options._renderChildren=i;var d=r.data.attrs||a;n._attrsProxy&&xe(n._attrsProxy,d,p.data&&p.data.attrs||a,n,"$attrs")&&(c=!0),n.$attrs=d,t=t||a;var u=n.$options._parentListeners;if(n._listenersProxy&&xe(n._listenersProxy,t,u||a,n,"$listeners"),n.$listeners=n.$options._parentListeners=t,Qe(n,t,u),e&&n.$options.props){An(!1);for(var m=n._props,g=n.$options._propKeys||[],h=0;h<g.length;h++){var v=g[h],b=n.$options.props;m[v]=Mt(v,b,e,n)}An(!0),n.$options.propsData=e}c&&(n.$slots=me(i,r.context),n.$forceUpdate())}(e.componentInstance=n.componentInstance,t.propsData,t.listeners,e,t.children)},insert:function(n){var e,t=n.context,a=n.componentInstance;a._isMounted||(a._isMounted=!0,et(a,"mounted")),n.data.keepAlive&&(t._isMounted?((e=a)._inactive=!1,at.push(e)):nt(a,!0))},destroy:function(n){var e=n.componentInstance;e._isDestroyed||(n.data.keepAlive?function n(e,t){if(!(t&&(e._directInactive=!0,Ye(e))||e._inactive)){e._inactive=!0;for(var a=0;a<e.$children.length;a++)n(e.$children[a]);et(e,"deactivated")}}(e,!0):e.$destroy())}},xt=Object.keys(yt);function St(n,e,t,l,c){if(!i(n)){var d=t.$options._base;if(p(n)&&(n=d.extend(n)),"function"==typeof n){var u;if(i(n.cid)&&void 0===(n=function(n,e){if(s(n.error)&&o(n.errorComp))return n.errorComp;if(o(n.resolved))return n.resolved;var t=je;if(t&&o(n.owners)&&-1===n.owners.indexOf(t)&&n.owners.push(t),s(n.loading)&&o(n.loadingComp))return n.loadingComp;if(t&&!o(n.owners)){var a=n.owners=[t],r=!0,l=null,c=null;t.$on("hook:destroyed",(function(){return S(a,t)}));var d=function(n){for(var e=0,t=a.length;e<t;e++)a[e].$forceUpdate();n&&(a.length=0,null!==l&&(clearTimeout(l),l=null),null!==c&&(clearTimeout(c),c=null))},u=_((function(t){n.resolved=ke(t,e),r?a.length=0:d(!0)})),m=_((function(e){o(n.errorComp)&&(n.error=!0,d(!0))})),g=n(u,m);return p(g)&&(h(g)?i(n.resolved)&&g.then(u,m):h(g.component)&&(g.component.then(u,m),o(g.error)&&(n.errorComp=ke(g.error,e)),o(g.loading)&&(n.loadingComp=ke(g.loading,e),0===g.delay?n.loading=!0:l=setTimeout((function(){l=null,i(n.resolved)&&i(n.error)&&(n.loading=!0,d(!1))}),g.delay||200)),o(g.timeout)&&(c=setTimeout((function(){c=null,i(n.resolved)&&m(null)}),g.timeout)))),r=!1,n.loading?n.loadingComp:n.resolved}}(u=n,d)))return function(n,e,t,a,r){var i=hn();return i.asyncFactory=n,i.asyncMeta={data:e,context:t,children:a,tag:r},i}(u,e,t,l,c);e=e||{},Wt(n),o(e.model)&&function(n,e){var t=n.model&&n.model.prop||"value",a=n.model&&n.model.event||"input";(e.attrs||(e.attrs={}))[t]=e.model.value;var i=e.on||(e.on={}),s=i[a],l=e.model.callback;o(s)?(r(s)?-1===s.indexOf(l):s!==l)&&(i[a]=[l].concat(s)):i[a]=l}(n.options,e);var m=function(n,e,t){var a=e.options.props;if(!i(a)){var r={},s=n.attrs,l=n.props;if(o(s)||o(l))for(var c in a){var p=A(c);Xn(r,l,c,p,!0)||Xn(r,s,c,p,!1)}return r}}(e,n);if(s(n.options.functional))return function(n,e,t,i,s){var l=n.options,c={},p=l.props;if(o(p))for(var d in p)c[d]=Mt(d,p,e||a);else o(t.attrs)&&bt(c,t.attrs),o(t.props)&&bt(c,t.props);var u=new ht(t,c,s,i,n),m=l.render.call(null,u._c,u);if(m instanceof gn)return vt(m,t,u.parent,l,u);if(r(m)){for(var g=Qn(m)||[],h=new Array(g.length),v=0;v<g.length;v++)h[v]=vt(g[v],t,u.parent,l,u);return h}}(n,m,e,t,l);var g=e.on;if(e.on=e.nativeOn,s(n.options.abstract)){var v=e.slot;e={},v&&(e.slot=v)}!function(n){for(var e=n.hook||(n.hook={}),t=0;t<xt.length;t++){var a=xt[t],r=e[a],i=yt[a];r===i||r&&r._merged||(e[a]=r?wt(i,r):i)}}(e);var b=ft(n.options)||c;return new gn("vue-component-".concat(n.cid).concat(b?"-".concat(b):""),e,void 0,void 0,void 0,t,{Ctor:n,propsData:m,listeners:g,tag:c,children:l},u)}}}function wt(n,e){var t=function(t,a){n(t,a),e(t,a)};return t._merged=!0,t}var jt=J,kt=N.optionMergeStrategies;function Tt(n,e,t){if(void 0===t&&(t=!0),!e)return n;for(var a,r,i,o=dn?Reflect.ownKeys(e):Object.keys(e),s=0;s<o.length;s++)"__ob__"!==(a=o[s])&&(r=n[a],i=e[a],t&&j(n,a)?r!==i&&u(r)&&u(i)&&Tt(r,i):Jn(n,a,i));return n}function It(n,e,t){return t?function(){var a=c(e)?e.call(t,t):e,r=c(n)?n.call(t,t):n;return a?Tt(a,r):r}:e?n?function(){return Tt(c(e)?e.call(this,this):e,c(n)?n.call(this,this):n)}:e:n}function Ct(n,e){var t=e?n?n.concat(e):r(e)?e:[e]:n;return t?function(n){for(var e=[],t=0;t<n.length;t++)-1===e.indexOf(n[t])&&e.push(n[t]);return e}(t):t}function Et(n,e,t,a){var r=Object.create(n||null);return e?M(r,e):r}kt.data=function(n,e,t){return t?It(n,e,t):e&&"function"!=typeof e?n:It(n,e)},U.forEach((function(n){kt[n]=Ct})),F.forEach((function(n){kt[n+"s"]=Et})),kt.watch=function(n,e,t,a){if(n===an&&(n=void 0),e===an&&(e=void 0),!e)return Object.create(n||null);if(!n)return e;var i={};for(var o in M(i,n),e){var s=i[o],l=e[o];s&&!r(s)&&(s=[s]),i[o]=s?s.concat(l):r(l)?l:[l]}return i},kt.props=kt.methods=kt.inject=kt.computed=function(n,e,t,a){if(!n)return e;var r=Object.create(null);return M(r,n),e&&M(r,e),r},kt.provide=function(n,e){return n?function(){var t=Object.create(null);return Tt(t,c(n)?n.call(this):n),e&&Tt(t,c(e)?e.call(this):e,!1),t}:e};var At=function(n,e){return void 0===e?n:e};function Pt(n,e,t){if(c(e)&&(e=e.options),function(n,e){var t=n.props;if(t){var a,i,o={};if(r(t))for(a=t.length;a--;)"string"==typeof(i=t[a])&&(o[I(i)]={type:null});else if(u(t))for(var s in t)i=t[s],o[I(s)]=u(i)?i:{type:i};else 0;n.props=o}}(e),function(n,e){var t=n.inject;if(t){var a=n.inject={};if(r(t))for(var i=0;i<t.length;i++)a[t[i]]={from:t[i]};else if(u(t))for(var o in t){var s=t[o];a[o]=u(s)?M({from:o},s):{from:s}}else 0}}(e),function(n){var e=n.directives;if(e)for(var t in e){var a=e[t];c(a)&&(e[t]={bind:a,update:a})}}(e),!e._base&&(e.extends&&(n=Pt(n,e.extends,t)),e.mixins))for(var a=0,i=e.mixins.length;a<i;a++)n=Pt(n,e.mixins[a],t);var o,s={};for(o in n)l(o);for(o in e)j(n,o)||l(o);function l(a){var r=kt[a]||At;s[a]=r(n[a],e[a],t,a)}return s}function Bt(n,e,t,a){if("string"==typeof t){var r=n[e];if(j(r,t))return r[t];var i=I(t);if(j(r,i))return r[i];var o=C(i);return j(r,o)?r[o]:r[t]||r[i]||r[o]}}function Mt(n,e,t,a){var r=e[n],i=!j(t,n),o=t[n],s=Lt(Boolean,r.type);if(s>-1)if(i&&!j(r,"default"))o=!1;else if(""===o||o===A(n)){var l=Lt(String,r.type);(l<0||s<l)&&(o=!0)}if(void 0===o){o=function(n,e,t){if(!j(e,"default"))return;var a=e.default;0;if(n&&n.$options.propsData&&void 0===n.$options.propsData[t]&&void 0!==n._props[t])return n._props[t];return c(a)&&"Function"!==Jt(e.type)?a.call(n):a}(a,r,n);var p=En;An(!0),Mn(o),An(p)}return o}var zt=/^\s*function (\w+)/;function Jt(n){var e=n&&n.toString().match(zt);return e?e[1]:""}function Rt(n,e){return Jt(n)===Jt(e)}function Lt(n,e){if(!r(e))return Rt(e,n)?0:-1;for(var t=0,a=e.length;t<a;t++)if(Rt(e[t],n))return t;return-1}var Dt={enumerable:!0,configurable:!0,get:J,set:J};function Ot(n,e,t){Dt.get=function(){return this[e][t]},Dt.set=function(n){this[e][t]=n},Object.defineProperty(n,t,Dt)}function _t(n){var e=n.$options;if(e.props&&function(n,e){var t=n.$options.propsData||{},a=n._props=Dn({}),r=n.$options._propKeys=[];n.$parent&&An(!1);var i=function(i){r.push(i);var o=Mt(i,e,t,n);zn(a,i,o,void 0,!0),i in n||Ot(n,"_props",i)};for(var o in e)i(o);An(!0)}(n,e.props),function(n){var e=n.$options,t=e.setup;if(t){var a=n._setupContext=ye(n);mn(n),wn();var r=Ee(t,null,[n._props||Dn({}),a],n,"setup");if(jn(),mn(),c(r))e.render=r;else if(p(r))if(n._setupState=r,r.__sfc){var i=n._setupProxy={};for(var o in r)"__sfc"!==o&&Fn(i,r,o)}else for(var o in r)$(o)||Fn(n,r,o);else 0}}(n),e.methods&&function(n,e){n.$options.props;for(var t in e)n[t]="function"!=typeof e[t]?J:P(e[t],n)}(n,e.methods),e.data)!function(n){var e=n.$options.data;u(e=n._data=c(e)?function(n,e){wn();try{return n.call(e,e)}catch(n){return Ce(n,e,"data()"),{}}finally{jn()}}(e,n):e||{})||(e={});var t=Object.keys(e),a=n.$options.props,r=(n.$options.methods,t.length);for(;r--;){var i=t[r];0,a&&j(a,i)||$(i)||Ot(n,"_data",i)}var o=Mn(e);o&&o.vmCount++}(n);else{var t=Mn(n._data={});t&&t.vmCount++}e.computed&&function(n,e){var t=n._computedWatchers=Object.create(null),a=sn();for(var r in e){var i=e[r],o=c(i)?i:i.get;0,a||(t[r]=new We(n,o||J,J,qt)),r in n||Ft(n,r,i)}}(n,e.computed),e.watch&&e.watch!==an&&function(n,e){for(var t in e){var a=e[t];if(r(a))for(var i=0;i<a.length;i++)Ht(n,t,a[i]);else Ht(n,t,a)}}(n,e.watch)}var qt={lazy:!0};function Ft(n,e,t){var a=!sn();c(t)?(Dt.get=a?Ut(e):Nt(t),Dt.set=J):(Dt.get=t.get?a&&!1!==t.cache?Ut(e):Nt(t.get):J,Dt.set=t.set||J),Object.defineProperty(n,e,Dt)}function Ut(n){return function(){var e=this._computedWatchers&&this._computedWatchers[n];if(e)return e.dirty&&e.evaluate(),xn.target&&e.depend(),e.value}}function Nt(n){return function(){return n.call(this,this)}}function Ht(n,e,t,a){return u(t)&&(a=t,t=t.handler),"string"==typeof t&&(t=n[t]),n.$watch(e,t,a)}var $t=0;function Wt(n){var e=n.options;if(n.super){var t=Wt(n.super);if(t!==n.superOptions){n.superOptions=t;var a=function(n){var e,t=n.options,a=n.sealedOptions;for(var r in t)t[r]!==a[r]&&(e||(e={}),e[r]=t[r]);return e}(n);a&&M(n.extendOptions,a),(e=n.options=Pt(t,n.extendOptions)).name&&(e.components[e.name]=n)}}return e}function Vt(n){this._init(n)}function Gt(n){n.cid=0;var e=1;n.extend=function(n){n=n||{};var t=this,a=t.cid,r=n._Ctor||(n._Ctor={});if(r[a])return r[a];var i=ft(n)||ft(t.options);var o=function(n){this._init(n)};return(o.prototype=Object.create(t.prototype)).constructor=o,o.cid=e++,o.options=Pt(t.options,n),o.super=t,o.options.props&&function(n){var e=n.options.props;for(var t in e)Ot(n.prototype,"_props",t)}(o),o.options.computed&&function(n){var e=n.options.computed;for(var t in e)Ft(n.prototype,t,e[t])}(o),o.extend=t.extend,o.mixin=t.mixin,o.use=t.use,F.forEach((function(n){o[n]=t[n]})),i&&(o.options.components[i]=o),o.superOptions=t.options,o.extendOptions=n,o.sealedOptions=M({},o.options),r[a]=o,o}}function Xt(n){return n&&(ft(n.Ctor.options)||n.tag)}function Qt(n,e){return r(n)?n.indexOf(e)>-1:"string"==typeof n?n.split(",").indexOf(e)>-1:!!m(n)&&n.test(e)}function Kt(n,e){var t=n.cache,a=n.keys,r=n._vnode,i=n.$vnode;for(var o in t){var s=t[o];if(s){var l=s.name;l&&!e(l)&&Zt(t,o,a,r)}}i.componentOptions.children=void 0}function Zt(n,e,t,a){var r=n[e];!r||a&&r.tag===a.tag||r.componentInstance.$destroy(),n[e]=null,S(t,e)}!function(n){n.prototype._init=function(n){var e=this;e._uid=$t++,e._isVue=!0,e.__v_skip=!0,e._scope=new Nn(!0),e._scope.parent=void 0,e._scope._vm=!0,n&&n._isComponent?function(n,e){var t=n.$options=Object.create(n.constructor.options),a=e._parentVnode;t.parent=e.parent,t._parentVnode=a;var r=a.componentOptions;t.propsData=r.propsData,t._parentListeners=r.listeners,t._renderChildren=r.children,t._componentTag=r.tag,e.render&&(t.render=e.render,t.staticRenderFns=e.staticRenderFns)}(e,n):e.$options=Pt(Wt(e.constructor),n||{},e),e._renderProxy=e,e._self=e,function(n){var e=n.$options,t=e.parent;if(t&&!e.abstract){for(;t.$options.abstract&&t.$parent;)t=t.$parent;t.$children.push(n)}n.$parent=t,n.$root=t?t.$root:n,n.$children=[],n.$refs={},n._provided=t?t._provided:Object.create(null),n._watcher=null,n._inactive=null,n._directInactive=!1,n._isMounted=!1,n._isDestroyed=!1,n._isBeingDestroyed=!1}(e),function(n){n._events=Object.create(null),n._hasHookEvent=!1;var e=n.$options._parentListeners;e&&Qe(n,e)}(e),function(n){n._vnode=null,n._staticTrees=null;var e=n.$options,t=n.$vnode=e._parentVnode,r=t&&t.context;n.$slots=me(e._renderChildren,r),n.$scopedSlots=t?ve(n.$parent,t.data.scopedSlots,n.$slots):a,n._c=function(e,t,a,r){return Ie(n,e,t,a,r,!1)},n.$createElement=function(e,t,a,r){return Ie(n,e,t,a,r,!0)};var i=t&&t.data;zn(n,"$attrs",i&&i.attrs||a,null,!0),zn(n,"$listeners",e._parentListeners||a,null,!0)}(e),et(e,"beforeCreate",void 0,!1),function(n){var e=gt(n.$options.inject,n);e&&(An(!1),Object.keys(e).forEach((function(t){zn(n,t,e[t])})),An(!0))}(e),_t(e),function(n){var e=n.$options.provide;if(e){var t=c(e)?e.call(n):e;if(!p(t))return;for(var a=Hn(n),r=dn?Reflect.ownKeys(t):Object.keys(t),i=0;i<r.length;i++){var o=r[i];Object.defineProperty(a,o,Object.getOwnPropertyDescriptor(t,o))}}}(e),et(e,"created"),e.$options.el&&e.$mount(e.$options.el)}}(Vt),function(n){var e={get:function(){return this._data}},t={get:function(){return this._props}};Object.defineProperty(n.prototype,"$data",e),Object.defineProperty(n.prototype,"$props",t),n.prototype.$set=Jn,n.prototype.$delete=Rn,n.prototype.$watch=function(n,e,t){if(u(e))return Ht(this,n,e,t);(t=t||{}).user=!0;var a=new We(this,n,e,t);if(t.immediate){var r='callback for immediate watcher "'.concat(a.expression,'"');wn(),Ee(e,this,[a.value],this,r),jn()}return function(){a.teardown()}}}(Vt),function(n){var e=/^hook:/;n.prototype.$on=function(n,t){var a=this;if(r(n))for(var i=0,o=n.length;i<o;i++)a.$on(n[i],t);else(a._events[n]||(a._events[n]=[])).push(t),e.test(n)&&(a._hasHookEvent=!0);return a},n.prototype.$once=function(n,e){var t=this;function a(){t.$off(n,a),e.apply(t,arguments)}return a.fn=e,t.$on(n,a),t},n.prototype.$off=function(n,e){var t=this;if(!arguments.length)return t._events=Object.create(null),t;if(r(n)){for(var a=0,i=n.length;a<i;a++)t.$off(n[a],e);return t}var o,s=t._events[n];if(!s)return t;if(!e)return t._events[n]=null,t;for(var l=s.length;l--;)if((o=s[l])===e||o.fn===e){s.splice(l,1);break}return t},n.prototype.$emit=function(n){var e=this,t=e._events[n];if(t){t=t.length>1?B(t):t;for(var a=B(arguments,1),r='event handler for "'.concat(n,'"'),i=0,o=t.length;i<o;i++)Ee(t[i],e,a,e,r)}return e}}(Vt),function(n){n.prototype._update=function(n,e){var t=this,a=t.$el,r=t._vnode,i=Ze(t);t._vnode=n,t.$el=r?t.__patch__(r,n):t.__patch__(t.$el,n,e,!1),i(),a&&(a.__vue__=null),t.$el&&(t.$el.__vue__=t);for(var o=t;o&&o.$vnode&&o.$parent&&o.$vnode===o.$parent._vnode;)o.$parent.$el=o.$el,o=o.$parent},n.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},n.prototype.$destroy=function(){var n=this;if(!n._isBeingDestroyed){et(n,"beforeDestroy"),n._isBeingDestroyed=!0;var e=n.$parent;!e||e._isBeingDestroyed||n.$options.abstract||S(e.$children,n),n._scope.stop(),n._data.__ob__&&n._data.__ob__.vmCount--,n._isDestroyed=!0,n.__patch__(n._vnode,null),et(n,"destroyed"),n.$off(),n.$el&&(n.$el.__vue__=null),n.$vnode&&(n.$vnode.parent=null)}}}(Vt),function(n){ue(n.prototype),n.prototype.$nextTick=function(n){return qe(n,this)},n.prototype._render=function(){var n=this,e=n.$options,t=e.render,a=e._parentVnode;a&&n._isMounted&&(n.$scopedSlots=ve(n.$parent,a.data.scopedSlots,n.$slots,n.$scopedSlots),n._slotsProxy&&we(n._slotsProxy,n.$scopedSlots)),n.$vnode=a;var i,o=un,s=je;try{mn(n),je=n,i=t.call(n._renderProxy,n.$createElement)}catch(e){Ce(e,n,"render"),i=n._vnode}finally{je=s,mn(o)}return r(i)&&1===i.length&&(i=i[0]),i instanceof gn||(i=hn()),i.parent=a,i}}(Vt);var Yt=[String,RegExp,Array],na={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:Yt,exclude:Yt,max:[String,Number]},methods:{cacheVNode:function(){var n=this.cache,e=this.keys,t=this.vnodeToCache,a=this.keyToCache;if(t){var r=t.tag,i=t.componentInstance,o=t.componentOptions;n[a]={name:Xt(o),tag:r,componentInstance:i},e.push(a),this.max&&e.length>parseInt(this.max)&&Zt(n,e[0],e,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var n in this.cache)Zt(this.cache,n,this.keys)},mounted:function(){var n=this;this.cacheVNode(),this.$watch("include",(function(e){Kt(n,(function(n){return Qt(e,n)}))})),this.$watch("exclude",(function(e){Kt(n,(function(n){return!Qt(e,n)}))}))},updated:function(){this.cacheVNode()},render:function(){var n=this.$slots.default,e=Te(n),t=e&&e.componentOptions;if(t){var a=Xt(t),r=this.include,i=this.exclude;if(r&&(!a||!Qt(r,a))||i&&a&&Qt(i,a))return e;var o=this.cache,s=this.keys,l=null==e.key?t.Ctor.cid+(t.tag?"::".concat(t.tag):""):e.key;o[l]?(e.componentInstance=o[l].componentInstance,S(s,l),s.push(l)):(this.vnodeToCache=e,this.keyToCache=l),e.data.keepAlive=!0}return e||n&&n[0]}}};!function(n){var e={get:function(){return N}};Object.defineProperty(n,"config",e),n.util={warn:jt,extend:M,mergeOptions:Pt,defineReactive:zn},n.set=Jn,n.delete=Rn,n.nextTick=qe,n.observable=function(n){return Mn(n),n},n.options=Object.create(null),F.forEach((function(e){n.options[e+"s"]=Object.create(null)})),n.options._base=n,M(n.options.components,na),function(n){n.use=function(n){var e=this._installedPlugins||(this._installedPlugins=[]);if(e.indexOf(n)>-1)return this;var t=B(arguments,1);return t.unshift(this),c(n.install)?n.install.apply(n,t):c(n)&&n.apply(null,t),e.push(n),this}}(n),function(n){n.mixin=function(n){return this.options=Pt(this.options,n),this}}(n),Gt(n),function(n){F.forEach((function(e){n[e]=function(n,t){return t?("component"===e&&u(t)&&(t.name=t.name||n,t=this.options._base.extend(t)),"directive"===e&&c(t)&&(t={bind:t,update:t}),this.options[e+"s"][n]=t,t):this.options[e+"s"][n]}}))}(n)}(Vt),Object.defineProperty(Vt.prototype,"$isServer",{get:sn}),Object.defineProperty(Vt.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(Vt,"FunctionalRenderContext",{value:ht}),Vt.version="2.7.16";var ea=y("style,class"),ta=y("input,textarea,option,select,progress"),aa=y("contenteditable,draggable,spellcheck"),ra=y("events,caret,typing,plaintext-only"),ia=y("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),oa="http://www.w3.org/1999/xlink",sa=function(n){return":"===n.charAt(5)&&"xlink"===n.slice(0,5)},la=function(n){return sa(n)?n.slice(6,n.length):""},ca=function(n){return null==n||!1===n};function pa(n){for(var e=n.data,t=n,a=n;o(a.componentInstance);)(a=a.componentInstance._vnode)&&a.data&&(e=da(a.data,e));for(;o(t=t.parent);)t&&t.data&&(e=da(e,t.data));return function(n,e){if(o(n)||o(e))return ua(n,ma(e));return""}(e.staticClass,e.class)}function da(n,e){return{staticClass:ua(n.staticClass,e.staticClass),class:o(n.class)?[n.class,e.class]:e.class}}function ua(n,e){return n?e?n+" "+e:n:e||""}function ma(n){return Array.isArray(n)?function(n){for(var e,t="",a=0,r=n.length;a<r;a++)o(e=ma(n[a]))&&""!==e&&(t&&(t+=" "),t+=e);return t}(n):p(n)?function(n){var e="";for(var t in n)n[t]&&(e&&(e+=" "),e+=t);return e}(n):"string"==typeof n?n:""}var ga={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},ha=y("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),va=y("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),ba=function(n){return ha(n)||va(n)};var fa=Object.create(null);var ya=y("text,number,password,search,email,tel,url");var xa=Object.freeze({__proto__:null,createElement:function(n,e){var t=document.createElement(n);return"select"!==n||e.data&&e.data.attrs&&void 0!==e.data.attrs.multiple&&t.setAttribute("multiple","multiple"),t},createElementNS:function(n,e){return document.createElementNS(ga[n],e)},createTextNode:function(n){return document.createTextNode(n)},createComment:function(n){return document.createComment(n)},insertBefore:function(n,e,t){n.insertBefore(e,t)},removeChild:function(n,e){n.removeChild(e)},appendChild:function(n,e){n.appendChild(e)},parentNode:function(n){return n.parentNode},nextSibling:function(n){return n.nextSibling},tagName:function(n){return n.tagName},setTextContent:function(n,e){n.textContent=e},setStyleScope:function(n,e){n.setAttribute(e,"")}}),Sa={create:function(n,e){wa(e)},update:function(n,e){n.data.ref!==e.data.ref&&(wa(n,!0),wa(e))},destroy:function(n){wa(n,!0)}};function wa(n,e){var t=n.data.ref;if(o(t)){var a=n.context,i=n.componentInstance||n.elm,s=e?null:i,l=e?void 0:i;if(c(t))Ee(t,a,[s],a,"template ref function");else{var p=n.data.refInFor,d="string"==typeof t||"number"==typeof t,u=qn(t),m=a.$refs;if(d||u)if(p){var g=d?m[t]:t.value;e?r(g)&&S(g,i):r(g)?g.includes(i)||g.push(i):d?(m[t]=[i],ja(a,t,m[t])):t.value=[i]}else if(d){if(e&&m[t]!==i)return;m[t]=l,ja(a,t,s)}else if(u){if(e&&t.value!==i)return;t.value=s}else 0}}}function ja(n,e,t){var a=n._setupState;a&&j(a,e)&&(qn(a[e])?a[e].value=t:a[e]=t)}var ka=new gn("",{},[]),Ta=["create","activate","update","remove","destroy"];function Ia(n,e){return n.key===e.key&&n.asyncFactory===e.asyncFactory&&(n.tag===e.tag&&n.isComment===e.isComment&&o(n.data)===o(e.data)&&function(n,e){if("input"!==n.tag)return!0;var t,a=o(t=n.data)&&o(t=t.attrs)&&t.type,r=o(t=e.data)&&o(t=t.attrs)&&t.type;return a===r||ya(a)&&ya(r)}(n,e)||s(n.isAsyncPlaceholder)&&i(e.asyncFactory.error))}function Ca(n,e,t){var a,r,i={};for(a=e;a<=t;++a)o(r=n[a].key)&&(i[r]=a);return i}var Ea={create:Aa,update:Aa,destroy:function(n){Aa(n,ka)}};function Aa(n,e){(n.data.directives||e.data.directives)&&function(n,e){var t,a,r,i=n===ka,o=e===ka,s=Ba(n.data.directives,n.context),l=Ba(e.data.directives,e.context),c=[],p=[];for(t in l)a=s[t],r=l[t],a?(r.oldValue=a.value,r.oldArg=a.arg,za(r,"update",e,n),r.def&&r.def.componentUpdated&&p.push(r)):(za(r,"bind",e,n),r.def&&r.def.inserted&&c.push(r));if(c.length){var d=function(){for(var t=0;t<c.length;t++)za(c[t],"inserted",e,n)};i?Gn(e,"insert",d):d()}p.length&&Gn(e,"postpatch",(function(){for(var t=0;t<p.length;t++)za(p[t],"componentUpdated",e,n)}));if(!i)for(t in s)l[t]||za(s[t],"unbind",n,n,o)}(n,e)}var Pa=Object.create(null);function Ba(n,e){var t,a,r=Object.create(null);if(!n)return r;for(t=0;t<n.length;t++){if((a=n[t]).modifiers||(a.modifiers=Pa),r[Ma(a)]=a,e._setupState&&e._setupState.__sfc){var i=a.def||Bt(e,"_setupState","v-"+a.name);a.def="function"==typeof i?{bind:i,update:i}:i}a.def=a.def||Bt(e.$options,"directives",a.name)}return r}function Ma(n){return n.rawName||"".concat(n.name,".").concat(Object.keys(n.modifiers||{}).join("."))}function za(n,e,t,a,r){var i=n.def&&n.def[e];if(i)try{i(t.elm,n,t,a,r)}catch(a){Ce(a,t.context,"directive ".concat(n.name," ").concat(e," hook"))}}var Ja=[Sa,Ea];function Ra(n,e){var t=e.componentOptions;if(!(o(t)&&!1===t.Ctor.options.inheritAttrs||i(n.data.attrs)&&i(e.data.attrs))){var a,r,l=e.elm,c=n.data.attrs||{},p=e.data.attrs||{};for(a in(o(p.__ob__)||s(p._v_attr_proxy))&&(p=e.data.attrs=M({},p)),p)r=p[a],c[a]!==r&&La(l,a,r,e.data.pre);for(a in(K||Y)&&p.value!==c.value&&La(l,"value",p.value),c)i(p[a])&&(sa(a)?l.removeAttributeNS(oa,la(a)):aa(a)||l.removeAttribute(a))}}function La(n,e,t,a){a||n.tagName.indexOf("-")>-1?Da(n,e,t):ia(e)?ca(t)?n.removeAttribute(e):(t="allowfullscreen"===e&&"EMBED"===n.tagName?"true":e,n.setAttribute(e,t)):aa(e)?n.setAttribute(e,function(n,e){return ca(e)||"false"===e?"false":"contenteditable"===n&&ra(e)?e:"true"}(e,t)):sa(e)?ca(t)?n.removeAttributeNS(oa,la(e)):n.setAttributeNS(oa,e,t):Da(n,e,t)}function Da(n,e,t){if(ca(t))n.removeAttribute(e);else{if(K&&!Z&&"TEXTAREA"===n.tagName&&"placeholder"===e&&""!==t&&!n.__ieph){var a=function(e){e.stopImmediatePropagation(),n.removeEventListener("input",a)};n.addEventListener("input",a),n.__ieph=!0}n.setAttribute(e,t)}}var Oa={create:Ra,update:Ra};function _a(n,e){var t=e.elm,a=e.data,r=n.data;if(!(i(a.staticClass)&&i(a.class)&&(i(r)||i(r.staticClass)&&i(r.class)))){var s=pa(e),l=t._transitionClasses;o(l)&&(s=ua(s,ma(l))),s!==t._prevClass&&(t.setAttribute("class",s),t._prevClass=s)}}var qa,Fa={create:_a,update:_a};function Ua(n,e,t){var a=qa;return function r(){var i=e.apply(null,arguments);null!==i&&$a(n,r,t,a)}}var Na=Me&&!(tn&&Number(tn[1])<=53);function Ha(n,e,t,a){if(Na){var r=lt,i=e;e=i._wrapper=function(n){if(n.target===n.currentTarget||n.timeStamp>=r||n.timeStamp<=0||n.target.ownerDocument!==document)return i.apply(this,arguments)}}qa.addEventListener(n,e,rn?{capture:t,passive:a}:t)}function $a(n,e,t,a){(a||qa).removeEventListener(n,e._wrapper||e,t)}function Wa(n,e){if(!i(n.data.on)||!i(e.data.on)){var t=e.data.on||{},a=n.data.on||{};qa=e.elm||n.elm,function(n){if(o(n.__r)){var e=K?"change":"input";n[e]=[].concat(n.__r,n[e]||[]),delete n.__r}o(n.__c)&&(n.change=[].concat(n.__c,n.change||[]),delete n.__c)}(t),Vn(t,a,Ha,$a,Ua,e.context),qa=void 0}}var Va,Ga={create:Wa,update:Wa,destroy:function(n){return Wa(n,ka)}};function Xa(n,e){if(!i(n.data.domProps)||!i(e.data.domProps)){var t,a,r=e.elm,l=n.data.domProps||{},c=e.data.domProps||{};for(t in(o(c.__ob__)||s(c._v_attr_proxy))&&(c=e.data.domProps=M({},c)),l)t in c||(r[t]="");for(t in c){if(a=c[t],"textContent"===t||"innerHTML"===t){if(e.children&&(e.children.length=0),a===l[t])continue;1===r.childNodes.length&&r.removeChild(r.childNodes[0])}if("value"===t&&"PROGRESS"!==r.tagName){r._value=a;var p=i(a)?"":String(a);Qa(r,p)&&(r.value=p)}else if("innerHTML"===t&&va(r.tagName)&&i(r.innerHTML)){(Va=Va||document.createElement("div")).innerHTML="<svg>".concat(a,"</svg>");for(var d=Va.firstChild;r.firstChild;)r.removeChild(r.firstChild);for(;d.firstChild;)r.appendChild(d.firstChild)}else if(a!==l[t])try{r[t]=a}catch(n){}}}}function Qa(n,e){return!n.composing&&("OPTION"===n.tagName||function(n,e){var t=!0;try{t=document.activeElement!==n}catch(n){}return t&&n.value!==e}(n,e)||function(n,e){var t=n.value,a=n._vModifiers;if(o(a)){if(a.number)return f(t)!==f(e);if(a.trim)return t.trim()!==e.trim()}return t!==e}(n,e))}var Ka={create:Xa,update:Xa},Za=k((function(n){var e={},t=/:(.+)/;return n.split(/;(?![^(]*\))/g).forEach((function(n){if(n){var a=n.split(t);a.length>1&&(e[a[0].trim()]=a[1].trim())}})),e}));function Ya(n){var e=nr(n.style);return n.staticStyle?M(n.staticStyle,e):e}function nr(n){return Array.isArray(n)?z(n):"string"==typeof n?Za(n):n}var er,tr=/^--/,ar=/\s*!important$/,rr=function(n,e,t){if(tr.test(e))n.style.setProperty(e,t);else if(ar.test(t))n.style.setProperty(A(e),t.replace(ar,""),"important");else{var a=or(e);if(Array.isArray(t))for(var r=0,i=t.length;r<i;r++)n.style[a]=t[r];else n.style[a]=t}},ir=["Webkit","Moz","ms"],or=k((function(n){if(er=er||document.createElement("div").style,"filter"!==(n=I(n))&&n in er)return n;for(var e=n.charAt(0).toUpperCase()+n.slice(1),t=0;t<ir.length;t++){var a=ir[t]+e;if(a in er)return a}}));function sr(n,e){var t=e.data,a=n.data;if(!(i(t.staticStyle)&&i(t.style)&&i(a.staticStyle)&&i(a.style))){var r,s,l=e.elm,c=a.staticStyle,p=a.normalizedStyle||a.style||{},d=c||p,u=nr(e.data.style)||{};e.data.normalizedStyle=o(u.__ob__)?M({},u):u;var m=function(n,e){var t,a={};if(e)for(var r=n;r.componentInstance;)(r=r.componentInstance._vnode)&&r.data&&(t=Ya(r.data))&&M(a,t);(t=Ya(n.data))&&M(a,t);for(var i=n;i=i.parent;)i.data&&(t=Ya(i.data))&&M(a,t);return a}(e,!0);for(s in d)i(m[s])&&rr(l,s,"");for(s in m)r=m[s],rr(l,s,null==r?"":r)}}var lr={create:sr,update:sr},cr=/\s+/;function pr(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(cr).forEach((function(e){return n.classList.add(e)})):n.classList.add(e);else{var t=" ".concat(n.getAttribute("class")||""," ");t.indexOf(" "+e+" ")<0&&n.setAttribute("class",(t+e).trim())}}function dr(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(cr).forEach((function(e){return n.classList.remove(e)})):n.classList.remove(e),n.classList.length||n.removeAttribute("class");else{for(var t=" ".concat(n.getAttribute("class")||""," "),a=" "+e+" ";t.indexOf(a)>=0;)t=t.replace(a," ");(t=t.trim())?n.setAttribute("class",t):n.removeAttribute("class")}}function ur(n){if(n){if("object"==typeof n){var e={};return!1!==n.css&&M(e,mr(n.name||"v")),M(e,n),e}return"string"==typeof n?mr(n):void 0}}var mr=k((function(n){return{enterClass:"".concat(n,"-enter"),enterToClass:"".concat(n,"-enter-to"),enterActiveClass:"".concat(n,"-enter-active"),leaveClass:"".concat(n,"-leave"),leaveToClass:"".concat(n,"-leave-to"),leaveActiveClass:"".concat(n,"-leave-active")}})),gr=X&&!Z,hr="transition",vr="transitionend",br="animation",fr="animationend";gr&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(hr="WebkitTransition",vr="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(br="WebkitAnimation",fr="webkitAnimationEnd"));var yr=X?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(n){return n()};function xr(n){yr((function(){yr(n)}))}function Sr(n,e){var t=n._transitionClasses||(n._transitionClasses=[]);t.indexOf(e)<0&&(t.push(e),pr(n,e))}function wr(n,e){n._transitionClasses&&S(n._transitionClasses,e),dr(n,e)}function jr(n,e,t){var a=Tr(n,e),r=a.type,i=a.timeout,o=a.propCount;if(!r)return t();var s="transition"===r?vr:fr,l=0,c=function(){n.removeEventListener(s,p),t()},p=function(e){e.target===n&&++l>=o&&c()};setTimeout((function(){l<o&&c()}),i+1),n.addEventListener(s,p)}var kr=/\b(transform|all)(,|$)/;function Tr(n,e){var t,a=window.getComputedStyle(n),r=(a[hr+"Delay"]||"").split(", "),i=(a[hr+"Duration"]||"").split(", "),o=Ir(r,i),s=(a[br+"Delay"]||"").split(", "),l=(a[br+"Duration"]||"").split(", "),c=Ir(s,l),p=0,d=0;return"transition"===e?o>0&&(t="transition",p=o,d=i.length):"animation"===e?c>0&&(t="animation",p=c,d=l.length):d=(t=(p=Math.max(o,c))>0?o>c?"transition":"animation":null)?"transition"===t?i.length:l.length:0,{type:t,timeout:p,propCount:d,hasTransform:"transition"===t&&kr.test(a[hr+"Property"])}}function Ir(n,e){for(;n.length<e.length;)n=n.concat(n);return Math.max.apply(null,e.map((function(e,t){return Cr(e)+Cr(n[t])})))}function Cr(n){return 1e3*Number(n.slice(0,-1).replace(",","."))}function Er(n,e){var t=n.elm;o(t._leaveCb)&&(t._leaveCb.cancelled=!0,t._leaveCb());var a=ur(n.data.transition);if(!i(a)&&!o(t._enterCb)&&1===t.nodeType){for(var r=a.css,s=a.type,l=a.enterClass,d=a.enterToClass,u=a.enterActiveClass,m=a.appearClass,g=a.appearToClass,h=a.appearActiveClass,v=a.beforeEnter,b=a.enter,y=a.afterEnter,x=a.enterCancelled,S=a.beforeAppear,w=a.appear,j=a.afterAppear,k=a.appearCancelled,T=a.duration,I=Ke,C=Ke.$vnode;C&&C.parent;)I=C.context,C=C.parent;var E=!I._isMounted||!n.isRootInsert;if(!E||w||""===w){var A=E&&m?m:l,P=E&&h?h:u,B=E&&g?g:d,M=E&&S||v,z=E&&c(w)?w:b,J=E&&j||y,R=E&&k||x,L=f(p(T)?T.enter:T);0;var D=!1!==r&&!Z,O=Br(z),q=t._enterCb=_((function(){D&&(wr(t,B),wr(t,P)),q.cancelled?(D&&wr(t,A),R&&R(t)):J&&J(t),t._enterCb=null}));n.data.show||Gn(n,"insert",(function(){var e=t.parentNode,a=e&&e._pending&&e._pending[n.key];a&&a.tag===n.tag&&a.elm._leaveCb&&a.elm._leaveCb(),z&&z(t,q)})),M&&M(t),D&&(Sr(t,A),Sr(t,P),xr((function(){wr(t,A),q.cancelled||(Sr(t,B),O||(Pr(L)?setTimeout(q,L):jr(t,s,q)))}))),n.data.show&&(e&&e(),z&&z(t,q)),D||O||q()}}}function Ar(n,e){var t=n.elm;o(t._enterCb)&&(t._enterCb.cancelled=!0,t._enterCb());var a=ur(n.data.transition);if(i(a)||1!==t.nodeType)return e();if(!o(t._leaveCb)){var r=a.css,s=a.type,l=a.leaveClass,c=a.leaveToClass,d=a.leaveActiveClass,u=a.beforeLeave,m=a.leave,g=a.afterLeave,h=a.leaveCancelled,v=a.delayLeave,b=a.duration,y=!1!==r&&!Z,x=Br(m),S=f(p(b)?b.leave:b);0;var w=t._leaveCb=_((function(){t.parentNode&&t.parentNode._pending&&(t.parentNode._pending[n.key]=null),y&&(wr(t,c),wr(t,d)),w.cancelled?(y&&wr(t,l),h&&h(t)):(e(),g&&g(t)),t._leaveCb=null}));v?v(j):j()}function j(){w.cancelled||(!n.data.show&&t.parentNode&&((t.parentNode._pending||(t.parentNode._pending={}))[n.key]=n),u&&u(t),y&&(Sr(t,l),Sr(t,d),xr((function(){wr(t,l),w.cancelled||(Sr(t,c),x||(Pr(S)?setTimeout(w,S):jr(t,s,w)))}))),m&&m(t,w),y||x||w())}}function Pr(n){return"number"==typeof n&&!isNaN(n)}function Br(n){if(i(n))return!1;var e=n.fns;return o(e)?Br(Array.isArray(e)?e[0]:e):(n._length||n.length)>1}function Mr(n,e){!0!==e.data.show&&Er(e)}var zr=function(n){var e,t,a={},c=n.modules,p=n.nodeOps;for(e=0;e<Ta.length;++e)for(a[Ta[e]]=[],t=0;t<c.length;++t)o(c[t][Ta[e]])&&a[Ta[e]].push(c[t][Ta[e]]);function d(n){var e=p.parentNode(n);o(e)&&p.removeChild(e,n)}function u(n,e,t,r,i,l,c){if(o(n.elm)&&o(l)&&(n=l[c]=bn(n)),n.isRootInsert=!i,!function(n,e,t,r){var i=n.data;if(o(i)){var l=o(n.componentInstance)&&i.keepAlive;if(o(i=i.hook)&&o(i=i.init)&&i(n,!1),o(n.componentInstance))return m(n,e),g(t,n.elm,r),s(l)&&function(n,e,t,r){var i,s=n;for(;s.componentInstance;)if(s=s.componentInstance._vnode,o(i=s.data)&&o(i=i.transition)){for(i=0;i<a.activate.length;++i)a.activate[i](ka,s);e.push(s);break}g(t,n.elm,r)}(n,e,t,r),!0}}(n,e,t,r)){var d=n.data,u=n.children,v=n.tag;o(v)?(n.elm=n.ns?p.createElementNS(n.ns,v):p.createElement(v,n),f(n),h(n,u,e),o(d)&&b(n,e),g(t,n.elm,r)):s(n.isComment)?(n.elm=p.createComment(n.text),g(t,n.elm,r)):(n.elm=p.createTextNode(n.text),g(t,n.elm,r))}}function m(n,e){o(n.data.pendingInsert)&&(e.push.apply(e,n.data.pendingInsert),n.data.pendingInsert=null),n.elm=n.componentInstance.$el,v(n)?(b(n,e),f(n)):(wa(n),e.push(n))}function g(n,e,t){o(n)&&(o(t)?p.parentNode(t)===n&&p.insertBefore(n,e,t):p.appendChild(n,e))}function h(n,e,t){if(r(e)){0;for(var a=0;a<e.length;++a)u(e[a],t,n.elm,null,!0,e,a)}else l(n.text)&&p.appendChild(n.elm,p.createTextNode(String(n.text)))}function v(n){for(;n.componentInstance;)n=n.componentInstance._vnode;return o(n.tag)}function b(n,t){for(var r=0;r<a.create.length;++r)a.create[r](ka,n);o(e=n.data.hook)&&(o(e.create)&&e.create(ka,n),o(e.insert)&&t.push(n))}function f(n){var e;if(o(e=n.fnScopeId))p.setStyleScope(n.elm,e);else for(var t=n;t;)o(e=t.context)&&o(e=e.$options._scopeId)&&p.setStyleScope(n.elm,e),t=t.parent;o(e=Ke)&&e!==n.context&&e!==n.fnContext&&o(e=e.$options._scopeId)&&p.setStyleScope(n.elm,e)}function x(n,e,t,a,r,i){for(;a<=r;++a)u(t[a],i,n,e,!1,t,a)}function S(n){var e,t,r=n.data;if(o(r))for(o(e=r.hook)&&o(e=e.destroy)&&e(n),e=0;e<a.destroy.length;++e)a.destroy[e](n);if(o(e=n.children))for(t=0;t<n.children.length;++t)S(n.children[t])}function w(n,e,t){for(;e<=t;++e){var a=n[e];o(a)&&(o(a.tag)?(j(a),S(a)):d(a.elm))}}function j(n,e){if(o(e)||o(n.data)){var t,r=a.remove.length+1;for(o(e)?e.listeners+=r:e=function(n,e){function t(){0==--t.listeners&&d(n)}return t.listeners=e,t}(n.elm,r),o(t=n.componentInstance)&&o(t=t._vnode)&&o(t.data)&&j(t,e),t=0;t<a.remove.length;++t)a.remove[t](n,e);o(t=n.data.hook)&&o(t=t.remove)?t(n,e):e()}else d(n.elm)}function k(n,e,t,a){for(var r=t;r<a;r++){var i=e[r];if(o(i)&&Ia(n,i))return r}}function T(n,e,t,r,l,c){if(n!==e){o(e.elm)&&o(r)&&(e=r[l]=bn(e));var d=e.elm=n.elm;if(s(n.isAsyncPlaceholder))o(e.asyncFactory.resolved)?E(n.elm,e,t):e.isAsyncPlaceholder=!0;else if(s(e.isStatic)&&s(n.isStatic)&&e.key===n.key&&(s(e.isCloned)||s(e.isOnce)))e.componentInstance=n.componentInstance;else{var m,g=e.data;o(g)&&o(m=g.hook)&&o(m=m.prepatch)&&m(n,e);var h=n.children,b=e.children;if(o(g)&&v(e)){for(m=0;m<a.update.length;++m)a.update[m](n,e);o(m=g.hook)&&o(m=m.update)&&m(n,e)}i(e.text)?o(h)&&o(b)?h!==b&&function(n,e,t,a,r){var s,l,c,d=0,m=0,g=e.length-1,h=e[0],v=e[g],b=t.length-1,f=t[0],y=t[b],S=!r;for(0;d<=g&&m<=b;)i(h)?h=e[++d]:i(v)?v=e[--g]:Ia(h,f)?(T(h,f,a,t,m),h=e[++d],f=t[++m]):Ia(v,y)?(T(v,y,a,t,b),v=e[--g],y=t[--b]):Ia(h,y)?(T(h,y,a,t,b),S&&p.insertBefore(n,h.elm,p.nextSibling(v.elm)),h=e[++d],y=t[--b]):Ia(v,f)?(T(v,f,a,t,m),S&&p.insertBefore(n,v.elm,h.elm),v=e[--g],f=t[++m]):(i(s)&&(s=Ca(e,d,g)),i(l=o(f.key)?s[f.key]:k(f,e,d,g))?u(f,a,n,h.elm,!1,t,m):Ia(c=e[l],f)?(T(c,f,a,t,m),e[l]=void 0,S&&p.insertBefore(n,c.elm,h.elm)):u(f,a,n,h.elm,!1,t,m),f=t[++m]);d>g?x(n,i(t[b+1])?null:t[b+1].elm,t,m,b,a):m>b&&w(e,d,g)}(d,h,b,t,c):o(b)?(o(n.text)&&p.setTextContent(d,""),x(d,null,b,0,b.length-1,t)):o(h)?w(h,0,h.length-1):o(n.text)&&p.setTextContent(d,""):n.text!==e.text&&p.setTextContent(d,e.text),o(g)&&o(m=g.hook)&&o(m=m.postpatch)&&m(n,e)}}}function I(n,e,t){if(s(t)&&o(n.parent))n.parent.data.pendingInsert=e;else for(var a=0;a<e.length;++a)e[a].data.hook.insert(e[a])}var C=y("attrs,class,staticClass,staticStyle,key");function E(n,e,t,a){var r,i=e.tag,l=e.data,c=e.children;if(a=a||l&&l.pre,e.elm=n,s(e.isComment)&&o(e.asyncFactory))return e.isAsyncPlaceholder=!0,!0;if(o(l)&&(o(r=l.hook)&&o(r=r.init)&&r(e,!0),o(r=e.componentInstance)))return m(e,t),!0;if(o(i)){if(o(c))if(n.hasChildNodes())if(o(r=l)&&o(r=r.domProps)&&o(r=r.innerHTML)){if(r!==n.innerHTML)return!1}else{for(var p=!0,d=n.firstChild,u=0;u<c.length;u++){if(!d||!E(d,c[u],t,a)){p=!1;break}d=d.nextSibling}if(!p||d)return!1}else h(e,c,t);if(o(l)){var g=!1;for(var v in l)if(!C(v)){g=!0,b(e,t);break}!g&&l.class&&Ne(l.class)}}else n.data!==e.text&&(n.data=e.text);return!0}return function(n,e,t,r){if(!i(e)){var l,c=!1,d=[];if(i(n))c=!0,u(e,d);else{var m=o(n.nodeType);if(!m&&Ia(n,e))T(n,e,d,null,null,r);else{if(m){if(1===n.nodeType&&n.hasAttribute("data-server-rendered")&&(n.removeAttribute("data-server-rendered"),t=!0),s(t)&&E(n,e,d))return I(e,d,!0),n;l=n,n=new gn(p.tagName(l).toLowerCase(),{},[],void 0,l)}var g=n.elm,h=p.parentNode(g);if(u(e,d,g._leaveCb?null:h,p.nextSibling(g)),o(e.parent))for(var b=e.parent,f=v(e);b;){for(var y=0;y<a.destroy.length;++y)a.destroy[y](b);if(b.elm=e.elm,f){for(var x=0;x<a.create.length;++x)a.create[x](ka,b);var j=b.data.hook.insert;if(j.merged)for(var k=j.fns.slice(1),C=0;C<k.length;C++)k[C]()}else wa(b);b=b.parent}o(h)?w([n],0,0):o(n.tag)&&S(n)}}return I(e,d,c),e.elm}o(n)&&S(n)}}({nodeOps:xa,modules:[Oa,Fa,Ga,Ka,lr,X?{create:Mr,activate:Mr,remove:function(n,e){!0!==n.data.show?Ar(n,e):e()}}:{}].concat(Ja)});Z&&document.addEventListener("selectionchange",(function(){var n=document.activeElement;n&&n.vmodel&&Fr(n,"input")}));var Jr={inserted:function(n,e,t,a){"select"===t.tag?(a.elm&&!a.elm._vOptions?Gn(t,"postpatch",(function(){Jr.componentUpdated(n,e,t)})):Rr(n,e,t.context),n._vOptions=[].map.call(n.options,Or)):("textarea"===t.tag||ya(n.type))&&(n._vModifiers=e.modifiers,e.modifiers.lazy||(n.addEventListener("compositionstart",_r),n.addEventListener("compositionend",qr),n.addEventListener("change",qr),Z&&(n.vmodel=!0)))},componentUpdated:function(n,e,t){if("select"===t.tag){Rr(n,e,t.context);var a=n._vOptions,r=n._vOptions=[].map.call(n.options,Or);if(r.some((function(n,e){return!D(n,a[e])})))(n.multiple?e.value.some((function(n){return Dr(n,r)})):e.value!==e.oldValue&&Dr(e.value,r))&&Fr(n,"change")}}};function Rr(n,e,t){Lr(n,e,t),(K||Y)&&setTimeout((function(){Lr(n,e,t)}),0)}function Lr(n,e,t){var a=e.value,r=n.multiple;if(!r||Array.isArray(a)){for(var i,o,s=0,l=n.options.length;s<l;s++)if(o=n.options[s],r)i=O(a,Or(o))>-1,o.selected!==i&&(o.selected=i);else if(D(Or(o),a))return void(n.selectedIndex!==s&&(n.selectedIndex=s));r||(n.selectedIndex=-1)}}function Dr(n,e){return e.every((function(e){return!D(e,n)}))}function Or(n){return"_value"in n?n._value:n.value}function _r(n){n.target.composing=!0}function qr(n){n.target.composing&&(n.target.composing=!1,Fr(n.target,"input"))}function Fr(n,e){var t=document.createEvent("HTMLEvents");t.initEvent(e,!0,!0),n.dispatchEvent(t)}function Ur(n){return!n.componentInstance||n.data&&n.data.transition?n:Ur(n.componentInstance._vnode)}var Nr={model:Jr,show:{bind:function(n,e,t){var a=e.value,r=(t=Ur(t)).data&&t.data.transition,i=n.__vOriginalDisplay="none"===n.style.display?"":n.style.display;a&&r?(t.data.show=!0,Er(t,(function(){n.style.display=i}))):n.style.display=a?i:"none"},update:function(n,e,t){var a=e.value;!a!=!e.oldValue&&((t=Ur(t)).data&&t.data.transition?(t.data.show=!0,a?Er(t,(function(){n.style.display=n.__vOriginalDisplay})):Ar(t,(function(){n.style.display="none"}))):n.style.display=a?n.__vOriginalDisplay:"none")},unbind:function(n,e,t,a,r){r||(n.style.display=n.__vOriginalDisplay)}}},Hr={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function $r(n){var e=n&&n.componentOptions;return e&&e.Ctor.options.abstract?$r(Te(e.children)):n}function Wr(n){var e={},t=n.$options;for(var a in t.propsData)e[a]=n[a];var r=t._parentListeners;for(var a in r)e[I(a)]=r[a];return e}function Vr(n,e){if(/\d-keep-alive$/.test(e.tag))return n("keep-alive",{props:e.componentOptions.propsData})}var Gr=function(n){return n.tag||he(n)},Xr=function(n){return"show"===n.name},Qr={name:"transition",props:Hr,abstract:!0,render:function(n){var e=this,t=this.$slots.default;if(t&&(t=t.filter(Gr)).length){0;var a=this.mode;0;var r=t[0];if(function(n){for(;n=n.parent;)if(n.data.transition)return!0}(this.$vnode))return r;var i=$r(r);if(!i)return r;if(this._leaving)return Vr(n,r);var o="__transition-".concat(this._uid,"-");i.key=null==i.key?i.isComment?o+"comment":o+i.tag:l(i.key)?0===String(i.key).indexOf(o)?i.key:o+i.key:i.key;var s=(i.data||(i.data={})).transition=Wr(this),c=this._vnode,p=$r(c);if(i.data.directives&&i.data.directives.some(Xr)&&(i.data.show=!0),p&&p.data&&!function(n,e){return e.key===n.key&&e.tag===n.tag}(i,p)&&!he(p)&&(!p.componentInstance||!p.componentInstance._vnode.isComment)){var d=p.data.transition=M({},s);if("out-in"===a)return this._leaving=!0,Gn(d,"afterLeave",(function(){e._leaving=!1,e.$forceUpdate()})),Vr(n,r);if("in-out"===a){if(he(i))return c;var u,m=function(){u()};Gn(s,"afterEnter",m),Gn(s,"enterCancelled",m),Gn(d,"delayLeave",(function(n){u=n}))}}return r}}},Kr=M({tag:String,moveClass:String},Hr);function Zr(n){n.elm._moveCb&&n.elm._moveCb(),n.elm._enterCb&&n.elm._enterCb()}function Yr(n){n.data.newPos=n.elm.getBoundingClientRect()}function ni(n){var e=n.data.pos,t=n.data.newPos,a=e.left-t.left,r=e.top-t.top;if(a||r){n.data.moved=!0;var i=n.elm.style;i.transform=i.WebkitTransform="translate(".concat(a,"px,").concat(r,"px)"),i.transitionDuration="0s"}}delete Kr.mode;var ei={Transition:Qr,TransitionGroup:{props:Kr,beforeMount:function(){var n=this,e=this._update;this._update=function(t,a){var r=Ze(n);n.__patch__(n._vnode,n.kept,!1,!0),n._vnode=n.kept,r(),e.call(n,t,a)}},render:function(n){for(var e=this.tag||this.$vnode.data.tag||"span",t=Object.create(null),a=this.prevChildren=this.children,r=this.$slots.default||[],i=this.children=[],o=Wr(this),s=0;s<r.length;s++){if((p=r[s]).tag)if(null!=p.key&&0!==String(p.key).indexOf("__vlist"))i.push(p),t[p.key]=p,(p.data||(p.data={})).transition=o;else;}if(a){var l=[],c=[];for(s=0;s<a.length;s++){var p;(p=a[s]).data.transition=o,p.data.pos=p.elm.getBoundingClientRect(),t[p.key]?l.push(p):c.push(p)}this.kept=n(e,null,l),this.removed=c}return n(e,null,i)},updated:function(){var n=this.prevChildren,e=this.moveClass||(this.name||"v")+"-move";n.length&&this.hasMove(n[0].elm,e)&&(n.forEach(Zr),n.forEach(Yr),n.forEach(ni),this._reflow=document.body.offsetHeight,n.forEach((function(n){if(n.data.moved){var t=n.elm,a=t.style;Sr(t,e),a.transform=a.WebkitTransform=a.transitionDuration="",t.addEventListener(vr,t._moveCb=function n(a){a&&a.target!==t||a&&!/transform$/.test(a.propertyName)||(t.removeEventListener(vr,n),t._moveCb=null,wr(t,e))})}})))},methods:{hasMove:function(n,e){if(!gr)return!1;if(this._hasMove)return this._hasMove;var t=n.cloneNode();n._transitionClasses&&n._transitionClasses.forEach((function(n){dr(t,n)})),pr(t,e),t.style.display="none",this.$el.appendChild(t);var a=Tr(t);return this.$el.removeChild(t),this._hasMove=a.hasTransform}}}};function ti(n,e){for(var t in e)n[t]=e[t];return n}Vt.config.mustUseProp=function(n,e,t){return"value"===t&&ta(n)&&"button"!==e||"selected"===t&&"option"===n||"checked"===t&&"input"===n||"muted"===t&&"video"===n},Vt.config.isReservedTag=ba,Vt.config.isReservedAttr=ea,Vt.config.getTagNamespace=function(n){return va(n)?"svg":"math"===n?"math":void 0},Vt.config.isUnknownElement=function(n){if(!X)return!0;if(ba(n))return!1;if(n=n.toLowerCase(),null!=fa[n])return fa[n];var e=document.createElement(n);return n.indexOf("-")>-1?fa[n]=e.constructor===window.HTMLUnknownElement||e.constructor===window.HTMLElement:fa[n]=/HTMLUnknownElement/.test(e.toString())},M(Vt.options.directives,Nr),M(Vt.options.components,ei),Vt.prototype.__patch__=X?zr:J,Vt.prototype.$mount=function(n,e){return function(n,e,t){var a;n.$el=e,n.$options.render||(n.$options.render=hn),et(n,"beforeMount"),a=function(){n._update(n._render(),t)},new We(n,a,J,{before:function(){n._isMounted&&!n._isDestroyed&&et(n,"beforeUpdate")}},!0),t=!1;var r=n._preWatchers;if(r)for(var i=0;i<r.length;i++)r[i].run();return null==n.$vnode&&(n._isMounted=!0,et(n,"mounted")),n}(this,n=n&&X?function(n){if("string"==typeof n){var e=document.querySelector(n);return e||document.createElement("div")}return n}(n):void 0,e)},X&&setTimeout((function(){N.devtools&&ln&&ln.emit("init",Vt)}),0);var ai=/[!'()*]/g,ri=function(n){return"%"+n.charCodeAt(0).toString(16)},ii=/%2C/g,oi=function(n){return encodeURIComponent(n).replace(ai,ri).replace(ii,",")};function si(n){try{return decodeURIComponent(n)}catch(n){0}return n}var li=function(n){return null==n||"object"==typeof n?n:String(n)};function ci(n){var e={};return(n=n.trim().replace(/^(\?|#|&)/,""))?(n.split("&").forEach((function(n){var t=n.replace(/\+/g," ").split("="),a=si(t.shift()),r=t.length>0?si(t.join("=")):null;void 0===e[a]?e[a]=r:Array.isArray(e[a])?e[a].push(r):e[a]=[e[a],r]})),e):e}function pi(n){var e=n?Object.keys(n).map((function(e){var t=n[e];if(void 0===t)return"";if(null===t)return oi(e);if(Array.isArray(t)){var a=[];return t.forEach((function(n){void 0!==n&&(null===n?a.push(oi(e)):a.push(oi(e)+"="+oi(n)))})),a.join("&")}return oi(e)+"="+oi(t)})).filter((function(n){return n.length>0})).join("&"):null;return e?"?"+e:""}var di=/\/?$/;function ui(n,e,t,a){var r=a&&a.options.stringifyQuery,i=e.query||{};try{i=mi(i)}catch(n){}var o={name:e.name||n&&n.name,meta:n&&n.meta||{},path:e.path||"/",hash:e.hash||"",query:i,params:e.params||{},fullPath:vi(e,r),matched:n?hi(n):[]};return t&&(o.redirectedFrom=vi(t,r)),Object.freeze(o)}function mi(n){if(Array.isArray(n))return n.map(mi);if(n&&"object"==typeof n){var e={};for(var t in n)e[t]=mi(n[t]);return e}return n}var gi=ui(null,{path:"/"});function hi(n){for(var e=[];n;)e.unshift(n),n=n.parent;return e}function vi(n,e){var t=n.path,a=n.query;void 0===a&&(a={});var r=n.hash;return void 0===r&&(r=""),(t||"/")+(e||pi)(a)+r}function bi(n,e,t){return e===gi?n===e:!!e&&(n.path&&e.path?n.path.replace(di,"")===e.path.replace(di,"")&&(t||n.hash===e.hash&&fi(n.query,e.query)):!(!n.name||!e.name)&&(n.name===e.name&&(t||n.hash===e.hash&&fi(n.query,e.query)&&fi(n.params,e.params))))}function fi(n,e){if(void 0===n&&(n={}),void 0===e&&(e={}),!n||!e)return n===e;var t=Object.keys(n).sort(),a=Object.keys(e).sort();return t.length===a.length&&t.every((function(t,r){var i=n[t];if(a[r]!==t)return!1;var o=e[t];return null==i||null==o?i===o:"object"==typeof i&&"object"==typeof o?fi(i,o):String(i)===String(o)}))}function yi(n){for(var e=0;e<n.matched.length;e++){var t=n.matched[e];for(var a in t.instances){var r=t.instances[a],i=t.enteredCbs[a];if(r&&i){delete t.enteredCbs[a];for(var o=0;o<i.length;o++)r._isBeingDestroyed||i[o](r)}}}}var xi={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(n,e){var t=e.props,a=e.children,r=e.parent,i=e.data;i.routerView=!0;for(var o=r.$createElement,s=t.name,l=r.$route,c=r._routerViewCache||(r._routerViewCache={}),p=0,d=!1;r&&r._routerRoot!==r;){var u=r.$vnode?r.$vnode.data:{};u.routerView&&p++,u.keepAlive&&r._directInactive&&r._inactive&&(d=!0),r=r.$parent}if(i.routerViewDepth=p,d){var m=c[s],g=m&&m.component;return g?(m.configProps&&Si(g,i,m.route,m.configProps),o(g,i,a)):o()}var h=l.matched[p],v=h&&h.components[s];if(!h||!v)return c[s]=null,o();c[s]={component:v},i.registerRouteInstance=function(n,e){var t=h.instances[s];(e&&t!==n||!e&&t===n)&&(h.instances[s]=e)},(i.hook||(i.hook={})).prepatch=function(n,e){h.instances[s]=e.componentInstance},i.hook.init=function(n){n.data.keepAlive&&n.componentInstance&&n.componentInstance!==h.instances[s]&&(h.instances[s]=n.componentInstance),yi(l)};var b=h.props&&h.props[s];return b&&(ti(c[s],{route:l,configProps:b}),Si(v,i,l,b)),o(v,i,a)}};function Si(n,e,t,a){var r=e.props=function(n,e){switch(typeof e){case"undefined":return;case"object":return e;case"function":return e(n);case"boolean":return e?n.params:void 0;default:0}}(t,a);if(r){r=e.props=ti({},r);var i=e.attrs=e.attrs||{};for(var o in r)n.props&&o in n.props||(i[o]=r[o],delete r[o])}}function wi(n,e,t){var a=n.charAt(0);if("/"===a)return n;if("?"===a||"#"===a)return e+n;var r=e.split("/");t&&r[r.length-1]||r.pop();for(var i=n.replace(/^\//,"").split("/"),o=0;o<i.length;o++){var s=i[o];".."===s?r.pop():"."!==s&&r.push(s)}return""!==r[0]&&r.unshift(""),r.join("/")}function ji(n){return n.replace(/\/(?:\s*\/)+/g,"/")}var ki=Array.isArray||function(n){return"[object Array]"==Object.prototype.toString.call(n)},Ti=_i,Ii=Bi,Ci=function(n,e){return zi(Bi(n,e),e)},Ei=zi,Ai=Oi,Pi=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function Bi(n,e){for(var t,a=[],r=0,i=0,o="",s=e&&e.delimiter||"/";null!=(t=Pi.exec(n));){var l=t[0],c=t[1],p=t.index;if(o+=n.slice(i,p),i=p+l.length,c)o+=c[1];else{var d=n[i],u=t[2],m=t[3],g=t[4],h=t[5],v=t[6],b=t[7];o&&(a.push(o),o="");var f=null!=u&&null!=d&&d!==u,y="+"===v||"*"===v,x="?"===v||"*"===v,S=t[2]||s,w=g||h;a.push({name:m||r++,prefix:u||"",delimiter:S,optional:x,repeat:y,partial:f,asterisk:!!b,pattern:w?Ri(w):b?".*":"[^"+Ji(S)+"]+?"})}}return i<n.length&&(o+=n.substr(i)),o&&a.push(o),a}function Mi(n){return encodeURI(n).replace(/[\/?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()}))}function zi(n,e){for(var t=new Array(n.length),a=0;a<n.length;a++)"object"==typeof n[a]&&(t[a]=new RegExp("^(?:"+n[a].pattern+")$",Di(e)));return function(e,a){for(var r="",i=e||{},o=(a||{}).pretty?Mi:encodeURIComponent,s=0;s<n.length;s++){var l=n[s];if("string"!=typeof l){var c,p=i[l.name];if(null==p){if(l.optional){l.partial&&(r+=l.prefix);continue}throw new TypeError('Expected "'+l.name+'" to be defined')}if(ki(p)){if(!l.repeat)throw new TypeError('Expected "'+l.name+'" to not repeat, but received `'+JSON.stringify(p)+"`");if(0===p.length){if(l.optional)continue;throw new TypeError('Expected "'+l.name+'" to not be empty')}for(var d=0;d<p.length;d++){if(c=o(p[d]),!t[s].test(c))throw new TypeError('Expected all "'+l.name+'" to match "'+l.pattern+'", but received `'+JSON.stringify(c)+"`");r+=(0===d?l.prefix:l.delimiter)+c}}else{if(c=l.asterisk?encodeURI(p).replace(/[?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()})):o(p),!t[s].test(c))throw new TypeError('Expected "'+l.name+'" to match "'+l.pattern+'", but received "'+c+'"');r+=l.prefix+c}}else r+=l}return r}}function Ji(n){return n.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function Ri(n){return n.replace(/([=!:$\/()])/g,"\\$1")}function Li(n,e){return n.keys=e,n}function Di(n){return n&&n.sensitive?"":"i"}function Oi(n,e,t){ki(e)||(t=e||t,e=[]);for(var a=(t=t||{}).strict,r=!1!==t.end,i="",o=0;o<n.length;o++){var s=n[o];if("string"==typeof s)i+=Ji(s);else{var l=Ji(s.prefix),c="(?:"+s.pattern+")";e.push(s),s.repeat&&(c+="(?:"+l+c+")*"),i+=c=s.optional?s.partial?l+"("+c+")?":"(?:"+l+"("+c+"))?":l+"("+c+")"}}var p=Ji(t.delimiter||"/"),d=i.slice(-p.length)===p;return a||(i=(d?i.slice(0,-p.length):i)+"(?:"+p+"(?=$))?"),i+=r?"$":a&&d?"":"(?="+p+"|$)",Li(new RegExp("^"+i,Di(t)),e)}function _i(n,e,t){return ki(e)||(t=e||t,e=[]),t=t||{},n instanceof RegExp?function(n,e){var t=n.source.match(/\((?!\?)/g);if(t)for(var a=0;a<t.length;a++)e.push({name:a,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return Li(n,e)}(n,e):ki(n)?function(n,e,t){for(var a=[],r=0;r<n.length;r++)a.push(_i(n[r],e,t).source);return Li(new RegExp("(?:"+a.join("|")+")",Di(t)),e)}(n,e,t):function(n,e,t){return Oi(Bi(n,t),e,t)}(n,e,t)}Ti.parse=Ii,Ti.compile=Ci,Ti.tokensToFunction=Ei,Ti.tokensToRegExp=Ai;var qi=Object.create(null);function Fi(n,e,t){e=e||{};try{var a=qi[n]||(qi[n]=Ti.compile(n));return"string"==typeof e.pathMatch&&(e[0]=e.pathMatch),a(e,{pretty:!0})}catch(n){return""}finally{delete e[0]}}function Ui(n,e,t,a){var r="string"==typeof n?{path:n}:n;if(r._normalized)return r;if(r.name){var i=(r=ti({},n)).params;return i&&"object"==typeof i&&(r.params=ti({},i)),r}if(!r.path&&r.params&&e){(r=ti({},r))._normalized=!0;var o=ti(ti({},e.params),r.params);if(e.name)r.name=e.name,r.params=o;else if(e.matched.length){var s=e.matched[e.matched.length-1].path;r.path=Fi(s,o,e.path)}else 0;return r}var l=function(n){var e="",t="",a=n.indexOf("#");a>=0&&(e=n.slice(a),n=n.slice(0,a));var r=n.indexOf("?");return r>=0&&(t=n.slice(r+1),n=n.slice(0,r)),{path:n,query:t,hash:e}}(r.path||""),c=e&&e.path||"/",p=l.path?wi(l.path,c,t||r.append):c,d=function(n,e,t){void 0===e&&(e={});var a,r=t||ci;try{a=r(n||"")}catch(n){a={}}for(var i in e){var o=e[i];a[i]=Array.isArray(o)?o.map(li):li(o)}return a}(l.query,r.query,a&&a.options.parseQuery),u=r.hash||l.hash;return u&&"#"!==u.charAt(0)&&(u="#"+u),{_normalized:!0,path:p,query:d,hash:u}}var Ni,Hi=function(){},$i={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(n){var e=this,t=this.$router,a=this.$route,r=t.resolve(this.to,a,this.append),i=r.location,o=r.route,s=r.href,l={},c=t.options.linkActiveClass,p=t.options.linkExactActiveClass,d=null==c?"router-link-active":c,u=null==p?"router-link-exact-active":p,m=null==this.activeClass?d:this.activeClass,g=null==this.exactActiveClass?u:this.exactActiveClass,h=o.redirectedFrom?ui(null,Ui(o.redirectedFrom),null,t):o;l[g]=bi(a,h,this.exactPath),l[m]=this.exact||this.exactPath?l[g]:function(n,e){return 0===n.path.replace(di,"/").indexOf(e.path.replace(di,"/"))&&(!e.hash||n.hash===e.hash)&&function(n,e){for(var t in e)if(!(t in n))return!1;return!0}(n.query,e.query)}(a,h);var v=l[g]?this.ariaCurrentValue:null,b=function(n){Wi(n)&&(e.replace?t.replace(i,Hi):t.push(i,Hi))},f={click:Wi};Array.isArray(this.event)?this.event.forEach((function(n){f[n]=b})):f[this.event]=b;var y={class:l},x=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:s,route:o,navigate:b,isActive:l[m],isExactActive:l[g]});if(x){if(1===x.length)return x[0];if(x.length>1||!x.length)return 0===x.length?n():n("span",{},x)}if("a"===this.tag)y.on=f,y.attrs={href:s,"aria-current":v};else{var S=function n(e){var t;if(e)for(var a=0;a<e.length;a++){if("a"===(t=e[a]).tag)return t;if(t.children&&(t=n(t.children)))return t}}(this.$slots.default);if(S){S.isStatic=!1;var w=S.data=ti({},S.data);for(var j in w.on=w.on||{},w.on){var k=w.on[j];j in f&&(w.on[j]=Array.isArray(k)?k:[k])}for(var T in f)T in w.on?w.on[T].push(f[T]):w.on[T]=b;var I=S.data.attrs=ti({},S.data.attrs);I.href=s,I["aria-current"]=v}else y.on=f}return n(this.tag,y,this.$slots.default)}};function Wi(n){if(!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey||n.defaultPrevented||void 0!==n.button&&0!==n.button)){if(n.currentTarget&&n.currentTarget.getAttribute){var e=n.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(e))return}return n.preventDefault&&n.preventDefault(),!0}}var Vi="undefined"!=typeof window;function Gi(n,e,t,a,r){var i=e||[],o=t||Object.create(null),s=a||Object.create(null);n.forEach((function(n){!function n(e,t,a,r,i,o){var s=r.path,l=r.name;0;var c=r.pathToRegexpOptions||{},p=function(n,e,t){t||(n=n.replace(/\/$/,""));if("/"===n[0])return n;if(null==e)return n;return ji(e.path+"/"+n)}(s,i,c.strict);"boolean"==typeof r.caseSensitive&&(c.sensitive=r.caseSensitive);var d={path:p,regex:Xi(p,c),components:r.components||{default:r.component},alias:r.alias?"string"==typeof r.alias?[r.alias]:r.alias:[],instances:{},enteredCbs:{},name:l,parent:i,matchAs:o,redirect:r.redirect,beforeEnter:r.beforeEnter,meta:r.meta||{},props:null==r.props?{}:r.components?r.props:{default:r.props}};r.children&&r.children.forEach((function(r){var i=o?ji(o+"/"+r.path):void 0;n(e,t,a,r,d,i)}));t[d.path]||(e.push(d.path),t[d.path]=d);if(void 0!==r.alias)for(var u=Array.isArray(r.alias)?r.alias:[r.alias],m=0;m<u.length;++m){0;var g={path:u[m],children:r.children};n(e,t,a,g,i,d.path||"/")}l&&(a[l]||(a[l]=d))}(i,o,s,n,r)}));for(var l=0,c=i.length;l<c;l++)"*"===i[l]&&(i.push(i.splice(l,1)[0]),c--,l--);return{pathList:i,pathMap:o,nameMap:s}}function Xi(n,e){return Ti(n,[],e)}function Qi(n,e){var t=Gi(n),a=t.pathList,r=t.pathMap,i=t.nameMap;function o(n,t,o){var s=Ui(n,t,!1,e),c=s.name;if(c){var p=i[c];if(!p)return l(null,s);var d=p.regex.keys.filter((function(n){return!n.optional})).map((function(n){return n.name}));if("object"!=typeof s.params&&(s.params={}),t&&"object"==typeof t.params)for(var u in t.params)!(u in s.params)&&d.indexOf(u)>-1&&(s.params[u]=t.params[u]);return s.path=Fi(p.path,s.params),l(p,s,o)}if(s.path){s.params={};for(var m=0;m<a.length;m++){var g=a[m],h=r[g];if(Ki(h.regex,s.path,s.params))return l(h,s,o)}}return l(null,s)}function s(n,t){var a=n.redirect,r="function"==typeof a?a(ui(n,t,null,e)):a;if("string"==typeof r&&(r={path:r}),!r||"object"!=typeof r)return l(null,t);var s=r,c=s.name,p=s.path,d=t.query,u=t.hash,m=t.params;if(d=s.hasOwnProperty("query")?s.query:d,u=s.hasOwnProperty("hash")?s.hash:u,m=s.hasOwnProperty("params")?s.params:m,c){i[c];return o({_normalized:!0,name:c,query:d,hash:u,params:m},void 0,t)}if(p){var g=function(n,e){return wi(n,e.parent?e.parent.path:"/",!0)}(p,n);return o({_normalized:!0,path:Fi(g,m),query:d,hash:u},void 0,t)}return l(null,t)}function l(n,t,a){return n&&n.redirect?s(n,a||t):n&&n.matchAs?function(n,e,t){var a=o({_normalized:!0,path:Fi(t,e.params)});if(a){var r=a.matched,i=r[r.length-1];return e.params=a.params,l(i,e)}return l(null,e)}(0,t,n.matchAs):ui(n,t,a,e)}return{match:o,addRoute:function(n,e){var t="object"!=typeof n?i[n]:void 0;Gi([e||n],a,r,i,t),t&&t.alias.length&&Gi(t.alias.map((function(n){return{path:n,children:[e]}})),a,r,i,t)},getRoutes:function(){return a.map((function(n){return r[n]}))},addRoutes:function(n){Gi(n,a,r,i)}}}function Ki(n,e,t){var a=e.match(n);if(!a)return!1;if(!t)return!0;for(var r=1,i=a.length;r<i;++r){var o=n.keys[r-1];o&&(t[o.name||"pathMatch"]="string"==typeof a[r]?si(a[r]):a[r])}return!0}var Zi=Vi&&window.performance&&window.performance.now?window.performance:Date;function Yi(){return Zi.now().toFixed(3)}var no=Yi();function eo(){return no}function to(n){return no=n}var ao=Object.create(null);function ro(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var n=window.location.protocol+"//"+window.location.host,e=window.location.href.replace(n,""),t=ti({},window.history.state);return t.key=eo(),window.history.replaceState(t,"",e),window.addEventListener("popstate",so),function(){window.removeEventListener("popstate",so)}}function io(n,e,t,a){if(n.app){var r=n.options.scrollBehavior;r&&n.app.$nextTick((function(){var i=function(){var n=eo();if(n)return ao[n]}(),o=r.call(n,e,t,a?i:null);o&&("function"==typeof o.then?o.then((function(n){mo(n,i)})).catch((function(n){0})):mo(o,i))}))}}function oo(){var n=eo();n&&(ao[n]={x:window.pageXOffset,y:window.pageYOffset})}function so(n){oo(),n.state&&n.state.key&&to(n.state.key)}function lo(n){return po(n.x)||po(n.y)}function co(n){return{x:po(n.x)?n.x:window.pageXOffset,y:po(n.y)?n.y:window.pageYOffset}}function po(n){return"number"==typeof n}var uo=/^#\d/;function mo(n,e){var t,a="object"==typeof n;if(a&&"string"==typeof n.selector){var r=uo.test(n.selector)?document.getElementById(n.selector.slice(1)):document.querySelector(n.selector);if(r){var i=n.offset&&"object"==typeof n.offset?n.offset:{};e=function(n,e){var t=document.documentElement.getBoundingClientRect(),a=n.getBoundingClientRect();return{x:a.left-t.left-e.x,y:a.top-t.top-e.y}}(r,i={x:po((t=i).x)?t.x:0,y:po(t.y)?t.y:0})}else lo(n)&&(e=co(n))}else a&&lo(n)&&(e=co(n));e&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:e.x,top:e.y,behavior:n.behavior}):window.scrollTo(e.x,e.y))}var go,ho=Vi&&((-1===(go=window.navigator.userAgent).indexOf("Android 2.")&&-1===go.indexOf("Android 4.0")||-1===go.indexOf("Mobile Safari")||-1!==go.indexOf("Chrome")||-1!==go.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState);function vo(n,e){oo();var t=window.history;try{if(e){var a=ti({},t.state);a.key=eo(),t.replaceState(a,"",n)}else t.pushState({key:to(Yi())},"",n)}catch(t){window.location[e?"replace":"assign"](n)}}function bo(n){vo(n,!0)}var fo={redirected:2,aborted:4,cancelled:8,duplicated:16};function yo(n,e){return So(n,e,fo.redirected,'Redirected when going from "'+n.fullPath+'" to "'+function(n){if("string"==typeof n)return n;if("path"in n)return n.path;var e={};return wo.forEach((function(t){t in n&&(e[t]=n[t])})),JSON.stringify(e,null,2)}(e)+'" via a navigation guard.')}function xo(n,e){return So(n,e,fo.cancelled,'Navigation cancelled from "'+n.fullPath+'" to "'+e.fullPath+'" with a new navigation.')}function So(n,e,t,a){var r=new Error(a);return r._isRouter=!0,r.from=n,r.to=e,r.type=t,r}var wo=["params","query","hash"];function jo(n){return Object.prototype.toString.call(n).indexOf("Error")>-1}function ko(n,e){return jo(n)&&n._isRouter&&(null==e||n.type===e)}function To(n,e,t){var a=function(r){r>=n.length?t():n[r]?e(n[r],(function(){a(r+1)})):a(r+1)};a(0)}function Io(n){return function(e,t,a){var r=!1,i=0,o=null;Co(n,(function(n,e,t,s){if("function"==typeof n&&void 0===n.cid){r=!0,i++;var l,c=Po((function(e){var r;((r=e).__esModule||Ao&&"Module"===r[Symbol.toStringTag])&&(e=e.default),n.resolved="function"==typeof e?e:Ni.extend(e),t.components[s]=e,--i<=0&&a()})),p=Po((function(n){var e="Failed to resolve async component "+s+": "+n;o||(o=jo(n)?n:new Error(e),a(o))}));try{l=n(c,p)}catch(n){p(n)}if(l)if("function"==typeof l.then)l.then(c,p);else{var d=l.component;d&&"function"==typeof d.then&&d.then(c,p)}}})),r||a()}}function Co(n,e){return Eo(n.map((function(n){return Object.keys(n.components).map((function(t){return e(n.components[t],n.instances[t],n,t)}))})))}function Eo(n){return Array.prototype.concat.apply([],n)}var Ao="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function Po(n){var e=!1;return function(){for(var t=[],a=arguments.length;a--;)t[a]=arguments[a];if(!e)return e=!0,n.apply(this,t)}}var Bo=function(n,e){this.router=n,this.base=function(n){if(!n)if(Vi){var e=document.querySelector("base");n=(n=e&&e.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else n="/";"/"!==n.charAt(0)&&(n="/"+n);return n.replace(/\/$/,"")}(e),this.current=gi,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function Mo(n,e,t,a){var r=Co(n,(function(n,a,r,i){var o=function(n,e){"function"!=typeof n&&(n=Ni.extend(n));return n.options[e]}(n,e);if(o)return Array.isArray(o)?o.map((function(n){return t(n,a,r,i)})):t(o,a,r,i)}));return Eo(a?r.reverse():r)}function zo(n,e){if(e)return function(){return n.apply(e,arguments)}}Bo.prototype.listen=function(n){this.cb=n},Bo.prototype.onReady=function(n,e){this.ready?n():(this.readyCbs.push(n),e&&this.readyErrorCbs.push(e))},Bo.prototype.onError=function(n){this.errorCbs.push(n)},Bo.prototype.transitionTo=function(n,e,t){var a,r=this;try{a=this.router.match(n,this.current)}catch(n){throw this.errorCbs.forEach((function(e){e(n)})),n}var i=this.current;this.confirmTransition(a,(function(){r.updateRoute(a),e&&e(a),r.ensureURL(),r.router.afterHooks.forEach((function(n){n&&n(a,i)})),r.ready||(r.ready=!0,r.readyCbs.forEach((function(n){n(a)})))}),(function(n){t&&t(n),n&&!r.ready&&(ko(n,fo.redirected)&&i===gi||(r.ready=!0,r.readyErrorCbs.forEach((function(e){e(n)}))))}))},Bo.prototype.confirmTransition=function(n,e,t){var a=this,r=this.current;this.pending=n;var i,o,s=function(n){!ko(n)&&jo(n)&&(a.errorCbs.length?a.errorCbs.forEach((function(e){e(n)})):console.error(n)),t&&t(n)},l=n.matched.length-1,c=r.matched.length-1;if(bi(n,r)&&l===c&&n.matched[l]===r.matched[c])return this.ensureURL(),n.hash&&io(this.router,r,n,!1),s(((o=So(i=r,n,fo.duplicated,'Avoided redundant navigation to current location: "'+i.fullPath+'".')).name="NavigationDuplicated",o));var p=function(n,e){var t,a=Math.max(n.length,e.length);for(t=0;t<a&&n[t]===e[t];t++);return{updated:e.slice(0,t),activated:e.slice(t),deactivated:n.slice(t)}}(this.current.matched,n.matched),d=p.updated,u=p.deactivated,m=p.activated,g=[].concat(function(n){return Mo(n,"beforeRouteLeave",zo,!0)}(u),this.router.beforeHooks,function(n){return Mo(n,"beforeRouteUpdate",zo)}(d),m.map((function(n){return n.beforeEnter})),Io(m)),h=function(e,t){if(a.pending!==n)return s(xo(r,n));try{e(n,r,(function(e){!1===e?(a.ensureURL(!0),s(function(n,e){return So(n,e,fo.aborted,'Navigation aborted from "'+n.fullPath+'" to "'+e.fullPath+'" via a navigation guard.')}(r,n))):jo(e)?(a.ensureURL(!0),s(e)):"string"==typeof e||"object"==typeof e&&("string"==typeof e.path||"string"==typeof e.name)?(s(yo(r,n)),"object"==typeof e&&e.replace?a.replace(e):a.push(e)):t(e)}))}catch(n){s(n)}};To(g,h,(function(){To(function(n){return Mo(n,"beforeRouteEnter",(function(n,e,t,a){return function(n,e,t){return function(a,r,i){return n(a,r,(function(n){"function"==typeof n&&(e.enteredCbs[t]||(e.enteredCbs[t]=[]),e.enteredCbs[t].push(n)),i(n)}))}}(n,t,a)}))}(m).concat(a.router.resolveHooks),h,(function(){if(a.pending!==n)return s(xo(r,n));a.pending=null,e(n),a.router.app&&a.router.app.$nextTick((function(){yi(n)}))}))}))},Bo.prototype.updateRoute=function(n){this.current=n,this.cb&&this.cb(n)},Bo.prototype.setupListeners=function(){},Bo.prototype.teardown=function(){this.listeners.forEach((function(n){n()})),this.listeners=[],this.current=gi,this.pending=null};var Jo=function(n){function e(e,t){n.call(this,e,t),this._startLocation=Ro(this.base)}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router,t=e.options.scrollBehavior,a=ho&&t;a&&this.listeners.push(ro());var r=function(){var t=n.current,r=Ro(n.base);n.current===gi&&r===n._startLocation||n.transitionTo(r,(function(n){a&&io(e,n,t,!0)}))};window.addEventListener("popstate",r),this.listeners.push((function(){window.removeEventListener("popstate",r)}))}},e.prototype.go=function(n){window.history.go(n)},e.prototype.push=function(n,e,t){var a=this,r=this.current;this.transitionTo(n,(function(n){vo(ji(a.base+n.fullPath)),io(a.router,n,r,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var a=this,r=this.current;this.transitionTo(n,(function(n){bo(ji(a.base+n.fullPath)),io(a.router,n,r,!1),e&&e(n)}),t)},e.prototype.ensureURL=function(n){if(Ro(this.base)!==this.current.fullPath){var e=ji(this.base+this.current.fullPath);n?vo(e):bo(e)}},e.prototype.getCurrentLocation=function(){return Ro(this.base)},e}(Bo);function Ro(n){var e=window.location.pathname,t=e.toLowerCase(),a=n.toLowerCase();return!n||t!==a&&0!==t.indexOf(ji(a+"/"))||(e=e.slice(n.length)),(e||"/")+window.location.search+window.location.hash}var Lo=function(n){function e(e,t,a){n.call(this,e,t),a&&function(n){var e=Ro(n);if(!/^\/#/.test(e))return window.location.replace(ji(n+"/#"+e)),!0}(this.base)||Do()}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router.options.scrollBehavior,t=ho&&e;t&&this.listeners.push(ro());var a=function(){var e=n.current;Do()&&n.transitionTo(Oo(),(function(a){t&&io(n.router,a,e,!0),ho||Fo(a.fullPath)}))},r=ho?"popstate":"hashchange";window.addEventListener(r,a),this.listeners.push((function(){window.removeEventListener(r,a)}))}},e.prototype.push=function(n,e,t){var a=this,r=this.current;this.transitionTo(n,(function(n){qo(n.fullPath),io(a.router,n,r,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var a=this,r=this.current;this.transitionTo(n,(function(n){Fo(n.fullPath),io(a.router,n,r,!1),e&&e(n)}),t)},e.prototype.go=function(n){window.history.go(n)},e.prototype.ensureURL=function(n){var e=this.current.fullPath;Oo()!==e&&(n?qo(e):Fo(e))},e.prototype.getCurrentLocation=function(){return Oo()},e}(Bo);function Do(){var n=Oo();return"/"===n.charAt(0)||(Fo("/"+n),!1)}function Oo(){var n=window.location.href,e=n.indexOf("#");return e<0?"":n=n.slice(e+1)}function _o(n){var e=window.location.href,t=e.indexOf("#");return(t>=0?e.slice(0,t):e)+"#"+n}function qo(n){ho?vo(_o(n)):window.location.hash=n}function Fo(n){ho?bo(_o(n)):window.location.replace(_o(n))}var Uo=function(n){function e(e,t){n.call(this,e,t),this.stack=[],this.index=-1}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.push=function(n,e,t){var a=this;this.transitionTo(n,(function(n){a.stack=a.stack.slice(0,a.index+1).concat(n),a.index++,e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var a=this;this.transitionTo(n,(function(n){a.stack=a.stack.slice(0,a.index).concat(n),e&&e(n)}),t)},e.prototype.go=function(n){var e=this,t=this.index+n;if(!(t<0||t>=this.stack.length)){var a=this.stack[t];this.confirmTransition(a,(function(){var n=e.current;e.index=t,e.updateRoute(a),e.router.afterHooks.forEach((function(e){e&&e(a,n)}))}),(function(n){ko(n,fo.duplicated)&&(e.index=t)}))}},e.prototype.getCurrentLocation=function(){var n=this.stack[this.stack.length-1];return n?n.fullPath:"/"},e.prototype.ensureURL=function(){},e}(Bo),No=function(n){void 0===n&&(n={}),this.app=null,this.apps=[],this.options=n,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=Qi(n.routes||[],this);var e=n.mode||"hash";switch(this.fallback="history"===e&&!ho&&!1!==n.fallback,this.fallback&&(e="hash"),Vi||(e="abstract"),this.mode=e,e){case"history":this.history=new Jo(this,n.base);break;case"hash":this.history=new Lo(this,n.base,this.fallback);break;case"abstract":this.history=new Uo(this,n.base);break;default:0}},Ho={currentRoute:{configurable:!0}};No.prototype.match=function(n,e,t){return this.matcher.match(n,e,t)},Ho.currentRoute.get=function(){return this.history&&this.history.current},No.prototype.init=function(n){var e=this;if(this.apps.push(n),n.$once("hook:destroyed",(function(){var t=e.apps.indexOf(n);t>-1&&e.apps.splice(t,1),e.app===n&&(e.app=e.apps[0]||null),e.app||e.history.teardown()})),!this.app){this.app=n;var t=this.history;if(t instanceof Jo||t instanceof Lo){var a=function(n){t.setupListeners(),function(n){var a=t.current,r=e.options.scrollBehavior;ho&&r&&"fullPath"in n&&io(e,n,a,!1)}(n)};t.transitionTo(t.getCurrentLocation(),a,a)}t.listen((function(n){e.apps.forEach((function(e){e._route=n}))}))}},No.prototype.beforeEach=function(n){return Wo(this.beforeHooks,n)},No.prototype.beforeResolve=function(n){return Wo(this.resolveHooks,n)},No.prototype.afterEach=function(n){return Wo(this.afterHooks,n)},No.prototype.onReady=function(n,e){this.history.onReady(n,e)},No.prototype.onError=function(n){this.history.onError(n)},No.prototype.push=function(n,e,t){var a=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){a.history.push(n,e,t)}));this.history.push(n,e,t)},No.prototype.replace=function(n,e,t){var a=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){a.history.replace(n,e,t)}));this.history.replace(n,e,t)},No.prototype.go=function(n){this.history.go(n)},No.prototype.back=function(){this.go(-1)},No.prototype.forward=function(){this.go(1)},No.prototype.getMatchedComponents=function(n){var e=n?n.matched?n:this.resolve(n).route:this.currentRoute;return e?[].concat.apply([],e.matched.map((function(n){return Object.keys(n.components).map((function(e){return n.components[e]}))}))):[]},No.prototype.resolve=function(n,e,t){var a=Ui(n,e=e||this.history.current,t,this),r=this.match(a,e),i=r.redirectedFrom||r.fullPath;return{location:a,route:r,href:function(n,e,t){var a="hash"===t?"#"+e:e;return n?ji(n+"/"+a):a}(this.history.base,i,this.mode),normalizedTo:a,resolved:r}},No.prototype.getRoutes=function(){return this.matcher.getRoutes()},No.prototype.addRoute=function(n,e){this.matcher.addRoute(n,e),this.history.current!==gi&&this.history.transitionTo(this.history.getCurrentLocation())},No.prototype.addRoutes=function(n){this.matcher.addRoutes(n),this.history.current!==gi&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(No.prototype,Ho);var $o=No;function Wo(n,e){return n.push(e),function(){var t=n.indexOf(e);t>-1&&n.splice(t,1)}}No.install=function n(e){if(!n.installed||Ni!==e){n.installed=!0,Ni=e;var t=function(n){return void 0!==n},a=function(n,e){var a=n.$options._parentVnode;t(a)&&t(a=a.data)&&t(a=a.registerRouteInstance)&&a(n,e)};e.mixin({beforeCreate:function(){t(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),e.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,a(this,this)},destroyed:function(){a(this)}}),Object.defineProperty(e.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(e.prototype,"$route",{get:function(){return this._routerRoot._route}}),e.component("RouterView",xi),e.component("RouterLink",$i);var r=e.config.optionMergeStrategies;r.beforeRouteEnter=r.beforeRouteLeave=r.beforeRouteUpdate=r.created}},No.version="3.6.5",No.isNavigationFailure=ko,No.NavigationFailureType=fo,No.START_LOCATION=gi,Vi&&window.Vue&&window.Vue.use(No);t(153),t(17),t(163);t(165),t(29);var Vo={NotFound:()=>Promise.all([t.e(0),t.e(4)]).then(t.bind(null,367)),Layout:()=>Promise.all([t.e(0),t.e(2)]).then(t.bind(null,366))},Go={"v-8c24c1c0":()=>t.e(5).then(t.bind(null,368)),"v-bd7f8880":()=>t.e(6).then(t.bind(null,369)),"v-1897f31c":()=>t.e(7).then(t.bind(null,370)),"v-36554d68":()=>t.e(8).then(t.bind(null,371)),"v-84fd370c":()=>t.e(10).then(t.bind(null,372)),"v-6ec25090":()=>t.e(9).then(t.bind(null,373)),"v-197081d4":()=>t.e(11).then(t.bind(null,374)),"v-f182b6d2":()=>t.e(12).then(t.bind(null,375)),"v-372bea40":()=>t.e(13).then(t.bind(null,376)),"v-63c3bd02":()=>t.e(14).then(t.bind(null,377)),"v-14be4fe4":()=>t.e(15).then(t.bind(null,378)),"v-2e4483c6":()=>t.e(16).then(t.bind(null,379)),"v-48965ab6":()=>t.e(17).then(t.bind(null,380)),"v-2a45c84c":()=>t.e(19).then(t.bind(null,381)),"v-60c4af86":()=>t.e(18).then(t.bind(null,382)),"v-c8c7b0bc":()=>t.e(21).then(t.bind(null,383)),"v-7a43a3c8":()=>t.e(20).then(t.bind(null,384)),"v-9dacab80":()=>t.e(22).then(t.bind(null,385)),"v-35a64902":()=>t.e(23).then(t.bind(null,386)),"v-030a633c":()=>t.e(24).then(t.bind(null,387)),"v-ecc5245e":()=>t.e(25).then(t.bind(null,388)),"v-160dee90":()=>t.e(26).then(t.bind(null,389)),"v-92d5b0d0":()=>t.e(28).then(t.bind(null,390)),"v-7212740e":()=>t.e(27).then(t.bind(null,391)),"v-5a249b69":()=>t.e(29).then(t.bind(null,392)),"v-a4ec7cea":()=>t.e(30).then(t.bind(null,393)),"v-51b6d2f2":()=>t.e(31).then(t.bind(null,394)),"v-12f6b900":()=>t.e(32).then(t.bind(null,395)),"v-596e4bb7":()=>t.e(33).then(t.bind(null,396)),"v-5fd2a085":()=>t.e(34).then(t.bind(null,397)),"v-5638950b":()=>t.e(35).then(t.bind(null,398)),"v-52bbe8ea":()=>t.e(36).then(t.bind(null,399)),"v-877bb26a":()=>t.e(37).then(t.bind(null,400)),"v-aa513a90":()=>t.e(39).then(t.bind(null,401)),"v-18d04790":()=>t.e(40).then(t.bind(null,402)),"v-1fa4716e":()=>t.e(38).then(t.bind(null,403)),"v-4e5dcd45":()=>t.e(41).then(t.bind(null,404)),"v-1fa328ca":()=>t.e(42).then(t.bind(null,405)),"v-6cd70b6c":()=>t.e(43).then(t.bind(null,406)),"v-a648697c":()=>t.e(44).then(t.bind(null,407)),"v-b1567070":()=>t.e(45).then(t.bind(null,408)),"v-d73a1b24":()=>t.e(46).then(t.bind(null,409)),"v-f62f42f0":()=>t.e(47).then(t.bind(null,410)),"v-19120fca":()=>t.e(48).then(t.bind(null,411)),"v-5cda01e4":()=>t.e(49).then(t.bind(null,412)),"v-98b41d6c":()=>t.e(50).then(t.bind(null,413)),"v-1d1948c1":()=>t.e(53).then(t.bind(null,414)),"v-7cf35edc":()=>t.e(51).then(t.bind(null,415)),"v-fefff020":()=>t.e(52).then(t.bind(null,416)),"v-e3a97658":()=>t.e(54).then(t.bind(null,417)),"v-377147a2":()=>t.e(55).then(t.bind(null,418)),"v-38be25ad":()=>t.e(56).then(t.bind(null,419)),"v-16dd06c5":()=>t.e(57).then(t.bind(null,420)),"v-4feafdf7":()=>t.e(58).then(t.bind(null,421)),"v-1b7ae99a":()=>t.e(59).then(t.bind(null,422)),"v-78a970ba":()=>t.e(61).then(t.bind(null,423)),"v-62f1222d":()=>t.e(60).then(t.bind(null,424)),"v-7d53b0b4":()=>t.e(62).then(t.bind(null,425)),"v-aebe0138":()=>t.e(63).then(t.bind(null,426)),"v-59088176":()=>t.e(64).then(t.bind(null,427)),"v-372d1374":()=>t.e(66).then(t.bind(null,428)),"v-4e3a5110":()=>t.e(65).then(t.bind(null,429)),"v-617edf3a":()=>t.e(67).then(t.bind(null,430)),"v-2a4dda94":()=>t.e(69).then(t.bind(null,431)),"v-55cc8b3f":()=>t.e(68).then(t.bind(null,432)),"v-5ff32bba":()=>t.e(70).then(t.bind(null,433)),"v-4643e240":()=>t.e(71).then(t.bind(null,434)),"v-6b2eab00":()=>t.e(72).then(t.bind(null,435)),"v-1243db1d":()=>t.e(73).then(t.bind(null,436)),"v-10b9b6b6":()=>t.e(74).then(t.bind(null,437)),"v-3fdf0214":()=>t.e(75).then(t.bind(null,438)),"v-95b1a28a":()=>t.e(76).then(t.bind(null,439)),"v-7bfb01a8":()=>t.e(77).then(t.bind(null,440)),"v-2969c73e":()=>t.e(78).then(t.bind(null,441)),"v-32d028da":()=>t.e(79).then(t.bind(null,442)),"v-16ce6423":()=>t.e(81).then(t.bind(null,443)),"v-3a6d09bb":()=>t.e(80).then(t.bind(null,444)),"v-375fe748":()=>t.e(83).then(t.bind(null,445)),"v-68aff9b6":()=>t.e(82).then(t.bind(null,446)),"v-fe2fd7e0":()=>t.e(84).then(t.bind(null,447)),"v-11d62c46":()=>t.e(85).then(t.bind(null,448)),"v-121f4bfb":()=>t.e(86).then(t.bind(null,449)),"v-e0b3a04c":()=>t.e(87).then(t.bind(null,450)),"v-50b7250c":()=>t.e(88).then(t.bind(null,451)),"v-10fbaa3f":()=>t.e(89).then(t.bind(null,452)),"v-7144da80":()=>t.e(90).then(t.bind(null,453)),"v-6feaabf6":()=>t.e(91).then(t.bind(null,454)),"v-21c80e99":()=>t.e(92).then(t.bind(null,455)),"v-69fe3d9a":()=>t.e(93).then(t.bind(null,456)),"v-3b4bf83b":()=>t.e(94).then(t.bind(null,457)),"v-299bf82c":()=>t.e(95).then(t.bind(null,458)),"v-c837cd76":()=>t.e(96).then(t.bind(null,459)),"v-029db6b7":()=>t.e(98).then(t.bind(null,460)),"v-1b892327":()=>t.e(97).then(t.bind(null,461)),"v-577422c2":()=>t.e(99).then(t.bind(null,462)),"v-033238fd":()=>t.e(101).then(t.bind(null,463)),"v-b0144bd0":()=>t.e(100).then(t.bind(null,464)),"v-27fc8106":()=>t.e(102).then(t.bind(null,465)),"v-e92f7bb8":()=>t.e(103).then(t.bind(null,466)),"v-aa040a8e":()=>t.e(104).then(t.bind(null,467)),"v-52097332":()=>t.e(105).then(t.bind(null,468)),"v-5c0a26b0":()=>t.e(106).then(t.bind(null,469)),"v-69fdd354":()=>t.e(107).then(t.bind(null,470)),"v-5a2a2041":()=>t.e(108).then(t.bind(null,471)),"v-23820ebe":()=>t.e(109).then(t.bind(null,472)),"v-e127b82a":()=>t.e(110).then(t.bind(null,473)),"v-4f10fdce":()=>t.e(111).then(t.bind(null,474)),"v-ca8d6204":()=>t.e(112).then(t.bind(null,475)),"v-f62f294c":()=>t.e(113).then(t.bind(null,476)),"v-25a234c6":()=>t.e(114).then(t.bind(null,477)),"v-6a3ca52c":()=>t.e(115).then(t.bind(null,478)),"v-16e36653":()=>t.e(116).then(t.bind(null,479)),"v-dde25f08":()=>t.e(118).then(t.bind(null,480)),"v-938fb0a0":()=>t.e(117).then(t.bind(null,481)),"v-5cf98845":()=>t.e(119).then(t.bind(null,482)),"v-f8df10f8":()=>t.e(120).then(t.bind(null,483)),"v-a97447de":()=>t.e(121).then(t.bind(null,484)),"v-2ce67d1d":()=>t.e(123).then(t.bind(null,485)),"v-de6109ae":()=>t.e(122).then(t.bind(null,486)),"v-7d955174":()=>t.e(124).then(t.bind(null,487)),"v-60970149":()=>t.e(125).then(t.bind(null,488)),"v-79787bec":()=>t.e(127).then(t.bind(null,489)),"v-0cc297da":()=>t.e(126).then(t.bind(null,490)),"v-18696fc0":()=>t.e(128).then(t.bind(null,491)),"v-50444ed1":()=>t.e(129).then(t.bind(null,492)),"v-e3279b12":()=>t.e(130).then(t.bind(null,493)),"v-60f62e76":()=>t.e(131).then(t.bind(null,494)),"v-12857866":()=>t.e(132).then(t.bind(null,495)),"v-3feddaec":()=>t.e(133).then(t.bind(null,496)),"v-04cda89e":()=>t.e(134).then(t.bind(null,497)),"v-26877d31":()=>t.e(136).then(t.bind(null,498)),"v-10d1fe8a":()=>t.e(137).then(t.bind(null,499)),"v-5d493111":()=>t.e(135).then(t.bind(null,500))};function Xo(n){const e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}const Qo=/-(\w)/g,Ko=Xo(n=>n.replace(Qo,(n,e)=>e?e.toUpperCase():"")),Zo=/\B([A-Z])/g,Yo=Xo(n=>n.replace(Zo,"-$1").toLowerCase()),ns=Xo(n=>n.charAt(0).toUpperCase()+n.slice(1));function es(n,e){if(!e)return;if(n(e))return n(e);return e.includes("-")?n(ns(Ko(e))):n(ns(e))||n(Yo(e))}const ts=Object.assign({},Vo,Go),as=n=>ts[n],rs=n=>Go[n],is=n=>Vo[n],os=n=>Vt.component(n);function ss(n){return es(rs,n)}function ls(n){return es(is,n)}function cs(n){return es(as,n)}function ps(n){return es(os,n)}function ds(...n){return Promise.all(n.filter(n=>n).map(async n=>{if(!ps(n)&&cs(n)){const e=await cs(n)();Vt.component(n,e.default)}}))}function us(n,e){"undefined"!=typeof window&&window.__VUEPRESS__&&(window.__VUEPRESS__[n]=e)}var ms=t(118),gs=t.n(ms),hs=t(119),vs=t.n(hs),bs={created(){if(this.siteMeta=this.$site.headTags.filter(([n])=>"meta"===n).map(([n,e])=>e),this.$ssrContext){const e=this.getMergedMetaTags();this.$ssrContext.title=this.$title,this.$ssrContext.lang=this.$lang,this.$ssrContext.pageMeta=(n=e)?n.map(n=>{let e="<meta";return Object.keys(n).forEach(t=>{e+=` ${t}="${vs()(n[t])}"`}),e+">"}).join("\n    "):"",this.$ssrContext.canonicalLink=ys(this.$canonicalUrl)}var n},mounted(){this.currentMetaTags=[...document.querySelectorAll("meta")],this.updateMeta(),this.updateCanonicalLink()},methods:{updateMeta(){document.title=this.$title,document.documentElement.lang=this.$lang;const n=this.getMergedMetaTags();this.currentMetaTags=xs(n,this.currentMetaTags)},getMergedMetaTags(){const n=this.$page.frontmatter.meta||[];return gs()([{name:"description",content:this.$description}],n,this.siteMeta,Ss)},updateCanonicalLink(){fs(),this.$canonicalUrl&&document.head.insertAdjacentHTML("beforeend",ys(this.$canonicalUrl))}},watch:{$page(){this.updateMeta(),this.updateCanonicalLink()}},beforeDestroy(){xs(null,this.currentMetaTags),fs()}};function fs(){const n=document.querySelector("link[rel='canonical']");n&&n.remove()}function ys(n=""){return n?`<link href="${n}" rel="canonical" />`:""}function xs(n,e){if(e&&[...e].filter(n=>n.parentNode===document.head).forEach(n=>document.head.removeChild(n)),n)return n.map(n=>{const e=document.createElement("meta");return Object.keys(n).forEach(t=>{e.setAttribute(t,n[t])}),document.head.appendChild(e),e})}function Ss(n){for(const e of["name","property","itemprop"])if(n.hasOwnProperty(e))return n[e]+e;return JSON.stringify(n)}t(64);var ws=t(68),js={mounted(){window.addEventListener("scroll",this.onScroll)},methods:{onScroll:t.n(ws)()((function(){this.setActiveHash()}),300),setActiveHash(){const n=[].slice.call(document.querySelectorAll(".sidebar-link")),e=[].slice.call(document.querySelectorAll(".header-anchor")).filter(e=>n.some(n=>n.hash===e.hash)),t=Math.max(window.pageYOffset,document.documentElement.scrollTop,document.body.scrollTop),a=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight),r=window.innerHeight+t;for(let n=0;n<e.length;n++){const i=e[n],o=e[n+1],s=0===n&&0===t||t>=i.parentElement.offsetTop+10&&(!o||t<o.parentElement.offsetTop-10),l=decodeURIComponent(this.$route.hash);if(s&&l!==decodeURIComponent(i.hash)){const t=i;if(r===a)for(let t=n+1;t<e.length;t++)if(l===decodeURIComponent(e[t].hash))return;return this.$vuepress.$set("disableScrollBehavior",!0),void this.$router.replace(decodeURIComponent(t.hash),()=>{this.$nextTick(()=>{this.$vuepress.$set("disableScrollBehavior",!1)})})}}}},beforeDestroy(){window.removeEventListener("scroll",this.onScroll)}},ks=t(43),Ts=t.n(ks),Is={mounted(){Ts.a.configure({showSpinner:!1}),this.$router.beforeEach((n,e,t)=>{n.path===e.path||Vt.component(n.name)||Ts.a.start(),t()}),this.$router.afterEach(()=>{Ts.a.done(),this.isSidebarOpen=!1})}};t(276),t(277);class Cs{constructor(){this.containerEl=document.getElementById("message-container"),this.containerEl||(this.containerEl=document.createElement("div"),this.containerEl.id="message-container",document.body.appendChild(this.containerEl))}show({text:n="",duration:e=3e3}){let t=document.createElement("div");t.className="message move-in",t.innerHTML=`\n      <i style="fill: #06a35a;font-size: 14px;display:inline-flex;align-items: center;">\n        <svg style="fill: #06a35a;font-size: 14px;" t="1572421810237" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2323" width="16" height="16"><path d="M822.811993 824.617989c-83.075838 81.99224-188.546032 124.613757-316.049383 127.86455-122.085362-3.250794-223.943563-45.87231-305.935802-127.86455s-124.613757-184.21164-127.86455-305.935802c3.250794-127.503351 45.87231-232.973545 127.86455-316.049383 81.99224-83.075838 184.21164-126.058554 305.935802-129.309347 127.503351 3.250794 232.973545 46.23351 316.049383 129.309347 83.075838 83.075838 126.058554 188.546032 129.309347 316.049383C949.231746 640.406349 905.887831 742.62575 822.811993 824.617989zM432.716755 684.111464c3.973192 3.973192 8.307584 5.779189 13.364374 6.140388 5.05679 0.361199 9.752381-1.444797 13.364374-5.417989l292.571429-287.514638c3.973192-3.973192 5.779189-8.307584 5.779189-13.364374 0-5.05679-1.805996-9.752381-5.779189-13.364374l1.805996 1.805996c-3.973192-3.973192-8.668783-5.779189-14.086772-6.140388-5.417989-0.361199-10.47478 1.444797-14.809171 5.417989l-264.397884 220.33157c-3.973192 3.250794-8.668783 4.695591-14.447972 4.695591-5.779189 0-10.835979-1.444797-15.53157-3.973192l-94.273016-72.962257c-4.334392-3.250794-9.391182-4.334392-14.447972-3.973192s-9.391182 3.250794-12.641975 7.585185l-2.889594 3.973192c-3.250794 4.334392-4.334392 9.391182-3.973192 14.809171 0.722399 5.417989 2.528395 10.11358 5.779189 14.086772L432.716755 684.111464z" p-id="2324"></path></svg>\n      </i>\n      <div class="text">${n}</div>\n    `,this.containerEl.appendChild(t),e>0&&setTimeout(()=>{this.close(t)},e)}close(n){n.className=n.className.replace("move-in",""),n.className+="move-out",n.addEventListener("animationend",()=>{n.remove()})}}var Es={mounted(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},updated(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},methods:{updateCopy(){setTimeout(()=>{(['div[class*="language-"] pre','div[class*="aside-code"] aside']instanceof Array||Array.isArray(['div[class*="language-"] pre','div[class*="aside-code"] aside']))&&['div[class*="language-"] pre','div[class*="aside-code"] aside'].forEach(n=>{document.querySelectorAll(n).forEach(this.generateCopyButton)})},1e3)},generateCopyButton(n){if(n.classList.contains("codecopy-enabled"))return;const e=document.createElement("i");e.className="code-copy",e.innerHTML='<svg  style="color:#aaa;font-size:14px" t="1572422231464" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3201" width="14" height="14"><path d="M866.461538 39.384615H354.461538c-43.323077 0-78.769231 35.446154-78.76923 78.769231v39.384616h472.615384c43.323077 0 78.769231 35.446154 78.769231 78.76923v551.384616h39.384615c43.323077 0 78.769231-35.446154 78.769231-78.769231V118.153846c0-43.323077-35.446154-78.769231-78.769231-78.769231z m-118.153846 275.692308c0-43.323077-35.446154-78.769231-78.76923-78.769231H157.538462c-43.323077 0-78.769231 35.446154-78.769231 78.769231v590.769231c0 43.323077 35.446154 78.769231 78.769231 78.769231h512c43.323077 0 78.769231-35.446154 78.76923-78.769231V315.076923z m-354.461538 137.846154c0 11.815385-7.876923 19.692308-19.692308 19.692308h-157.538461c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h157.538461c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z m157.538461 315.076923c0 11.815385-7.876923 19.692308-19.692307 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h315.076923c11.815385 0 19.692308 7.876923 19.692307 19.692308v39.384615z m78.769231-157.538462c0 11.815385-7.876923 19.692308-19.692308 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h393.846153c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z" p-id="3202"></path></svg>',e.title="Copy to clipboard",e.addEventListener("click",()=>{this.copyToClipboard(n.innerText)}),n.appendChild(e),n.classList.add("codecopy-enabled")},copyToClipboard(n){const e=document.createElement("textarea");e.value=n,e.setAttribute("readonly",""),e.style.position="absolute",e.style.left="-9999px",document.body.appendChild(e);const t=document.getSelection().rangeCount>0&&document.getSelection().getRangeAt(0);e.select(),document.execCommand("copy");(new Cs).show({text:"复制成功",duration:1e3}),document.body.removeChild(e),t&&(document.getSelection().removeAllRanges(),document.getSelection().addRange(t))}}};!function(n,e){void 0===e&&(e={});var t=e.insertAt;if(n&&"undefined"!=typeof document){var a=document.head||document.getElementsByTagName("head")[0],r=document.createElement("style");r.type="text/css","top"===t&&a.firstChild?a.insertBefore(r,a.firstChild):a.appendChild(r),r.styleSheet?r.styleSheet.cssText=n:r.appendChild(document.createTextNode(n))}}("@media (max-width: 1000px) {\n  .vuepress-plugin-demo-block__h_code {\n    display: none;\n  }\n  .vuepress-plugin-demo-block__app {\n    margin-left: auto !important;\n    margin-right: auto !important;\n  }\n}\n.vuepress-plugin-demo-block__wrapper {\n  margin-top: 10px;\n  border: 1px solid #ebebeb;\n  border-radius: 4px;\n  transition: all 0.2s;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display {\n  height: 400px;\n  display: flex;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__app {\n  width: 300px;\n  border: 1px solid #ebebeb;\n  box-shadow: 1px 1px 3px #ebebeb;\n  margin-right: 5px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code {\n  flex: 1;\n  overflow: auto;\n  height: 100%;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code > pre {\n  overflow: visible;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  max-height: 400px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper div {\n  box-sizing: border-box;\n}\n.vuepress-plugin-demo-block__wrapper:hover {\n  box-shadow: 0 0 11px rgba(33, 33, 33, 0.2);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code {\n  overflow: hidden;\n  height: 0;\n  padding: 0 !important;\n  background-color: #282c34;\n  border-radius: 0 !important;\n  transition: height 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code pre {\n  margin: 0 !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  padding: 20px;\n  border-bottom: 1px solid #ebebeb;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer {\n  position: relative;\n  text-align: center;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__codepen {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__expand::before {\n  border-top: none;\n  border-right: 6px solid transparent;\n  border-bottom: 6px solid #ccc;\n  border-left: 6px solid transparent;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__codepen,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand span,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand::before {\n  border-top-color: #3eaf7c !important;\n  border-bottom-color: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover svg {\n  fill: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand-text {\n  transition: all 0.5s;\n  opacity: 0;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:nth-last-child(2) {\n  right: 50px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:last-child {\n  right: 10px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button {\n  border-color: transparent;\n  background-color: transparent;\n  font-size: 14px;\n  color: #3eaf7c;\n  cursor: pointer;\n  outline: none;\n  margin: 0;\n  width: 46px;\n  position: relative;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::before {\n  content: attr(data-tip);\n  white-space: nowrap;\n  position: absolute;\n  top: -30px;\n  left: 50%;\n  color: #eee;\n  line-height: 1;\n  z-index: 1000;\n  border-radius: 4px;\n  padding: 6px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  background-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::after {\n  content: '' !important;\n  display: block;\n  position: absolute;\n  left: 50%;\n  top: -5px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  border: 5px solid transparent;\n  border-top-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button svg {\n  width: 34px;\n  height: 20px;\n  fill: #ccc;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__codepen {\n  position: absolute;\n  top: 10px;\n  transition: all 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand {\n  position: relative;\n  width: 100px;\n  height: 40px;\n  margin: 0;\n  color: #3eaf7c;\n  font-size: 14px;\n  background-color: transparent;\n  border-color: transparent;\n  outline: none;\n  transition: all 0.5s;\n  cursor: pointer;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand::before {\n  content: \"\";\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  width: 0;\n  height: 0;\n  border-top: 6px solid #ccc;\n  border-right: 6px solid transparent;\n  border-left: 6px solid transparent;\n  -webkit-transform: translate(-50%, -50%);\n          transform: translate(-50%, -50%);\n}\n");var As={jsLib:[],cssLib:[],jsfiddle:!0,codepen:!0,codepenLayout:"left",codepenJsProcessor:"babel",codepenEditors:"101",horizontal:!1,vue:"https://cdn.jsdelivr.net/npm/vue/dist/vue.min.js",react:"https://cdn.jsdelivr.net/npm/react/umd/react.production.min.js",reactDOM:"https://cdn.jsdelivr.net/npm/react-dom/umd/react-dom.production.min.js"},Ps={},Bs=function(n){return'<div id="app">\n'.concat(n,"\n</div>")},Ms=function(n){return window.$VUEPRESS_DEMO_BLOCK&&void 0!==window.$VUEPRESS_DEMO_BLOCK[n]?window.$VUEPRESS_DEMO_BLOCK[n]:As[n]},zs=function n(e,t,a){var r=document.createElement(e);return t&&Object.keys(t).forEach((function(n){if(n.indexOf("data"))r[n]=t[n];else{var e=n.replace("data","");r.dataset[e]=t[n]}})),a&&a.forEach((function(e){var t=e.tag,a=e.attrs,i=e.children;r.appendChild(n(t,a,i))})),r},Js=function(n,e,t){var a,r=(a=n.querySelectorAll(".".concat(e)),Array.prototype.slice.call(a));return 1!==r.length||t?r:r[0]},Rs=function(n,e){var t,a,r=n.match(/<style>([\s\S]+)<\/style>/),i=n.match(/<template>([\s\S]+)<\/template>/),o=n.match(/<script>([\s\S]+)<\/script>/),s={css:r&&r[1].replace(/^\n|\n$/g,""),html:i&&i[1].replace(/^\n|\n$/g,""),js:o&&o[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};s.htmlTpl=Bs(s.html),s.jsTpl=(t=s.js,a=t.replace(/export\s+default\s*?\{\n*/,"").replace(/\n*\}\s*$/,"").trim(),"new Vue({\n  el: '#app',\n  ".concat(a,"\n})")),s.script=function(n,e){var t=n.split(/export\s+default/),a="(function() {".concat(t[0]," ; return ").concat(t[1],"})()"),r=window.Babel?window.Babel.transform(a,{presets:["es2015"]}).code:a,i=[eval][0](r);return i.template=e,i}(s.js,s.html);var l=Ms("vue");return s.jsLib.unshift(l),s},Ls=function(n,e){var t,a=n.match(/<style>([\s\S]+)<\/style>/),r=n.match(/<html>([\s\S]+)<\/html>/),i=n.match(/<script>([\s\S]+)<\/script>/),o={css:a&&a[1].replace(/^\n|\n$/g,""),html:r&&r[1].replace(/^\n|\n$/g,""),js:i&&i[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};return o.htmlTpl=o.html,o.jsTpl=o.js,o.script=(t=o.js,window.Babel?window.Babel.transform(t,{presets:["es2015"]}).code:t),o},Ds=function(n){return n=n.replace("export default ","").replace(/App\.__style__(\s*)=(\s*)`([\s\S]*)?`/,""),n+='ReactDOM.render(React.createElement(App), document.getElementById("app"))'};function Os(){var n=Js(document,"vuepress-plugin-demo-block__wrapper",!0);n.length?n.forEach((function(n){if("true"!==n.dataset.created){n.style.display="block";var e=Js(n,"vuepress-plugin-demo-block__code"),t=Js(n,"vuepress-plugin-demo-block__display"),a=Js(n,"vuepress-plugin-demo-block__footer"),r=Js(t,"vuepress-plugin-demo-block__app"),i=decodeURIComponent(n.dataset.code),o=decodeURIComponent(n.dataset.config),s=decodeURIComponent(n.dataset.type);o=o?JSON.parse(o):{};var l=e.querySelector("div").clientHeight,c="react"===s?function(n,e){var t=(0,window.Babel.transform)(n,{presets:["es2015","react"]}).code,a="(function(exports){var module={};module.exports=exports;".concat(t,";return module.exports.__esModule?module.exports.default:module.exports;})({})"),r=new Function("return ".concat(a))(),i={js:r,css:r.__style__||"",jsLib:e.jsLib||[],cssLib:e.cssLib||[],jsTpl:Ds(n),htmlTpl:Bs("")},o=Ms("react"),s=Ms("reactDOM");return i.jsLib.unshift(o,s),i}(i,o):"vanilla"===s?Ls(i,o):Rs(i,o),p=zs("button",{className:"".concat("vuepress-plugin-demo-block__expand")});if(a.appendChild(p),p.addEventListener("click",_s.bind(null,p,l,e,a)),Ms("jsfiddle")&&a.appendChild(function(n){var e=n.css,t=n.htmlTpl,a=n.jsTpl,r=n.jsLib,i=n.cssLib,o=r.concat(i).concat(Ms("cssLib")).concat(Ms("jsLib")).join(",");return zs("form",{className:"vuepress-plugin-demo-block__jsfiddle",target:"_blank",action:"https://jsfiddle.net/api/post/library/pure/",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"css",value:e}},{tag:"input",attrs:{type:"hidden",name:"html",value:t}},{tag:"input",attrs:{type:"hidden",name:"js",value:a}},{tag:"input",attrs:{type:"hidden",name:"panel_js",value:3}},{tag:"input",attrs:{type:"hidden",name:"wrap",value:1}},{tag:"input",attrs:{type:"hidden",name:"resources",value:o}},{tag:"button",attrs:{type:"submit",className:"vuepress-plugin-demo-block__button",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088289967" class="icon" style="" viewBox="0 0 1170 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1952" xmlns:xlink="http://www.w3.org/1999/xlink" width="228.515625" height="200"><defs><style type="text/css"></style></defs><path d="M1028.571429 441.142857q63.428571 26.285714 102.571428 83.142857T1170.285714 650.857143q0 93.714286-67.428571 160.285714T940 877.714286q-2.285714 0-6.571429-0.285715t-6-0.285714H232q-97.142857-5.714286-164.571429-71.714286T0 645.142857q0-62.857143 31.428571-116t84-84q-6.857143-22.285714-6.857142-46.857143 0-65.714286 46.857142-112t113.714286-46.285714q54.285714 0 98.285714 33.142857 42.857143-88 127.142858-141.714286t186.571428-53.714285q94.857143 0 174.857143 46T982.571429 248.571429t46.571428 172q0 3.428571-0.285714 10.285714t-0.285714 10.285714zM267.428571 593.142857q0 69.714286 48 110.285714t118.857143 40.571429q78.285714 0 137.142857-56.571429-9.142857-11.428571-27.142857-32.285714T519.428571 626.285714q-38.285714 37.142857-82.285714 37.142857-31.428571 0-53.428571-19.142857T361.714286 594.285714q0-30.285714 22-49.714285t52.285714-19.428572q25.142857 0 48.285714 12t41.714286 31.428572 37.142857 42.857142 39.428572 46.857143 44 42.857143 55.428571 31.428572 69.428571 12q69.142857 0 116.857143-40.857143T936 594.857143q0-69.142857-48-109.714286t-118.285714-40.571428q-81.714286 0-137.714286 55.428571l53.142857 61.714286q37.714286-36.571429 81.142857-36.571429 29.714286 0 52.571429 18.857143t22.857143 48q0 32.571429-21.142857 52.285714t-53.714286 19.714286q-24.571429 0-47.142857-12t-41.142857-31.428571-37.428572-42.857143-39.714286-46.857143-44.285714-42.857143-55.142857-31.428571T434.285714 444.571429q-69.714286 0-118.285714 40.285714T267.428571 593.142857z" p-id="1953"></path></svg>',datatip:"JSFiddle"}}])}(c)),Ms("codepen")&&a.appendChild(function(n){var e=n.css,t=n.htmlTpl,a=n.jsTpl,r=n.jsLib,i=n.cssLib,o=JSON.stringify({css:e,html:t,js:a,js_external:r.concat(Ms("jsLib")).join(";"),css_external:i.concat(Ms("cssLib")).join(";"),layout:Ms("codepenLayout"),js_pre_processor:Ms("codepenJsProcessor"),editors:Ms("codepenEditors")});return zs("form",{className:"vuepress-plugin-demo-block__codepen",target:"_blank",action:"https://codepen.io/pen/define",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"data",value:o}},{tag:"button",attrs:{type:"submit",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088271207" class="icon" style="" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1737" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><defs><style type="text/css"></style></defs><path d="M123.428571 668l344.571429 229.714286v-205.142857L277.142857 565.142857z m-35.428571-82.285714l110.285714-73.714286-110.285714-73.714286v147.428572z m468 312l344.571429-229.714286-153.714286-102.857143-190.857143 127.428572v205.142857z m-44-281.714286l155.428571-104-155.428571-104-155.428571 104zM277.142857 458.857143l190.857143-127.428572V126.285714L123.428571 356z m548.571429 53.142857l110.285714 73.714286V438.285714z m-78.857143-53.142857l153.714286-102.857143-344.571429-229.714286v205.142857z m277.142857-102.857143v312q0 23.428571-19.428571 36.571429l-468 312q-12 7.428571-24.571429 7.428571t-24.571429-7.428571L19.428571 704.571429q-19.428571-13.142857-19.428571-36.571429V356q0-23.428571 19.428571-36.571429L487.428571 7.428571q12-7.428571 24.571429-7.428571t24.571429 7.428571l468 312q19.428571 13.142857 19.428571 36.571429z" p-id="1738"></path></svg>',className:"vuepress-plugin-demo-block__button",datatip:"Codepen"}}])}(c)),void 0!==o.horizontal?o.horizontal:Ms("horizontal")){n.classList.add("vuepress-plugin-demo-block__horizontal");var d=e.firstChild.cloneNode(!0);d.classList.add("vuepress-plugin-demo-block__h_code"),t.appendChild(d)}if(c.css&&function(n){if(!Ps[n]){var e=zs("style",{innerHTML:n});document.body.appendChild(e),Ps[n]=!0}}(c.css),"react"===s)ReactDOM.render(React.createElement(c.js),r);else if("vue"===s){var u=(new(Vue.extend(c.script))).$mount();r.appendChild(u.$el)}else"vanilla"===s&&(r.innerHTML=c.html,new Function("return (function(){".concat(c.script,"})()"))());n.dataset.created="true"}})):setTimeout((function(n){Os()}),300)}function _s(n,e,t,a){var r="1"!==n.dataset.isExpand;t.style.height=r?"".concat(e,"px"):0,r?a.classList.add("vuepress-plugin-demo-block__show-link"):a.classList.remove("vuepress-plugin-demo-block__show-link"),n.dataset.isExpand=r?"1":"0"}var qs={mounted:function(){window.$VUEPRESS_DEMO_BLOCK={jsfiddle:!1,codepen:!0,horizontal:!1},Os()},updated:function(){Os()}},Fs="auto",Us="zoom-in",Ns="zoom-out",Hs="grab",$s="move";function Ws(n,e,t){var a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],r={passive:!1};a?n.addEventListener(e,t,r):n.removeEventListener(e,t,r)}function Vs(n,e){if(n){var t=new Image;t.onload=function(){e&&e(t)},t.src=n}}function Gs(n){return n.dataset.original?n.dataset.original:"A"===n.parentNode.tagName?n.parentNode.getAttribute("href"):null}function Xs(n,e,t){!function(n){var e=Qs,t=Ks;if(n.transition){var a=n.transition;delete n.transition,n[e]=a}if(n.transform){var r=n.transform;delete n.transform,n[t]=r}}(e);var a=n.style,r={};for(var i in e)t&&(r[i]=a[i]||""),a[i]=e[i];return r}var Qs="transition",Ks="transform",Zs="transform",Ys="transitionend";var nl=function(){},el={enableGrab:!0,preloadImage:!1,closeOnWindowResize:!0,transitionDuration:.4,transitionTimingFunction:"cubic-bezier(0.4, 0, 0, 1)",bgColor:"rgb(255, 255, 255)",bgOpacity:1,scaleBase:1,scaleExtra:.5,scrollThreshold:40,zIndex:998,customSize:null,onOpen:nl,onClose:nl,onGrab:nl,onMove:nl,onRelease:nl,onBeforeOpen:nl,onBeforeClose:nl,onBeforeGrab:nl,onBeforeRelease:nl,onImageLoading:nl,onImageLoaded:nl},tl={init:function(n){var e,t;e=this,t=n,Object.getOwnPropertyNames(Object.getPrototypeOf(e)).forEach((function(n){e[n]=e[n].bind(t)}))},click:function(n){if(n.preventDefault(),rl(n))return window.open(this.target.srcOriginal||n.currentTarget.src,"_blank");this.shown?this.released?this.close():this.release():this.open(n.currentTarget)},scroll:function(){var n=document.documentElement||document.body.parentNode||document.body,e=window.pageXOffset||n.scrollLeft,t=window.pageYOffset||n.scrollTop;null===this.lastScrollPosition&&(this.lastScrollPosition={x:e,y:t});var a=this.lastScrollPosition.x-e,r=this.lastScrollPosition.y-t,i=this.options.scrollThreshold;(Math.abs(r)>=i||Math.abs(a)>=i)&&(this.lastScrollPosition=null,this.close())},keydown:function(n){(function(n){return"Escape"===(n.key||n.code)||27===n.keyCode})(n)&&(this.released?this.close():this.release(this.close))},mousedown:function(n){if(al(n)&&!rl(n)){n.preventDefault();var e=n.clientX,t=n.clientY;this.pressTimer=setTimeout(function(){this.grab(e,t)}.bind(this),200)}},mousemove:function(n){this.released||this.move(n.clientX,n.clientY)},mouseup:function(n){al(n)&&!rl(n)&&(clearTimeout(this.pressTimer),this.released?this.close():this.release())},touchstart:function(n){n.preventDefault();var e=n.touches[0],t=e.clientX,a=e.clientY;this.pressTimer=setTimeout(function(){this.grab(t,a)}.bind(this),200)},touchmove:function(n){if(!this.released){var e=n.touches[0],t=e.clientX,a=e.clientY;this.move(t,a)}},touchend:function(n){(function(n){n.targetTouches.length})(n)||(clearTimeout(this.pressTimer),this.released?this.close():this.release())},clickOverlay:function(){this.close()},resizeWindow:function(){this.close()}};function al(n){return 0===n.button}function rl(n){return n.metaKey||n.ctrlKey}var il={init:function(n){this.el=document.createElement("div"),this.instance=n,this.parent=document.body,Xs(this.el,{position:"fixed",top:0,left:0,right:0,bottom:0,opacity:0}),this.updateStyle(n.options),Ws(this.el,"click",n.handler.clickOverlay.bind(n))},updateStyle:function(n){Xs(this.el,{zIndex:n.zIndex,backgroundColor:n.bgColor,transition:"opacity\n        "+n.transitionDuration+"s\n        "+n.transitionTimingFunction})},insert:function(){this.parent.appendChild(this.el)},remove:function(){this.parent.removeChild(this.el)},fadeIn:function(){this.el.offsetWidth,this.el.style.opacity=this.instance.options.bgOpacity},fadeOut:function(){this.el.style.opacity=0}},ol="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},sl=function(){function n(n,e){for(var t=0;t<e.length;t++){var a=e[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(n,a.key,a)}}return function(e,t,a){return t&&n(e.prototype,t),a&&n(e,a),e}}(),ll=Object.assign||function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(n[a]=t[a])}return n},cl={init:function(n,e){this.el=n,this.instance=e,this.srcThumbnail=this.el.getAttribute("src"),this.srcset=this.el.getAttribute("srcset"),this.srcOriginal=Gs(this.el),this.rect=this.el.getBoundingClientRect(),this.translate=null,this.scale=null,this.styleOpen=null,this.styleClose=null},zoomIn:function(){var n=this.instance.options,e=n.zIndex,t=n.enableGrab,a=n.transitionDuration,r=n.transitionTimingFunction;this.translate=this.calculateTranslate(),this.scale=this.calculateScale(),this.styleOpen={position:"relative",zIndex:e+1,cursor:t?Hs:Ns,transition:Zs+"\n        "+a+"s\n        "+r,transform:"translate3d("+this.translate.x+"px, "+this.translate.y+"px, 0px)\n        scale("+this.scale.x+","+this.scale.y+")",height:this.rect.height+"px",width:this.rect.width+"px"},this.el.offsetWidth,this.styleClose=Xs(this.el,this.styleOpen,!0)},zoomOut:function(){this.el.offsetWidth,Xs(this.el,{transform:"none"})},grab:function(n,e,t){var a=pl(),r=a.x-n,i=a.y-e;Xs(this.el,{cursor:$s,transform:"translate3d(\n        "+(this.translate.x+r)+"px, "+(this.translate.y+i)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},move:function(n,e,t){var a=pl(),r=a.x-n,i=a.y-e;Xs(this.el,{transition:Zs,transform:"translate3d(\n        "+(this.translate.x+r)+"px, "+(this.translate.y+i)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},restoreCloseStyle:function(){Xs(this.el,this.styleClose)},restoreOpenStyle:function(){Xs(this.el,this.styleOpen)},upgradeSource:function(){if(this.srcOriginal){var n=this.el.parentNode;this.srcset&&this.el.removeAttribute("srcset");var e=this.el.cloneNode(!1);e.setAttribute("src",this.srcOriginal),e.style.position="fixed",e.style.visibility="hidden",n.appendChild(e),setTimeout(function(){this.el.setAttribute("src",this.srcOriginal),n.removeChild(e)}.bind(this),50)}},downgradeSource:function(){this.srcOriginal&&(this.srcset&&this.el.setAttribute("srcset",this.srcset),this.el.setAttribute("src",this.srcThumbnail))},calculateTranslate:function(){var n=pl(),e=this.rect.left+this.rect.width/2,t=this.rect.top+this.rect.height/2;return{x:n.x-e,y:n.y-t}},calculateScale:function(){var n=this.el.dataset,e=n.zoomingHeight,t=n.zoomingWidth,a=this.instance.options,r=a.customSize,i=a.scaleBase;if(!r&&e&&t)return{x:t/this.rect.width,y:e/this.rect.height};if(r&&"object"===(void 0===r?"undefined":ol(r)))return{x:r.width/this.rect.width,y:r.height/this.rect.height};var o=this.rect.width/2,s=this.rect.height/2,l=pl(),c={x:l.x-o,y:l.y-s},p=c.x/o,d=c.y/s,u=i+Math.min(p,d);if(r&&"string"==typeof r){var m=t||this.el.naturalWidth,g=e||this.el.naturalHeight,h=parseFloat(r)*m/(100*this.rect.width),v=parseFloat(r)*g/(100*this.rect.height);if(u>h||u>v)return{x:h,y:v}}return{x:u,y:u}}};function pl(){var n=document.documentElement;return{x:Math.min(n.clientWidth,window.innerWidth)/2,y:Math.min(n.clientHeight,window.innerHeight)/2}}function dl(n,e,t){["mousedown","mousemove","mouseup","touchstart","touchmove","touchend"].forEach((function(a){Ws(n,a,e[a],t)}))}var ul=function(){function n(e){!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,n),this.target=Object.create(cl),this.overlay=Object.create(il),this.handler=Object.create(tl),this.body=document.body,this.shown=!1,this.lock=!1,this.released=!0,this.lastScrollPosition=null,this.pressTimer=null,this.options=ll({},el,e),this.overlay.init(this),this.handler.init(this)}return sl(n,[{key:"listen",value:function(n){if("string"==typeof n)for(var e=document.querySelectorAll(n),t=e.length;t--;)this.listen(e[t]);else"IMG"===n.tagName&&(n.style.cursor=Us,Ws(n,"click",this.handler.click),this.options.preloadImage&&Vs(Gs(n)));return this}},{key:"config",value:function(n){return n?(ll(this.options,n),this.overlay.updateStyle(this.options),this):this.options}},{key:"open",value:function(n){var e=this,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.options.onOpen;if(!this.shown&&!this.lock){var a="string"==typeof n?document.querySelector(n):n;if("IMG"===a.tagName){if(this.options.onBeforeOpen(a),this.target.init(a,this),!this.options.preloadImage){var r=this.target.srcOriginal;null!=r&&(this.options.onImageLoading(a),Vs(r,this.options.onImageLoaded))}this.shown=!0,this.lock=!0,this.target.zoomIn(),this.overlay.insert(),this.overlay.fadeIn(),Ws(document,"scroll",this.handler.scroll),Ws(document,"keydown",this.handler.keydown),this.options.closeOnWindowResize&&Ws(window,"resize",this.handler.resizeWindow);var i=function n(){Ws(a,Ys,n,!1),e.lock=!1,e.target.upgradeSource(),e.options.enableGrab&&dl(document,e.handler,!0),t(a)};return Ws(a,Ys,i),this}}}},{key:"close",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onClose;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeClose(t),this.lock=!0,this.body.style.cursor=Fs,this.overlay.fadeOut(),this.target.zoomOut(),Ws(document,"scroll",this.handler.scroll,!1),Ws(document,"keydown",this.handler.keydown,!1),this.options.closeOnWindowResize&&Ws(window,"resize",this.handler.resizeWindow,!1);var a=function a(){Ws(t,Ys,a,!1),n.shown=!1,n.lock=!1,n.target.downgradeSource(),n.options.enableGrab&&dl(document,n.handler,!1),n.target.restoreCloseStyle(),n.overlay.remove(),e(t)};return Ws(t,Ys,a),this}}},{key:"grab",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onGrab;if(this.shown&&!this.lock){var r=this.target.el;this.options.onBeforeGrab(r),this.released=!1,this.target.grab(n,e,t);var i=function n(){Ws(r,Ys,n,!1),a(r)};return Ws(r,Ys,i),this}}},{key:"move",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onMove;if(this.shown&&!this.lock){this.released=!1,this.body.style.cursor=$s,this.target.move(n,e,t);var r=this.target.el,i=function n(){Ws(r,Ys,n,!1),a(r)};return Ws(r,Ys,i),this}}},{key:"release",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onRelease;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeRelease(t),this.lock=!0,this.body.style.cursor=Fs,this.target.restoreOpenStyle();var a=function a(){Ws(t,Ys,a,!1),n.lock=!1,n.released=!0,e(t)};return Ws(t,Ys,a),this}}}]),n}();const ml=JSON.parse('{"bgColor":"rgba(0,0,0,0.6)"}'),gl=Number("500");class hl{constructor(){this.instance=new ul(ml)}update(n=".theme-vdoing-content img:not(.no-zoom)"){"undefined"!=typeof window&&this.instance.listen(n)}updateDelay(n=".theme-vdoing-content img:not(.no-zoom)",e=gl){setTimeout(()=>this.update(n),e)}}var vl=[bs,js,Is,Es,qs,{watch:{"$page.path"(){void 0!==this.$vuepress.zooming&&this.$vuepress.zooming.updateDelay()}},mounted(){this.$vuepress.zooming=new hl,this.$vuepress.zooming.updateDelay()}}],bl={name:"GlobalLayout",computed:{layout(){const n=this.getLayout();return us("layout",n),Vt.component(n)}},methods:{getLayout(){if(this.$page.path){const n=this.$page.frontmatter.layout;return n&&(this.$vuepress.getLayoutAsyncComponent(n)||this.$vuepress.getVueComponent(n))?n:"Layout"}return"NotFound"}}},fl=t(14),yl=Object(fl.a)(bl,(function(){return(0,this._self._c)(this.layout,{tag:"component"})}),[],!1,null,null,null).exports;!function(n,e,t){switch(e){case"components":n[e]||(n[e]={}),Object.assign(n[e],t);break;case"mixins":n[e]||(n[e]=[]),n[e].push(...t);break;default:throw new Error("Unknown option name.")}}(yl,"mixins",vl);const xl=[{name:"v-8c24c1c0",path:"/pages/e98894/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-8c24c1c0").then(t)}},{path:"/pages/e98894/index.html",redirect:"/pages/e98894/"},{path:"/01.Java/02.JavaEE/01.JavaWeb/01.JavaWeb之Servlet指南.html",redirect:"/pages/e98894/"},{name:"v-bd7f8880",path:"/pages/8cc787/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-bd7f8880").then(t)}},{path:"/pages/8cc787/index.html",redirect:"/pages/8cc787/"},{path:"/01.Java/02.JavaEE/01.JavaWeb/02.JavaWeb之Jsp指南.html",redirect:"/pages/8cc787/"},{name:"v-1897f31c",path:"/pages/82df5f/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-1897f31c").then(t)}},{path:"/pages/82df5f/index.html",redirect:"/pages/82df5f/"},{path:"/01.Java/02.JavaEE/01.JavaWeb/03.JavaWeb之Filter和Listener.html",redirect:"/pages/82df5f/"},{name:"v-36554d68",path:"/pages/c46bff/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-36554d68").then(t)}},{path:"/pages/c46bff/index.html",redirect:"/pages/c46bff/"},{path:"/01.Java/02.JavaEE/01.JavaWeb/04.JavaWeb之Cookie和Session.html",redirect:"/pages/c46bff/"},{name:"v-84fd370c",path:"/pages/50f49f/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-84fd370c").then(t)}},{path:"/pages/50f49f/index.html",redirect:"/pages/50f49f/"},{path:"/01.Java/02.JavaEE/01.JavaWeb/",redirect:"/pages/50f49f/"},{name:"v-6ec25090",path:"/pages/e175ce/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-6ec25090").then(t)}},{path:"/pages/e175ce/index.html",redirect:"/pages/e175ce/"},{path:"/01.Java/02.JavaEE/01.JavaWeb/99.JavaWeb面经.html",redirect:"/pages/e175ce/"},{name:"v-197081d4",path:"/pages/4a4c02/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-197081d4").then(t)}},{path:"/pages/4a4c02/index.html",redirect:"/pages/4a4c02/"},{path:"/01.Java/02.JavaEE/02.服务器/01.Tomcat/01.Tomcat快速入门.html",redirect:"/pages/4a4c02/"},{name:"v-f182b6d2",path:"/pages/13f070/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-f182b6d2").then(t)}},{path:"/pages/13f070/index.html",redirect:"/pages/13f070/"},{path:"/01.Java/02.JavaEE/02.服务器/01.Tomcat/02.Tomcat连接器.html",redirect:"/pages/13f070/"},{name:"v-372bea40",path:"/pages/d5076a/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-372bea40").then(t)}},{path:"/pages/d5076a/index.html",redirect:"/pages/d5076a/"},{path:"/01.Java/02.JavaEE/02.服务器/01.Tomcat/03.Tomcat容器.html",redirect:"/pages/d5076a/"},{name:"v-63c3bd02",path:"/pages/f9e1e6/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-63c3bd02").then(t)}},{path:"/pages/f9e1e6/index.html",redirect:"/pages/f9e1e6/"},{path:"/01.Java/02.JavaEE/02.服务器/01.Tomcat/04.Tomcat优化.html",redirect:"/pages/f9e1e6/"},{name:"v-14be4fe4",path:"/pages/f37326/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-14be4fe4").then(t)}},{path:"/pages/f37326/index.html",redirect:"/pages/f37326/"},{path:"/01.Java/02.JavaEE/02.服务器/01.Tomcat/05.Tomcat和Jetty.html",redirect:"/pages/f37326/"},{name:"v-2e4483c6",path:"/pages/33e817/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-2e4483c6").then(t)}},{path:"/pages/33e817/index.html",redirect:"/pages/33e817/"},{path:"/01.Java/02.JavaEE/02.服务器/01.Tomcat/",redirect:"/pages/33e817/"},{name:"v-48965ab6",path:"/pages/ec364e/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-48965ab6").then(t)}},{path:"/pages/ec364e/index.html",redirect:"/pages/ec364e/"},{path:"/01.Java/02.JavaEE/02.服务器/02.Jetty.html",redirect:"/pages/ec364e/"},{name:"v-2a45c84c",path:"/pages/80a822/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-2a45c84c").then(t)}},{path:"/pages/80a822/index.html",redirect:"/pages/80a822/"},{path:"/01.Java/02.JavaEE/",redirect:"/pages/80a822/"},{name:"v-60c4af86",path:"/pages/e3f3f3/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-60c4af86").then(t)}},{path:"/pages/e3f3f3/index.html",redirect:"/pages/e3f3f3/"},{path:"/01.Java/02.JavaEE/02.服务器/",redirect:"/pages/e3f3f3/"},{name:"v-c8c7b0bc",path:"/pages/d893c2/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-c8c7b0bc").then(t)}},{path:"/pages/d893c2/index.html",redirect:"/pages/d893c2/"},{path:"/01.Java/11.软件/01.构建/01.Maven/02.Maven教程之pom.xml详解.html",redirect:"/pages/d893c2/"},{name:"v-7a43a3c8",path:"/pages/e5b79f/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-7a43a3c8").then(t)}},{path:"/pages/e5b79f/index.html",redirect:"/pages/e5b79f/"},{path:"/01.Java/11.软件/01.构建/01.Maven/01.Maven快速入门.html",redirect:"/pages/e5b79f/"},{name:"v-9dacab80",path:"/pages/1d58f1/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-9dacab80").then(t)}},{path:"/pages/1d58f1/index.html",redirect:"/pages/1d58f1/"},{path:"/01.Java/11.软件/01.构建/01.Maven/03.Maven教程之settings.xml详解.html",redirect:"/pages/1d58f1/"},{name:"v-35a64902",path:"/pages/198618/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-35a64902").then(t)}},{path:"/pages/198618/index.html",redirect:"/pages/198618/"},{path:"/01.Java/11.软件/01.构建/01.Maven/04.Maven实战问题和最佳实践.html",redirect:"/pages/198618/"},{name:"v-030a633c",path:"/pages/7bdaf9/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-030a633c").then(t)}},{path:"/pages/7bdaf9/index.html",redirect:"/pages/7bdaf9/"},{path:"/01.Java/11.软件/01.构建/01.Maven/05.Maven教程之发布jar到私服或中央仓库.html",redirect:"/pages/7bdaf9/"},{name:"v-ecc5245e",path:"/pages/370f1d/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-ecc5245e").then(t)}},{path:"/pages/370f1d/index.html",redirect:"/pages/370f1d/"},{path:"/01.Java/11.软件/01.构建/01.Maven/06.Maven插件之代码检查.html",redirect:"/pages/370f1d/"},{name:"v-160dee90",path:"/pages/85f27a/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-160dee90").then(t)}},{path:"/pages/85f27a/index.html",redirect:"/pages/85f27a/"},{path:"/01.Java/11.软件/01.构建/01.Maven/",redirect:"/pages/85f27a/"},{name:"v-92d5b0d0",path:"/pages/d1859b/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-92d5b0d0").then(t)}},{path:"/pages/d1859b/index.html",redirect:"/pages/d1859b/"},{path:"/01.Java/11.软件/01.构建/",redirect:"/pages/d1859b/"},{name:"v-7212740e",path:"/pages/0bafae/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-7212740e").then(t)}},{path:"/pages/0bafae/index.html",redirect:"/pages/0bafae/"},{path:"/01.Java/11.软件/01.构建/02.Ant.html",redirect:"/pages/0bafae/"},{name:"v-5a249b69",path:"/pages/ac5c6a/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-5a249b69").then(t)}},{path:"/pages/ac5c6a/index.html",redirect:"/pages/ac5c6a/"},{path:"/01.Java/11.软件/02.IDE/01.Intellij.html",redirect:"/pages/ac5c6a/"},{name:"v-a4ec7cea",path:"/pages/2257c7/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-a4ec7cea").then(t)}},{path:"/pages/2257c7/index.html",redirect:"/pages/2257c7/"},{path:"/01.Java/11.软件/02.IDE/02.Eclipse.html",redirect:"/pages/2257c7/"},{name:"v-51b6d2f2",path:"/pages/0f7153/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-51b6d2f2").then(t)}},{path:"/pages/0f7153/index.html",redirect:"/pages/0f7153/"},{path:"/01.Java/11.软件/02.IDE/03.VsCode.html",redirect:"/pages/0f7153/"},{name:"v-12f6b900",path:"/pages/8695a7/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-12f6b900").then(t)}},{path:"/pages/8695a7/index.html",redirect:"/pages/8695a7/"},{path:"/01.Java/11.软件/02.IDE/",redirect:"/pages/8695a7/"},{name:"v-596e4bb7",path:"/pages/16563a/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-596e4bb7").then(t)}},{path:"/pages/16563a/index.html",redirect:"/pages/16563a/"},{path:"/01.Java/11.软件/03.监控诊断/01.监控工具对比.html",redirect:"/pages/16563a/"},{name:"v-5fd2a085",path:"/pages/821ca3/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-5fd2a085").then(t)}},{path:"/pages/821ca3/index.html",redirect:"/pages/821ca3/"},{path:"/01.Java/11.软件/03.监控诊断/02.CAT.html",redirect:"/pages/821ca3/"},{name:"v-5638950b",path:"/pages/0a8826/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-5638950b").then(t)}},{path:"/pages/0a8826/index.html",redirect:"/pages/0a8826/"},{path:"/01.Java/11.软件/03.监控诊断/03.Zipkin.html",redirect:"/pages/0a8826/"},{name:"v-52bbe8ea",path:"/pages/df7dec/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-52bbe8ea").then(t)}},{path:"/pages/df7dec/index.html",redirect:"/pages/df7dec/"},{path:"/01.Java/11.软件/03.监控诊断/04.Skywalking.html",redirect:"/pages/df7dec/"},{name:"v-877bb26a",path:"/pages/c689d1/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-877bb26a").then(t)}},{path:"/pages/c689d1/index.html",redirect:"/pages/c689d1/"},{path:"/01.Java/11.软件/03.监控诊断/05.Arthas.html",redirect:"/pages/c689d1/"},{name:"v-aa513a90",path:"/pages/2cb045/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-aa513a90").then(t)}},{path:"/pages/2cb045/index.html",redirect:"/pages/2cb045/"},{path:"/01.Java/11.软件/",redirect:"/pages/2cb045/"},{name:"v-18d04790",path:"/pages/4622a6/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-18d04790").then(t)}},{path:"/pages/4622a6/index.html",redirect:"/pages/4622a6/"},{path:"/01.Java/12.工具/01.IO/01.JSON序列化.html",redirect:"/pages/4622a6/"},{name:"v-1fa4716e",path:"/pages/3d16d3/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-1fa4716e").then(t)}},{path:"/pages/3d16d3/index.html",redirect:"/pages/3d16d3/"},{path:"/01.Java/11.软件/03.监控诊断/",redirect:"/pages/3d16d3/"},{name:"v-4e5dcd45",path:"/pages/08d872/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-4e5dcd45").then(t)}},{path:"/pages/08d872/index.html",redirect:"/pages/08d872/"},{path:"/01.Java/12.工具/01.IO/02.二进制序列化.html",redirect:"/pages/08d872/"},{name:"v-1fa328ca",path:"/pages/08b504/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-1fa328ca").then(t)}},{path:"/pages/08b504/index.html",redirect:"/pages/08b504/"},{path:"/01.Java/12.工具/01.IO/",redirect:"/pages/08b504/"},{name:"v-6cd70b6c",path:"/pages/eb1d46/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-6cd70b6c").then(t)}},{path:"/pages/eb1d46/index.html",redirect:"/pages/eb1d46/"},{path:"/01.Java/12.工具/02.JavaBean/01.Lombok.html",redirect:"/pages/eb1d46/"},{name:"v-a648697c",path:"/pages/45e21b/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-a648697c").then(t)}},{path:"/pages/45e21b/index.html",redirect:"/pages/45e21b/"},{path:"/01.Java/12.工具/02.JavaBean/02.Dozer.html",redirect:"/pages/45e21b/"},{name:"v-b1567070",path:"/pages/a60ccf/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-b1567070").then(t)}},{path:"/pages/a60ccf/index.html",redirect:"/pages/a60ccf/"},{path:"/01.Java/12.工具/03.模板引擎/01.Freemark.html",redirect:"/pages/a60ccf/"},{name:"v-d73a1b24",path:"/pages/e7d2ad/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-d73a1b24").then(t)}},{path:"/pages/e7d2ad/index.html",redirect:"/pages/e7d2ad/"},{path:"/01.Java/12.工具/03.模板引擎/02.Thymeleaf.html",redirect:"/pages/e7d2ad/"},{name:"v-f62f42f0",path:"/pages/3ba0ff/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-f62f42f0").then(t)}},{path:"/pages/3ba0ff/index.html",redirect:"/pages/3ba0ff/"},{path:"/01.Java/12.工具/03.模板引擎/03.Velocity.html",redirect:"/pages/3ba0ff/"},{name:"v-19120fca",path:"/pages/9d37fa/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-19120fca").then(t)}},{path:"/pages/9d37fa/index.html",redirect:"/pages/9d37fa/"},{path:"/01.Java/12.工具/03.模板引擎/",redirect:"/pages/9d37fa/"},{name:"v-5cda01e4",path:"/pages/b39f47/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-5cda01e4").then(t)}},{path:"/pages/b39f47/index.html",redirect:"/pages/b39f47/"},{path:"/01.Java/12.工具/04.测试/01.Junit.html",redirect:"/pages/b39f47/"},{name:"v-98b41d6c",path:"/pages/f2c6f5/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-98b41d6c").then(t)}},{path:"/pages/f2c6f5/index.html",redirect:"/pages/f2c6f5/"},{path:"/01.Java/12.工具/04.测试/02.Mockito.html",redirect:"/pages/f2c6f5/"},{name:"v-1d1948c1",path:"/pages/2cecc3/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-1d1948c1").then(t)}},{path:"/pages/2cecc3/index.html",redirect:"/pages/2cecc3/"},{path:"/01.Java/12.工具/04.测试/",redirect:"/pages/2cecc3/"},{name:"v-7cf35edc",path:"/pages/0e5ab1/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-7cf35edc").then(t)}},{path:"/pages/0e5ab1/index.html",redirect:"/pages/0e5ab1/"},{path:"/01.Java/12.工具/04.测试/03.Jmeter.html",redirect:"/pages/0e5ab1/"},{name:"v-fefff020",path:"/pages/9c6402/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-fefff020").then(t)}},{path:"/pages/9c6402/index.html",redirect:"/pages/9c6402/"},{path:"/01.Java/12.工具/04.测试/04.JMH.html",redirect:"/pages/9c6402/"},{name:"v-e3a97658",path:"/pages/fcc1c4/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-e3a97658").then(t)}},{path:"/pages/fcc1c4/index.html",redirect:"/pages/fcc1c4/"},{path:"/01.Java/12.工具/99.其他/01.Java日志.html",redirect:"/pages/fcc1c4/"},{name:"v-377147a2",path:"/pages/27ad42/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-377147a2").then(t)}},{path:"/pages/27ad42/index.html",redirect:"/pages/27ad42/"},{path:"/01.Java/12.工具/99.其他/02.Java工具包.html",redirect:"/pages/27ad42/"},{name:"v-38be25ad",path:"/pages/ce6195/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-38be25ad").then(t)}},{path:"/pages/ce6195/index.html",redirect:"/pages/ce6195/"},{path:"/01.Java/12.工具/99.其他/03.Reflections.html",redirect:"/pages/ce6195/"},{name:"v-16dd06c5",path:"/pages/cd38ec/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-16dd06c5").then(t)}},{path:"/pages/cd38ec/index.html",redirect:"/pages/cd38ec/"},{path:"/01.Java/12.工具/99.其他/04.JavaMail.html",redirect:"/pages/cd38ec/"},{name:"v-4feafdf7",path:"/pages/5dd78d/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-4feafdf7").then(t)}},{path:"/pages/5dd78d/index.html",redirect:"/pages/5dd78d/"},{path:"/01.Java/12.工具/99.其他/05.Jsoup.html",redirect:"/pages/5dd78d/"},{name:"v-1b7ae99a",path:"/pages/adacc5/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-1b7ae99a").then(t)}},{path:"/pages/adacc5/index.html",redirect:"/pages/adacc5/"},{path:"/01.Java/12.工具/99.其他/06.Thumbnailator.html",redirect:"/pages/adacc5/"},{name:"v-78a970ba",path:"/pages/1123e1/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-78a970ba").then(t)}},{path:"/pages/1123e1/index.html",redirect:"/pages/1123e1/"},{path:"/01.Java/12.工具/",redirect:"/pages/1123e1/"},{name:"v-62f1222d",path:"/pages/b563af/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-62f1222d").then(t)}},{path:"/pages/b563af/index.html",redirect:"/pages/b563af/"},{path:"/01.Java/12.工具/99.其他/07.Zxing.html",redirect:"/pages/b563af/"},{name:"v-7d53b0b4",path:"/pages/9d3091/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-7d53b0b4").then(t)}},{path:"/pages/9d3091/index.html",redirect:"/pages/9d3091/"},{path:"/01.Java/13.框架/01.Spring/00.Spring综合/01.Spring概述.html",redirect:"/pages/9d3091/"},{name:"v-aebe0138",path:"/pages/430f53/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-aebe0138").then(t)}},{path:"/pages/430f53/index.html",redirect:"/pages/430f53/"},{path:"/01.Java/13.框架/01.Spring/00.Spring综合/21.SpringBoot知识图谱.html",redirect:"/pages/430f53/"},{name:"v-59088176",path:"/pages/dbf521/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-59088176").then(t)}},{path:"/pages/dbf521/index.html",redirect:"/pages/dbf521/"},{path:"/01.Java/13.框架/01.Spring/00.Spring综合/22.SpringBoot基本原理.html",redirect:"/pages/dbf521/"},{name:"v-372d1374",path:"/pages/9e0b67/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-372d1374").then(t)}},{path:"/pages/9e0b67/index.html",redirect:"/pages/9e0b67/"},{path:"/01.Java/13.框架/01.Spring/00.Spring综合/",redirect:"/pages/9e0b67/"},{name:"v-4e3a5110",path:"/pages/db33b0/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-4e3a5110").then(t)}},{path:"/pages/db33b0/index.html",redirect:"/pages/db33b0/"},{path:"/01.Java/13.框架/01.Spring/00.Spring综合/99.Spring面试.html",redirect:"/pages/db33b0/"},{name:"v-617edf3a",path:"/pages/68097d/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-617edf3a").then(t)}},{path:"/pages/68097d/index.html",redirect:"/pages/68097d/"},{path:"/01.Java/13.框架/01.Spring/01.Spring核心/01.SpringBean.html",redirect:"/pages/68097d/"},{name:"v-2a4dda94",path:"/pages/9a6f6b/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-2a4dda94").then(t)}},{path:"/pages/9a6f6b/index.html",redirect:"/pages/9a6f6b/"},{path:"/01.Java/13.框架/01.Spring/01.Spring核心/03.Spring依赖查找.html",redirect:"/pages/9a6f6b/"},{name:"v-55cc8b3f",path:"/pages/915530/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-55cc8b3f").then(t)}},{path:"/pages/915530/index.html",redirect:"/pages/915530/"},{path:"/01.Java/13.框架/01.Spring/01.Spring核心/02.SpringIoC.html",redirect:"/pages/915530/"},{name:"v-5ff32bba",path:"/pages/f61a1c/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-5ff32bba").then(t)}},{path:"/pages/f61a1c/index.html",redirect:"/pages/f61a1c/"},{path:"/01.Java/13.框架/01.Spring/01.Spring核心/04.Spring依赖注入.html",redirect:"/pages/f61a1c/"},{name:"v-4643e240",path:"/pages/a5f257/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-4643e240").then(t)}},{path:"/pages/a5f257/index.html",redirect:"/pages/a5f257/"},{path:"/01.Java/13.框架/01.Spring/01.Spring核心/05.SpringIoC依赖来源.html",redirect:"/pages/a5f257/"},{name:"v-6b2eab00",path:"/pages/8289f5/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-6b2eab00").then(t)}},{path:"/pages/8289f5/index.html",redirect:"/pages/8289f5/"},{path:"/01.Java/13.框架/01.Spring/01.Spring核心/06.SpringBean作用域.html",redirect:"/pages/8289f5/"},{name:"v-1243db1d",path:"/pages/4ab176/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-1243db1d").then(t)}},{path:"/pages/4ab176/index.html",redirect:"/pages/4ab176/"},{path:"/01.Java/13.框架/01.Spring/01.Spring核心/07.SpringBean生命周期.html",redirect:"/pages/4ab176/"},{name:"v-10b9b6b6",path:"/pages/55f315/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-10b9b6b6").then(t)}},{path:"/pages/55f315/index.html",redirect:"/pages/55f315/"},{path:"/01.Java/13.框架/01.Spring/01.Spring核心/08.Spring配置元数据.html",redirect:"/pages/55f315/"},{name:"v-3fdf0214",path:"/pages/ad472e/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-3fdf0214").then(t)}},{path:"/pages/ad472e/index.html",redirect:"/pages/ad472e/"},{path:"/01.Java/13.框架/01.Spring/01.Spring核心/09.Spring应用上下文生命周期.html",redirect:"/pages/ad472e/"},{name:"v-95b1a28a",path:"/pages/53aedb/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-95b1a28a").then(t)}},{path:"/pages/53aedb/index.html",redirect:"/pages/53aedb/"},{path:"/01.Java/13.框架/01.Spring/01.Spring核心/10.SpringAop.html",redirect:"/pages/53aedb/"},{name:"v-7bfb01a8",path:"/pages/a1549f/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-7bfb01a8").then(t)}},{path:"/pages/a1549f/index.html",redirect:"/pages/a1549f/"},{path:"/01.Java/13.框架/01.Spring/01.Spring核心/20.Spring资源管理.html",redirect:"/pages/a1549f/"},{name:"v-2969c73e",path:"/pages/fe6aad/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-2969c73e").then(t)}},{path:"/pages/fe6aad/index.html",redirect:"/pages/fe6aad/"},{path:"/01.Java/13.框架/01.Spring/01.Spring核心/21.Spring校验.html",redirect:"/pages/fe6aad/"},{name:"v-32d028da",path:"/pages/267b4c/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-32d028da").then(t)}},{path:"/pages/267b4c/index.html",redirect:"/pages/267b4c/"},{path:"/01.Java/13.框架/01.Spring/01.Spring核心/22.Spring数据绑定.html",redirect:"/pages/267b4c/"},{name:"v-16ce6423",path:"/pages/1f743f/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-16ce6423").then(t)}},{path:"/pages/1f743f/index.html",redirect:"/pages/1f743f/"},{path:"/01.Java/13.框架/01.Spring/01.Spring核心/24.SpringEL.html",redirect:"/pages/1f743f/"},{name:"v-3a6d09bb",path:"/pages/6662dc/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-3a6d09bb").then(t)}},{path:"/pages/6662dc/index.html",redirect:"/pages/6662dc/"},{path:"/01.Java/13.框架/01.Spring/01.Spring核心/23.Spring类型转换.html",redirect:"/pages/6662dc/"},{name:"v-375fe748",path:"/pages/b5b8ad/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-375fe748").then(t)}},{path:"/pages/b5b8ad/index.html",redirect:"/pages/b5b8ad/"},{path:"/01.Java/13.框架/01.Spring/01.Spring核心/26.Spring国际化.html",redirect:"/pages/b5b8ad/"},{name:"v-68aff9b6",path:"/pages/cca414/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-68aff9b6").then(t)}},{path:"/pages/cca414/index.html",redirect:"/pages/cca414/"},{path:"/01.Java/13.框架/01.Spring/01.Spring核心/25.Spring事件.html",redirect:"/pages/cca414/"},{name:"v-fe2fd7e0",path:"/pages/175cbd/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-fe2fd7e0").then(t)}},{path:"/pages/175cbd/index.html",redirect:"/pages/175cbd/"},{path:"/01.Java/13.框架/01.Spring/01.Spring核心/27.Spring泛型处理.html",redirect:"/pages/175cbd/"},{name:"v-11d62c46",path:"/pages/b6556f/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-11d62c46").then(t)}},{path:"/pages/b6556f/index.html",redirect:"/pages/b6556f/"},{path:"/01.Java/13.框架/01.Spring/01.Spring核心/28.Spring注解.html",redirect:"/pages/b6556f/"},{name:"v-121f4bfb",path:"/pages/03d838/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-121f4bfb").then(t)}},{path:"/pages/03d838/index.html",redirect:"/pages/03d838/"},{path:"/01.Java/13.框架/01.Spring/01.Spring核心/29.SpringEnvironment抽象.html",redirect:"/pages/03d838/"},{name:"v-e0b3a04c",path:"/pages/950e4d/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-e0b3a04c").then(t)}},{path:"/pages/950e4d/index.html",redirect:"/pages/950e4d/"},{path:"/01.Java/13.框架/01.Spring/01.Spring核心/31.SpringBoot之快速入门.html",redirect:"/pages/950e4d/"},{name:"v-50b7250c",path:"/pages/0fb992/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-50b7250c").then(t)}},{path:"/pages/0fb992/index.html",redirect:"/pages/0fb992/"},{path:"/01.Java/13.框架/01.Spring/01.Spring核心/32.SpringBoot之属性加载.html",redirect:"/pages/0fb992/"},{name:"v-10fbaa3f",path:"/pages/cb598e/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-10fbaa3f").then(t)}},{path:"/pages/cb598e/index.html",redirect:"/pages/cb598e/"},{path:"/01.Java/13.框架/01.Spring/01.Spring核心/33.SpringBoot之Profile.html",redirect:"/pages/cb598e/"},{name:"v-7144da80",path:"/pages/5e7c20/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-7144da80").then(t)}},{path:"/pages/5e7c20/index.html",redirect:"/pages/5e7c20/"},{path:"/01.Java/13.框架/01.Spring/01.Spring核心/",redirect:"/pages/5e7c20/"},{name:"v-6feaabf6",path:"/pages/1b774c/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-6feaabf6").then(t)}},{path:"/pages/1b774c/index.html",redirect:"/pages/1b774c/"},{path:"/01.Java/13.框架/01.Spring/02.Spring数据/01.Spring之数据源.html",redirect:"/pages/1b774c/"},{name:"v-21c80e99",path:"/pages/cf19fd/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-21c80e99").then(t)}},{path:"/pages/cf19fd/index.html",redirect:"/pages/cf19fd/"},{path:"/01.Java/13.框架/01.Spring/02.Spring数据/02.Spring之JDBC.html",redirect:"/pages/cf19fd/"},{name:"v-69fe3d9a",path:"/pages/128c54/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-69fe3d9a").then(t)}},{path:"/pages/128c54/index.html",redirect:"/pages/128c54/"},{path:"/01.Java/13.框架/01.Spring/02.Spring数据/03.Spring之事务.html",redirect:"/pages/128c54/"},{name:"v-3b4bf83b",path:"/pages/a03d7b/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-3b4bf83b").then(t)}},{path:"/pages/a03d7b/index.html",redirect:"/pages/a03d7b/"},{path:"/01.Java/13.框架/01.Spring/02.Spring数据/04.Spring之JPA.html",redirect:"/pages/a03d7b/"},{name:"v-299bf82c",path:"/pages/88219e/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-299bf82c").then(t)}},{path:"/pages/88219e/index.html",redirect:"/pages/88219e/"},{path:"/01.Java/13.框架/01.Spring/02.Spring数据/10.Spring集成Mybatis.html",redirect:"/pages/88219e/"},{name:"v-c837cd76",path:"/pages/191cdb/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-c837cd76").then(t)}},{path:"/pages/191cdb/index.html",redirect:"/pages/191cdb/"},{path:"/01.Java/13.框架/01.Spring/02.Spring数据/20.SpringData综合.html",redirect:"/pages/191cdb/"},{name:"v-029db6b7",path:"/pages/db2a41/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-029db6b7").then(t)}},{path:"/pages/db2a41/index.html",redirect:"/pages/db2a41/"},{path:"/01.Java/13.框架/01.Spring/02.Spring数据/22.Spring访问MongoDB.html",redirect:"/pages/db2a41/"},{name:"v-1b892327",path:"/pages/65e4a2/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-1b892327").then(t)}},{path:"/pages/65e4a2/index.html",redirect:"/pages/65e4a2/"},{path:"/01.Java/13.框架/01.Spring/02.Spring数据/21.Spring访问Redis.html",redirect:"/pages/65e4a2/"},{name:"v-577422c2",path:"/pages/fac14c/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-577422c2").then(t)}},{path:"/pages/fac14c/index.html",redirect:"/pages/fac14c/"},{path:"/01.Java/13.框架/01.Spring/02.Spring数据/23.Spring访问Elasticsearch.html",redirect:"/pages/fac14c/"},{name:"v-033238fd",path:"/pages/65351b/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-033238fd").then(t)}},{path:"/pages/65351b/index.html",redirect:"/pages/65351b/"},{path:"/01.Java/13.框架/01.Spring/03.SpringWeb/01.SpringWebMvc.html",redirect:"/pages/65351b/"},{name:"v-b0144bd0",path:"/pages/b912d1/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-b0144bd0").then(t)}},{path:"/pages/b912d1/index.html",redirect:"/pages/b912d1/"},{path:"/01.Java/13.框架/01.Spring/02.Spring数据/",redirect:"/pages/b912d1/"},{name:"v-27fc8106",path:"/pages/ad0516/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-27fc8106").then(t)}},{path:"/pages/ad0516/index.html",redirect:"/pages/ad0516/"},{path:"/01.Java/13.框架/01.Spring/03.SpringWeb/21.SpringBoot之应用EasyUI.html",redirect:"/pages/ad0516/"},{name:"v-e92f7bb8",path:"/pages/e2586a/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-e92f7bb8").then(t)}},{path:"/pages/e2586a/index.html",redirect:"/pages/e2586a/"},{path:"/01.Java/13.框架/01.Spring/03.SpringWeb/",redirect:"/pages/e2586a/"},{name:"v-aa040a8e",path:"/pages/92add2/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-aa040a8e").then(t)}},{path:"/pages/92add2/index.html",redirect:"/pages/92add2/"},{path:"/01.Java/13.框架/01.Spring/04.SpringIO/01.SpringBoot之异步请求.html",redirect:"/pages/92add2/"},{name:"v-52097332",path:"/pages/676725/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-52097332").then(t)}},{path:"/pages/676725/index.html",redirect:"/pages/676725/"},{path:"/01.Java/13.框架/01.Spring/04.SpringIO/02.SpringBoot之Json.html",redirect:"/pages/676725/"},{name:"v-5c0a26b0",path:"/pages/2586f1/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-5c0a26b0").then(t)}},{path:"/pages/2586f1/index.html",redirect:"/pages/2586f1/"},{path:"/01.Java/13.框架/01.Spring/04.SpringIO/03.SpringBoot之邮件.html",redirect:"/pages/2586f1/"},{name:"v-69fdd354",path:"/pages/56581b/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-69fdd354").then(t)}},{path:"/pages/56581b/index.html",redirect:"/pages/56581b/"},{path:"/01.Java/13.框架/01.Spring/04.SpringIO/",redirect:"/pages/56581b/"},{name:"v-5a2a2041",path:"/pages/a311cb/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-5a2a2041").then(t)}},{path:"/pages/a311cb/index.html",redirect:"/pages/a311cb/"},{path:"/01.Java/13.框架/01.Spring/05.Spring集成/01.Spring集成缓存.html",redirect:"/pages/a311cb/"},{name:"v-23820ebe",path:"/pages/a187f0/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-23820ebe").then(t)}},{path:"/pages/a187f0/index.html",redirect:"/pages/a187f0/"},{path:"/01.Java/13.框架/01.Spring/05.Spring集成/02.Spring集成调度器.html",redirect:"/pages/a187f0/"},{name:"v-e127b82a",path:"/pages/274fd7/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-e127b82a").then(t)}},{path:"/pages/274fd7/index.html",redirect:"/pages/274fd7/"},{path:"/01.Java/13.框架/01.Spring/05.Spring集成/03.Spring集成Dubbo.html",redirect:"/pages/274fd7/"},{name:"v-4f10fdce",path:"/pages/d6025b/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-4f10fdce").then(t)}},{path:"/pages/d6025b/index.html",redirect:"/pages/d6025b/"},{path:"/01.Java/13.框架/01.Spring/05.Spring集成/",redirect:"/pages/d6025b/"},{name:"v-ca8d6204",path:"/pages/568352/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-ca8d6204").then(t)}},{path:"/pages/568352/index.html",redirect:"/pages/568352/"},{path:"/01.Java/13.框架/01.Spring/10.Spring安全/01.SpringBoot之安全快速入门.html",redirect:"/pages/568352/"},{name:"v-f62f294c",path:"/pages/752c6a/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-f62f294c").then(t)}},{path:"/pages/752c6a/index.html",redirect:"/pages/752c6a/"},{path:"/01.Java/13.框架/01.Spring/99.Spring其他/01.Spring4升级.html",redirect:"/pages/752c6a/"},{name:"v-25a234c6",path:"/pages/bac2ce/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-25a234c6").then(t)}},{path:"/pages/bac2ce/index.html",redirect:"/pages/bac2ce/"},{path:"/01.Java/13.框架/01.Spring/99.Spring其他/21.SpringBoot之banner.html",redirect:"/pages/bac2ce/"},{name:"v-6a3ca52c",path:"/pages/c013cc/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-6a3ca52c").then(t)}},{path:"/pages/c013cc/index.html",redirect:"/pages/c013cc/"},{path:"/01.Java/13.框架/01.Spring/99.Spring其他/22.SpringBoot之Actuator.html",redirect:"/pages/c013cc/"},{name:"v-16e36653",path:"/pages/6bb8c1/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-16e36653").then(t)}},{path:"/pages/6bb8c1/index.html",redirect:"/pages/6bb8c1/"},{path:"/01.Java/13.框架/01.Spring/99.Spring其他/",redirect:"/pages/6bb8c1/"},{name:"v-dde25f08",path:"/pages/d4e6ee/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-dde25f08").then(t)}},{path:"/pages/d4e6ee/index.html",redirect:"/pages/d4e6ee/"},{path:"/01.Java/13.框架/11.ORM/01.Mybatis快速入门.html",redirect:"/pages/d4e6ee/"},{name:"v-938fb0a0",path:"/pages/a1a3d3/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-938fb0a0").then(t)}},{path:"/pages/a1a3d3/index.html",redirect:"/pages/a1a3d3/"},{path:"/01.Java/13.框架/01.Spring/",redirect:"/pages/a1a3d3/"},{name:"v-5cf98845",path:"/pages/d55184/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-5cf98845").then(t)}},{path:"/pages/d55184/index.html",redirect:"/pages/d55184/"},{path:"/01.Java/13.框架/11.ORM/02.Mybatis原理.html",redirect:"/pages/d55184/"},{name:"v-f8df10f8",path:"/pages/fe879a/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-f8df10f8").then(t)}},{path:"/pages/fe879a/index.html",redirect:"/pages/fe879a/"},{path:"/01.Java/13.框架/11.ORM/",redirect:"/pages/fe879a/"},{name:"v-a97447de",path:"/pages/3295c4/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-a97447de").then(t)}},{path:"/pages/3295c4/index.html",redirect:"/pages/3295c4/"},{path:"/01.Java/13.框架/12.安全/01.Shiro.html",redirect:"/pages/3295c4/"},{name:"v-2ce67d1d",path:"/pages/10bd70/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-2ce67d1d").then(t)}},{path:"/pages/10bd70/index.html",redirect:"/pages/10bd70/"},{path:"/01.Java/13.框架/13.IO/01.Netty.html",redirect:"/pages/10bd70/"},{name:"v-de6109ae",path:"/pages/050cdd/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-de6109ae").then(t)}},{path:"/pages/050cdd/index.html",redirect:"/pages/050cdd/"},{path:"/01.Java/13.框架/12.安全/02.SpringSecurity.html",redirect:"/pages/050cdd/"},{name:"v-7d955174",path:"/pages/e373d7/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-7d955174").then(t)}},{path:"/pages/e373d7/index.html",redirect:"/pages/e373d7/"},{path:"/01.Java/13.框架/",redirect:"/pages/e373d7/"},{name:"v-60970149",path:"/pages/85460d/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-60970149").then(t)}},{path:"/pages/85460d/index.html",redirect:"/pages/85460d/"},{path:"/01.Java/14.中间件/02.缓存/02.Java缓存中间件.html",redirect:"/pages/85460d/"},{name:"v-79787bec",path:"/pages/59f078/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-79787bec").then(t)}},{path:"/pages/59f078/index.html",redirect:"/pages/59f078/"},{path:"/01.Java/14.中间件/02.缓存/05.Java进程内缓存.html",redirect:"/pages/59f078/"},{name:"v-0cc297da",path:"/pages/5f7893/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-0cc297da").then(t)}},{path:"/pages/5f7893/index.html",redirect:"/pages/5f7893/"},{path:"/01.Java/14.中间件/02.缓存/04.Ehcache.html",redirect:"/pages/5f7893/"},{name:"v-18696fc0",path:"/pages/30abaa/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-18696fc0").then(t)}},{path:"/pages/30abaa/index.html",redirect:"/pages/30abaa/"},{path:"/01.Java/14.中间件/02.缓存/06.Http缓存.html",redirect:"/pages/30abaa/"},{name:"v-50444ed1",path:"/pages/c4efe9/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-50444ed1").then(t)}},{path:"/pages/c4efe9/index.html",redirect:"/pages/c4efe9/"},{path:"/01.Java/14.中间件/02.缓存/",redirect:"/pages/c4efe9/"},{name:"v-e3279b12",path:"/pages/364124/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-e3279b12").then(t)}},{path:"/pages/364124/index.html",redirect:"/pages/364124/"},{path:"/01.Java/14.中间件/03.流量控制/01.Hystrix.html",redirect:"/pages/364124/"},{name:"v-60f62e76",path:"/pages/be5227/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-60f62e76").then(t)}},{path:"/pages/be5227/index.html",redirect:"/pages/be5227/"},{path:"/01.Java/14.中间件/99.其他/01.数据库连接池.html",redirect:"/pages/be5227/"},{name:"v-12857866",path:"/pages/fe6d83/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-12857866").then(t)}},{path:"/pages/fe6d83/index.html",redirect:"/pages/fe6d83/"},{path:"/01.Java/14.中间件/",redirect:"/pages/fe6d83/"},{name:"v-3feddaec",path:"/pages/0d2474/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-3feddaec").then(t)}},{path:"/pages/0d2474/index.html",redirect:"/pages/0d2474/"},{path:"/01.Java/",redirect:"/pages/0d2474/"},{name:"v-04cda89e",path:"/archives/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-04cda89e").then(t)}},{path:"/archives/index.html",redirect:"/archives/"},{path:"/@pages/archivesPage.html",redirect:"/archives/"},{name:"v-26877d31",path:"/tags/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-26877d31").then(t)}},{path:"/tags/index.html",redirect:"/tags/"},{path:"/@pages/tagsPage.html",redirect:"/tags/"},{name:"v-10d1fe8a",path:"/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-10d1fe8a").then(t)}},{path:"/index.html",redirect:"/"},{name:"v-5d493111",path:"/categories/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-5d493111").then(t)}},{path:"/categories/index.html",redirect:"/categories/"},{path:"/@pages/categoriesPage.html",redirect:"/categories/"},{path:"*",component:yl}],Sl={title:"JAVA-TUTORIAL",description:"☕ java-tutorial 是一个 Java 教程，汇集一个老司机在 Java 领域的十年积累。",base:"/java-tutorial/",headTags:[["link",{rel:"icon",href:"/java-tutorial/img/favicon.ico"}],["meta",{name:"keywords",content:"vuepress,theme,blog,vdoing"}],["meta",{name:"theme-color",content:"#11a8cd"}],["meta",{name:"wwads-cn-verify",content:"mxqWx62nfQQ9ocT4e5DzISHzOWyF4s"}],["script",{src:"https://cdn.wwads.cn/js/makemoney.js",type:"text/javascript"}]],pages:[{title:"JavaWeb 之 Servlet 指南",frontmatter:{title:"JavaWeb 之 Servlet 指南",date:"2020-08-24T19:41:46.000Z",order:1,categories:["Java","JavaEE","JavaWeb"],tags:["Java","JavaWeb","Servlet"],permalink:"/pages/e98894/"},regularPath:"/01.Java/02.JavaEE/01.JavaWeb/01.JavaWeb%E4%B9%8BServlet%E6%8C%87%E5%8D%97.html",relativePath:"01.Java/02.JavaEE/01.JavaWeb/01.JavaWeb之Servlet指南.md",key:"v-8c24c1c0",path:"/pages/e98894/",headers:[{level:2,title:"JavaWeb 简介",slug:"javaweb-简介",normalizedTitle:"javaweb 简介",charIndex:27},{level:3,title:"Web 应用程序",slug:"web-应用程序",normalizedTitle:"web 应用程序",charIndex:42},{level:3,title:"常见 Web 服务器",slug:"常见-web-服务器",normalizedTitle:"常见 web 服务器",charIndex:369},{level:2,title:"Servlet 简介",slug:"servlet-简介",normalizedTitle:"servlet 简介",charIndex:466},{level:3,title:"什么是 Servlet",slug:"什么是-servlet",normalizedTitle:"什么是 servlet",charIndex:481},{level:3,title:"Servlet 和 CGI 的区别",slug:"servlet-和-cgi-的区别",normalizedTitle:"servlet 和 cgi 的区别",charIndex:773},{level:3,title:"Servlet 版本以及主要特性",slug:"servlet-版本以及主要特性",normalizedTitle:"servlet 版本以及主要特性",charIndex:1e3},{level:3,title:"Servlet 任务",slug:"servlet-任务",normalizedTitle:"servlet 任务",charIndex:1838},{level:3,title:"Servlet 生命周期",slug:"servlet-生命周期",normalizedTitle:"servlet 生命周期",charIndex:2248},{level:2,title:"Servlet API",slug:"servlet-api",normalizedTitle:"servlet api",charIndex:2528},{level:3,title:"Servlet 包",slug:"servlet-包",normalizedTitle:"servlet 包",charIndex:2544},{level:3,title:"Servlet 接口",slug:"servlet-接口",normalizedTitle:"servlet 接口",charIndex:658},{level:4,title:"init() 方法",slug:"init-方法",normalizedTitle:"init() 方法",charIndex:3167},{level:4,title:"service() 方法",slug:"service-方法",normalizedTitle:"service() 方法",charIndex:879},{level:4,title:"doGet() 方法",slug:"doget-方法",normalizedTitle:"doget() 方法",charIndex:4255},{level:4,title:"doPost() 方法",slug:"dopost-方法",normalizedTitle:"dopost() 方法",charIndex:4213},{level:4,title:"destroy() 方法",slug:"destroy-方法",normalizedTitle:"destroy() 方法",charIndex:2465},{level:2,title:"Servlet 和 HTTP 状态码",slug:"servlet-和-http-状态码",normalizedTitle:"servlet 和 http 状态码",charIndex:4975},{level:3,title:"HTTP 状态码",slug:"http-状态码",normalizedTitle:"http 状态码",charIndex:4985},{level:3,title:"设置 HTTP 状态码的方法",slug:"设置-http-状态码的方法",normalizedTitle:"设置 http 状态码的方法",charIndex:5888},{level:3,title:"HTTP 状态码实例",slug:"http-状态码实例",normalizedTitle:"http 状态码实例",charIndex:6372},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:7316}],headersStr:"JavaWeb 简介 Web 应用程序 常见 Web 服务器 Servlet 简介 什么是 Servlet Servlet 和 CGI 的区别 Servlet 版本以及主要特性 Servlet 任务 Servlet 生命周期 Servlet API Servlet 包 Servlet 接口 init() 方法 service() 方法 doGet() 方法 doPost() 方法 destroy() 方法 Servlet 和 HTTP 状态码 HTTP 状态码 设置 HTTP 状态码的方法 HTTP 状态码实例 参考资料",content:'# JavaWeb 之 Servlet 指南\n\n\n# JavaWeb 简介\n\n\n# Web 应用程序\n\nWeb，在英语中 web 即表示网页的意思，它用于表示 Internet 主机上供外界访问的资源。\n\nWeb 应用程序是一种可以通过 Web 访问的应用程序，程序的最大好处是用户很容易访问应用程序，用户只需要有浏览器即可，不需要再安装其他软件。\n\nInternet 上供外界访问的 Web 资源分为：\n\n * 静态 web 资源：指 web 页面中供人们浏览的数据始终是不变。常见静态资源文件：html、css、各种图片类型（jpg、png）\n * 动态 web 资源：指 web 页面中供人们浏览的数据是由程序产生的，不同时间点访问 web 页面看到的内容各不相同。常见动态资源技术：JSP/Servlet、ASP、PHP\n\n\n# 常见 Web 服务器\n\n * Tomcat\n * Jetty\n * Resin\n * Apache\n * Nginx\n * WebSphere\n * WebLogic\n * JBoss\n\n\n# Servlet 简介\n\n\n# 什么是 Servlet\n\nServlet（Server Applet），即小服务程序或服务连接器。Servlet 是 Java 编写的服务器端程序，具有独立于平台和协议的特性，主要功能在于交互式地浏览和生成数据，生成动态 Web 内容。\n\n * 狭义的 Servlet 是指 Java 实现的一个接口。\n * 广义的 Servlet 是指任何实现了这个 Servlet 接口的类。\n\nServlet 运行于支持 Java 的应用服务器中。从原理上讲，Servlet 可以响应任何类型的请求，但绝大多数情况下 Servlet 只用来扩展基于 HTTP 协议的 Web 服务器。\n\n\n# Servlet 和 CGI 的区别\n\nServlet 技术出现之前，Web 主要使用 CGI 技术。它们的区别如下：\n\n * Servlet 是基于 Java 编写的，处于服务器进程中，他能够通过多线程方式运行 service() 方法，一个实例可以服务于多个请求，而且一般不会销毁；\n * CGI(Common Gateway Interface)，即通用网关接口。它会为每个请求产生新的进程，服务完成后销毁，所以效率上低于 Servlet。\n\n\n# Servlet 版本以及主要特性\n\n版本            日期            JAVA EE/JDK 版本       特性\nServlet 4.0   2017 年 10 月   JavaEE 8             HTTP2\nServlet 3.1   2013 年 5 月    JavaEE 7             非阻塞 I/O，HTTP 协议升级机制\nServlet 3.0   2009 年 12 月   JavaEE 6, JavaSE 6   可插拔性，易于开发，异步 Servlet，安全性，文件上传\nServlet 2.5   2005 年 10 月   JavaEE 5, JavaSE 5   依赖 JavaSE 5，支持注解\nServlet 2.4   2003 年 11 月   J2EE 1.4, J2SE 1.3   web.xml 使用 XML Schema\nServlet 2.3   2001 年 8 月    J2EE 1.3, J2SE 1.2   Filter\nServlet 2.2   1999 年 8 月    J2EE 1.2, J2SE 1.2   成为 J2EE 标准\nServlet 2.1   1998 年 11 月   未指定                  First official specification, added RequestDispatcher,\n                                                 ServletContext\nServlet 2.0                 JDK 1.1              Part of Java Servlet Development Kit 2.0\nServlet 1.0   1997 年 6 月                         \n\n\n# Servlet 任务\n\nServlet 执行以下主要任务：\n\n * 读取客户端（浏览器）发送的显式的数据。这包括网页上的 HTML 表单，或者也可以是来自 applet 或自定义的 HTTP 客户端程序的表单。\n * 读取客户端（浏览器）发送的隐式的 HTTP 请求数据。这包括 cookies、媒体类型和浏览器能理解的压缩格式等等。\n * 处理数据并生成结果。这个过程可能需要访问数据库，执行 RMI 或 CORBA 调用，调用 Web 服务，或者直接计算得出对应的响应。\n * 发送显式的数据（即文档）到客户端（浏览器）。该文档的格式可以是多种多样的，包括文本文件（HTML 或 XML）、二进制文件（GIF 图像）、Excel 等。\n * 发送隐式的 HTTP 响应到客户端（浏览器）。这包括告诉浏览器或其他客户端被返回的文档类型（例如 HTML），设置 cookies 和缓存参数，以及其他类似的任务。\n\n\n# Servlet 生命周期\n\n\n\nServlet 生命周期如下：\n\n 1. 加载 - 第一个到达服务器的 HTTP 请求被委派到 Servlet 容器。容器通过类加载器使用 Servlet 类对应的文件加载 servlet；\n 2. 初始化 - Servlet 通过调用 init () 方法进行初始化。\n 3. 服务 - Servlet 调用 service() 方法来处理客户端的请求。\n 4. 销毁 - Servlet 通过调用 destroy() 方法终止（结束）。\n 5. 卸载 - Servlet 是由 JVM 的垃圾回收器进行垃圾回收的。\n\n\n# Servlet API\n\n\n# Servlet 包\n\nJava Servlet 是运行在带有支持 Java Servlet 规范的解释器的 web 服务器上的 Java 类。\n\nServlet 可以使用 javax.servlet 和 javax.servlet.http 包创建，它是 Java 企业版的标准组成部分，Java 企业版是支持大型开发项目的 Java 类库的扩展版本。\n\nJava Servlet 就像任何其他的 Java 类一样已经被创建和编译。在您安装 Servlet 包并把它们添加到您的计算机上的 Classpath 类路径中之后，您就可以通过 JDK 的 Java 编译器或任何其他编译器来编译 Servlet。\n\n\n# Servlet 接口\n\nServlet 接口定义了下面五个方法：\n\npublic interface Servlet {\n    void init(ServletConfig var1) throws ServletException;\n\n    ServletConfig getServletConfig();\n\n    void service(ServletRequest var1, ServletResponse var2) throws ServletException, IOException;\n\n    String getServletInfo();\n\n    void destroy();\n}\n\n\n# init() 方法\n\ninit 方法被设计成只调用一次。它在第一次创建 Servlet 时被调用，在后续每次用户请求时不再调用。因此，它是用于一次性初始化，就像 Applet 的 init 方法一样。\n\nServlet 创建于用户第一次调用对应于该 Servlet 的 URL 时，但是您也可以指定 Servlet 在服务器第一次启动时被加载。\n\n当用户调用一个 Servlet 时，就会创建一个 Servlet 实例，每一个用户请求都会产生一个新的线程，适当的时候移交给 doGet 或 doPost 方法。init() 方法简单地创建或加载一些数据，这些数据将被用于 Servlet 的整个生命周期。\n\ninit 方法的定义如下：\n\npublic void init() throws ServletException {\n  // 初始化代码...\n}\n\n\n# service() 方法\n\nservice() 方法是执行实际任务的核心方法。Servlet 容器（即 Web 服务器）调用 service() 方法来处理来自客户端（浏览器）的请求，并把格式化的响应写回给客户端。\n\nservice() 方法有两个参数：ServletRequest 和 ServletResponse。ServletRequest 用来封装请求信息，ServletResponse 用来封装响应信息，因此本质上这两个类是对通信协议的封装。\n\n每次服务器接收到一个 Servlet 请求时，服务器会产生一个新的线程并调用服务。service() 方法检查 HTTP 请求类型（GET、POST、PUT、DELETE 等），并在适当的时候调用 doGet、doPost、doPut，doDelete 等方法。\n\n下面是该方法的特征：\n\npublic void service(ServletRequest request,\n                    ServletResponse response)\n      throws ServletException, IOException{\n}\n\n\nservice() 方法由容器调用，service 方法在适当的时候调用 doGet、doPost、doPut、doDelete 等方法。所以，您不用对 service() 方法做任何动作，您只需要根据来自客户端的请求类型来重写 doGet() 或 doPost() 即可。\n\ndoGet() 和 doPost() 方法是每次服务请求中最常用的方法。下面是这两种方法的特征。\n\n# doGet() 方法\n\nGET 请求来自于一个 URL 的正常请求，或者来自于一个未指定 METHOD 的 HTML 表单，它由 doGet() 方法处理。\n\npublic void doGet(HttpServletRequest request,\n                  HttpServletResponse response)\n    throws ServletException, IOException {\n    // Servlet 代码\n}\n\n\n# doPost() 方法\n\nPOST 请求来自于一个特别指定了 METHOD 为 POST 的 HTML 表单，它由 doPost() 方法处理。\n\npublic void doPost(HttpServletRequest request,\n                   HttpServletResponse response)\n    throws ServletException, IOException {\n    // Servlet 代码\n}\n\n\n# destroy() 方法\n\ndestroy() 方法只会被调用一次，在 Servlet 生命周期结束时被调用。destroy() 方法可以让您的 Servlet 关闭数据库连接、停止后台线程、把 Cookie 列表或点击计数器写入到磁盘，并执行其他类似的清理活动。\n\n在调用 destroy() 方法之后，servlet 对象被标记为垃圾回收。destroy 方法定义如下所示：\n\n  public void destroy() {\n    // 终止化代码...\n  }\n\n\n\n# Servlet 和 HTTP 状态码\n\ntitle: JavaEE Servlet HTTP 状态码 date: 2017-11-08 categories:\n\n * javaee tags:\n * javaee\n * servlet\n * http\n\n\n# HTTP 状态码\n\nHTTP 请求和 HTTP 响应消息的格式是类似的，结构如下：\n\n * 初始状态行 + 回车换行符（回车+换行）\n * 零个或多个标题行+回车换行符\n * 一个空白行，即回车换行符\n * 一个可选的消息主体，比如文件、查询数据或查询输出\n\n例如，服务器的响应头如下所示：\n\nHTTP/1.1 200 OK\nContent-Type: text/html\nHeader2: ...\n...\nHeaderN: ...\n  (Blank Line)\n<!doctype ...>\n<html>\n<head>...</head>\n<body>\n...\n</body>\n</html>\n\n\n状态行包括 HTTP 版本（在本例中为 HTTP/1.1）、一个状态码（在本例中为 200）和一个对应于状态码的短消息（在本例中为 OK）。\n\n以下是可能从 Web 服务器返回的 HTTP 状态码和相关的信息列表：\n\n * 1**：信息性状态码\n * 2**：成功状态码\n   * 200：请求正常成功\n   * 204：指示请求成功但没有返回新信息\n   * 206：指示服务器已完成对资源的部分 GET 请求\n * 3**：重定向状态码\n   * 301：永久性重定向\n   * 302：临时性重定向\n   * 304：服务器端允许请求访问资源，但未满足条件\n * 4**：客户端错误状态码\n   * 400：请求报文中存在语法错误\n   * 401：发送的请求需要有通过 HTTP 认证的认证信息\n   * 403：对请求资源的访问被服务器拒绝了\n   * 404：服务器上无法找到请求的资源\n * 5**：服务器错误状态码\n   * 500：服务器端在执行请求时发生了错误\n   * 503：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求\n\n\n# 设置 HTTP 状态码的方法\n\n下面的方法可用于在 Servlet 程序中设置 HTTP 状态码。这些方法通过 HttpServletResponse 对象可用。\n\n序号   方法 & 描述\n1    **public void setStatus ( int statusCode\n     )**该方法设置一个任意的状态码。setStatus 方法接受一个\n     int（状态码）作为参数。如果您的反应包含了一个特殊的状态码和文档，请确保在使用 PrintWriter\n     实际返回任何内容之前调用 setStatus。\n2    **public void sendRedirect(String url)**该方法生成一个 302\n     响应，连同一个带有新文档 URL 的 Location 头。\n3    **public void sendError(int code, String\n     message)**该方法发送一个状态码（通常为 404），连同一个在 HTML\n     文档内部自动格式化并发送到客户端的短消息。\n\n\n# HTTP 状态码实例\n\n下面的例子把 407 错误代码发送到客户端浏览器，浏览器会显示 "Need authentication!!!" 消息。\n\n// 导入必需的 java 库\nimport java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport java.util.*;\n\n// 扩展 HttpServlet 类\npublic class showError extends HttpServlet {\n\n  // 处理 GET 方法请求的方法\n  public void doGet(HttpServletRequest request,\n                    HttpServletResponse response)\n            throws ServletException, IOException\n  {\n      // 设置错误代码和原因\n      response.sendError(407, "Need authentication!!!" );\n  }\n  // 处理 POST 方法请求的方法\n  public void doPost(HttpServletRequest request,\n                     HttpServletResponse response)\n      throws ServletException, IOException {\n     doGet(request, response);\n  }\n}\n\n\n现在，调用上面的 Servlet 将显示以下结果：\n\nHTTP Status 407 - Need authentication!!!\ntype Status report\nmessage Need authentication!!!\ndescription The client must first authenticate itself with the proxy (Need authentication!!!).\nApache Tomcat/5.5.29\n\n\n\n# 参考资料\n\n * 深入拆解 Tomcat & Jetty\n * Java Web 整合开发王者归来',normalizedContent:'# javaweb 之 servlet 指南\n\n\n# javaweb 简介\n\n\n# web 应用程序\n\nweb，在英语中 web 即表示网页的意思，它用于表示 internet 主机上供外界访问的资源。\n\nweb 应用程序是一种可以通过 web 访问的应用程序，程序的最大好处是用户很容易访问应用程序，用户只需要有浏览器即可，不需要再安装其他软件。\n\ninternet 上供外界访问的 web 资源分为：\n\n * 静态 web 资源：指 web 页面中供人们浏览的数据始终是不变。常见静态资源文件：html、css、各种图片类型（jpg、png）\n * 动态 web 资源：指 web 页面中供人们浏览的数据是由程序产生的，不同时间点访问 web 页面看到的内容各不相同。常见动态资源技术：jsp/servlet、asp、php\n\n\n# 常见 web 服务器\n\n * tomcat\n * jetty\n * resin\n * apache\n * nginx\n * websphere\n * weblogic\n * jboss\n\n\n# servlet 简介\n\n\n# 什么是 servlet\n\nservlet（server applet），即小服务程序或服务连接器。servlet 是 java 编写的服务器端程序，具有独立于平台和协议的特性，主要功能在于交互式地浏览和生成数据，生成动态 web 内容。\n\n * 狭义的 servlet 是指 java 实现的一个接口。\n * 广义的 servlet 是指任何实现了这个 servlet 接口的类。\n\nservlet 运行于支持 java 的应用服务器中。从原理上讲，servlet 可以响应任何类型的请求，但绝大多数情况下 servlet 只用来扩展基于 http 协议的 web 服务器。\n\n\n# servlet 和 cgi 的区别\n\nservlet 技术出现之前，web 主要使用 cgi 技术。它们的区别如下：\n\n * servlet 是基于 java 编写的，处于服务器进程中，他能够通过多线程方式运行 service() 方法，一个实例可以服务于多个请求，而且一般不会销毁；\n * cgi(common gateway interface)，即通用网关接口。它会为每个请求产生新的进程，服务完成后销毁，所以效率上低于 servlet。\n\n\n# servlet 版本以及主要特性\n\n版本            日期            java ee/jdk 版本       特性\nservlet 4.0   2017 年 10 月   javaee 8             http2\nservlet 3.1   2013 年 5 月    javaee 7             非阻塞 i/o，http 协议升级机制\nservlet 3.0   2009 年 12 月   javaee 6, javase 6   可插拔性，易于开发，异步 servlet，安全性，文件上传\nservlet 2.5   2005 年 10 月   javaee 5, javase 5   依赖 javase 5，支持注解\nservlet 2.4   2003 年 11 月   j2ee 1.4, j2se 1.3   web.xml 使用 xml schema\nservlet 2.3   2001 年 8 月    j2ee 1.3, j2se 1.2   filter\nservlet 2.2   1999 年 8 月    j2ee 1.2, j2se 1.2   成为 j2ee 标准\nservlet 2.1   1998 年 11 月   未指定                  first official specification, added requestdispatcher,\n                                                 servletcontext\nservlet 2.0                 jdk 1.1              part of java servlet development kit 2.0\nservlet 1.0   1997 年 6 月                         \n\n\n# servlet 任务\n\nservlet 执行以下主要任务：\n\n * 读取客户端（浏览器）发送的显式的数据。这包括网页上的 html 表单，或者也可以是来自 applet 或自定义的 http 客户端程序的表单。\n * 读取客户端（浏览器）发送的隐式的 http 请求数据。这包括 cookies、媒体类型和浏览器能理解的压缩格式等等。\n * 处理数据并生成结果。这个过程可能需要访问数据库，执行 rmi 或 corba 调用，调用 web 服务，或者直接计算得出对应的响应。\n * 发送显式的数据（即文档）到客户端（浏览器）。该文档的格式可以是多种多样的，包括文本文件（html 或 xml）、二进制文件（gif 图像）、excel 等。\n * 发送隐式的 http 响应到客户端（浏览器）。这包括告诉浏览器或其他客户端被返回的文档类型（例如 html），设置 cookies 和缓存参数，以及其他类似的任务。\n\n\n# servlet 生命周期\n\n\n\nservlet 生命周期如下：\n\n 1. 加载 - 第一个到达服务器的 http 请求被委派到 servlet 容器。容器通过类加载器使用 servlet 类对应的文件加载 servlet；\n 2. 初始化 - servlet 通过调用 init () 方法进行初始化。\n 3. 服务 - servlet 调用 service() 方法来处理客户端的请求。\n 4. 销毁 - servlet 通过调用 destroy() 方法终止（结束）。\n 5. 卸载 - servlet 是由 jvm 的垃圾回收器进行垃圾回收的。\n\n\n# servlet api\n\n\n# servlet 包\n\njava servlet 是运行在带有支持 java servlet 规范的解释器的 web 服务器上的 java 类。\n\nservlet 可以使用 javax.servlet 和 javax.servlet.http 包创建，它是 java 企业版的标准组成部分，java 企业版是支持大型开发项目的 java 类库的扩展版本。\n\njava servlet 就像任何其他的 java 类一样已经被创建和编译。在您安装 servlet 包并把它们添加到您的计算机上的 classpath 类路径中之后，您就可以通过 jdk 的 java 编译器或任何其他编译器来编译 servlet。\n\n\n# servlet 接口\n\nservlet 接口定义了下面五个方法：\n\npublic interface servlet {\n    void init(servletconfig var1) throws servletexception;\n\n    servletconfig getservletconfig();\n\n    void service(servletrequest var1, servletresponse var2) throws servletexception, ioexception;\n\n    string getservletinfo();\n\n    void destroy();\n}\n\n\n# init() 方法\n\ninit 方法被设计成只调用一次。它在第一次创建 servlet 时被调用，在后续每次用户请求时不再调用。因此，它是用于一次性初始化，就像 applet 的 init 方法一样。\n\nservlet 创建于用户第一次调用对应于该 servlet 的 url 时，但是您也可以指定 servlet 在服务器第一次启动时被加载。\n\n当用户调用一个 servlet 时，就会创建一个 servlet 实例，每一个用户请求都会产生一个新的线程，适当的时候移交给 doget 或 dopost 方法。init() 方法简单地创建或加载一些数据，这些数据将被用于 servlet 的整个生命周期。\n\ninit 方法的定义如下：\n\npublic void init() throws servletexception {\n  // 初始化代码...\n}\n\n\n# service() 方法\n\nservice() 方法是执行实际任务的核心方法。servlet 容器（即 web 服务器）调用 service() 方法来处理来自客户端（浏览器）的请求，并把格式化的响应写回给客户端。\n\nservice() 方法有两个参数：servletrequest 和 servletresponse。servletrequest 用来封装请求信息，servletresponse 用来封装响应信息，因此本质上这两个类是对通信协议的封装。\n\n每次服务器接收到一个 servlet 请求时，服务器会产生一个新的线程并调用服务。service() 方法检查 http 请求类型（get、post、put、delete 等），并在适当的时候调用 doget、dopost、doput，dodelete 等方法。\n\n下面是该方法的特征：\n\npublic void service(servletrequest request,\n                    servletresponse response)\n      throws servletexception, ioexception{\n}\n\n\nservice() 方法由容器调用，service 方法在适当的时候调用 doget、dopost、doput、dodelete 等方法。所以，您不用对 service() 方法做任何动作，您只需要根据来自客户端的请求类型来重写 doget() 或 dopost() 即可。\n\ndoget() 和 dopost() 方法是每次服务请求中最常用的方法。下面是这两种方法的特征。\n\n# doget() 方法\n\nget 请求来自于一个 url 的正常请求，或者来自于一个未指定 method 的 html 表单，它由 doget() 方法处理。\n\npublic void doget(httpservletrequest request,\n                  httpservletresponse response)\n    throws servletexception, ioexception {\n    // servlet 代码\n}\n\n\n# dopost() 方法\n\npost 请求来自于一个特别指定了 method 为 post 的 html 表单，它由 dopost() 方法处理。\n\npublic void dopost(httpservletrequest request,\n                   httpservletresponse response)\n    throws servletexception, ioexception {\n    // servlet 代码\n}\n\n\n# destroy() 方法\n\ndestroy() 方法只会被调用一次，在 servlet 生命周期结束时被调用。destroy() 方法可以让您的 servlet 关闭数据库连接、停止后台线程、把 cookie 列表或点击计数器写入到磁盘，并执行其他类似的清理活动。\n\n在调用 destroy() 方法之后，servlet 对象被标记为垃圾回收。destroy 方法定义如下所示：\n\n  public void destroy() {\n    // 终止化代码...\n  }\n\n\n\n# servlet 和 http 状态码\n\ntitle: javaee servlet http 状态码 date: 2017-11-08 categories:\n\n * javaee tags:\n * javaee\n * servlet\n * http\n\n\n# http 状态码\n\nhttp 请求和 http 响应消息的格式是类似的，结构如下：\n\n * 初始状态行 + 回车换行符（回车+换行）\n * 零个或多个标题行+回车换行符\n * 一个空白行，即回车换行符\n * 一个可选的消息主体，比如文件、查询数据或查询输出\n\n例如，服务器的响应头如下所示：\n\nhttp/1.1 200 ok\ncontent-type: text/html\nheader2: ...\n...\nheadern: ...\n  (blank line)\n<!doctype ...>\n<html>\n<head>...</head>\n<body>\n...\n</body>\n</html>\n\n\n状态行包括 http 版本（在本例中为 http/1.1）、一个状态码（在本例中为 200）和一个对应于状态码的短消息（在本例中为 ok）。\n\n以下是可能从 web 服务器返回的 http 状态码和相关的信息列表：\n\n * 1**：信息性状态码\n * 2**：成功状态码\n   * 200：请求正常成功\n   * 204：指示请求成功但没有返回新信息\n   * 206：指示服务器已完成对资源的部分 get 请求\n * 3**：重定向状态码\n   * 301：永久性重定向\n   * 302：临时性重定向\n   * 304：服务器端允许请求访问资源，但未满足条件\n * 4**：客户端错误状态码\n   * 400：请求报文中存在语法错误\n   * 401：发送的请求需要有通过 http 认证的认证信息\n   * 403：对请求资源的访问被服务器拒绝了\n   * 404：服务器上无法找到请求的资源\n * 5**：服务器错误状态码\n   * 500：服务器端在执行请求时发生了错误\n   * 503：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求\n\n\n# 设置 http 状态码的方法\n\n下面的方法可用于在 servlet 程序中设置 http 状态码。这些方法通过 httpservletresponse 对象可用。\n\n序号   方法 & 描述\n1    **public void setstatus ( int statuscode\n     )**该方法设置一个任意的状态码。setstatus 方法接受一个\n     int（状态码）作为参数。如果您的反应包含了一个特殊的状态码和文档，请确保在使用 printwriter\n     实际返回任何内容之前调用 setstatus。\n2    **public void sendredirect(string url)**该方法生成一个 302\n     响应，连同一个带有新文档 url 的 location 头。\n3    **public void senderror(int code, string\n     message)**该方法发送一个状态码（通常为 404），连同一个在 html\n     文档内部自动格式化并发送到客户端的短消息。\n\n\n# http 状态码实例\n\n下面的例子把 407 错误代码发送到客户端浏览器，浏览器会显示 "need authentication!!!" 消息。\n\n// 导入必需的 java 库\nimport java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport java.util.*;\n\n// 扩展 httpservlet 类\npublic class showerror extends httpservlet {\n\n  // 处理 get 方法请求的方法\n  public void doget(httpservletrequest request,\n                    httpservletresponse response)\n            throws servletexception, ioexception\n  {\n      // 设置错误代码和原因\n      response.senderror(407, "need authentication!!!" );\n  }\n  // 处理 post 方法请求的方法\n  public void dopost(httpservletrequest request,\n                     httpservletresponse response)\n      throws servletexception, ioexception {\n     doget(request, response);\n  }\n}\n\n\n现在，调用上面的 servlet 将显示以下结果：\n\nhttp status 407 - need authentication!!!\ntype status report\nmessage need authentication!!!\ndescription the client must first authenticate itself with the proxy (need authentication!!!).\napache tomcat/5.5.29\n\n\n\n# 参考资料\n\n * 深入拆解 tomcat & jetty\n * java web 整合开发王者归来',charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"JavaWeb 之 Jsp 指南",frontmatter:{title:"JavaWeb 之 Jsp 指南",date:"2020-02-07T23:04:47.000Z",order:2,categories:["Java","JavaEE","JavaWeb"],tags:["Java","JavaWeb","JSP"],permalink:"/pages/8cc787/"},regularPath:"/01.Java/02.JavaEE/01.JavaWeb/02.JavaWeb%E4%B9%8BJsp%E6%8C%87%E5%8D%97.html",relativePath:"01.Java/02.JavaEE/01.JavaWeb/02.JavaWeb之Jsp指南.md",key:"v-bd7f8880",path:"/pages/8cc787/",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:23},{level:3,title:"什么是 Java Server Pages",slug:"什么是-java-server-pages",normalizedTitle:"什么是 java server pages",charIndex:30},{level:3,title:"为什么使用 JSP",slug:"为什么使用-jsp",normalizedTitle:"为什么使用 jsp",charIndex:365},{level:3,title:"JSP 的优势",slug:"jsp-的优势",normalizedTitle:"jsp 的优势",charIndex:797},{level:2,title:"JSP 工作原理",slug:"jsp-工作原理",normalizedTitle:"jsp 工作原理",charIndex:1145},{level:3,title:"JSP 工作流程",slug:"jsp-工作流程",normalizedTitle:"jsp 工作流程",charIndex:1378},{level:4,title:"工作步骤",slug:"工作步骤",normalizedTitle:"工作步骤",charIndex:1590},{level:3,title:"JSP 生命周期",slug:"jsp-生命周期",normalizedTitle:"jsp 生命周期",charIndex:2296},{level:4,title:"JSP 编译",slug:"jsp-编译",normalizedTitle:"jsp 编译",charIndex:2689},{level:4,title:"JSP 初始化",slug:"jsp-初始化",normalizedTitle:"jsp 初始化",charIndex:2845},{level:4,title:"JSP 执行",slug:"jsp-执行",normalizedTitle:"jsp 执行",charIndex:3054},{level:4,title:"JSP 清理",slug:"jsp-清理",normalizedTitle:"jsp 清理",charIndex:3449},{level:2,title:"语法",slug:"语法",normalizedTitle:"语法",charIndex:3659},{level:3,title:"脚本",slug:"脚本",normalizedTitle:"脚本",charIndex:576},{level:4,title:"中文编码问题",slug:"中文编码问题",normalizedTitle:"中文编码问题",charIndex:4264},{level:3,title:"JSP 声明",slug:"jsp-声明",normalizedTitle:"jsp 声明",charIndex:4743},{level:3,title:"JSP 表达式",slug:"jsp-表达式",normalizedTitle:"jsp 表达式",charIndex:5041},{level:3,title:"JSP 注释",slug:"jsp-注释",normalizedTitle:"jsp 注释",charIndex:5692},{level:3,title:"控制语句",slug:"控制语句",normalizedTitle:"控制语句",charIndex:6338},{level:4,title:"if…else 语句",slug:"if-else-语句",normalizedTitle:"if…else 语句",charIndex:6421},{level:4,title:"switch…case 语句",slug:"switch-case-语句",normalizedTitle:"switch…case 语句",charIndex:6867},{level:4,title:"循环语句",slug:"循环语句",normalizedTitle:"循环语句",charIndex:6410},{level:3,title:"JSP 字面量",slug:"jsp-字面量",normalizedTitle:"jsp 字面量",charIndex:9420},{level:2,title:"指令",slug:"指令",normalizedTitle:"指令",charIndex:9577},{level:3,title:"Page 指令",slug:"page-指令",normalizedTitle:"page 指令",charIndex:9891},{level:4,title:"属性",slug:"属性",normalizedTitle:"属性",charIndex:6298},{level:3,title:"Include 指令",slug:"include-指令",normalizedTitle:"include 指令",charIndex:10730},{level:3,title:"Taglib 指令",slug:"taglib-指令",normalizedTitle:"taglib 指令",charIndex:11020},{level:2,title:"JSP 动作元素",slug:"jsp-动作元素",normalizedTitle:"jsp 动作元素",charIndex:11273},{level:3,title:"常见的属性",slug:"常见的属性",normalizedTitle:"常见的属性",charIndex:12042},{level:3,title:"<jsp:include>",slug:"jsp-include",normalizedTitle:'<a href="jsp:include">jsp:include</a>',charIndex:null},{level:3,title:"<jsp:useBean>",slug:"jsp-usebean",normalizedTitle:'<a href="jsp:usebean">jsp:usebean</a>',charIndex:null},{level:3,title:"<jsp:setProperty>",slug:"jsp-setproperty",normalizedTitle:'<a href="jsp:setproperty">jsp:setproperty</a>',charIndex:null},{level:3,title:"<jsp:getProperty>",slug:"jsp-getproperty",normalizedTitle:'<a href="jsp:getproperty">jsp:getproperty</a>',charIndex:null},{level:3,title:"<jsp:forward>",slug:"jsp-forward",normalizedTitle:'<a href="jsp:forward">jsp:forward</a>',charIndex:null},{level:3,title:"<jsp:plugin>",slug:"jsp-plugin",normalizedTitle:'<a href="jsp:plugin">jsp:plugin</a>',charIndex:null},{level:3,title:"<jsp:element> 、 <jsp:attribute>、<jsp:body>",slug:"jsp-element-、-jsp-attribute-、-jsp-body",normalizedTitle:'<a href="jsp:element">jsp:element</a> 、 <a href="jsp:attribute">jsp:attribute</a>、<a href="jsp:body">jsp:body</a>',charIndex:null},{level:3,title:"<jsp:text>",slug:"jsp-text",normalizedTitle:'<a href="jsp:text">jsp:text</a>',charIndex:null},{level:2,title:"JSP 隐式对象",slug:"jsp-隐式对象",normalizedTitle:"jsp 隐式对象",charIndex:18963},{level:3,title:"request 对象",slug:"request-对象",normalizedTitle:"request 对象",charIndex:19445},{level:3,title:"response 对象",slug:"response-对象",normalizedTitle:"response 对象",charIndex:19616},{level:3,title:"out 对象",slug:"out-对象",normalizedTitle:"out 对象",charIndex:10218},{level:3,title:"session 对象",slug:"session-对象",normalizedTitle:"session 对象",charIndex:20282},{level:3,title:"application 对象",slug:"application-对象",normalizedTitle:"application 对象",charIndex:20406},{level:3,title:"config 对象",slug:"config-对象",normalizedTitle:"config 对象",charIndex:20641},{level:3,title:"pageContext 对象",slug:"pagecontext-对象",normalizedTitle:"pagecontext 对象",charIndex:20916},{level:3,title:"page 对象",slug:"page-对象",normalizedTitle:"page 对象",charIndex:21499},{level:3,title:"exception 对象",slug:"exception-对象",normalizedTitle:"exception 对象",charIndex:21568},{level:2,title:"EL 表达式",slug:"el-表达式",normalizedTitle:"el 表达式",charIndex:10686},{level:3,title:"一个简单的语法",slug:"一个简单的语法",normalizedTitle:"一个简单的语法",charIndex:21848},{level:3,title:"EL 中的基础操作符",slug:"el-中的基础操作符",normalizedTitle:"el 中的基础操作符",charIndex:22729},{level:3,title:"JSP EL 中的函数",slug:"jsp-el-中的函数",normalizedTitle:"jsp el 中的函数",charIndex:23141},{level:3,title:"JSP EL 隐含对象",slug:"jsp-el-隐含对象",normalizedTitle:"jsp el 隐含对象",charIndex:23457},{level:3,title:"pageContext 对象",slug:"pagecontext-对象-2",normalizedTitle:"pagecontext 对象",charIndex:20916},{level:3,title:"Scope 对象",slug:"scope-对象",normalizedTitle:"scope 对象",charIndex:24087},{level:3,title:"param 和 paramValues 对象",slug:"param-和-paramvalues-对象",normalizedTitle:"param 和 paramvalues 对象",charIndex:24249},{level:3,title:"header 和 headerValues 对象",slug:"header-和-headervalues-对象",normalizedTitle:"header 和 headervalues 对象",charIndex:24847},{level:2,title:"JSTL",slug:"jstl",normalizedTitle:"jstl",charIndex:23330},{level:3,title:"JSTL 库安装",slug:"jstl-库安装",normalizedTitle:"jstl 库安装",charIndex:25680},{level:3,title:"核心标签",slug:"核心标签",normalizedTitle:"核心标签",charIndex:25631},{level:3,title:"格式化标签",slug:"格式化标签",normalizedTitle:"格式化标签",charIndex:25639},{level:3,title:"SQL 标签",slug:"sql-标签",normalizedTitle:"sql 标签",charIndex:25554},{level:3,title:"XML 标签",slug:"xml-标签",normalizedTitle:"xml 标签",charIndex:25658},{level:3,title:"JSTL 函数",slug:"jstl-函数",normalizedTitle:"jstl 函数",charIndex:25668},{level:2,title:"Taglib",slug:"taglib",normalizedTitle:"taglib",charIndex:11020},{level:3,title:"JSP 自定义标签",slug:"jsp-自定义标签",normalizedTitle:"jsp 自定义标签",charIndex:30954},{level:3,title:'创建"Hello"标签',slug:"创建-hello-标签",normalizedTitle:"创建&quot;hello&quot;标签",charIndex:null},{level:3,title:"访问标签体",slug:"访问标签体",normalizedTitle:"访问标签体",charIndex:32315},{level:3,title:"自定义标签属性",slug:"自定义标签属性",normalizedTitle:"自定义标签属性",charIndex:33369}],headersStr:'简介 什么是 Java Server Pages 为什么使用 JSP JSP 的优势 JSP 工作原理 JSP 工作流程 工作步骤 JSP 生命周期 JSP 编译 JSP 初始化 JSP 执行 JSP 清理 语法 脚本 中文编码问题 JSP 声明 JSP 表达式 JSP 注释 控制语句 if…else 语句 switch…case 语句 循环语句 JSP 字面量 指令 Page 指令 属性 Include 指令 Taglib 指令 JSP 动作元素 常见的属性 <jsp:include> <jsp:useBean> <jsp:setProperty> <jsp:getProperty> <jsp:forward> <jsp:plugin> <jsp:element> 、 <jsp:attribute>、<jsp:body> <jsp:text> JSP 隐式对象 request 对象 response 对象 out 对象 session 对象 application 对象 config 对象 pageContext 对象 page 对象 exception 对象 EL 表达式 一个简单的语法 EL 中的基础操作符 JSP EL 中的函数 JSP EL 隐含对象 pageContext 对象 Scope 对象 param 和 paramValues 对象 header 和 headerValues 对象 JSTL JSTL 库安装 核心标签 格式化标签 SQL 标签 XML 标签 JSTL 函数 Taglib JSP 自定义标签 创建"Hello"标签 访问标签体 自定义标签属性',content:'# JavaWeb 之 Jsp 指南\n\n\n# 简介\n\n\n# 什么是 Java Server Pages\n\nJSP全称Java Server Pages，是一种动态网页开发技术。\n\n它使用 JSP 标签在 HTML 网页中插入 Java 代码。标签通常以 <% 开头以 %> 结束。\n\nJSP 是一种 Java servlet，主要用于实现 Java web 应用程序的用户界面部分。网页开发者们通过结合 HTML 代码、XHTML 代码、XML 元素以及嵌入 JSP 操作和命令来编写 JSP。\n\nJSP 通过网页表单获取用户输入数据、访问数据库及其他数据源，然后动态地创建网页。\n\nJSP 标签有多种功能，比如访问数据库、记录用户选择信息、访问 JavaBeans 组件等，还可以在不同的网页中传递控制信息和共享信息。\n\n\n# 为什么使用 JSP\n\nJSP 也是一种 Servlet，因此 JSP 能够完成 Servlet 能完成的任何工作。\n\nJSP 程序与 CGI 程序有着相似的功能，但和 CGI 程序相比，JSP 程序有如下优势：\n\n * 性能更加优越，因为 JSP 可以直接在 HTML 网页中动态嵌入元素而不需要单独引用 CGI 文件。\n * 服务器调用的是已经编译好的 JSP 文件，而不像 CGI/Perl 那样必须先载入解释器和目标脚本。\n * JSP 基于 Java Servlets API，因此，JSP 拥有各种强大的企业级 Java API，包括 JDBC，JNDI，EJB，JAXP 等等。\n * JSP 页面可以与处理业务逻辑的 servlets 一起使用，这种模式被 Java servlet 模板引擎所支持。\n\n最后，JSP 是 Java EE 不可或缺的一部分，是一个完整的企业级应用平台。这意味着 JSP 可以用最简单的方式来实现最复杂的应用。\n\n\n# JSP 的优势\n\n以下列出了使用 JSP 带来的其他好处：\n\n * 与 ASP 相比：JSP 有两大优势。首先，动态部分用 Java 编写，而不是 VB 或其他 MS 专用语言，所以更加强大与易用。第二点就是 JSP 易于移植到非 MS 平台上。\n * 与纯 Servlets 相比：JSP 可以很方便的编写或者修改 HTML 网页而不用去面对大量的 println 语句。\n * 与 SSI 相比：SSI 无法使用表单数据、无法进行数据库链接。\n * 与 JavaScript 相比：虽然 JavaScript 可以在客户端动态生成 HTML，但是很难与服务器交互，因此不能提供复杂的服务，比如访问数据库和图像处理等等。\n * 与静态 HTML 相比：静态 HTML 不包含动态信息。\n\n\n# JSP 工作原理\n\nJSP 是一种 Servlet，但工作方式和 Servlet 有所差别。\n\nServlet 是先将源代码编译为 class 文件后部署到服务器下的，先编译后部署。\n\nJsp 是先将源代码部署到服务器再编译，先部署后编译。\n\nJsp 会在客户端第一次请求 Jsp 文件时被编译为 HttpJspPage 类（Servlet 的一个子类）。该类会被服务器临时存放在服务器工作目录里。所以，第一次请求 Jsp 后，访问速度会变快就是这个道理。\n\n\n# JSP 工作流程\n\n网络服务器需要一个 JSP 引擎，也就是一个容器来处理 JSP 页面。容器负责截获对 JSP 页面的请求。本教程使用内嵌 JSP 容器的 Apache 来支持 JSP 开发。\n\nJSP 容器与 Web 服务器协同合作，为 JSP 的正常运行提供必要的运行环境和其他服务，并且能够正确识别专属于 JSP 网页的特殊元素。\n\n下图显示了 JSP 容器和 JSP 文件在 Web 应用中所处的位置。\n\n\n\n# 工作步骤\n\n以下步骤表明了 Web 服务器是如何使用 JSP 来创建网页的：\n\n * 就像其他普通的网页一样，您的浏览器发送一个 HTTP 请求给服务器。\n * Web 服务器识别出这是一个对 JSP 网页的请求，并且将该请求传递给 JSP 引擎。通过使用 URL 或者.jsp 文件来完成。\n * JSP 引擎从磁盘中载入 JSP 文件，然后将它们转化为 servlet。这种转化只是简单地将所有模板文本改用 println()语句，并且将所有的 JSP 元素转化成 Java 代码。\n * JSP 引擎将 servlet 编译成可执行类，并且将原始请求传递给 servlet 引擎。\n * Web 服务器的某组件将会调用 servlet 引擎，然后载入并执行 servlet 类。在执行过程中，servlet 产生 HTML 格式的输出并将其内嵌于 HTTP response 中上交给 Web 服务器。\n * Web 服务器以静态 HTML 网页的形式将 HTTP response 返回到您的浏览器中。\n * 最终，Web 浏览器处理 HTTP response 中动态产生的 HTML 网页，就好像在处理静态网页一样。\n\n以上提及到的步骤可以用下图来表示：\n\n一般情况下，JSP 引擎会检查 JSP 文件对应的 servlet 是否已经存在，并且检查 JSP 文件的修改日期是否早于 servlet。如果 JSP 文件的修改日期早于对应的 servlet，那么容器就可以确定 JSP 文件没有被修改过并且 servlet 有效。这使得整个流程与其他脚本语言（比如 PHP）相比要高效快捷一些。\n\n\n# JSP 生命周期\n\n理解 JSP 底层功能的关键就是去理解它们所遵守的生命周期。\n\nJSP 生命周期就是从创建到销毁的整个过程，类似于 servlet 生命周期，区别在于 JSP 生命周期还包括将 JSP 文件编译成 servlet。\n\n以下是 JSP 生命周期中所走过的几个阶段：\n\n * **编译阶段：**servlet 容器编译 servlet 源文件，生成 servlet 类\n * **初始化阶段：**加载与 JSP 对应的 servlet 类，创建其实例，并调用它的初始化方法\n * **执行阶段：**调用与 JSP 对应的 servlet 实例的服务方法\n * **销毁阶段：**调用与 JSP 对应的 servlet 实例的销毁方法，然后销毁 servlet 实例\n\n很明显，JSP 生命周期的四个主要阶段和 servlet 生命周期非常相似，下面给出图示：\n\n\n\n# JSP 编译\n\n当浏览器请求 JSP 页面时，JSP 引擎会首先去检查是否需要编译这个文件。如果这个文件没有被编译过，或者在上次编译后被更改过，则编译这个 JSP 文件。\n\n编译的过程包括三个步骤：\n\n * 解析 JSP 文件。\n * 将 JSP 文件转为 servlet。\n * 编译 servlet。\n\n# JSP 初始化\n\n容器载入 JSP 文件后，它会在为请求提供任何服务前调用 jspInit()方法。如果您需要执行自定义的 JSP 初始化任务，复写 jspInit()方法就行了，就像下面这样：\n\npublic void jspInit(){\n  // 初始化代码\n}\n\n\n一般来讲程序只初始化一次，servlet 也是如此。通常情况下您可以在 jspInit()方法中初始化数据库连接、打开文件和创建查询表。\n\n# JSP 执行\n\n这一阶段描述了 JSP 生命周期中一切与请求相关的交互行为，直到被销毁。\n\n当 JSP 网页完成初始化后，JSP 引擎将会调用 _jspService() 方法。\n\n_jspService() 方法需要一个 HttpServletRequest 对象和一个 HttpServletResponse 对象作为它的参数，就像下面这样：\n\nvoid _jspService(HttpServletRequest request,\n                 HttpServletResponse response) {\n   // 服务端处理代码\n}\n\n\n_jspService() 方法在每个 request 中被调用一次并且负责产生与之相对应的 response，并且它还负责产生所有 7 个 HTTP 方法的回应，比如 GET、POST、DELETE 等等。\n\n# JSP 清理\n\nJSP 生命周期的销毁阶段描述了当一个 JSP 网页从容器中被移除时所发生的一切。\n\njspDestroy()方法在 JSP 中等价于 servlet 中的销毁方法。当您需要执行任何清理工作时复写 jspDestroy()方法，比如释放数据库连接或者关闭文件夹等等。\n\njspDestroy()方法的格式如下：\n\npublic void jspDestroy() {\n   // 清理代码\n}\n\n\n\n# 语法\n\n\n# 脚本\n\n脚本程序可以包含任意量的 Java 语句、变量、方法或表达式，只要它们在脚本语言中是有效的。\n\n脚本程序的语法格式：\n\n<% 代码片段 %>\n\n\n或者，您也可以编写与其等价的 XML 语句，就像下面这样：\n\n<jsp:scriptlet>\n  代码片段\n</jsp:scriptlet>\n\n\n任何文本、HTML 标签、JSP 元素必须写在脚本程序的外面。\n\n下面给出一个示例，同时也是本教程的第一个 JSP 示例：\n\n<html>\n  <head>\n    <title>Hello World</title>\n  </head>\n  <body>\n    Hello World!<br />\n    <% out.println("Your IP address is " + request.getRemoteAddr()); %>\n  </body>\n</html>\n\n\n**注意：**请确保 Apache Tomcat 已经安装在 C:\\apache-tomcat-7.0.2 目录下并且运行环境已经正确设置。\n\n将以上代码保存在 hello.jsp 中，然后将它放置在 C:\\apache-tomcat-7.0.2\\webapps\\ROOT 目录下，打开浏览器并在地址栏中输入 http://localhost:8080/hello.jsp 。运行后得到以下结果：\n\n\n\n# 中文编码问题\n\n如果我们要在页面正常显示中文，我们需要在 JSP 文件头部添加以下代码：<>\n\n<%@ page language="java" contentType="text/html; charset=UTF-8"\npageEncoding="UTF-8"%>\n\n\n接下来我们将以上程序修改为：\n\n<%@ page language="java" contentType="text/html; charset=UTF-8"\npageEncoding="UTF-8"%>\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset="utf-8" />\n    <title>菜鸟教程(runoob.com)</title>\n  </head>\n  <body>\n    Hello World!<br />\n    <% out.println("你的 IP 地址 " + request.getRemoteAddr()); %>\n  </body>\n</html>\n\n\n这样中文就可以正常显示了。\n\n\n# JSP 声明\n\n一个声明语句可以声明一个或多个变量、方法，供后面的 Java 代码使用。在 JSP 文件中，您必须先声明这些变量和方法然后才能使用它们。\n\nJSP 声明的语法格式：\n\n<%! declaration; [ declaration; ]+ ... %>\n\n\n或者，您也可以编写与其等价的 XML 语句，就像下面这样：\n\n<jsp:declaration>\n  代码片段\n</jsp:declaration>\n\n\n程序示例：\n\n<%! int i = 0; %> <%! int a, b, c; %> <%! Circle a = new Circle(2.0); %>\n\n\n\n# JSP 表达式\n\n一个 JSP 表达式中包含的脚本语言表达式，先被转化成 String，然后插入到表达式出现的地方。\n\n由于表达式的值会被转化成 String，所以您可以在一个文本行中使用表达式而不用去管它是否是 HTML 标签。\n\n表达式元素中可以包含任何符合 Java 语言规范的表达式，但是不能使用分号来结束表达式。\n\nJSP 表达式的语法格式：\n\n<%= 表达式 %>\n\n\n同样，您也可以编写与之等价的 XML 语句：\n\n<jsp:expression>\n  表达式\n</jsp:expression>\n\n\n程序示例：\n\n<%@ page language="java" contentType="text/html; charset=UTF-8"\npageEncoding="UTF-8"%>\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset="utf-8" />\n    <title>菜鸟教程(runoob.com)</title>\n  </head>\n  <body>\n    <p>\n      今天的日期是: <%= (new java.util.Date()).toLocaleString()%>\n    </p>\n  </body>\n</html>\n\n\n运行后得到以下结果：\n\n今天的日期是: 2016-6-25 13:40:07\n\n\n----------------------------------------\n\n\n# JSP 注释\n\nJSP 注释主要有两个作用：为代码作注释以及将某段代码注释掉。\n\nJSP 注释的语法格式：\n\n<%@ page language="java" contentType="text/html; charset=UTF-8"\npageEncoding="UTF-8"%>\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset="utf-8" />\n    <title>JSP注释示例</title>\n  </head>\n  <body>\n    <%-- 该部分注释在网页中不会被显示--%>\n    <p>\n      今天的日期是: <%= (new java.util.Date()).toLocaleString()%>\n    </p>\n  </body>\n</html>\n\n\n运行后得到以下结果：\n\n今天的日期是: 2016-6-25 13:41:26\n\n\n不同情况下使用注释的语法规则：\n\n语法             描述\n<%-- 注释 --%>   JSP 注释，注释内容不会被发送至浏览器甚至不会被编译\n\x3c!-- 注释 --\x3e    HTML 注释，通过浏览器查看网页源代码时可以看见注释内容\n<%             代表静态 <% 常量\n%>             代表静态 %> 常量\n\'              在属性中使用的单引号\n"              在属性中使用的双引号\n\n\n# 控制语句\n\nJSP 提供对 Java 语言的全面支持。您可以在 JSP 程序中使用 Java API 甚至建立 Java 代码块，包括判断语句和循环语句等等。\n\n# if…else 语句\n\nIf…else块，请看下面这个例子：\n\n<%@ page language="java" contentType="text/html; charset=UTF-8"\npageEncoding="UTF-8"%> <%! int day = 1; %>\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset="utf-8" />\n    <title>02.JSP语法 - if...else示例</title>\n  </head>\n  <body>\n    <h3>IF...ELSE 实例</h3>\n    <% if (day == 1 | day == 7) { %>\n    <p>今天是周末</p>\n    <% } else { %>\n    <p>今天不是周末</p>\n    <% } %>\n  </body>\n</html>\n\n\n运行后得到以下结果：\n\nIF...ELSE 实例\n今天不是周末\n\n\n# switch…case 语句\n\n现在来看看 switch…case 块，与 if…else 块有很大的不同，它使用 out.println()，并且整个都装在脚本程序的标签中，就像下面这样：\n\n<%@ page language="java" contentType="text/html; charset=UTF-8"\npageEncoding="UTF-8"%> <%! int day = 3; %>\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset="utf-8" />\n    <title>02.JSP语法 - switch...case示例</title>\n  </head>\n  <body>\n    <h3>Sswitch...case示例</h3>\n    <% switch(day) { case 0: out.println("星期天"); break; case 1:\n    out.println("星期一"); break; case 2: out.println("星期二"); break; case 3:\n    out.println("星期三"); break; case 4: out.println("星期四"); break; case 5:\n    out.println("星期五"); break; default: out.println("星期六"); } %>\n  </body>\n</html>\n\n\n浏览器访问，运行后得出以下结果：\n\nSWITCH...CASE 实例\n\n星期三\n\n\n# 循环语句\n\n在 JSP 程序中可以使用 Java 的三个基本循环类型：for，while，和 do…while。\n\n让我们来看看 for 循环的例子，以下输出的不同字体大小的"菜鸟教程"：\n\n<%@ page language="java" contentType="text/html; charset=UTF-8"\npageEncoding="UTF-8"%> <%! int fontSize; %>\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset="utf-8" />\n    <title>菜鸟教程(runoob.com)</title>\n  </head>\n  <body>\n    <h3>For 循环实例</h3>\n    <%for ( fontSize = 1; fontSize <= 3; fontSize++){ %>\n    <font color="green" size="<%= fontSize %>">\n      菜鸟教程 </font\n    ><br />\n    <%}%>\n  </body>\n</html>\n\n\n运行后得到以下结果：\n\n\n\n将上例改用 while 循环来写：\n\n<%@ page language="java" contentType="text/html; charset=UTF-8"\npageEncoding="UTF-8"%> <%! int fontSize; %>\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset="utf-8" />\n    <title>菜鸟教程(runoob.com)</title>\n  </head>\n  <body>\n    <h3>While 循环实例</h3>\n    <%while ( fontSize <= 3){ %>\n    <font color="green" size="<%= fontSize %>">\n      菜鸟教程 </font\n    ><br />\n    <%fontSize++;%> <%}%>\n  </body>\n</html>\n\n\n浏览器访问，输出结果为（fontSize 初始化为 0，所以多输出了一行）：\n\n\n\nJSP 运算符\n\nJSP 支持所有 Java 逻辑和算术运算符。\n\n下表罗列出了 JSP 常见运算符，优先级从高到底：\n\n类别      操作符                                   结合性\n后缀      () [] . (点运算符)                        左到右\n一元      ++ - - ! ~                            右到左\n可乘性     * / %                                 左到右\n可加性     + -                                   左到右\n移位      >> >>> <<                             左到右\n关系      > >= < <=                             左到右\n相等/不等   == !=                                 左到右\n位与      &                                     左到右\n位异或     ^                                     左到右\n位或      |                                     左到右\n逻辑与     &&                                    左到右\n逻辑或     | |                                   左到右\n条件判断    ?:                                    右到左\n赋值      = += -= \\*= /= %= >>= <<= &= ^= | =   右到左\n逗号      ,                                     左到右\n\n\n# JSP 字面量\n\nJSP 语言定义了以下几个字面量：\n\n * 布尔值(boolean)：true 和 false;\n * 整型(int)：与 Java 中的一样;\n * 浮点型(float)：与 Java 中的一样;\n * 字符串(string)：以单引号或双引号开始和结束;\n * Null：null。\n\n\n# 指令\n\nJSP 指令用来设置整个 JSP 页面相关的属性，如网页的编码方式和脚本语言。\n\nJSP 指令以开<%@开始，以%>结束。\n\nJSP 指令语法格式如下：\n\n<%@ directive attribute="value" %>\n\n\n指令可以有很多个属性，它们以键值对的形式存在，并用逗号隔开。\n\nJSP 中的三种指令标签：\n\n指令                   描述\n<%@ page ... %>      定义网页依赖属性，比如脚本语言、error 页面、缓存需求等等\n<%@ include ... %>   包含其他文件\n<%@ taglib ... %>    引入标签库的定义，可以是自定义标签\n\n\n# Page 指令\n\nPage 指令为容器提供当前页面的使用说明。一个 JSP 页面可以包含多个page指令。\n\nPage 指令的语法格式：\n\n<%@ page attribute="value" %>\n\n\n等价的 XML 格式：\n\n<jsp:directive.page attribute="value" />\n\n\n例：\n\n<%@ page language="java" contentType="text/html; charset=UTF-8"\npageEncoding="UTF-8" %>\n\n\n# 属性\n\n下表列出与 Page 指令相关的属性：\n\n属性                   描述\nbuffer               指定 out 对象使用缓冲区的大小\nautoFlush            控制 out 对象的 缓存区\ncontentType          指定当前 JSP 页面的 MIME 类型和字符编码\nerrorPage            指定当 JSP 页面发生异常时需要转向的错误处理页面\nisErrorPage          指定当前页面是否可以作为另一个 JSP 页面的错误处理页面\nextends              指定 servlet 从哪一个类继承\nimport               导入要使用的 Java 类\ninfo                 定义 JSP 页面的描述信息\nisThreadSafe         指定对 JSP 页面的访问是否为线程安全\nlanguage             定义 JSP 页面所用的脚本语言，默认是 Java\nsession              指定 JSP 页面是否使用 session\nisELIgnored          指定是否执行 EL 表达式\nisScriptingEnabled   确定脚本元素能否被使用\n\n\n# Include 指令\n\nJSP 可以通过include指令来包含其他文件。\n\n被包含的文件可以是 JSP 文件、HTML 文件或文本文件。包含的文件就好像是该 JSP 文件的一部分，会被同时编译执行。\n\nInclude 指令的语法格式如下：\n\n<%@ include file="文件相对 url 地址" %>\n\n\ninclude 指令中的文件名实际上是一个相对的 URL 地址。\n\n如果您没有给文件关联一个路径，JSP 编译器默认在当前路径下寻找。\n\n等价的 XML 语法：\n\n<jsp:directive.include file="文件相对 url 地址" />\n\n\n\n# Taglib 指令\n\nJSP 允许用户自定义标签，一个自定义标签库就是自定义标签的集合。\n\ntaglib指令引入一个自定义标签集合的定义，包括库路径、自定义标签。\n\ntaglib指令的语法：\n\n<%@ taglib uri="uri" prefix="prefixOfTag" %>\n\n\nuri 属性确定标签库的位置，prefix 属性指定标签库的前缀。\n\n等价的 XML 语法：\n\n<jsp:directive.taglib uri="uri" prefix="prefixOfTag" />\n\n\n\n# JSP 动作元素\n\nJSP 动作元素是一组 JSP 内置的标签，只需要书写很少的标记代码就能使用 JSP 提供的丰富功能。JSP 动作元素是对常用的 JSP 功能的抽象与封装，包括两种，自定义 JSP 动作元素与标准 JSP 动作元素。\n\n与 JSP 指令元素不同的是，JSP 动作元素在请求处理阶段起作用。JSP 动作元素是用 XML 语法写成的。\n\n利用 JSP 动作可以动态地插入文件、重用 JavaBean 组件、把用户重定向到另外的页面、为 Java 插件生成 HTML 代码。\n\n动作元素只有一种语法，它符合 XML 标准：\n\n<jsp:action_name attribute="value" />\n\n\n动作元素基本上都是预定义的函数，JSP 规范定义了一系列的标准动作，它用 JSP 作为前缀，可用的标准动作元素如下：\n\n语法                描述\njsp:include       在页面被请求的时候引入一个文件。\njsp:useBean       寻找或者实例化一个 JavaBean。\njsp:setProperty   设置 JavaBean 的属性。\njsp:getProperty   输出某个 JavaBean 的属性。\njsp:forward       把请求转到一个新的页面。\njsp:plugin        根据浏览器类型为 Java 插件生成 OBJECT 或 EMBED 标记。\njsp:element       定义动态 XML 元素\njsp:attribute     设置动态定义的 XML 元素属性。\njsp:body          设置动态定义的 XML 元素内容。\njsp:text          在 JSP 页面和文档中使用写入文本的模板\n\n\n# 常见的属性\n\n所有的动作要素都有两个属性：id 属性和 scope 属性。\n\n * **id 属性：**id 属性是动作元素的唯一标识，可以在 JSP 页面中引用。动作元素创建的 id 值可以通过 PageContext 来调用。\n * **scope 属性：**该属性用于识别动作元素的生命周期。 id 属性和 scope 属性有直接关系，scope 属性定义了相关联 id 对象的寿命。 scope 属性有四个可能的值： (a) page, (b)request, (c)session, 和 (d) application。\n\n\n# <jsp:include>\n\n<jsp:include> 用来包含静态和动态的文件。该动作把指定文件插入正在生成的页面。\n\n如果被包含的文件为 JSP 程序，则会先执行 JSP 程序，再将执行结果包含进来。\n\n语法格式如下：\n\n<jsp:include page="相对 URL 地址" flush="true" />\n\n\n前面已经介绍过 include 指令，它是在 JSP 文件被转换成 Servlet 的时候引入文件，而这里的 jsp:include 动作不同，插入文件的时间是在页面被请求的时候。\n\n以下是 include 动作相关的属性列表。\n\n属性      描述\npage    包含在页面中的相对 URL 地址。\nflush   布尔属性，定义在包含资源前是否刷新缓存区。\n\n示例：\n\n以下我们定义了两个文件 date.jsp 和 main.jsp，代码如下所示：\n\ndate.jsp 文件代码：\n\n<%@ page language="java" contentType="text/html; charset=UTF-8"\npageEncoding="UTF-8"%>\n<p>\n  今天的日期是: <%= (new java.util.Date())%>\n</p>\n\n\nmain.jsp 文件代码：\n\n<%@ page language="java" contentType="text/html; charset=UTF-8"\npageEncoding="UTF-8"%>\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset="utf-8" />\n    <title>菜鸟教程(runoob.com)</title>\n  </head>\n  <body>\n    <h2>include 动作实例</h2>\n    <jsp:include page="date.jsp" flush="true" />\n  </body>\n</html>\n\n\n现在将以上两个文件放在服务器的根目录下，访问 main.jsp 文件。显示结果如下：\n\ninclude 动作实例\n\n今天的日期是: 2016-6-25 14:08:17\n\n\n\n# <jsp:useBean>\n\njsp:useBean 动作用来加载一个将在 JSP 页面中使用的 JavaBean。\n\n这个功能非常有用，因为它使得我们可以发挥 Java 组件复用的优势。\n\njsp:useBean 动作最简单的语法为：\n\n<jsp:useBean id="name" class="package.class" />\n\n\n在类载入后，我们既可以通过 jsp:setProperty 和 jsp:getProperty 动作来修改和检索 bean 的属性。\n\n以下是 useBean 动作相关的属性列表。\n\n属性         描述\nclass      指定 Bean 的完整包名。\ntype       指定将引用该对象变量的类型。\nbeanName   通过 java.beans.Beans 的 instantiate() 方法指定 Bean 的名字。\n\n在给出具体实例前，让我们先来看下 jsp:setProperty 和 jsp:getProperty 动作元素：\n\n\n# <jsp:setProperty>\n\njsp:setProperty 用来设置已经实例化的 Bean 对象的属性，有两种用法。首先，你可以在 jsp:useBean 元素的外面（后面）使用 jsp:setProperty，如下所示：\n\n<jsp:useBean id="myName" ... />\n...\n<jsp:setProperty name="myName" property="someProperty" .../>\n\n\n此时，不管 jsp:useBean 是找到了一个现有的 Bean，还是新创建了一个 Bean 实例，jsp:setProperty 都会执行。第二种用法是把 jsp:setProperty 放入 jsp:useBean 元素的内部，如下所示：\n\n<jsp:useBean id="myName" ... >\n...\n   <jsp:setProperty name="myName" property="someProperty" .../>\n</jsp:useBean>\n\n\n此时，jsp:setProperty 只有在新建 Bean 实例时才会执行，如果是使用现有实例则不执行 jsp:setProperty。\n\njsp:setProperty 动作有下面四个属性,如下表：\n\n属性         描述\nname       name 属性是必需的。它表示要设置属性的是哪个 Bean。\nproperty   property 属性是必需的。它表示要设置哪个属性。有一个特殊用法：如果 property\n           的值是"*"，表示所有名字和 Bean 属性名字匹配的请求参数都将被传递给相应的属性 set 方法。\nvalue      value 属性是可选的。该属性用来指定 Bean 属性的值。字符串数据会在目标类中通过标准的 valueOf\n           方法自动转换成数字、boolean、Boolean、\n           byte、Byte、char、Character。例如，boolean 和 Boolean\n           类型的属性值（比如"true"）通过 Boolean.valueOf 转换，int 和 Integer\n           类型的属性值（比如"42"）通过 Integer.valueOf 转换。 　　 value 和 param\n           不能同时使用，但可以使用其中任意一个。\nparam      param 是可选的。它指定用哪个请求参数作为 Bean 属性的值。如果当前请求没有参数，则什么事情也不做，系统不会把\n           null 传递给 Bean 属性的 set 方法。因此，你可以让 Bean\n           自己提供默认属性值，只有当请求参数明确指定了新值时才修改默认属性值。\n\n\n# <jsp:getProperty>\n\njsp:getProperty 动作提取指定 Bean 属性的值，转换成字符串，然后输出。语法格式如下：\n\n<jsp:useBean id="myName" ... />\n...\n<jsp:getProperty name="myName" property="someProperty" .../>\n\n\n下表是与 getProperty 相关联的属性：\n\n属性         描述\nname       要检索的 Bean 属性名称。Bean 必须已定义。\nproperty   表示要提取 Bean 属性的值\n\n实例\n\n以下实例我们使用了 Bean:\n\npackage com.runoob.main;\n\npublic class TestBean {\n   private String message = "菜鸟教程";\n\n   public String getMessage() {\n      return(message);\n   }\n   public void setMessage(String message) {\n      this.message = message;\n   }\n}\n\n\n编译以上实例文件 TestBean.java ：\n\n$ javac TestBean.java\n\n\n编译完成后会在当前目录下生成一个 TestBean.class 文件， 将该文件拷贝至当前 JSP 项目的 WebContent/WEB-INF/classes/com/runoob/main 下( com/runoob/main 包路径，没有需要手动创建)。\n\n下面是一个 Eclipse 中目录结构图：\n\n\n\n下面是一个很简单的例子，它的功能是装载一个 Bean，然后设置/读取它的 message 属性。\n\n现在让我们在 main.jsp 文件中调用该 Bean:\n\n<%@ page language="java" contentType="text/html; charset=UTF-8"\npageEncoding="UTF-8"%>\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset="utf-8" />\n    <title>菜鸟教程(runoob.com)</title>\n  </head>\n  <body>\n    <h2>Jsp 使用 JavaBean 实例</h2>\n    <jsp:useBean id="test" class="com.runoob.main.TestBean" />\n\n    <jsp:setProperty name="test" property="message" value="菜鸟教程..." />\n\n    <p>输出信息....</p>\n\n    <jsp:getProperty name="test" property="message" />\n  </body>\n</html>\n\n\n浏览器访问，执行以上文件，输出如下所示：\n\n\n\n\n# <jsp:forward>\n\njsp:forward 动作把请求转到另外的页面。jsp:forward 标记只有一个属性 page。语法格式如下所示：\n\n<jsp:forward page="相对 URL 地址" />\n\n\n以下是 forward 相关联的属性：\n\n属性     描述\npage   page 属性包含的是一个相对 URL。page 的值既可以直接给出，也可以在请求的时候动态计算，可以是一个 JSP\n       页面或者一个 Java Servlet.\n\n实例\n\n以下实例我们使用了两个文件，分别是： date.jsp 和 main.jsp。\n\ndate.jsp 文件代码如下：\n\n<%@ page language="java" contentType="text/html; charset=UTF-8"\npageEncoding="UTF-8"%>\n<p>\n  今天的日期是: <%= (new java.util.Date()).toLocaleString()%>\n</p>\n\n\nmain.jsp 文件代码：\n\n<%@ page language="java" contentType="text/html; charset=UTF-8"\npageEncoding="UTF-8"%>\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset="utf-8" />\n    <title>菜鸟教程(runoob.com)</title>\n  </head>\n  <body>\n    <h2>forward 动作实例</h2>\n    <jsp:forward page="date.jsp" />\n  </body>\n</html>\n\n\n现在将以上两个文件放在服务器的根目录下，访问 main.jsp 文件。显示结果如下：\n\n今天的日期是: 2016-6-25 14:37:25\n\n\n\n# <jsp:plugin>\n\njsp:plugin 动作用来根据浏览器的类型，插入通过 Java 插件 运行 Java Applet 所必需的 OBJECT 或 EMBED 元素。\n\n如果需要的插件不存在，它会下载插件，然后执行 Java 组件。 Java 组件可以是一个 applet 或一个 JavaBean。\n\nplugin 动作有多个对应 HTML 元素的属性用于格式化 Java 组件。param 元素可用于向 Applet 或 Bean 传递参数。\n\n以下是使用 plugin 动作元素的典型实例:\n\n<jsp:plugin type="applet" codebase="dirname" code="MyApplet.class"\n                           width="60" height="80">\n   <jsp:param name="fontcolor" value="red" />\n   <jsp:param name="background" value="black" />\n\n   <jsp:fallback>\n      Unable to initialize Java Plugin\n   </jsp:fallback>\n\n</jsp:plugin>\n\n\n如果你有兴趣可以尝试使用 applet 来测试 jsp:plugin 动作元素，<fallback> 元素是一个新元素，在组件出现故障的错误是发送给用户错误信息。\n\n\n# <jsp:element> 、 <jsp:attribute>、<jsp:body>\n\n<jsp:element> 、 <jsp:attribute>、<jsp:body> 动作元素动态定义 XML 元素。动态是非常重要的，这就意味着 XML 元素在编译时是动态生成的而非静态。\n\n以下实例动态定义了 XML 元素：\n\n<%@ page language="java" contentType="text/html; charset=UTF-8"\npageEncoding="UTF-8"%>\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset="utf-8" />\n    <title>菜鸟教程(runoob.com)</title>\n  </head>\n  <body>\n    <jsp:element name="xmlElement">\n      <jsp:attribute name="xmlElementAttr">\n        属性值\n      </jsp:attribute>\n      <jsp:body>\n        XML 元素的主体\n      </jsp:body>\n    </jsp:element>\n  </body>\n</html>\n\n\n浏览器访问以下页面，输出结果如下所示：\n\n\n\n\n# <jsp:text>\n\njsp:text动作元素允许在 JSP 页面和文档中使用写入文本的模板，语法格式如下：\n\n<jsp:text>模板数据</jsp:text>\n\n\n以上文本模板不能包含其他元素，只能只能包含文本和 EL 表达式（注：EL 表达式将在后续章节中介绍）。请注意，在 XML 文件中，您不能使用表达式如 ${whatever > 0}，因为>符号是非法的。 你可以使用 ${whatever gt 0}表达式或者嵌入在一个 CDATA 部分的值。\n\n<jsp:text><![CDATA[<br>]]></jsp:text>\n\n\n如果你需要在 XHTML 中声明 DOCTYPE,必须使用到 <jsp:text> 动作元素，实例如下：\n\n<jsp:text><![CDATA[<!DOCTYPE html\nPUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"\n"DTD/xhtml1-strict.dtd">]]>\n</jsp:text>\n<head><title>jsp:text action</title></head>\n<body>\n\n<books><book><jsp:text>\n    Welcome to JSP Programming\n</jsp:text></book></books>\n\n</body>\n</html>\n\n\n你可以对以上实例尝试使用jsp:text及不使用该动作元素执行结果的区别。\n\n\n# JSP 隐式对象\n\nJSP 隐式对象是 JSP 容器为每个页面提供的 Java 对象，开发者可以直接使用它们而不用显式声明。JSP 隐式对象也被称为预定义变量。\n\nJSP 所支持的九大隐式对象：\n\n对象            描述\nrequest       HttpServletRequest类的实例\nresponse      HttpServletResponse类的实例\nout           PrintWriter类的实例，用于把结果输出至网页上\nsession       HttpSession类的实例\napplication   ServletContext类的实例，与应用上下文有关\nconfig        ServletConfig类的实例\npageContext   PageContext类的实例，提供对 JSP 页面所有对象以及命名空间的访问\npage          类似于 Java 类中的 this 关键字\nException     Exception类的对象，代表发生错误的 JSP 页面中对应的异常对象\n\n\n# request 对象\n\nrequest对象是javax.servlet.http.HttpServletRequest 类的实例。\n\n每当客户端请求一个 JSP 页面时，JSP 引擎就会制造一个新的request对象来代表这个请求。\n\nrequest对象提供了一系列方法来获取 HTTP 头信息，cookies，HTTP 方法等等。\n\n\n# response 对象\n\nresponse对象是javax.servlet.http.HttpServletResponse类的实例。\n\n当服务器创建request对象时会同时创建用于响应这个客户端的response对象。\n\nresponse对象也定义了处理 HTTP 头模块的接口。通过这个对象，开发者们可以添加新的 cookies，时间戳，HTTP 状态码等等。\n\n\n# out 对象\n\nout对象是javax.servlet.jsp.JspWriter类的实例，用来在response对象中写入内容。\n\n最初的JspWriter类对象根据页面是否有缓存来进行不同的实例化操作。可以在page指令中使用buffered=\'false\'属性来轻松关闭缓存。\n\nJspWriter类包含了大部分java.io.PrintWriter类中的方法。不过，JspWriter新增了一些专为处理缓存而设计的方法。还有就是，JspWriter类会抛出IOExceptions异常，而PrintWriter不会。\n\n下表列出了我们将会用来输出boolean，char，int，double，String，object等类型数据的重要方法：\n\n方法                         描述\nout.print(dataType dt)     输出 Type 类型的值\nout.println(dataType dt)   输出 Type 类型的值然后换行\nout.flush()                刷新输出流\n\n\n# session 对象\n\nsession对象是javax.servlet.http.HttpSession类的实例。和 Java Servlets 中的session对象有一样的行为。\n\nsession对象用来跟踪在各个客户端请求间的会话。\n\n\n# application 对象\n\napplication对象直接包装了 servlet 的ServletContext类的对象，是javax.servlet.ServletContext类的实例。\n\n这个对象在 JSP 页面的整个生命周期中都代表着这个 JSP 页面。这个对象在 JSP 页面初始化时被创建，随着jspDestroy()方法的调用而被移除。\n\n通过向application中添加属性，则所有组成您 web 应用的 JSP 文件都能访问到这些属性。\n\n\n# config 对象\n\nconfig对象是javax.servlet.ServletConfig类的实例，直接包装了 servlet 的ServletConfig类的对象。\n\n这个对象允许开发者访问 Servlet 或者 JSP 引擎的初始化参数，比如文件路径等。\n\n以下是 config 对象的使用方法，不是很重要，所以不常用：\n\nconfig.getServletName();\n\n\n它返回包含在<servlet-name>元素中的 servlet 名字，注意，<servlet-name>元素在WEB-INF\\web.xml文件中定义。\n\n\n# pageContext 对象\n\npageContext对象是javax.servlet.jsp.PageContext类的实例，用来代表整个 JSP 页面。\n\n这个对象主要用来访问页面信息，同时过滤掉大部分实现细节。\n\n这个对象存储了request对象和response对象的引用。application对象，config对象，session对象，out对象可以通过访问这个对象的属性来导出。\n\npageContext对象也包含了传给 JSP 页面的指令信息，包括缓存信息，ErrorPage URL,页面 scope 等。\n\nPageContext类定义了一些字段，包括 PAGE_SCOPE，REQUEST_SCOPE，SESSION_SCOPE， APPLICATION_SCOPE。它也提供了 40 余种方法，有一半继承自javax.servlet.jsp.JspContext 类。\n\n其中一个重要的方法就是removeArribute()，它可接受一个或两个参数。比如，pageContext.removeArribute("attrName")移除四个 scope 中相关属性，但是下面这种方法只移除特定 scope 中的相关属性：\n\npageContext.removeAttribute("attrName", PAGE_SCOPE);\n\n\n\n# page 对象\n\n这个对象就是页面实例的引用。它可以被看做是整个 JSP 页面的代表。\n\npage对象就是this对象的同义词。\n\n\n# exception 对象\n\nexception对象包装了从先前页面中抛出的异常信息。它通常被用来产生对出错条件的适当响应。\n\n\n# EL 表达式\n\nEL 表达式是用${}括起来的脚本，用来更方便地读取对象。EL 表达式写在 JSP 的 HTML 代码中，而不能写在<%与%>引起的 JSP 脚本中。\n\nJSP 表达式语言（EL）使得访问存储在 JavaBean 中的数据变得非常简单。JSP EL 既可以用来创建算术表达式也可以用来创建逻辑表达式。在 JSP EL 表达式内可以使用整型数，浮点数，字符串，常量 true、false，还有 null。\n\n\n# 一个简单的语法\n\n典型的，当您需要在 JSP 标签中指定一个属性值时，只需要简单地使用字符串即可：\n\n<jsp:setProperty name="box" property="perimeter" value="100" />\n\n\nJSP EL 允许您指定一个表达式来表示属性值。一个简单的表达式语法如下：\n\n${expr}\n\n\n其中，expr 指的是表达式。在 JSP EL 中通用的操作符是"."和"[]"。这两个操作符允许您通过内嵌的 JSP 对象访问各种各样的 JavaBean 属性。\n\n举例来说，上面的 <jsp:setProperty> 标签可以使用表达式语言改写成如下形式：\n\n<jsp:setProperty\n  name="box"\n  property="perimeter"\n  value="${2*box.width+2*box.height}"\n/>\n\n\n当 JSP 编译器在属性中见到"${}"格式后，它会产生代码来计算这个表达式，并且产生一个替代品来代替表达式的值。\n\n您也可以在标签的模板文本中使用表达式语言。比如 <jsp:text> 标签简单地将其主体中的文本插入到 JSP 输出中：\n\n<jsp:text>\n  <h1>Hello JSP!</h1>\n</jsp:text>\n\n\n现在，在jsp:text标签主体中使用表达式，就像这样：\n\n<jsp:text>\n  Box Perimeter is: ${2*box.width + 2*box.height}\n</jsp:text>\n\n\n在 EL 表达式中可以使用圆括号来组织子表达式。比如 ${(1 + 2) _ 3} 等于 9，但是 ${1 + (2 _ 3)} 等于 7。\n\n想要停用对 EL 表达式的评估的话，需要使用 page 指令将 isELIgnored 属性值设为 true：\n\n<%@ page isELIgnored ="true|false" %>\n\n\n这样，EL 表达式就会被忽略。若设为 false，则容器将会计算 EL 表达式。\n\n\n# EL 中的基础操作符\n\nEL 表达式支持大部分 Java 所提供的算术和逻辑操作符：\n\n操作符         描述\n.           访问一个 Bean 属性或者一个映射条目\n[]          访问一个数组或者链表的元素\n( )         组织一个子表达式以改变优先级\n+           加\n-           减或负\n*           乘\n/ or div    除\n% or mod    取模\n== or eq    测试是否相等\n!= or ne    测试是否不等\n< or lt     测试是否小于\n> or gt     测试是否大于\n<= or le    测试是否小于等于\n>= or ge    测试是否大于等于\n&& or and   测试逻辑与\n|| or or    测试逻辑或\n! or not    测试取反\nempty       测试是否空值\n\n\n# JSP EL 中的函数\n\nJSP EL 允许您在表达式中使用函数。这些函数必须被定义在自定义标签库中。函数的使用语法如下：\n\n${ns:func(param1, param2, ...)}\n\n\nns 指的是命名空间（namespace），func 指的是函数的名称，param1 指的是第一个参数，param2 指的是第二个参数，以此类推。比如，有函数 fn:length，在 JSTL 库中定义，可以像下面这样来获取一个字符串的长度：\n\n${fn:length("Get my length")}\n\n\n要使用任何标签库中的函数，您需要将这些库安装在服务器中，然后使用 <taglib> 标签在 JSP 文件中包含这些库。\n\n\n# JSP EL 隐含对象\n\nJSP EL 支持下表列出的隐含对象：\n\n隐含对象               描述\npageScope          page 作用域\nrequestScope       request 作用域\nsessionScope       session 作用域\napplicationScope   application 作用域\nparam              Request 对象的参数，字符串\nparamValues        Request 对象的参数，字符串集合\nheader             HTTP 信息头，字符串\nheaderValues       HTTP 信息头，字符串集合\ninitParam          上下文初始化参数\ncookie             Cookie 值\npageContext        当前页面的 pageContext\n\n您可以在表达式中使用这些对象，就像使用变量一样。接下来会给出几个例子来更好的理解这个概念。\n\n\n# pageContext 对象\n\npageContext 对象是 JSP 中 pageContext 对象的引用。通过 pageContext 对象，您可以访问 request 对象。比如，访问 request 对象传入的查询字符串，就像这样：\n\n${pageContext.request.queryString}\n\n\n\n# Scope 对象\n\npageScope，requestScope，sessionScope，applicationScope 变量用来访问存储在各个作用域层次的变量。\n\n举例来说，如果您需要显式访问在 applicationScope 层的 box 变量，可以这样来访问：applicationScope.box。\n\n\n# param 和 paramValues 对象\n\nparam 和 paramValues 对象用来访问参数值，通过使用 request.getParameter 方法和 request.getParameterValues 方法。\n\n举例来说，访问一个名为 order 的参数，可以这样使用表达式：${param.order}，或者${param["order"]}。\n\n接下来的例子表明了如何访问 request 中的 username 参数：\n\n<%@ page import="java.io.*,java.util.*" %> <% String title = "Accessing Request\nParam"; %>\n<html>\n  <head>\n    <title><% out.print(title); %></title>\n  </head>\n  <body>\n    <center>\n      <h1><% out.print(title); %></h1>\n    </center>\n    <div align="center">\n      <p>${param["username"]}</p>\n    </div>\n  </body>\n</html>\n\n\nparam 对象返回单一的字符串，而 paramValues 对象则返回一个字符串数组。\n\n\n# header 和 headerValues 对象\n\nheader 和 headerValues 对象用来访问信息头，通过使用 request.getHeader 方法和 request.getHeaders 方法。\n\n举例来说，要访问一个名为 user-agent 的信息头，可以这样使用表达式：${header.user-agent}，或者 ${header["user-agent"]}。\n\n接下来的例子表明了如何访问 user-agent 信息头：\n\n<%@ page import="java.io.*,java.util.*" %> <% String title = "User Agent\nExample"; %>\n<html>\n  <head>\n    <title><% out.print(title); %></title>\n  </head>\n  <body>\n    <center>\n      <h1><% out.print(title); %></h1>\n    </center>\n    <div align="center">\n      <p>${header["user-agent"]}</p>\n    </div>\n  </body>\n</html>\n\n\n运行结果如下：\n\n\n\nheader 对象返回单一值，而 headerValues 则返回一个字符串数组。\n\n\n# JSTL\n\nJSP 标准标签库（JSTL）是一个 JSP 标签集合，它封装了 JSP 应用的通用核心功能。\n\nJSTL 支持通用的、结构化的任务，比如迭代，条件判断，XML 文档操作，国际化标签，SQL 标签。 除了这些，它还提供了一个框架来使用集成 JSTL 的自定义标签。\n\n根据 JSTL 标签所提供的功能，可以将其分为 5 个类别。\n\n * 核心标签\n * 格式化标签\n * SQL 标签\n * XML 标签\n * JSTL 函数\n\n\n# JSTL 库安装\n\nApache Tomcat 安装 JSTL 库步骤如下：\n\n从 Apache 的标准标签库中下载的二进包(jakarta-taglibs-standard-current.zip)。\n\n * 官方下载地址：http://archive.apache.org/dist/jakarta/taglibs/standard/binaries/\n * 本站下载地址：jakarta-taglibs-standard-1.1.2.zip\n\n下载 jakarta-taglibs-standard-1.1.2.zip 包并解压，将 jakarta-taglibs-standard-1.1.2/lib/ 下的两个 jar 文件：standard.jar 和 jstl.jar 文件拷贝到 /WEB-INF/lib/ 下。\n\n将 tld 下的需要引入的 tld 文件复制到 WEB-INF 目录下。\n\n接下来我们在 web.xml 文件中添加以下配置：\n\n<?xml version="1.0" encoding="UTF-8"?>\n<web-app\n  version="2.4"\n  xmlns="http://java.sun.com/xml/ns/j2ee"\n  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n  xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee\n        http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"\n>\n  <jsp-config>\n    <taglib>\n      <taglib-uri>http://java.sun.com/jsp/jstl/fmt</taglib-uri>\n      <taglib-location>/WEB-INF/fmt.tld</taglib-location>\n    </taglib>\n    <taglib>\n      <taglib-uri>http://java.sun.com/jsp/jstl/fmt-rt</taglib-uri>\n      <taglib-location>/WEB-INF/fmt-rt.tld</taglib-location>\n    </taglib>\n    <taglib>\n      <taglib-uri>http://java.sun.com/jsp/jstl/core</taglib-uri>\n      <taglib-location>/WEB-INF/c.tld</taglib-location>\n    </taglib>\n    <taglib>\n      <taglib-uri>http://java.sun.com/jsp/jstl/core-rt</taglib-uri>\n      <taglib-location>/WEB-INF/c-rt.tld</taglib-location>\n    </taglib>\n    <taglib>\n      <taglib-uri>http://java.sun.com/jsp/jstl/sql</taglib-uri>\n      <taglib-location>/WEB-INF/sql.tld</taglib-location>\n    </taglib>\n    <taglib>\n      <taglib-uri>http://java.sun.com/jsp/jstl/sql-rt</taglib-uri>\n      <taglib-location>/WEB-INF/sql-rt.tld</taglib-location>\n    </taglib>\n    <taglib>\n      <taglib-uri>http://java.sun.com/jsp/jstl/x</taglib-uri>\n      <taglib-location>/WEB-INF/x.tld</taglib-location>\n    </taglib>\n    <taglib>\n      <taglib-uri>http://java.sun.com/jsp/jstl/x-rt</taglib-uri>\n      <taglib-location>/WEB-INF/x-rt.tld</taglib-location>\n    </taglib>\n  </jsp-config>\n</web-app>\n\n\n使用任何库，你必须在每个 JSP 文件中的头部包含 <taglib> 标签。\n\n\n# 核心标签\n\n核心标签是最常用的 JSTL 标签。引用核心标签库的语法如下：\n\n<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>\n\n\n标签              描述\n<c:out>         用于在 JSP 中显示数据，就像<%= ... >\n<c:set>         用于保存数据\n<c:remove>      用于删除数据\n<c:catch>       用来处理产生错误的异常状况，并且将错误信息储存起来\n<c:if>          与我们在一般程序中用的 if 一样\n<c:choose>      本身只当做 <c:when> 和 <c:otherwise> 的父标签\n<c:when>        <c:choose> 的子标签，用来判断条件是否成立\n<c:otherwise>   <c:choose> 的子标签，接在 <c:when> 标签后，当 <c:when> 标签判断为 false 时被执行\n<c:import>      检索一个绝对或相对 URL，然后将其内容暴露给页面\n<c:forEach>     基础迭代标签，接受多种集合类型\n<c:forTokens>   根据指定的分隔符来分隔内容并迭代输出\n<c:param>       用来给包含或重定向的页面传递参数\n<c:redirect>    重定向至一个新的 URL.\n<c:url>         使用可选的查询参数来创造一个 URL\n\n\n# 格式化标签\n\nJSTL 格式化标签用来格式化并输出文本、日期、时间、数字。引用格式化标签库的语法如下：\n\n<%@ taglib prefix="fmt" uri="http://java.sun.com/jsp/jstl/fmt" %>\n\n\n标签                      描述\n<fmt:formatNumber>      使用指定的格式或精度格式化数字\n<fmt:parseNumber>       解析一个代表着数字，货币或百分比的字符串\n<fmt:formatDate>        使用指定的风格或模式格式化日期和时间\n<fmt:parseDate>         解析一个代表着日期或时间的字符串\n<fmt:bundle>            绑定资源\n<fmt:setLocale>         指定地区\n<fmt:setBundle>         绑定资源\n<fmt:timeZone>          指定时区\n<fmt:setTimeZone>       指定时区\n<fmt:message>           显示资源配置文件信息\n<fmt:requestEncoding>   设置 request 的字符编码\n\n\n# SQL 标签\n\nJSTL SQL 标签库提供了与关系型数据库（Oracle，MySQL，SQL Server 等等）进行交互的标签。引用 SQL 标签库的语法如下：\n\n<%@ taglib prefix="sql" uri="http://java.sun.com/jsp/jstl/sql" %>\n\n\n标签                    描述\n<sql:setDataSource>   指定数据源\n<sql:query>           运行 SQL 查询语句\n<sql:update>          运行 SQL 更新语句\n<sql:param>           将 SQL 语句中的参数设为指定值\n<sql:dateParam>       将 SQL 语句中的日期参数设为指定的 java.util.Date 对象值\n<sql:transaction>     在共享数据库连接中提供嵌套的数据库行为元素，将所有语句以一个事务的形式来运行\n\n\n# XML 标签\n\nJSTL XML 标签库提供了创建和操作 XML 文档的标签。引用 XML 标签库的语法如下：\n\n<%@ taglib prefix="x" uri="http://java.sun.com/jsp/jstl/xml" %>\n\n\n在使用 xml 标签前，你必须将 XML 和 XPath 的相关包拷贝至你的 <Tomcat 安装目录>\\lib 下:\n\n * XercesImpl.jar\n   \n   下载地址： http://www.apache.org/dist/xerces/j/\n\n * xalan.jar\n   \n   下载地址： http://xml.apache.org/xalan-j/index.html\n\n标签              描述\n<x:out>         与 <%= ... >,类似，不过只用于 XPath 表达式\n<x:parse>       解析 XML 数据\n<x:set>         设置 XPath 表达式\n<x:if>          判断 XPath 表达式，若为真，则执行本体中的内容，否则跳过本体\n<x:forEach>     迭代 XML 文档中的节点\n<x:choose>      <x:when> 和 <x:otherwise> 的父标签\n<x:when>        <x:choose> 的子标签，用来进行条件判断\n<x:otherwise>   <x:choose> 的子标签，当 <x:when> 判断为 false 时被执行\n<x:transform>   将 XSL 转换应用在 XML 文档中\n<x:param>       与 <x:transform> 共同使用，用于设置 XSL 样式表\n\n\n# JSTL 函数\n\nJSTL 包含一系列标准函数，大部分是通用的字符串处理函数。引用 JSTL 函数库的语法如下：\n\n<%@ taglib prefix="fn" uri="http://java.sun.com/jsp/jstl/functions" %>\n\n\n函数                        描述\nfn:contains()             测试输入的字符串是否包含指定的子串\nfn:containsIgnoreCase()   测试输入的字符串是否包含指定的子串，大小写不敏感\nfn:endsWith()             测试输入的字符串是否以指定的后缀结尾\nfn:escapeXml()            跳过可以作为 XML 标记的字符\nfn:indexOf()              返回指定字符串在输入字符串中出现的位置\nfn:join()                 将数组中的元素合成一个字符串然后输出\nfn:length()               返回字符串长度\nfn:replace()              将输入字符串中指定的位置替换为指定的字符串然后返回\nfn:split()                将字符串用指定的分隔符分隔然后组成一个子字符串数组并返回\nfn:startsWith()           测试输入字符串是否以指定的前缀开始\nfn:substring()            返回字符串的子集\nfn:substringAfter()       返回字符串在指定子串之后的子集\nfn:substringBefore()      返回字符串在指定子串之前的子集\nfn:toLowerCase()          将字符串中的字符转为小写\nfn:toUpperCase()          将字符串中的字符转为大写\nfn:trim()                 移除首尾的空白符\n\n\n# Taglib\n\n\n# JSP 自定义标签\n\n自定义标签是用户定义的 JSP 语言元素。当 JSP 页面包含一个自定义标签时将被转化为 servlet，标签转化为对被 称为 tag handler 的对象的操作，即当 servlet 执行时 Web container 调用那些操作。\n\nJSP 标签扩展可以让你创建新的标签并且可以直接插入到一个 JSP 页面。 JSP 2.0 规范中引入 Simple Tag Handlers 来编写这些自定义标记。\n\n你可以继承 SimpleTagSupport 类并重写的 doTag()方法来开发一个最简单的自定义标签。\n\n\n# 创建"Hello"标签\n\n接下来，我们想创建一个自定义标签叫作ex:Hello，标签格式为：\n\n<ex:Hello />\n\n\n要创建自定义的 JSP 标签，你首先必须创建处理标签的 Java 类。所以，让我们创建一个 HelloTag 类，如下所示：\n\npackage com.runoob; import javax.servlet.jsp.tagext.*; import\njavax.servlet.jsp.*; import java.io.*; public class HelloTag extends\nSimpleTagSupport { public void doTag() throws JspException, IOException {\nJspWriter out = getJspContext().getOut(); out.println("Hello Custom Tag!"); } }\n\n\n以下代码重写了 doTag()方法，方法中使用了 getJspContext()方法来获取当前的 JspContext 对象，并将"Hello Custom Tag!"传递给 JspWriter 对象。\n\n编译以上类，并将其复制到环境变量 CLASSPATH 目录中。最后创建如下标签库：<Tomcat安装目录>webapps\\ROOT\\WEB-INF\\custom.tld。\n\n<taglib>\n  <tlib-version>1.0</tlib-version>\n  <jsp-version>2.0</jsp-version>\n  <short-name>Example TLD</short-name>\n  <tag>\n    <name>Hello</name>\n    <tag-class>com.runoob.HelloTag</tag-class>\n    <body-content>empty</body-content>\n  </tag>\n</taglib>\n\n\n接下来，我们就可以在 JSP 文件中使用 Hello 标签：\n\n<%@ taglib prefix="ex" uri="WEB-INF/custom.tld"%>\n<html>\n  <head>\n    <title>A sample custom tag</title>\n  </head>\n  <body>\n    <ex:Hello />\n  </body>\n</html>\n\n\n以上程序输出结果为：\n\nHello Custom Tag!\n\n\n\n# 访问标签体\n\n你可以像标准标签库一样在标签中包含消息内容。如我们要在我们自定义的 Hello 中包含内容，格式如下：\n\n<ex:Hello>\n  This is message body\n</ex:Hello>\n\n\n我们可以修改标签处理类文件，代码如下：\n\npackage com.runoob;\n\nimport javax.servlet.jsp.tagext.*;\nimport javax.servlet.jsp.*;\nimport java.io.*;\n\npublic class HelloTag extends SimpleTagSupport {\n\n   StringWriter sw = new StringWriter();\n   public void doTag()\n      throws JspException, IOException\n    {\n       getJspBody().invoke(sw);\n       getJspContext().getOut().println(sw.toString());\n    }\n\n}\n\n\n接下来我们需要修改 TLD 文件，如下所示：\n\n<taglib>\n  <tlib-version>1.0</tlib-version>\n  <jsp-version>2.0</jsp-version>\n  <short-name>Example TLD with Body</short-name>\n  <tag>\n    <name>Hello</name>\n    <tag-class>com.runoob.HelloTag</tag-class>\n    <body-content>scriptless</body-content>\n  </tag>\n</taglib>\n\n\n现在我们可以在 JSP 使用修改后的标签，如下所示:\n\n<%@ taglib prefix="ex" uri="WEB-INF/custom.tld"%>\n<html>\n  <head>\n    <title>A sample custom tag</title>\n  </head>\n  <body>\n    <ex:Hello>\n      This is message body\n    </ex:Hello>\n  </body>\n</html>\n\n\n以上程序输出结果如下所示：\n\nThis is message body\n\n\n\n# 自定义标签属性\n\n你可以在自定义标准中设置各种属性，要接收属性，值自定义标签类必须实现 setter 方法， JavaBean 中的 setter 方法如下所示：\n\npackage com.runoob;\n\nimport javax.servlet.jsp.tagext.*;\nimport javax.servlet.jsp.*;\nimport java.io.*;\n\npublic class HelloTag extends SimpleTagSupport {\n\n   private String message;\n\n   public void setMessage(String msg) {\n      this.message = msg;\n   }\n\n   StringWriter sw = new StringWriter();\n\n   public void doTag()\n      throws JspException, IOException\n    {\n       if (message != null) {\n          /* 从属性中使用消息 */\n          JspWriter out = getJspContext().getOut();\n          out.println( message );\n       }\n       else {\n          /* 从内容体中使用消息 */\n          getJspBody().invoke(sw);\n          getJspContext().getOut().println(sw.toString());\n       }\n   }\n\n}\n\n\n属性的名称是"message"，所以 setter 方法是的 setMessage()。现在让我们在 TLD 文件中使用的 <attribute> 元素添加此属性：\n\n<taglib>\n  <tlib-version>1.0</tlib-version>\n  <jsp-version>2.0</jsp-version>\n  <short-name>Example TLD with Body</short-name>\n  <tag>\n    <name>Hello</name>\n    <tag-class>com.runoob.HelloTag</tag-class>\n    <body-content>scriptless</body-content>\n    <attribute>\n      <name>message</name>\n    </attribute>\n  </tag>\n</taglib>\n\n\n现在我们就可以在 JSP 文件中使用 message 属性了，如下所示：\n\n<%@ taglib prefix="ex" uri="WEB-INF/custom.tld"%>\n<html>\n  <head>\n    <title>A sample custom tag</title>\n  </head>\n  <body>\n    <ex:Hello message="This is custom tag" />\n  </body>\n</html>\n\n\n以上实例数据输出结果为：\n\nThis is custom tag\n\n\n你还可以包含以下属性：\n\n属性            描述\nname          定义属性的名称。每个标签的是属性名称必须是唯一的。\nrequired      指定属性是否是必须的或者可选的,如果设置为 false 为可选。\nrtexprvalue   声明在运行表达式时，标签属性是否有效。\ntype          定义该属性的 Java 类类型 。默认指定为 String\ndescription   描述信息\nfragment      如果声明了该属性,属性值将被视为一个 JspFragment。\n\n以下是指定相关的属性实例：\n\n.....\n<attribute>\n  <name>attribute_name</name>\n  <required>false</required>\n  <type>java.util.Date</type>\n  <fragment>false</fragment>\n</attribute>\n.....\n\n\n如果你使用了两个属性，修改 TLD 文件，如下所示：\n\n.....\n<attribute>\n  <name>attribute_name1</name>\n  <required>false</required>\n  <type>java.util.Boolean</type>\n  <fragment>false</fragment>\n</attribute>\n<attribute>\n  <name>attribute_name2</name>\n  <required>true</required>\n  <type>java.util.Date</type>\n</attribute>\n.....\n',normalizedContent:'# javaweb 之 jsp 指南\n\n\n# 简介\n\n\n# 什么是 java server pages\n\njsp全称java server pages，是一种动态网页开发技术。\n\n它使用 jsp 标签在 html 网页中插入 java 代码。标签通常以 <% 开头以 %> 结束。\n\njsp 是一种 java servlet，主要用于实现 java web 应用程序的用户界面部分。网页开发者们通过结合 html 代码、xhtml 代码、xml 元素以及嵌入 jsp 操作和命令来编写 jsp。\n\njsp 通过网页表单获取用户输入数据、访问数据库及其他数据源，然后动态地创建网页。\n\njsp 标签有多种功能，比如访问数据库、记录用户选择信息、访问 javabeans 组件等，还可以在不同的网页中传递控制信息和共享信息。\n\n\n# 为什么使用 jsp\n\njsp 也是一种 servlet，因此 jsp 能够完成 servlet 能完成的任何工作。\n\njsp 程序与 cgi 程序有着相似的功能，但和 cgi 程序相比，jsp 程序有如下优势：\n\n * 性能更加优越，因为 jsp 可以直接在 html 网页中动态嵌入元素而不需要单独引用 cgi 文件。\n * 服务器调用的是已经编译好的 jsp 文件，而不像 cgi/perl 那样必须先载入解释器和目标脚本。\n * jsp 基于 java servlets api，因此，jsp 拥有各种强大的企业级 java api，包括 jdbc，jndi，ejb，jaxp 等等。\n * jsp 页面可以与处理业务逻辑的 servlets 一起使用，这种模式被 java servlet 模板引擎所支持。\n\n最后，jsp 是 java ee 不可或缺的一部分，是一个完整的企业级应用平台。这意味着 jsp 可以用最简单的方式来实现最复杂的应用。\n\n\n# jsp 的优势\n\n以下列出了使用 jsp 带来的其他好处：\n\n * 与 asp 相比：jsp 有两大优势。首先，动态部分用 java 编写，而不是 vb 或其他 ms 专用语言，所以更加强大与易用。第二点就是 jsp 易于移植到非 ms 平台上。\n * 与纯 servlets 相比：jsp 可以很方便的编写或者修改 html 网页而不用去面对大量的 println 语句。\n * 与 ssi 相比：ssi 无法使用表单数据、无法进行数据库链接。\n * 与 javascript 相比：虽然 javascript 可以在客户端动态生成 html，但是很难与服务器交互，因此不能提供复杂的服务，比如访问数据库和图像处理等等。\n * 与静态 html 相比：静态 html 不包含动态信息。\n\n\n# jsp 工作原理\n\njsp 是一种 servlet，但工作方式和 servlet 有所差别。\n\nservlet 是先将源代码编译为 class 文件后部署到服务器下的，先编译后部署。\n\njsp 是先将源代码部署到服务器再编译，先部署后编译。\n\njsp 会在客户端第一次请求 jsp 文件时被编译为 httpjsppage 类（servlet 的一个子类）。该类会被服务器临时存放在服务器工作目录里。所以，第一次请求 jsp 后，访问速度会变快就是这个道理。\n\n\n# jsp 工作流程\n\n网络服务器需要一个 jsp 引擎，也就是一个容器来处理 jsp 页面。容器负责截获对 jsp 页面的请求。本教程使用内嵌 jsp 容器的 apache 来支持 jsp 开发。\n\njsp 容器与 web 服务器协同合作，为 jsp 的正常运行提供必要的运行环境和其他服务，并且能够正确识别专属于 jsp 网页的特殊元素。\n\n下图显示了 jsp 容器和 jsp 文件在 web 应用中所处的位置。\n\n\n\n# 工作步骤\n\n以下步骤表明了 web 服务器是如何使用 jsp 来创建网页的：\n\n * 就像其他普通的网页一样，您的浏览器发送一个 http 请求给服务器。\n * web 服务器识别出这是一个对 jsp 网页的请求，并且将该请求传递给 jsp 引擎。通过使用 url 或者.jsp 文件来完成。\n * jsp 引擎从磁盘中载入 jsp 文件，然后将它们转化为 servlet。这种转化只是简单地将所有模板文本改用 println()语句，并且将所有的 jsp 元素转化成 java 代码。\n * jsp 引擎将 servlet 编译成可执行类，并且将原始请求传递给 servlet 引擎。\n * web 服务器的某组件将会调用 servlet 引擎，然后载入并执行 servlet 类。在执行过程中，servlet 产生 html 格式的输出并将其内嵌于 http response 中上交给 web 服务器。\n * web 服务器以静态 html 网页的形式将 http response 返回到您的浏览器中。\n * 最终，web 浏览器处理 http response 中动态产生的 html 网页，就好像在处理静态网页一样。\n\n以上提及到的步骤可以用下图来表示：\n\n一般情况下，jsp 引擎会检查 jsp 文件对应的 servlet 是否已经存在，并且检查 jsp 文件的修改日期是否早于 servlet。如果 jsp 文件的修改日期早于对应的 servlet，那么容器就可以确定 jsp 文件没有被修改过并且 servlet 有效。这使得整个流程与其他脚本语言（比如 php）相比要高效快捷一些。\n\n\n# jsp 生命周期\n\n理解 jsp 底层功能的关键就是去理解它们所遵守的生命周期。\n\njsp 生命周期就是从创建到销毁的整个过程，类似于 servlet 生命周期，区别在于 jsp 生命周期还包括将 jsp 文件编译成 servlet。\n\n以下是 jsp 生命周期中所走过的几个阶段：\n\n * **编译阶段：**servlet 容器编译 servlet 源文件，生成 servlet 类\n * **初始化阶段：**加载与 jsp 对应的 servlet 类，创建其实例，并调用它的初始化方法\n * **执行阶段：**调用与 jsp 对应的 servlet 实例的服务方法\n * **销毁阶段：**调用与 jsp 对应的 servlet 实例的销毁方法，然后销毁 servlet 实例\n\n很明显，jsp 生命周期的四个主要阶段和 servlet 生命周期非常相似，下面给出图示：\n\n\n\n# jsp 编译\n\n当浏览器请求 jsp 页面时，jsp 引擎会首先去检查是否需要编译这个文件。如果这个文件没有被编译过，或者在上次编译后被更改过，则编译这个 jsp 文件。\n\n编译的过程包括三个步骤：\n\n * 解析 jsp 文件。\n * 将 jsp 文件转为 servlet。\n * 编译 servlet。\n\n# jsp 初始化\n\n容器载入 jsp 文件后，它会在为请求提供任何服务前调用 jspinit()方法。如果您需要执行自定义的 jsp 初始化任务，复写 jspinit()方法就行了，就像下面这样：\n\npublic void jspinit(){\n  // 初始化代码\n}\n\n\n一般来讲程序只初始化一次，servlet 也是如此。通常情况下您可以在 jspinit()方法中初始化数据库连接、打开文件和创建查询表。\n\n# jsp 执行\n\n这一阶段描述了 jsp 生命周期中一切与请求相关的交互行为，直到被销毁。\n\n当 jsp 网页完成初始化后，jsp 引擎将会调用 _jspservice() 方法。\n\n_jspservice() 方法需要一个 httpservletrequest 对象和一个 httpservletresponse 对象作为它的参数，就像下面这样：\n\nvoid _jspservice(httpservletrequest request,\n                 httpservletresponse response) {\n   // 服务端处理代码\n}\n\n\n_jspservice() 方法在每个 request 中被调用一次并且负责产生与之相对应的 response，并且它还负责产生所有 7 个 http 方法的回应，比如 get、post、delete 等等。\n\n# jsp 清理\n\njsp 生命周期的销毁阶段描述了当一个 jsp 网页从容器中被移除时所发生的一切。\n\njspdestroy()方法在 jsp 中等价于 servlet 中的销毁方法。当您需要执行任何清理工作时复写 jspdestroy()方法，比如释放数据库连接或者关闭文件夹等等。\n\njspdestroy()方法的格式如下：\n\npublic void jspdestroy() {\n   // 清理代码\n}\n\n\n\n# 语法\n\n\n# 脚本\n\n脚本程序可以包含任意量的 java 语句、变量、方法或表达式，只要它们在脚本语言中是有效的。\n\n脚本程序的语法格式：\n\n<% 代码片段 %>\n\n\n或者，您也可以编写与其等价的 xml 语句，就像下面这样：\n\n<jsp:scriptlet>\n  代码片段\n</jsp:scriptlet>\n\n\n任何文本、html 标签、jsp 元素必须写在脚本程序的外面。\n\n下面给出一个示例，同时也是本教程的第一个 jsp 示例：\n\n<html>\n  <head>\n    <title>hello world</title>\n  </head>\n  <body>\n    hello world!<br />\n    <% out.println("your ip address is " + request.getremoteaddr()); %>\n  </body>\n</html>\n\n\n**注意：**请确保 apache tomcat 已经安装在 c:\\apache-tomcat-7.0.2 目录下并且运行环境已经正确设置。\n\n将以上代码保存在 hello.jsp 中，然后将它放置在 c:\\apache-tomcat-7.0.2\\webapps\\root 目录下，打开浏览器并在地址栏中输入 http://localhost:8080/hello.jsp 。运行后得到以下结果：\n\n\n\n# 中文编码问题\n\n如果我们要在页面正常显示中文，我们需要在 jsp 文件头部添加以下代码：<>\n\n<%@ page language="java" contenttype="text/html; charset=utf-8"\npageencoding="utf-8"%>\n\n\n接下来我们将以上程序修改为：\n\n<%@ page language="java" contenttype="text/html; charset=utf-8"\npageencoding="utf-8"%>\n<!doctype html>\n<html>\n  <head>\n    <meta charset="utf-8" />\n    <title>菜鸟教程(runoob.com)</title>\n  </head>\n  <body>\n    hello world!<br />\n    <% out.println("你的 ip 地址 " + request.getremoteaddr()); %>\n  </body>\n</html>\n\n\n这样中文就可以正常显示了。\n\n\n# jsp 声明\n\n一个声明语句可以声明一个或多个变量、方法，供后面的 java 代码使用。在 jsp 文件中，您必须先声明这些变量和方法然后才能使用它们。\n\njsp 声明的语法格式：\n\n<%! declaration; [ declaration; ]+ ... %>\n\n\n或者，您也可以编写与其等价的 xml 语句，就像下面这样：\n\n<jsp:declaration>\n  代码片段\n</jsp:declaration>\n\n\n程序示例：\n\n<%! int i = 0; %> <%! int a, b, c; %> <%! circle a = new circle(2.0); %>\n\n\n\n# jsp 表达式\n\n一个 jsp 表达式中包含的脚本语言表达式，先被转化成 string，然后插入到表达式出现的地方。\n\n由于表达式的值会被转化成 string，所以您可以在一个文本行中使用表达式而不用去管它是否是 html 标签。\n\n表达式元素中可以包含任何符合 java 语言规范的表达式，但是不能使用分号来结束表达式。\n\njsp 表达式的语法格式：\n\n<%= 表达式 %>\n\n\n同样，您也可以编写与之等价的 xml 语句：\n\n<jsp:expression>\n  表达式\n</jsp:expression>\n\n\n程序示例：\n\n<%@ page language="java" contenttype="text/html; charset=utf-8"\npageencoding="utf-8"%>\n<!doctype html>\n<html>\n  <head>\n    <meta charset="utf-8" />\n    <title>菜鸟教程(runoob.com)</title>\n  </head>\n  <body>\n    <p>\n      今天的日期是: <%= (new java.util.date()).tolocalestring()%>\n    </p>\n  </body>\n</html>\n\n\n运行后得到以下结果：\n\n今天的日期是: 2016-6-25 13:40:07\n\n\n----------------------------------------\n\n\n# jsp 注释\n\njsp 注释主要有两个作用：为代码作注释以及将某段代码注释掉。\n\njsp 注释的语法格式：\n\n<%@ page language="java" contenttype="text/html; charset=utf-8"\npageencoding="utf-8"%>\n<!doctype html>\n<html>\n  <head>\n    <meta charset="utf-8" />\n    <title>jsp注释示例</title>\n  </head>\n  <body>\n    <%-- 该部分注释在网页中不会被显示--%>\n    <p>\n      今天的日期是: <%= (new java.util.date()).tolocalestring()%>\n    </p>\n  </body>\n</html>\n\n\n运行后得到以下结果：\n\n今天的日期是: 2016-6-25 13:41:26\n\n\n不同情况下使用注释的语法规则：\n\n语法             描述\n<%-- 注释 --%>   jsp 注释，注释内容不会被发送至浏览器甚至不会被编译\n\x3c!-- 注释 --\x3e    html 注释，通过浏览器查看网页源代码时可以看见注释内容\n<%             代表静态 <% 常量\n%>             代表静态 %> 常量\n\'              在属性中使用的单引号\n"              在属性中使用的双引号\n\n\n# 控制语句\n\njsp 提供对 java 语言的全面支持。您可以在 jsp 程序中使用 java api 甚至建立 java 代码块，包括判断语句和循环语句等等。\n\n# if…else 语句\n\nif…else块，请看下面这个例子：\n\n<%@ page language="java" contenttype="text/html; charset=utf-8"\npageencoding="utf-8"%> <%! int day = 1; %>\n<!doctype html>\n<html>\n  <head>\n    <meta charset="utf-8" />\n    <title>02.jsp语法 - if...else示例</title>\n  </head>\n  <body>\n    <h3>if...else 实例</h3>\n    <% if (day == 1 | day == 7) { %>\n    <p>今天是周末</p>\n    <% } else { %>\n    <p>今天不是周末</p>\n    <% } %>\n  </body>\n</html>\n\n\n运行后得到以下结果：\n\nif...else 实例\n今天不是周末\n\n\n# switch…case 语句\n\n现在来看看 switch…case 块，与 if…else 块有很大的不同，它使用 out.println()，并且整个都装在脚本程序的标签中，就像下面这样：\n\n<%@ page language="java" contenttype="text/html; charset=utf-8"\npageencoding="utf-8"%> <%! int day = 3; %>\n<!doctype html>\n<html>\n  <head>\n    <meta charset="utf-8" />\n    <title>02.jsp语法 - switch...case示例</title>\n  </head>\n  <body>\n    <h3>sswitch...case示例</h3>\n    <% switch(day) { case 0: out.println("星期天"); break; case 1:\n    out.println("星期一"); break; case 2: out.println("星期二"); break; case 3:\n    out.println("星期三"); break; case 4: out.println("星期四"); break; case 5:\n    out.println("星期五"); break; default: out.println("星期六"); } %>\n  </body>\n</html>\n\n\n浏览器访问，运行后得出以下结果：\n\nswitch...case 实例\n\n星期三\n\n\n# 循环语句\n\n在 jsp 程序中可以使用 java 的三个基本循环类型：for，while，和 do…while。\n\n让我们来看看 for 循环的例子，以下输出的不同字体大小的"菜鸟教程"：\n\n<%@ page language="java" contenttype="text/html; charset=utf-8"\npageencoding="utf-8"%> <%! int fontsize; %>\n<!doctype html>\n<html>\n  <head>\n    <meta charset="utf-8" />\n    <title>菜鸟教程(runoob.com)</title>\n  </head>\n  <body>\n    <h3>for 循环实例</h3>\n    <%for ( fontsize = 1; fontsize <= 3; fontsize++){ %>\n    <font color="green" size="<%= fontsize %>">\n      菜鸟教程 </font\n    ><br />\n    <%}%>\n  </body>\n</html>\n\n\n运行后得到以下结果：\n\n\n\n将上例改用 while 循环来写：\n\n<%@ page language="java" contenttype="text/html; charset=utf-8"\npageencoding="utf-8"%> <%! int fontsize; %>\n<!doctype html>\n<html>\n  <head>\n    <meta charset="utf-8" />\n    <title>菜鸟教程(runoob.com)</title>\n  </head>\n  <body>\n    <h3>while 循环实例</h3>\n    <%while ( fontsize <= 3){ %>\n    <font color="green" size="<%= fontsize %>">\n      菜鸟教程 </font\n    ><br />\n    <%fontsize++;%> <%}%>\n  </body>\n</html>\n\n\n浏览器访问，输出结果为（fontsize 初始化为 0，所以多输出了一行）：\n\n\n\njsp 运算符\n\njsp 支持所有 java 逻辑和算术运算符。\n\n下表罗列出了 jsp 常见运算符，优先级从高到底：\n\n类别      操作符                                   结合性\n后缀      () [] . (点运算符)                        左到右\n一元      ++ - - ! ~                            右到左\n可乘性     * / %                                 左到右\n可加性     + -                                   左到右\n移位      >> >>> <<                             左到右\n关系      > >= < <=                             左到右\n相等/不等   == !=                                 左到右\n位与      &                                     左到右\n位异或     ^                                     左到右\n位或      |                                     左到右\n逻辑与     &&                                    左到右\n逻辑或     | |                                   左到右\n条件判断    ?:                                    右到左\n赋值      = += -= \\*= /= %= >>= <<= &= ^= | =   右到左\n逗号      ,                                     左到右\n\n\n# jsp 字面量\n\njsp 语言定义了以下几个字面量：\n\n * 布尔值(boolean)：true 和 false;\n * 整型(int)：与 java 中的一样;\n * 浮点型(float)：与 java 中的一样;\n * 字符串(string)：以单引号或双引号开始和结束;\n * null：null。\n\n\n# 指令\n\njsp 指令用来设置整个 jsp 页面相关的属性，如网页的编码方式和脚本语言。\n\njsp 指令以开<%@开始，以%>结束。\n\njsp 指令语法格式如下：\n\n<%@ directive attribute="value" %>\n\n\n指令可以有很多个属性，它们以键值对的形式存在，并用逗号隔开。\n\njsp 中的三种指令标签：\n\n指令                   描述\n<%@ page ... %>      定义网页依赖属性，比如脚本语言、error 页面、缓存需求等等\n<%@ include ... %>   包含其他文件\n<%@ taglib ... %>    引入标签库的定义，可以是自定义标签\n\n\n# page 指令\n\npage 指令为容器提供当前页面的使用说明。一个 jsp 页面可以包含多个page指令。\n\npage 指令的语法格式：\n\n<%@ page attribute="value" %>\n\n\n等价的 xml 格式：\n\n<jsp:directive.page attribute="value" />\n\n\n例：\n\n<%@ page language="java" contenttype="text/html; charset=utf-8"\npageencoding="utf-8" %>\n\n\n# 属性\n\n下表列出与 page 指令相关的属性：\n\n属性                   描述\nbuffer               指定 out 对象使用缓冲区的大小\nautoflush            控制 out 对象的 缓存区\ncontenttype          指定当前 jsp 页面的 mime 类型和字符编码\nerrorpage            指定当 jsp 页面发生异常时需要转向的错误处理页面\niserrorpage          指定当前页面是否可以作为另一个 jsp 页面的错误处理页面\nextends              指定 servlet 从哪一个类继承\nimport               导入要使用的 java 类\ninfo                 定义 jsp 页面的描述信息\nisthreadsafe         指定对 jsp 页面的访问是否为线程安全\nlanguage             定义 jsp 页面所用的脚本语言，默认是 java\nsession              指定 jsp 页面是否使用 session\niselignored          指定是否执行 el 表达式\nisscriptingenabled   确定脚本元素能否被使用\n\n\n# include 指令\n\njsp 可以通过include指令来包含其他文件。\n\n被包含的文件可以是 jsp 文件、html 文件或文本文件。包含的文件就好像是该 jsp 文件的一部分，会被同时编译执行。\n\ninclude 指令的语法格式如下：\n\n<%@ include file="文件相对 url 地址" %>\n\n\ninclude 指令中的文件名实际上是一个相对的 url 地址。\n\n如果您没有给文件关联一个路径，jsp 编译器默认在当前路径下寻找。\n\n等价的 xml 语法：\n\n<jsp:directive.include file="文件相对 url 地址" />\n\n\n\n# taglib 指令\n\njsp 允许用户自定义标签，一个自定义标签库就是自定义标签的集合。\n\ntaglib指令引入一个自定义标签集合的定义，包括库路径、自定义标签。\n\ntaglib指令的语法：\n\n<%@ taglib uri="uri" prefix="prefixoftag" %>\n\n\nuri 属性确定标签库的位置，prefix 属性指定标签库的前缀。\n\n等价的 xml 语法：\n\n<jsp:directive.taglib uri="uri" prefix="prefixoftag" />\n\n\n\n# jsp 动作元素\n\njsp 动作元素是一组 jsp 内置的标签，只需要书写很少的标记代码就能使用 jsp 提供的丰富功能。jsp 动作元素是对常用的 jsp 功能的抽象与封装，包括两种，自定义 jsp 动作元素与标准 jsp 动作元素。\n\n与 jsp 指令元素不同的是，jsp 动作元素在请求处理阶段起作用。jsp 动作元素是用 xml 语法写成的。\n\n利用 jsp 动作可以动态地插入文件、重用 javabean 组件、把用户重定向到另外的页面、为 java 插件生成 html 代码。\n\n动作元素只有一种语法，它符合 xml 标准：\n\n<jsp:action_name attribute="value" />\n\n\n动作元素基本上都是预定义的函数，jsp 规范定义了一系列的标准动作，它用 jsp 作为前缀，可用的标准动作元素如下：\n\n语法                描述\njsp:include       在页面被请求的时候引入一个文件。\njsp:usebean       寻找或者实例化一个 javabean。\njsp:setproperty   设置 javabean 的属性。\njsp:getproperty   输出某个 javabean 的属性。\njsp:forward       把请求转到一个新的页面。\njsp:plugin        根据浏览器类型为 java 插件生成 object 或 embed 标记。\njsp:element       定义动态 xml 元素\njsp:attribute     设置动态定义的 xml 元素属性。\njsp:body          设置动态定义的 xml 元素内容。\njsp:text          在 jsp 页面和文档中使用写入文本的模板\n\n\n# 常见的属性\n\n所有的动作要素都有两个属性：id 属性和 scope 属性。\n\n * **id 属性：**id 属性是动作元素的唯一标识，可以在 jsp 页面中引用。动作元素创建的 id 值可以通过 pagecontext 来调用。\n * **scope 属性：**该属性用于识别动作元素的生命周期。 id 属性和 scope 属性有直接关系，scope 属性定义了相关联 id 对象的寿命。 scope 属性有四个可能的值： (a) page, (b)request, (c)session, 和 (d) application。\n\n\n# <jsp:include>\n\n<jsp:include> 用来包含静态和动态的文件。该动作把指定文件插入正在生成的页面。\n\n如果被包含的文件为 jsp 程序，则会先执行 jsp 程序，再将执行结果包含进来。\n\n语法格式如下：\n\n<jsp:include page="相对 url 地址" flush="true" />\n\n\n前面已经介绍过 include 指令，它是在 jsp 文件被转换成 servlet 的时候引入文件，而这里的 jsp:include 动作不同，插入文件的时间是在页面被请求的时候。\n\n以下是 include 动作相关的属性列表。\n\n属性      描述\npage    包含在页面中的相对 url 地址。\nflush   布尔属性，定义在包含资源前是否刷新缓存区。\n\n示例：\n\n以下我们定义了两个文件 date.jsp 和 main.jsp，代码如下所示：\n\ndate.jsp 文件代码：\n\n<%@ page language="java" contenttype="text/html; charset=utf-8"\npageencoding="utf-8"%>\n<p>\n  今天的日期是: <%= (new java.util.date())%>\n</p>\n\n\nmain.jsp 文件代码：\n\n<%@ page language="java" contenttype="text/html; charset=utf-8"\npageencoding="utf-8"%>\n<!doctype html>\n<html>\n  <head>\n    <meta charset="utf-8" />\n    <title>菜鸟教程(runoob.com)</title>\n  </head>\n  <body>\n    <h2>include 动作实例</h2>\n    <jsp:include page="date.jsp" flush="true" />\n  </body>\n</html>\n\n\n现在将以上两个文件放在服务器的根目录下，访问 main.jsp 文件。显示结果如下：\n\ninclude 动作实例\n\n今天的日期是: 2016-6-25 14:08:17\n\n\n\n# <jsp:usebean>\n\njsp:usebean 动作用来加载一个将在 jsp 页面中使用的 javabean。\n\n这个功能非常有用，因为它使得我们可以发挥 java 组件复用的优势。\n\njsp:usebean 动作最简单的语法为：\n\n<jsp:usebean id="name" class="package.class" />\n\n\n在类载入后，我们既可以通过 jsp:setproperty 和 jsp:getproperty 动作来修改和检索 bean 的属性。\n\n以下是 usebean 动作相关的属性列表。\n\n属性         描述\nclass      指定 bean 的完整包名。\ntype       指定将引用该对象变量的类型。\nbeanname   通过 java.beans.beans 的 instantiate() 方法指定 bean 的名字。\n\n在给出具体实例前，让我们先来看下 jsp:setproperty 和 jsp:getproperty 动作元素：\n\n\n# <jsp:setproperty>\n\njsp:setproperty 用来设置已经实例化的 bean 对象的属性，有两种用法。首先，你可以在 jsp:usebean 元素的外面（后面）使用 jsp:setproperty，如下所示：\n\n<jsp:usebean id="myname" ... />\n...\n<jsp:setproperty name="myname" property="someproperty" .../>\n\n\n此时，不管 jsp:usebean 是找到了一个现有的 bean，还是新创建了一个 bean 实例，jsp:setproperty 都会执行。第二种用法是把 jsp:setproperty 放入 jsp:usebean 元素的内部，如下所示：\n\n<jsp:usebean id="myname" ... >\n...\n   <jsp:setproperty name="myname" property="someproperty" .../>\n</jsp:usebean>\n\n\n此时，jsp:setproperty 只有在新建 bean 实例时才会执行，如果是使用现有实例则不执行 jsp:setproperty。\n\njsp:setproperty 动作有下面四个属性,如下表：\n\n属性         描述\nname       name 属性是必需的。它表示要设置属性的是哪个 bean。\nproperty   property 属性是必需的。它表示要设置哪个属性。有一个特殊用法：如果 property\n           的值是"*"，表示所有名字和 bean 属性名字匹配的请求参数都将被传递给相应的属性 set 方法。\nvalue      value 属性是可选的。该属性用来指定 bean 属性的值。字符串数据会在目标类中通过标准的 valueof\n           方法自动转换成数字、boolean、boolean、\n           byte、byte、char、character。例如，boolean 和 boolean\n           类型的属性值（比如"true"）通过 boolean.valueof 转换，int 和 integer\n           类型的属性值（比如"42"）通过 integer.valueof 转换。 　　 value 和 param\n           不能同时使用，但可以使用其中任意一个。\nparam      param 是可选的。它指定用哪个请求参数作为 bean 属性的值。如果当前请求没有参数，则什么事情也不做，系统不会把\n           null 传递给 bean 属性的 set 方法。因此，你可以让 bean\n           自己提供默认属性值，只有当请求参数明确指定了新值时才修改默认属性值。\n\n\n# <jsp:getproperty>\n\njsp:getproperty 动作提取指定 bean 属性的值，转换成字符串，然后输出。语法格式如下：\n\n<jsp:usebean id="myname" ... />\n...\n<jsp:getproperty name="myname" property="someproperty" .../>\n\n\n下表是与 getproperty 相关联的属性：\n\n属性         描述\nname       要检索的 bean 属性名称。bean 必须已定义。\nproperty   表示要提取 bean 属性的值\n\n实例\n\n以下实例我们使用了 bean:\n\npackage com.runoob.main;\n\npublic class testbean {\n   private string message = "菜鸟教程";\n\n   public string getmessage() {\n      return(message);\n   }\n   public void setmessage(string message) {\n      this.message = message;\n   }\n}\n\n\n编译以上实例文件 testbean.java ：\n\n$ javac testbean.java\n\n\n编译完成后会在当前目录下生成一个 testbean.class 文件， 将该文件拷贝至当前 jsp 项目的 webcontent/web-inf/classes/com/runoob/main 下( com/runoob/main 包路径，没有需要手动创建)。\n\n下面是一个 eclipse 中目录结构图：\n\n\n\n下面是一个很简单的例子，它的功能是装载一个 bean，然后设置/读取它的 message 属性。\n\n现在让我们在 main.jsp 文件中调用该 bean:\n\n<%@ page language="java" contenttype="text/html; charset=utf-8"\npageencoding="utf-8"%>\n<!doctype html>\n<html>\n  <head>\n    <meta charset="utf-8" />\n    <title>菜鸟教程(runoob.com)</title>\n  </head>\n  <body>\n    <h2>jsp 使用 javabean 实例</h2>\n    <jsp:usebean id="test" class="com.runoob.main.testbean" />\n\n    <jsp:setproperty name="test" property="message" value="菜鸟教程..." />\n\n    <p>输出信息....</p>\n\n    <jsp:getproperty name="test" property="message" />\n  </body>\n</html>\n\n\n浏览器访问，执行以上文件，输出如下所示：\n\n\n\n\n# <jsp:forward>\n\njsp:forward 动作把请求转到另外的页面。jsp:forward 标记只有一个属性 page。语法格式如下所示：\n\n<jsp:forward page="相对 url 地址" />\n\n\n以下是 forward 相关联的属性：\n\n属性     描述\npage   page 属性包含的是一个相对 url。page 的值既可以直接给出，也可以在请求的时候动态计算，可以是一个 jsp\n       页面或者一个 java servlet.\n\n实例\n\n以下实例我们使用了两个文件，分别是： date.jsp 和 main.jsp。\n\ndate.jsp 文件代码如下：\n\n<%@ page language="java" contenttype="text/html; charset=utf-8"\npageencoding="utf-8"%>\n<p>\n  今天的日期是: <%= (new java.util.date()).tolocalestring()%>\n</p>\n\n\nmain.jsp 文件代码：\n\n<%@ page language="java" contenttype="text/html; charset=utf-8"\npageencoding="utf-8"%>\n<!doctype html>\n<html>\n  <head>\n    <meta charset="utf-8" />\n    <title>菜鸟教程(runoob.com)</title>\n  </head>\n  <body>\n    <h2>forward 动作实例</h2>\n    <jsp:forward page="date.jsp" />\n  </body>\n</html>\n\n\n现在将以上两个文件放在服务器的根目录下，访问 main.jsp 文件。显示结果如下：\n\n今天的日期是: 2016-6-25 14:37:25\n\n\n\n# <jsp:plugin>\n\njsp:plugin 动作用来根据浏览器的类型，插入通过 java 插件 运行 java applet 所必需的 object 或 embed 元素。\n\n如果需要的插件不存在，它会下载插件，然后执行 java 组件。 java 组件可以是一个 applet 或一个 javabean。\n\nplugin 动作有多个对应 html 元素的属性用于格式化 java 组件。param 元素可用于向 applet 或 bean 传递参数。\n\n以下是使用 plugin 动作元素的典型实例:\n\n<jsp:plugin type="applet" codebase="dirname" code="myapplet.class"\n                           width="60" height="80">\n   <jsp:param name="fontcolor" value="red" />\n   <jsp:param name="background" value="black" />\n\n   <jsp:fallback>\n      unable to initialize java plugin\n   </jsp:fallback>\n\n</jsp:plugin>\n\n\n如果你有兴趣可以尝试使用 applet 来测试 jsp:plugin 动作元素，<fallback> 元素是一个新元素，在组件出现故障的错误是发送给用户错误信息。\n\n\n# <jsp:element> 、 <jsp:attribute>、<jsp:body>\n\n<jsp:element> 、 <jsp:attribute>、<jsp:body> 动作元素动态定义 xml 元素。动态是非常重要的，这就意味着 xml 元素在编译时是动态生成的而非静态。\n\n以下实例动态定义了 xml 元素：\n\n<%@ page language="java" contenttype="text/html; charset=utf-8"\npageencoding="utf-8"%>\n<!doctype html>\n<html>\n  <head>\n    <meta charset="utf-8" />\n    <title>菜鸟教程(runoob.com)</title>\n  </head>\n  <body>\n    <jsp:element name="xmlelement">\n      <jsp:attribute name="xmlelementattr">\n        属性值\n      </jsp:attribute>\n      <jsp:body>\n        xml 元素的主体\n      </jsp:body>\n    </jsp:element>\n  </body>\n</html>\n\n\n浏览器访问以下页面，输出结果如下所示：\n\n\n\n\n# <jsp:text>\n\njsp:text动作元素允许在 jsp 页面和文档中使用写入文本的模板，语法格式如下：\n\n<jsp:text>模板数据</jsp:text>\n\n\n以上文本模板不能包含其他元素，只能只能包含文本和 el 表达式（注：el 表达式将在后续章节中介绍）。请注意，在 xml 文件中，您不能使用表达式如 ${whatever > 0}，因为>符号是非法的。 你可以使用 ${whatever gt 0}表达式或者嵌入在一个 cdata 部分的值。\n\n<jsp:text><![cdata[<br>]]></jsp:text>\n\n\n如果你需要在 xhtml 中声明 doctype,必须使用到 <jsp:text> 动作元素，实例如下：\n\n<jsp:text><![cdata[<!doctype html\npublic "-//w3c//dtd xhtml 1.0 strict//en"\n"dtd/xhtml1-strict.dtd">]]>\n</jsp:text>\n<head><title>jsp:text action</title></head>\n<body>\n\n<books><book><jsp:text>\n    welcome to jsp programming\n</jsp:text></book></books>\n\n</body>\n</html>\n\n\n你可以对以上实例尝试使用jsp:text及不使用该动作元素执行结果的区别。\n\n\n# jsp 隐式对象\n\njsp 隐式对象是 jsp 容器为每个页面提供的 java 对象，开发者可以直接使用它们而不用显式声明。jsp 隐式对象也被称为预定义变量。\n\njsp 所支持的九大隐式对象：\n\n对象            描述\nrequest       httpservletrequest类的实例\nresponse      httpservletresponse类的实例\nout           printwriter类的实例，用于把结果输出至网页上\nsession       httpsession类的实例\napplication   servletcontext类的实例，与应用上下文有关\nconfig        servletconfig类的实例\npagecontext   pagecontext类的实例，提供对 jsp 页面所有对象以及命名空间的访问\npage          类似于 java 类中的 this 关键字\nexception     exception类的对象，代表发生错误的 jsp 页面中对应的异常对象\n\n\n# request 对象\n\nrequest对象是javax.servlet.http.httpservletrequest 类的实例。\n\n每当客户端请求一个 jsp 页面时，jsp 引擎就会制造一个新的request对象来代表这个请求。\n\nrequest对象提供了一系列方法来获取 http 头信息，cookies，http 方法等等。\n\n\n# response 对象\n\nresponse对象是javax.servlet.http.httpservletresponse类的实例。\n\n当服务器创建request对象时会同时创建用于响应这个客户端的response对象。\n\nresponse对象也定义了处理 http 头模块的接口。通过这个对象，开发者们可以添加新的 cookies，时间戳，http 状态码等等。\n\n\n# out 对象\n\nout对象是javax.servlet.jsp.jspwriter类的实例，用来在response对象中写入内容。\n\n最初的jspwriter类对象根据页面是否有缓存来进行不同的实例化操作。可以在page指令中使用buffered=\'false\'属性来轻松关闭缓存。\n\njspwriter类包含了大部分java.io.printwriter类中的方法。不过，jspwriter新增了一些专为处理缓存而设计的方法。还有就是，jspwriter类会抛出ioexceptions异常，而printwriter不会。\n\n下表列出了我们将会用来输出boolean，char，int，double，string，object等类型数据的重要方法：\n\n方法                         描述\nout.print(datatype dt)     输出 type 类型的值\nout.println(datatype dt)   输出 type 类型的值然后换行\nout.flush()                刷新输出流\n\n\n# session 对象\n\nsession对象是javax.servlet.http.httpsession类的实例。和 java servlets 中的session对象有一样的行为。\n\nsession对象用来跟踪在各个客户端请求间的会话。\n\n\n# application 对象\n\napplication对象直接包装了 servlet 的servletcontext类的对象，是javax.servlet.servletcontext类的实例。\n\n这个对象在 jsp 页面的整个生命周期中都代表着这个 jsp 页面。这个对象在 jsp 页面初始化时被创建，随着jspdestroy()方法的调用而被移除。\n\n通过向application中添加属性，则所有组成您 web 应用的 jsp 文件都能访问到这些属性。\n\n\n# config 对象\n\nconfig对象是javax.servlet.servletconfig类的实例，直接包装了 servlet 的servletconfig类的对象。\n\n这个对象允许开发者访问 servlet 或者 jsp 引擎的初始化参数，比如文件路径等。\n\n以下是 config 对象的使用方法，不是很重要，所以不常用：\n\nconfig.getservletname();\n\n\n它返回包含在<servlet-name>元素中的 servlet 名字，注意，<servlet-name>元素在web-inf\\web.xml文件中定义。\n\n\n# pagecontext 对象\n\npagecontext对象是javax.servlet.jsp.pagecontext类的实例，用来代表整个 jsp 页面。\n\n这个对象主要用来访问页面信息，同时过滤掉大部分实现细节。\n\n这个对象存储了request对象和response对象的引用。application对象，config对象，session对象，out对象可以通过访问这个对象的属性来导出。\n\npagecontext对象也包含了传给 jsp 页面的指令信息，包括缓存信息，errorpage url,页面 scope 等。\n\npagecontext类定义了一些字段，包括 page_scope，request_scope，session_scope， application_scope。它也提供了 40 余种方法，有一半继承自javax.servlet.jsp.jspcontext 类。\n\n其中一个重要的方法就是removearribute()，它可接受一个或两个参数。比如，pagecontext.removearribute("attrname")移除四个 scope 中相关属性，但是下面这种方法只移除特定 scope 中的相关属性：\n\npagecontext.removeattribute("attrname", page_scope);\n\n\n\n# page 对象\n\n这个对象就是页面实例的引用。它可以被看做是整个 jsp 页面的代表。\n\npage对象就是this对象的同义词。\n\n\n# exception 对象\n\nexception对象包装了从先前页面中抛出的异常信息。它通常被用来产生对出错条件的适当响应。\n\n\n# el 表达式\n\nel 表达式是用${}括起来的脚本，用来更方便地读取对象。el 表达式写在 jsp 的 html 代码中，而不能写在<%与%>引起的 jsp 脚本中。\n\njsp 表达式语言（el）使得访问存储在 javabean 中的数据变得非常简单。jsp el 既可以用来创建算术表达式也可以用来创建逻辑表达式。在 jsp el 表达式内可以使用整型数，浮点数，字符串，常量 true、false，还有 null。\n\n\n# 一个简单的语法\n\n典型的，当您需要在 jsp 标签中指定一个属性值时，只需要简单地使用字符串即可：\n\n<jsp:setproperty name="box" property="perimeter" value="100" />\n\n\njsp el 允许您指定一个表达式来表示属性值。一个简单的表达式语法如下：\n\n${expr}\n\n\n其中，expr 指的是表达式。在 jsp el 中通用的操作符是"."和"[]"。这两个操作符允许您通过内嵌的 jsp 对象访问各种各样的 javabean 属性。\n\n举例来说，上面的 <jsp:setproperty> 标签可以使用表达式语言改写成如下形式：\n\n<jsp:setproperty\n  name="box"\n  property="perimeter"\n  value="${2*box.width+2*box.height}"\n/>\n\n\n当 jsp 编译器在属性中见到"${}"格式后，它会产生代码来计算这个表达式，并且产生一个替代品来代替表达式的值。\n\n您也可以在标签的模板文本中使用表达式语言。比如 <jsp:text> 标签简单地将其主体中的文本插入到 jsp 输出中：\n\n<jsp:text>\n  <h1>hello jsp!</h1>\n</jsp:text>\n\n\n现在，在jsp:text标签主体中使用表达式，就像这样：\n\n<jsp:text>\n  box perimeter is: ${2*box.width + 2*box.height}\n</jsp:text>\n\n\n在 el 表达式中可以使用圆括号来组织子表达式。比如 ${(1 + 2) _ 3} 等于 9，但是 ${1 + (2 _ 3)} 等于 7。\n\n想要停用对 el 表达式的评估的话，需要使用 page 指令将 iselignored 属性值设为 true：\n\n<%@ page iselignored ="true|false" %>\n\n\n这样，el 表达式就会被忽略。若设为 false，则容器将会计算 el 表达式。\n\n\n# el 中的基础操作符\n\nel 表达式支持大部分 java 所提供的算术和逻辑操作符：\n\n操作符         描述\n.           访问一个 bean 属性或者一个映射条目\n[]          访问一个数组或者链表的元素\n( )         组织一个子表达式以改变优先级\n+           加\n-           减或负\n*           乘\n/ or div    除\n% or mod    取模\n== or eq    测试是否相等\n!= or ne    测试是否不等\n< or lt     测试是否小于\n> or gt     测试是否大于\n<= or le    测试是否小于等于\n>= or ge    测试是否大于等于\n&& or and   测试逻辑与\n|| or or    测试逻辑或\n! or not    测试取反\nempty       测试是否空值\n\n\n# jsp el 中的函数\n\njsp el 允许您在表达式中使用函数。这些函数必须被定义在自定义标签库中。函数的使用语法如下：\n\n${ns:func(param1, param2, ...)}\n\n\nns 指的是命名空间（namespace），func 指的是函数的名称，param1 指的是第一个参数，param2 指的是第二个参数，以此类推。比如，有函数 fn:length，在 jstl 库中定义，可以像下面这样来获取一个字符串的长度：\n\n${fn:length("get my length")}\n\n\n要使用任何标签库中的函数，您需要将这些库安装在服务器中，然后使用 <taglib> 标签在 jsp 文件中包含这些库。\n\n\n# jsp el 隐含对象\n\njsp el 支持下表列出的隐含对象：\n\n隐含对象               描述\npagescope          page 作用域\nrequestscope       request 作用域\nsessionscope       session 作用域\napplicationscope   application 作用域\nparam              request 对象的参数，字符串\nparamvalues        request 对象的参数，字符串集合\nheader             http 信息头，字符串\nheadervalues       http 信息头，字符串集合\ninitparam          上下文初始化参数\ncookie             cookie 值\npagecontext        当前页面的 pagecontext\n\n您可以在表达式中使用这些对象，就像使用变量一样。接下来会给出几个例子来更好的理解这个概念。\n\n\n# pagecontext 对象\n\npagecontext 对象是 jsp 中 pagecontext 对象的引用。通过 pagecontext 对象，您可以访问 request 对象。比如，访问 request 对象传入的查询字符串，就像这样：\n\n${pagecontext.request.querystring}\n\n\n\n# scope 对象\n\npagescope，requestscope，sessionscope，applicationscope 变量用来访问存储在各个作用域层次的变量。\n\n举例来说，如果您需要显式访问在 applicationscope 层的 box 变量，可以这样来访问：applicationscope.box。\n\n\n# param 和 paramvalues 对象\n\nparam 和 paramvalues 对象用来访问参数值，通过使用 request.getparameter 方法和 request.getparametervalues 方法。\n\n举例来说，访问一个名为 order 的参数，可以这样使用表达式：${param.order}，或者${param["order"]}。\n\n接下来的例子表明了如何访问 request 中的 username 参数：\n\n<%@ page import="java.io.*,java.util.*" %> <% string title = "accessing request\nparam"; %>\n<html>\n  <head>\n    <title><% out.print(title); %></title>\n  </head>\n  <body>\n    <center>\n      <h1><% out.print(title); %></h1>\n    </center>\n    <div align="center">\n      <p>${param["username"]}</p>\n    </div>\n  </body>\n</html>\n\n\nparam 对象返回单一的字符串，而 paramvalues 对象则返回一个字符串数组。\n\n\n# header 和 headervalues 对象\n\nheader 和 headervalues 对象用来访问信息头，通过使用 request.getheader 方法和 request.getheaders 方法。\n\n举例来说，要访问一个名为 user-agent 的信息头，可以这样使用表达式：${header.user-agent}，或者 ${header["user-agent"]}。\n\n接下来的例子表明了如何访问 user-agent 信息头：\n\n<%@ page import="java.io.*,java.util.*" %> <% string title = "user agent\nexample"; %>\n<html>\n  <head>\n    <title><% out.print(title); %></title>\n  </head>\n  <body>\n    <center>\n      <h1><% out.print(title); %></h1>\n    </center>\n    <div align="center">\n      <p>${header["user-agent"]}</p>\n    </div>\n  </body>\n</html>\n\n\n运行结果如下：\n\n\n\nheader 对象返回单一值，而 headervalues 则返回一个字符串数组。\n\n\n# jstl\n\njsp 标准标签库（jstl）是一个 jsp 标签集合，它封装了 jsp 应用的通用核心功能。\n\njstl 支持通用的、结构化的任务，比如迭代，条件判断，xml 文档操作，国际化标签，sql 标签。 除了这些，它还提供了一个框架来使用集成 jstl 的自定义标签。\n\n根据 jstl 标签所提供的功能，可以将其分为 5 个类别。\n\n * 核心标签\n * 格式化标签\n * sql 标签\n * xml 标签\n * jstl 函数\n\n\n# jstl 库安装\n\napache tomcat 安装 jstl 库步骤如下：\n\n从 apache 的标准标签库中下载的二进包(jakarta-taglibs-standard-current.zip)。\n\n * 官方下载地址：http://archive.apache.org/dist/jakarta/taglibs/standard/binaries/\n * 本站下载地址：jakarta-taglibs-standard-1.1.2.zip\n\n下载 jakarta-taglibs-standard-1.1.2.zip 包并解压，将 jakarta-taglibs-standard-1.1.2/lib/ 下的两个 jar 文件：standard.jar 和 jstl.jar 文件拷贝到 /web-inf/lib/ 下。\n\n将 tld 下的需要引入的 tld 文件复制到 web-inf 目录下。\n\n接下来我们在 web.xml 文件中添加以下配置：\n\n<?xml version="1.0" encoding="utf-8"?>\n<web-app\n  version="2.4"\n  xmlns="http://java.sun.com/xml/ns/j2ee"\n  xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n  xsi:schemalocation="http://java.sun.com/xml/ns/j2ee\n        http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"\n>\n  <jsp-config>\n    <taglib>\n      <taglib-uri>http://java.sun.com/jsp/jstl/fmt</taglib-uri>\n      <taglib-location>/web-inf/fmt.tld</taglib-location>\n    </taglib>\n    <taglib>\n      <taglib-uri>http://java.sun.com/jsp/jstl/fmt-rt</taglib-uri>\n      <taglib-location>/web-inf/fmt-rt.tld</taglib-location>\n    </taglib>\n    <taglib>\n      <taglib-uri>http://java.sun.com/jsp/jstl/core</taglib-uri>\n      <taglib-location>/web-inf/c.tld</taglib-location>\n    </taglib>\n    <taglib>\n      <taglib-uri>http://java.sun.com/jsp/jstl/core-rt</taglib-uri>\n      <taglib-location>/web-inf/c-rt.tld</taglib-location>\n    </taglib>\n    <taglib>\n      <taglib-uri>http://java.sun.com/jsp/jstl/sql</taglib-uri>\n      <taglib-location>/web-inf/sql.tld</taglib-location>\n    </taglib>\n    <taglib>\n      <taglib-uri>http://java.sun.com/jsp/jstl/sql-rt</taglib-uri>\n      <taglib-location>/web-inf/sql-rt.tld</taglib-location>\n    </taglib>\n    <taglib>\n      <taglib-uri>http://java.sun.com/jsp/jstl/x</taglib-uri>\n      <taglib-location>/web-inf/x.tld</taglib-location>\n    </taglib>\n    <taglib>\n      <taglib-uri>http://java.sun.com/jsp/jstl/x-rt</taglib-uri>\n      <taglib-location>/web-inf/x-rt.tld</taglib-location>\n    </taglib>\n  </jsp-config>\n</web-app>\n\n\n使用任何库，你必须在每个 jsp 文件中的头部包含 <taglib> 标签。\n\n\n# 核心标签\n\n核心标签是最常用的 jstl 标签。引用核心标签库的语法如下：\n\n<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>\n\n\n标签              描述\n<c:out>         用于在 jsp 中显示数据，就像<%= ... >\n<c:set>         用于保存数据\n<c:remove>      用于删除数据\n<c:catch>       用来处理产生错误的异常状况，并且将错误信息储存起来\n<c:if>          与我们在一般程序中用的 if 一样\n<c:choose>      本身只当做 <c:when> 和 <c:otherwise> 的父标签\n<c:when>        <c:choose> 的子标签，用来判断条件是否成立\n<c:otherwise>   <c:choose> 的子标签，接在 <c:when> 标签后，当 <c:when> 标签判断为 false 时被执行\n<c:import>      检索一个绝对或相对 url，然后将其内容暴露给页面\n<c:foreach>     基础迭代标签，接受多种集合类型\n<c:fortokens>   根据指定的分隔符来分隔内容并迭代输出\n<c:param>       用来给包含或重定向的页面传递参数\n<c:redirect>    重定向至一个新的 url.\n<c:url>         使用可选的查询参数来创造一个 url\n\n\n# 格式化标签\n\njstl 格式化标签用来格式化并输出文本、日期、时间、数字。引用格式化标签库的语法如下：\n\n<%@ taglib prefix="fmt" uri="http://java.sun.com/jsp/jstl/fmt" %>\n\n\n标签                      描述\n<fmt:formatnumber>      使用指定的格式或精度格式化数字\n<fmt:parsenumber>       解析一个代表着数字，货币或百分比的字符串\n<fmt:formatdate>        使用指定的风格或模式格式化日期和时间\n<fmt:parsedate>         解析一个代表着日期或时间的字符串\n<fmt:bundle>            绑定资源\n<fmt:setlocale>         指定地区\n<fmt:setbundle>         绑定资源\n<fmt:timezone>          指定时区\n<fmt:settimezone>       指定时区\n<fmt:message>           显示资源配置文件信息\n<fmt:requestencoding>   设置 request 的字符编码\n\n\n# sql 标签\n\njstl sql 标签库提供了与关系型数据库（oracle，mysql，sql server 等等）进行交互的标签。引用 sql 标签库的语法如下：\n\n<%@ taglib prefix="sql" uri="http://java.sun.com/jsp/jstl/sql" %>\n\n\n标签                    描述\n<sql:setdatasource>   指定数据源\n<sql:query>           运行 sql 查询语句\n<sql:update>          运行 sql 更新语句\n<sql:param>           将 sql 语句中的参数设为指定值\n<sql:dateparam>       将 sql 语句中的日期参数设为指定的 java.util.date 对象值\n<sql:transaction>     在共享数据库连接中提供嵌套的数据库行为元素，将所有语句以一个事务的形式来运行\n\n\n# xml 标签\n\njstl xml 标签库提供了创建和操作 xml 文档的标签。引用 xml 标签库的语法如下：\n\n<%@ taglib prefix="x" uri="http://java.sun.com/jsp/jstl/xml" %>\n\n\n在使用 xml 标签前，你必须将 xml 和 xpath 的相关包拷贝至你的 <tomcat 安装目录>\\lib 下:\n\n * xercesimpl.jar\n   \n   下载地址： http://www.apache.org/dist/xerces/j/\n\n * xalan.jar\n   \n   下载地址： http://xml.apache.org/xalan-j/index.html\n\n标签              描述\n<x:out>         与 <%= ... >,类似，不过只用于 xpath 表达式\n<x:parse>       解析 xml 数据\n<x:set>         设置 xpath 表达式\n<x:if>          判断 xpath 表达式，若为真，则执行本体中的内容，否则跳过本体\n<x:foreach>     迭代 xml 文档中的节点\n<x:choose>      <x:when> 和 <x:otherwise> 的父标签\n<x:when>        <x:choose> 的子标签，用来进行条件判断\n<x:otherwise>   <x:choose> 的子标签，当 <x:when> 判断为 false 时被执行\n<x:transform>   将 xsl 转换应用在 xml 文档中\n<x:param>       与 <x:transform> 共同使用，用于设置 xsl 样式表\n\n\n# jstl 函数\n\njstl 包含一系列标准函数，大部分是通用的字符串处理函数。引用 jstl 函数库的语法如下：\n\n<%@ taglib prefix="fn" uri="http://java.sun.com/jsp/jstl/functions" %>\n\n\n函数                        描述\nfn:contains()             测试输入的字符串是否包含指定的子串\nfn:containsignorecase()   测试输入的字符串是否包含指定的子串，大小写不敏感\nfn:endswith()             测试输入的字符串是否以指定的后缀结尾\nfn:escapexml()            跳过可以作为 xml 标记的字符\nfn:indexof()              返回指定字符串在输入字符串中出现的位置\nfn:join()                 将数组中的元素合成一个字符串然后输出\nfn:length()               返回字符串长度\nfn:replace()              将输入字符串中指定的位置替换为指定的字符串然后返回\nfn:split()                将字符串用指定的分隔符分隔然后组成一个子字符串数组并返回\nfn:startswith()           测试输入字符串是否以指定的前缀开始\nfn:substring()            返回字符串的子集\nfn:substringafter()       返回字符串在指定子串之后的子集\nfn:substringbefore()      返回字符串在指定子串之前的子集\nfn:tolowercase()          将字符串中的字符转为小写\nfn:touppercase()          将字符串中的字符转为大写\nfn:trim()                 移除首尾的空白符\n\n\n# taglib\n\n\n# jsp 自定义标签\n\n自定义标签是用户定义的 jsp 语言元素。当 jsp 页面包含一个自定义标签时将被转化为 servlet，标签转化为对被 称为 tag handler 的对象的操作，即当 servlet 执行时 web container 调用那些操作。\n\njsp 标签扩展可以让你创建新的标签并且可以直接插入到一个 jsp 页面。 jsp 2.0 规范中引入 simple tag handlers 来编写这些自定义标记。\n\n你可以继承 simpletagsupport 类并重写的 dotag()方法来开发一个最简单的自定义标签。\n\n\n# 创建"hello"标签\n\n接下来，我们想创建一个自定义标签叫作ex:hello，标签格式为：\n\n<ex:hello />\n\n\n要创建自定义的 jsp 标签，你首先必须创建处理标签的 java 类。所以，让我们创建一个 hellotag 类，如下所示：\n\npackage com.runoob; import javax.servlet.jsp.tagext.*; import\njavax.servlet.jsp.*; import java.io.*; public class hellotag extends\nsimpletagsupport { public void dotag() throws jspexception, ioexception {\njspwriter out = getjspcontext().getout(); out.println("hello custom tag!"); } }\n\n\n以下代码重写了 dotag()方法，方法中使用了 getjspcontext()方法来获取当前的 jspcontext 对象，并将"hello custom tag!"传递给 jspwriter 对象。\n\n编译以上类，并将其复制到环境变量 classpath 目录中。最后创建如下标签库：<tomcat安装目录>webapps\\root\\web-inf\\custom.tld。\n\n<taglib>\n  <tlib-version>1.0</tlib-version>\n  <jsp-version>2.0</jsp-version>\n  <short-name>example tld</short-name>\n  <tag>\n    <name>hello</name>\n    <tag-class>com.runoob.hellotag</tag-class>\n    <body-content>empty</body-content>\n  </tag>\n</taglib>\n\n\n接下来，我们就可以在 jsp 文件中使用 hello 标签：\n\n<%@ taglib prefix="ex" uri="web-inf/custom.tld"%>\n<html>\n  <head>\n    <title>a sample custom tag</title>\n  </head>\n  <body>\n    <ex:hello />\n  </body>\n</html>\n\n\n以上程序输出结果为：\n\nhello custom tag!\n\n\n\n# 访问标签体\n\n你可以像标准标签库一样在标签中包含消息内容。如我们要在我们自定义的 hello 中包含内容，格式如下：\n\n<ex:hello>\n  this is message body\n</ex:hello>\n\n\n我们可以修改标签处理类文件，代码如下：\n\npackage com.runoob;\n\nimport javax.servlet.jsp.tagext.*;\nimport javax.servlet.jsp.*;\nimport java.io.*;\n\npublic class hellotag extends simpletagsupport {\n\n   stringwriter sw = new stringwriter();\n   public void dotag()\n      throws jspexception, ioexception\n    {\n       getjspbody().invoke(sw);\n       getjspcontext().getout().println(sw.tostring());\n    }\n\n}\n\n\n接下来我们需要修改 tld 文件，如下所示：\n\n<taglib>\n  <tlib-version>1.0</tlib-version>\n  <jsp-version>2.0</jsp-version>\n  <short-name>example tld with body</short-name>\n  <tag>\n    <name>hello</name>\n    <tag-class>com.runoob.hellotag</tag-class>\n    <body-content>scriptless</body-content>\n  </tag>\n</taglib>\n\n\n现在我们可以在 jsp 使用修改后的标签，如下所示:\n\n<%@ taglib prefix="ex" uri="web-inf/custom.tld"%>\n<html>\n  <head>\n    <title>a sample custom tag</title>\n  </head>\n  <body>\n    <ex:hello>\n      this is message body\n    </ex:hello>\n  </body>\n</html>\n\n\n以上程序输出结果如下所示：\n\nthis is message body\n\n\n\n# 自定义标签属性\n\n你可以在自定义标准中设置各种属性，要接收属性，值自定义标签类必须实现 setter 方法， javabean 中的 setter 方法如下所示：\n\npackage com.runoob;\n\nimport javax.servlet.jsp.tagext.*;\nimport javax.servlet.jsp.*;\nimport java.io.*;\n\npublic class hellotag extends simpletagsupport {\n\n   private string message;\n\n   public void setmessage(string msg) {\n      this.message = msg;\n   }\n\n   stringwriter sw = new stringwriter();\n\n   public void dotag()\n      throws jspexception, ioexception\n    {\n       if (message != null) {\n          /* 从属性中使用消息 */\n          jspwriter out = getjspcontext().getout();\n          out.println( message );\n       }\n       else {\n          /* 从内容体中使用消息 */\n          getjspbody().invoke(sw);\n          getjspcontext().getout().println(sw.tostring());\n       }\n   }\n\n}\n\n\n属性的名称是"message"，所以 setter 方法是的 setmessage()。现在让我们在 tld 文件中使用的 <attribute> 元素添加此属性：\n\n<taglib>\n  <tlib-version>1.0</tlib-version>\n  <jsp-version>2.0</jsp-version>\n  <short-name>example tld with body</short-name>\n  <tag>\n    <name>hello</name>\n    <tag-class>com.runoob.hellotag</tag-class>\n    <body-content>scriptless</body-content>\n    <attribute>\n      <name>message</name>\n    </attribute>\n  </tag>\n</taglib>\n\n\n现在我们就可以在 jsp 文件中使用 message 属性了，如下所示：\n\n<%@ taglib prefix="ex" uri="web-inf/custom.tld"%>\n<html>\n  <head>\n    <title>a sample custom tag</title>\n  </head>\n  <body>\n    <ex:hello message="this is custom tag" />\n  </body>\n</html>\n\n\n以上实例数据输出结果为：\n\nthis is custom tag\n\n\n你还可以包含以下属性：\n\n属性            描述\nname          定义属性的名称。每个标签的是属性名称必须是唯一的。\nrequired      指定属性是否是必须的或者可选的,如果设置为 false 为可选。\nrtexprvalue   声明在运行表达式时，标签属性是否有效。\ntype          定义该属性的 java 类类型 。默认指定为 string\ndescription   描述信息\nfragment      如果声明了该属性,属性值将被视为一个 jspfragment。\n\n以下是指定相关的属性实例：\n\n.....\n<attribute>\n  <name>attribute_name</name>\n  <required>false</required>\n  <type>java.util.date</type>\n  <fragment>false</fragment>\n</attribute>\n.....\n\n\n如果你使用了两个属性，修改 tld 文件，如下所示：\n\n.....\n<attribute>\n  <name>attribute_name1</name>\n  <required>false</required>\n  <type>java.util.boolean</type>\n  <fragment>false</fragment>\n</attribute>\n<attribute>\n  <name>attribute_name2</name>\n  <required>true</required>\n  <type>java.util.date</type>\n</attribute>\n.....\n',charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"JavaWeb 之 Filter 和 Listener",frontmatter:{title:"JavaWeb 之 Filter 和 Listener",date:"2020-08-24T19:41:46.000Z",order:3,categories:["Java","JavaEE","JavaWeb"],tags:["Java","JavaWeb","Filter","Listener"],permalink:"/pages/82df5f/"},regularPath:"/01.Java/02.JavaEE/01.JavaWeb/03.JavaWeb%E4%B9%8BFilter%E5%92%8CListener.html",relativePath:"01.Java/02.JavaEE/01.JavaWeb/03.JavaWeb之Filter和Listener.md",key:"v-1897f31c",path:"/pages/82df5f/",headers:[{level:2,title:"Filter",slug:"filter",normalizedTitle:"filter",charIndex:12},{level:3,title:"过滤器方法",slug:"过滤器方法",normalizedTitle:"过滤器方法",charIndex:483},{level:3,title:"过滤器配置",slug:"过滤器配置",normalizedTitle:"过滤器配置",charIndex:1350},{level:2,title:"Listener",slug:"listener",normalizedTitle:"listener",charIndex:21},{level:3,title:"监听器的分类",slug:"监听器的分类",normalizedTitle:"监听器的分类",charIndex:2207},{level:3,title:"监听对象的创建和销毁",slug:"监听对象的创建和销毁",normalizedTitle:"监听对象的创建和销毁",charIndex:2439},{level:4,title:"HttpSessionListener",slug:"httpsessionlistener",normalizedTitle:"httpsessionlistener",charIndex:2453},{level:4,title:"ServletContextListener",slug:"servletcontextlistener",normalizedTitle:"servletcontextlistener",charIndex:2652},{level:4,title:"ServletRequestListener",slug:"servletrequestlistener",normalizedTitle:"servletrequestlistener",charIndex:3072},{level:3,title:"监听对象的属性变化",slug:"监听对象的属性变化",normalizedTitle:"监听对象的属性变化",charIndex:3390},{level:4,title:"attributeAdded 方法",slug:"attributeadded-方法",normalizedTitle:"attributeadded 方法",charIndex:3676},{level:4,title:"attributeRemoved 方法",slug:"attributeremoved-方法",normalizedTitle:"attributeremoved 方法",charIndex:4011},{level:4,title:"attributeReplaced 方法",slug:"attributereplaced-方法",normalizedTitle:"attributereplaced 方法",charIndex:4298},{level:3,title:"监听 Session 内的对象",slug:"监听-session-内的对象",normalizedTitle:"监听 session 内的对象",charIndex:4594},{level:4,title:"HttpSessionBindingListener",slug:"httpsessionbindinglistener",normalizedTitle:"httpsessionbindinglistener",charIndex:4828},{level:4,title:"HttpSessionActivationListener",slug:"httpsessionactivationlistener",normalizedTitle:"httpsessionactivationlistener",charIndex:4856},{level:2,title:"Filter 和 Listener",slug:"filter-和-listener",normalizedTitle:"filter 和 listener",charIndex:12},{level:2,title:"示例代码",slug:"示例代码",normalizedTitle:"示例代码",charIndex:5846},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:5896}],headersStr:"Filter 过滤器方法 过滤器配置 Listener 监听器的分类 监听对象的创建和销毁 HttpSessionListener ServletContextListener ServletRequestListener 监听对象的属性变化 attributeAdded 方法 attributeRemoved 方法 attributeReplaced 方法 监听 Session 内的对象 HttpSessionBindingListener HttpSessionActivationListener Filter 和 Listener 示例代码 参考资料",content:'# JavaWeb 之 Filter 和 Listener\n\n引入了 Servlet 规范后，你不需要关心 Socket 网络通信、不需要关心 HTTP 协议，也不需要关心你的业务类是如何被实例化和调用的，因为这些都被 Servlet 规范标准化了，你只要关心怎么实现的你的业务逻辑。这对于程序员来说是件好事，但也有不方便的一面。所谓规范就是说大家都要遵守，就会千篇一律，但是如果这个规范不能满足你的业务的个性化需求，就有问题了，因此设计一个规范或者一个中间件，要充分考虑到可扩展性。Servlet 规范提供了两种扩展机制：Filter和Listener。\n\n\n# Filter\n\nFilter 是过滤器，这个接口允许你对请求和响应做一些统一的定制化处理。\n\nFilter 提供了过滤链（Filter Chain）的概念，一个过滤链包括多个 Filter。客户端请求 request 在抵达 Servlet 之前会经过过滤链的所有 Filter，服务器响应 response 从 Servlet 抵达客户端浏览器之前也会经过过滤链的所有 FIlter。\n\n\n\n\n# 过滤器方法\n\nFilter 接口有三个方法：\n\n * init：初始化 Filter\n * destroy：销毁 Filter\n * doFilter：将请求传给下个 Filter 或 Servlet\n\ninit 和 destroy 方法只会被调用一次；doFilter 每次有客户端请求都会被调用一次。\n\npublic interface Filter {\n\n\t/**\n\t * web 程序启动时调用此方法, 用于初始化该 Filter\n\t * @param config\n\t *            可以从该参数中获取初始化参数以及ServletContext信息等\n\t * @throws ServletException\n\t */\n\tpublic void init(FilterConfig config) throws ServletException;\n\n\t/**\n\t * 客户请求服务器时会经过\n\t *\n\t * @param request\n\t *            客户请求\n\t * @param response\n\t *            服务器响应\n\t * @param chain\n\t *            过滤链, 通过 chain.doFilter(request, response) 将请求传给下个 Filter 或\n\t *            Servlet\n\t * @throws ServletException\n\t * @throws IOException\n\t */\n\tpublic void doFilter(ServletRequest request, ServletResponse response,\n\t\t\tFilterChain chain) throws ServletException, IOException;\n\n\t/**\n\t * web 程序关闭时调用此方法, 用于销毁一些资源\n\t */\n\tpublic void destroy();\n\n}\n\n\n\n# 过滤器配置\n\nFilter 需要配置在 web.xml 中才能生效。一个 Filter 需要配置 <filter> 与 <filter-mapping> 标签。\n\n * <filter> 配置 Filter 名称，实现类以及初始化参数。\n * <filter-mapping> 配置什么规则下使用该 Filter。\n * <filter> 的 filterName 与 <filter-mapping> 的 filterName 必须匹配。\n * <url-pattern> 配置 URL 的规则，可以配置多个，可以使用通配符（*）。\n * <dispatcher> 配置到达 Servlet 的方式，有 4 种取值：REQUEST、FORWARD、INCLUDE、ERROR。可以同时配置多个 <dispatcher>。如果没有配置任何 <dispatcher>，默认为 REQUEST。\n   * REQUEST - 表示仅当直接请求 Servlet 时才生效。\n   * FORWARD - 表示仅当某 Servlet 通过 FORWARD 到该 Servlet 时才生效。\n   * INCLUDE - JSP 中可以通过 <jsp:include> 请求某 Servlet。仅在这种情况表有效。\n   * ERROR - JSP 中可以通过 <%@ page errorPage="error.jsp" %> 指定错误处理页面。仅在这种情况表有效。\n\n\n# Listener\n\n监听器（Listener）用于监听 web 应用程序中的ServletContext, HttpSession和 ServletRequest等域对象的创建与销毁事件，以及监听这些域对象中的属性发生修改的事件。\n\n使用 Listener 不需要关注该类事件时怎样触发或者怎么调用相应的 Listener，只要记住该类事件触发时一定会调用相应的 Listener，遵循 Servlet 规范的服务器会自动完成相应工作。\n\n\n# 监听器的分类\n\n在 Servlet 规范中定义了多种类型的监听器，它们用于监听的事件源分别为ServletContext，HttpSession和ServletRequest这三个域对象 Servlet 规范针对这三个对象上的操作，又把多种类型的监听器划分为三种类型：\n\n 1. 监听域对象自身的创建和销毁的事件监听器。\n 2. 监听域对象中的属性的增加和删除的事件监听器。\n 3. 监听绑定到 HttpSession 域中的某个对象的状态的事件监听器。\n\n\n# 监听对象的创建和销毁\n\n# HttpSessionListener\n\nHttpSessionListener 接口用于监听 HttpSession 对象的创建和销毁。\n\n * 创建一个 Session 时，激发 sessionCreated (HttpSessionEvent se) 方法\n * 销毁一个 Session 时，激发 sessionDestroyed (HttpSessionEvent se) 方法。\n\n# ServletContextListener\n\nServletContextListener 接口用于监听 ServletContext 对象的创建和销毁事件。\n\n实现了 ServletContextListener 接口的类都可以对 ServletContext 对象的创建和销毁进行监听。\n\n * 当 ServletContext 对象被创建时，激发 contextInitialized (ServletContextEvent sce) 方法。\n * 当 ServletContext 对象被销毁时，激发 contextDestroyed(ServletContextEvent sce) 方法。\n\nServletContext 域对象创建和销毁时机：\n\n * 创建：服务器启动针对每一个 Web 应用创建 ServletContext\n * 销毁：服务器关闭前先关闭代表每一个 web 应用的 ServletContext\n\n# ServletRequestListener\n\nServletRequestListener 接口用于监听 ServletRequest 对象的创建和销毁。\n\n * Request 对象被创建时，监听器的 requestInitialized(ServletRequestEvent sre) 方法将会被调用\n * Request 对象被销毁时，监听器的 requestDestroyed(ServletRequestEvent sre) 方法将会被调用\n\nServletRequest 域对象创建和销毁时机：\n\n * 创建：用户每一次访问都会创建 request 对象\n * 销毁：当前访问结束，request 对象就会销毁\n\n\n# 监听对象的属性变化\n\n域对象中属性的变更的事件监听器就是用来监听 ServletContext、HttpSession、HttpServletRequest 这三个对象中的属性变更信息事件的监听器。 这三个监听器接口分别是 ServletContextAttributeListener、HttpSessionAttributeListener 和 ServletRequestAttributeListener，这三个接口中都定义了三个方法来处理被监听对象中的属性的增加，删除和替换的事件，同一个事件在这三个接口中对应的方法名称完全相同，只是接受的参数类型不同。\n\n# attributeAdded 方法\n\n当向被监听对象中增加一个属性时，web 容器就调用事件监听器的 attributeAdded 方法进行响应，这个方法接收一个事件类型的参数，监听器可以通过这个参数来获得正在增加属性的域对象和被保存到域中的属性对象 各个域属性监听器中的完整语法定义为：\n\npublic void attributeAdded(ServletContextAttributeEvent scae)\npublic void attributeReplaced(HttpSessionBindingEvent hsbe)\npublic void attributeRmoved(ServletRequestAttributeEvent srae)\n\n\n# attributeRemoved 方法\n\n当删除被监听对象中的一个属性时，web 容器调用事件监听器的 attributeRemoved 方法进行响应 各个域属性监听器中的完整语法定义为：\n\npublic void attributeRemoved(ServletContextAttributeEvent scae)\npublic void attributeRemoved(HttpSessionBindingEvent hsbe)\npublic void attributeRemoved(ServletRequestAttributeEvent srae)\n\n\n# attributeReplaced 方法\n\n当监听器的域对象中的某个属性被替换时，web 容器调用事件监听器的 attributeReplaced 方法进行响应 各个域属性监听器中的完整语法定义为：\n\npublic void attributeReplaced(ServletContextAttributeEvent scae)\npublic void attributeReplaced(HttpSessionBindingEvent hsbe)\npublic void attributeReplaced(ServletRequestAttributeEvent srae)\n\n\n\n# 监听 Session 内的对象\n\n保存在 Session 域中的对象可以有多种状态：\n\n * 绑定（session.setAttribute("bean",Object)）到 Session 中；\n * 从 Session 域中解除绑定（session.removeAttribute("bean")）；\n * 随 Session 对象持久化到一个存储设备中；\n * 随 Session 对象从一个存储设备中恢复。\n\nServlet 规范中定义了两个特殊的监听器接口 HttpSessionBindingListener 和HttpSessionActivationListener 来帮助 JavaBean 对象了解自己在 Session 域中的这些状态。\n\n实现这两个接口的类不需要 web.xml 文件中进行注册。\n\n# HttpSessionBindingListener\n\nHttpSessionBindingListener 接口的 JavaBean 对象可以感知自己被绑定或解绑定到 Session 中的事件。\n\n * 当对象被绑定到 HttpSession 对象中时，web 服务器调用该对象的 valueBound(HttpSessionBindingEvent event) 方法。\n * 当对象从 HttpSession 对象中解除绑定时，web 服务器调用该对象的 valueUnbound(HttpSessionBindingEvent event) 方法。\n\n# HttpSessionActivationListener\n\n实现了 HttpSessionActivationListener 接口的 JavaBean 对象可以感知自己被活化(反序列化)和钝化(序列化)的事件。\n\n * 当绑定到 HttpSession 对象中的 JavaBean 对象将要随 HttpSession 对象被序列化之前，web 服务器调用该 JavaBean 对象的 sessionWillPassivate(HttpSessionEvent event) 方法。这样 JavaBean 对象就可以知道自己将要和 HttpSession 对象一起被序列化到硬盘中.\n * 当绑定到 HttpSession 对象中的 JavaBean 对象将要随 HttpSession 对象被反序列化之后，web 服务器调用该 JavaBean 对象的 sessionDidActive(HttpSessionEvent event) 方法。这样 JavaBean 对象就可以知道自己将要和 HttpSession 对象一起被反序列化回到内存中\n\n\n# Filter 和 Listener\n\nFilter 和 Listener 的本质区别：\n\n * Filter 是干预过程的，它是过程的一部分，是基于过程行为的。\n * Listener 是基于状态的，任何行为改变同一个状态，触发的事件是一致的。\n\n\n# 示例代码\n\n * Filter 的示例源码：源码\n * Listener 的示例源码：源码\n\n\n# 参考资料\n\n * 深入拆解 Tomcat & Jetty\n * Java Web 整合开发王者归来',normalizedContent:'# javaweb 之 filter 和 listener\n\n引入了 servlet 规范后，你不需要关心 socket 网络通信、不需要关心 http 协议，也不需要关心你的业务类是如何被实例化和调用的，因为这些都被 servlet 规范标准化了，你只要关心怎么实现的你的业务逻辑。这对于程序员来说是件好事，但也有不方便的一面。所谓规范就是说大家都要遵守，就会千篇一律，但是如果这个规范不能满足你的业务的个性化需求，就有问题了，因此设计一个规范或者一个中间件，要充分考虑到可扩展性。servlet 规范提供了两种扩展机制：filter和listener。\n\n\n# filter\n\nfilter 是过滤器，这个接口允许你对请求和响应做一些统一的定制化处理。\n\nfilter 提供了过滤链（filter chain）的概念，一个过滤链包括多个 filter。客户端请求 request 在抵达 servlet 之前会经过过滤链的所有 filter，服务器响应 response 从 servlet 抵达客户端浏览器之前也会经过过滤链的所有 filter。\n\n\n\n\n# 过滤器方法\n\nfilter 接口有三个方法：\n\n * init：初始化 filter\n * destroy：销毁 filter\n * dofilter：将请求传给下个 filter 或 servlet\n\ninit 和 destroy 方法只会被调用一次；dofilter 每次有客户端请求都会被调用一次。\n\npublic interface filter {\n\n\t/**\n\t * web 程序启动时调用此方法, 用于初始化该 filter\n\t * @param config\n\t *            可以从该参数中获取初始化参数以及servletcontext信息等\n\t * @throws servletexception\n\t */\n\tpublic void init(filterconfig config) throws servletexception;\n\n\t/**\n\t * 客户请求服务器时会经过\n\t *\n\t * @param request\n\t *            客户请求\n\t * @param response\n\t *            服务器响应\n\t * @param chain\n\t *            过滤链, 通过 chain.dofilter(request, response) 将请求传给下个 filter 或\n\t *            servlet\n\t * @throws servletexception\n\t * @throws ioexception\n\t */\n\tpublic void dofilter(servletrequest request, servletresponse response,\n\t\t\tfilterchain chain) throws servletexception, ioexception;\n\n\t/**\n\t * web 程序关闭时调用此方法, 用于销毁一些资源\n\t */\n\tpublic void destroy();\n\n}\n\n\n\n# 过滤器配置\n\nfilter 需要配置在 web.xml 中才能生效。一个 filter 需要配置 <filter> 与 <filter-mapping> 标签。\n\n * <filter> 配置 filter 名称，实现类以及初始化参数。\n * <filter-mapping> 配置什么规则下使用该 filter。\n * <filter> 的 filtername 与 <filter-mapping> 的 filtername 必须匹配。\n * <url-pattern> 配置 url 的规则，可以配置多个，可以使用通配符（*）。\n * <dispatcher> 配置到达 servlet 的方式，有 4 种取值：request、forward、include、error。可以同时配置多个 <dispatcher>。如果没有配置任何 <dispatcher>，默认为 request。\n   * request - 表示仅当直接请求 servlet 时才生效。\n   * forward - 表示仅当某 servlet 通过 forward 到该 servlet 时才生效。\n   * include - jsp 中可以通过 <jsp:include> 请求某 servlet。仅在这种情况表有效。\n   * error - jsp 中可以通过 <%@ page errorpage="error.jsp" %> 指定错误处理页面。仅在这种情况表有效。\n\n\n# listener\n\n监听器（listener）用于监听 web 应用程序中的servletcontext, httpsession和 servletrequest等域对象的创建与销毁事件，以及监听这些域对象中的属性发生修改的事件。\n\n使用 listener 不需要关注该类事件时怎样触发或者怎么调用相应的 listener，只要记住该类事件触发时一定会调用相应的 listener，遵循 servlet 规范的服务器会自动完成相应工作。\n\n\n# 监听器的分类\n\n在 servlet 规范中定义了多种类型的监听器，它们用于监听的事件源分别为servletcontext，httpsession和servletrequest这三个域对象 servlet 规范针对这三个对象上的操作，又把多种类型的监听器划分为三种类型：\n\n 1. 监听域对象自身的创建和销毁的事件监听器。\n 2. 监听域对象中的属性的增加和删除的事件监听器。\n 3. 监听绑定到 httpsession 域中的某个对象的状态的事件监听器。\n\n\n# 监听对象的创建和销毁\n\n# httpsessionlistener\n\nhttpsessionlistener 接口用于监听 httpsession 对象的创建和销毁。\n\n * 创建一个 session 时，激发 sessioncreated (httpsessionevent se) 方法\n * 销毁一个 session 时，激发 sessiondestroyed (httpsessionevent se) 方法。\n\n# servletcontextlistener\n\nservletcontextlistener 接口用于监听 servletcontext 对象的创建和销毁事件。\n\n实现了 servletcontextlistener 接口的类都可以对 servletcontext 对象的创建和销毁进行监听。\n\n * 当 servletcontext 对象被创建时，激发 contextinitialized (servletcontextevent sce) 方法。\n * 当 servletcontext 对象被销毁时，激发 contextdestroyed(servletcontextevent sce) 方法。\n\nservletcontext 域对象创建和销毁时机：\n\n * 创建：服务器启动针对每一个 web 应用创建 servletcontext\n * 销毁：服务器关闭前先关闭代表每一个 web 应用的 servletcontext\n\n# servletrequestlistener\n\nservletrequestlistener 接口用于监听 servletrequest 对象的创建和销毁。\n\n * request 对象被创建时，监听器的 requestinitialized(servletrequestevent sre) 方法将会被调用\n * request 对象被销毁时，监听器的 requestdestroyed(servletrequestevent sre) 方法将会被调用\n\nservletrequest 域对象创建和销毁时机：\n\n * 创建：用户每一次访问都会创建 request 对象\n * 销毁：当前访问结束，request 对象就会销毁\n\n\n# 监听对象的属性变化\n\n域对象中属性的变更的事件监听器就是用来监听 servletcontext、httpsession、httpservletrequest 这三个对象中的属性变更信息事件的监听器。 这三个监听器接口分别是 servletcontextattributelistener、httpsessionattributelistener 和 servletrequestattributelistener，这三个接口中都定义了三个方法来处理被监听对象中的属性的增加，删除和替换的事件，同一个事件在这三个接口中对应的方法名称完全相同，只是接受的参数类型不同。\n\n# attributeadded 方法\n\n当向被监听对象中增加一个属性时，web 容器就调用事件监听器的 attributeadded 方法进行响应，这个方法接收一个事件类型的参数，监听器可以通过这个参数来获得正在增加属性的域对象和被保存到域中的属性对象 各个域属性监听器中的完整语法定义为：\n\npublic void attributeadded(servletcontextattributeevent scae)\npublic void attributereplaced(httpsessionbindingevent hsbe)\npublic void attributermoved(servletrequestattributeevent srae)\n\n\n# attributeremoved 方法\n\n当删除被监听对象中的一个属性时，web 容器调用事件监听器的 attributeremoved 方法进行响应 各个域属性监听器中的完整语法定义为：\n\npublic void attributeremoved(servletcontextattributeevent scae)\npublic void attributeremoved(httpsessionbindingevent hsbe)\npublic void attributeremoved(servletrequestattributeevent srae)\n\n\n# attributereplaced 方法\n\n当监听器的域对象中的某个属性被替换时，web 容器调用事件监听器的 attributereplaced 方法进行响应 各个域属性监听器中的完整语法定义为：\n\npublic void attributereplaced(servletcontextattributeevent scae)\npublic void attributereplaced(httpsessionbindingevent hsbe)\npublic void attributereplaced(servletrequestattributeevent srae)\n\n\n\n# 监听 session 内的对象\n\n保存在 session 域中的对象可以有多种状态：\n\n * 绑定（session.setattribute("bean",object)）到 session 中；\n * 从 session 域中解除绑定（session.removeattribute("bean")）；\n * 随 session 对象持久化到一个存储设备中；\n * 随 session 对象从一个存储设备中恢复。\n\nservlet 规范中定义了两个特殊的监听器接口 httpsessionbindinglistener 和httpsessionactivationlistener 来帮助 javabean 对象了解自己在 session 域中的这些状态。\n\n实现这两个接口的类不需要 web.xml 文件中进行注册。\n\n# httpsessionbindinglistener\n\nhttpsessionbindinglistener 接口的 javabean 对象可以感知自己被绑定或解绑定到 session 中的事件。\n\n * 当对象被绑定到 httpsession 对象中时，web 服务器调用该对象的 valuebound(httpsessionbindingevent event) 方法。\n * 当对象从 httpsession 对象中解除绑定时，web 服务器调用该对象的 valueunbound(httpsessionbindingevent event) 方法。\n\n# httpsessionactivationlistener\n\n实现了 httpsessionactivationlistener 接口的 javabean 对象可以感知自己被活化(反序列化)和钝化(序列化)的事件。\n\n * 当绑定到 httpsession 对象中的 javabean 对象将要随 httpsession 对象被序列化之前，web 服务器调用该 javabean 对象的 sessionwillpassivate(httpsessionevent event) 方法。这样 javabean 对象就可以知道自己将要和 httpsession 对象一起被序列化到硬盘中.\n * 当绑定到 httpsession 对象中的 javabean 对象将要随 httpsession 对象被反序列化之后，web 服务器调用该 javabean 对象的 sessiondidactive(httpsessionevent event) 方法。这样 javabean 对象就可以知道自己将要和 httpsession 对象一起被反序列化回到内存中\n\n\n# filter 和 listener\n\nfilter 和 listener 的本质区别：\n\n * filter 是干预过程的，它是过程的一部分，是基于过程行为的。\n * listener 是基于状态的，任何行为改变同一个状态，触发的事件是一致的。\n\n\n# 示例代码\n\n * filter 的示例源码：源码\n * listener 的示例源码：源码\n\n\n# 参考资料\n\n * 深入拆解 tomcat & jetty\n * java web 整合开发王者归来',charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"JavaWeb 之 Cookie 和 Session",frontmatter:{title:"JavaWeb 之 Cookie 和 Session",date:"2020-08-24T19:41:46.000Z",order:4,categories:["Java","JavaEE","JavaWeb"],tags:["Java","JavaWeb","Cookie","Session"],permalink:"/pages/c46bff/"},regularPath:"/01.Java/02.JavaEE/01.JavaWeb/04.JavaWeb%E4%B9%8BCookie%E5%92%8CSession.html",relativePath:"01.Java/02.JavaEE/01.JavaWeb/04.JavaWeb之Cookie和Session.md",key:"v-36554d68",path:"/pages/c46bff/",headers:[{level:2,title:"Cookie",slug:"cookie",normalizedTitle:"cookie",charIndex:12},{level:3,title:"Cookie 是什么",slug:"cookie-是什么",normalizedTitle:"cookie 是什么",charIndex:143},{level:3,title:"Cookie 剖析",slug:"cookie-剖析",normalizedTitle:"cookie 剖析",charIndex:483},{level:3,title:"Cookie 类中的方法",slug:"cookie-类中的方法",normalizedTitle:"cookie 类中的方法",charIndex:1288},{level:3,title:"Cookie 的有效期",slug:"cookie-的有效期",normalizedTitle:"cookie 的有效期",charIndex:2432},{level:3,title:"Cookie 的域名",slug:"cookie-的域名",normalizedTitle:"cookie 的域名",charIndex:2632},{level:3,title:"Cookie 的路径",slug:"cookie-的路径",normalizedTitle:"cookie 的路径",charIndex:991},{level:3,title:"Cookie 的安全属性",slug:"cookie-的安全属性",normalizedTitle:"cookie 的安全属性",charIndex:3014},{level:3,title:"Cookie 实例",slug:"cookie-实例",normalizedTitle:"cookie 实例",charIndex:3254},{level:4,title:"添加 Cookie",slug:"添加-cookie",normalizedTitle:"添加 cookie",charIndex:3267},{level:4,title:"显示 Cookie",slug:"显示-cookie",normalizedTitle:"显示 cookie",charIndex:6148},{level:4,title:"删除 Cookie",slug:"删除-cookie",normalizedTitle:"删除 cookie",charIndex:8707},{level:2,title:"Session",slug:"session",normalizedTitle:"session",charIndex:21},{level:3,title:"Session 是什么",slug:"session-是什么",normalizedTitle:"session 是什么",charIndex:11262},{level:3,title:"Session 类中的方法",slug:"session-类中的方法",normalizedTitle:"session 类中的方法",charIndex:11473},{level:3,title:"Session 的有效期",slug:"session-的有效期",normalizedTitle:"session 的有效期",charIndex:12772},{level:3,title:"Session 对浏览器的要求",slug:"session-对浏览器的要求",normalizedTitle:"session 对浏览器的要求",charIndex:13121},{level:3,title:"URL 地址重写",slug:"url-地址重写",normalizedTitle:"url 地址重写",charIndex:13375},{level:3,title:"Session 中禁用 Cookie",slug:"session-中禁用-cookie",normalizedTitle:"session 中禁用 cookie",charIndex:13563},{level:3,title:"Session 实例",slug:"session-实例",normalizedTitle:"session 实例",charIndex:13763},{level:4,title:"Session 跟踪",slug:"session-跟踪",normalizedTitle:"session 跟踪",charIndex:13777},{level:4,title:"删除 Session 会话数据",slug:"删除-session-会话数据",normalizedTitle:"删除 session 会话数据",charIndex:16954},{level:2,title:"Cookie vs Session",slug:"cookie-vs-session",normalizedTitle:"cookie vs session",charIndex:17664},{level:3,title:"存取方式",slug:"存取方式",normalizedTitle:"存取方式",charIndex:17686},{level:3,title:"隐私安全",slug:"隐私安全",normalizedTitle:"隐私安全",charIndex:2726},{level:3,title:"有效期",slug:"有效期",normalizedTitle:"有效期",charIndex:2440},{level:3,title:"服务器的开销",slug:"服务器的开销",normalizedTitle:"服务器的开销",charIndex:18160},{level:3,title:"浏览器的支持",slug:"浏览器的支持",normalizedTitle:"浏览器的支持",charIndex:379},{level:3,title:"跨域名",slug:"跨域名",normalizedTitle:"跨域名",charIndex:2655}],headersStr:"Cookie Cookie 是什么 Cookie 剖析 Cookie 类中的方法 Cookie 的有效期 Cookie 的域名 Cookie 的路径 Cookie 的安全属性 Cookie 实例 添加 Cookie 显示 Cookie 删除 Cookie Session Session 是什么 Session 类中的方法 Session 的有效期 Session 对浏览器的要求 URL 地址重写 Session 中禁用 Cookie Session 实例 Session 跟踪 删除 Session 会话数据 Cookie vs Session 存取方式 隐私安全 有效期 服务器的开销 浏览器的支持 跨域名",content:'# JavaWeb 之 Cookie 和 Session\n\n\n# Cookie\n\n由于 Http 是一种无状态的协议，服务器单从网络连接上无从知道客户身份。\n\n会话跟踪是 Web 程序中常用的技术，用来跟踪用户的整个会话。常用会话跟踪技术是 Cookie 与 Session。\n\n\n# Cookie 是什么\n\nCookie 实际上是存储在客户端上的文本信息，并保留了各种跟踪的信息。\n\nCookie 工作步骤：\n\n 1. 客户端请求服务器，如果服务器需要记录该用户的状态，就是用 response 向客户端浏览器颁发一个 Cookie。\n 2. 客户端浏览器会把 Cookie 保存下来。\n 3. 当浏览器再请求该网站时，浏览器把该请求的网址连同 Cookie 一同提交给服务器。服务器检查该 Cookie，以此来辨认用户状态。\n\n注：Cookie 功能需要浏览器的支持，如果浏览器不支持 Cookie 或者 Cookie 禁用了，Cookie 功能就会失效。\n\nJava 中把 Cookie 封装成了javax.servlet.http.Cookie类。\n\n\n# Cookie 剖析\n\nCookies 通常设置在 HTTP 头信息中（虽然 JavaScript 也可以直接在浏览器上设置一个 Cookie）。\n\n设置 Cookie 的 Servlet 会发送如下的头信息：\n\nHTTP/1.1 200 OK\nDate: Fri, 04 Feb 2000 21:03:38 GMT\nServer: Apache/1.3.9 (UNIX) PHP/4.0b3\nSet-Cookie: name=xyz; expires=Friday, 04-Feb-07 22:03:38 GMT;\n                 path=/; domain=w3cschool.cc\nConnection: close\nContent-Type: text/html\n\n\n正如您所看到的，Set-Cookie 头包含了一个名称值对、一个 GMT 日期、一个路径和一个域。名称和值会被 URL 编码。expires 字段是一个指令，告诉浏览器在给定的时间和日期之后"忘记"该 Cookie。\n\n如果浏览器被配置为存储 Cookies，它将会保留此信息直到到期日期。如果用户的浏览器指向任何匹配该 Cookie 的路径和域的页面，它会重新发送 Cookie 到服务器。浏览器的头信息可能如下所示：\n\nGET / HTTP/1.0\nConnection: Keep-Alive\nUser-Agent: Mozilla/4.6 (X11; I; Linux 2.2.6-15apmac ppc)\nHost: zink.demon.co.uk:1126\nAccept: image/gif, */*\nAccept-Encoding: gzip\nAccept-Language: en\nAccept-Charset: iso-8859-1,*,utf-8\nCookie: name=xyz\n\n\n\n# Cookie 类中的方法\n\n方法                                       功能\npublic void setDomain(String pattern)    该方法设置 cookie 适用的域。\npublic String getDomain()                该方法获取 cookie 适用的域。\npublic void setMaxAge(int expiry)        该方法设置 cookie 过期的时间（以秒为单位）。如果不这样设置，cookie 只会在当前 session\n                                         会话中持续有效。\npublic int getMaxAge()                   该方法返回 cookie 的最大生存周期（以秒为单位），默认情况下，-1 表示 cookie\n                                         将持续下去，直到浏览器关闭。\npublic String getName()                  该方法返回 cookie 的名称。名称在创建后不能改变。\npublic void setValue(String newValue)    该方法设置与 cookie 关联的值。\npublic String getValue()                 该方法获取与 cookie 关联的值。\npublic void setPath(String uri)          该方法设置 cookie 适用的路径。如果您不指定路径，与当前页面相同目录下的（包括子目录下的）所有 URL 都会返回\n                                         cookie。\npublic String getPath()                  该方法获取 cookie 适用的路径。\npublic void setSecure(boolean flag)      该方法设置布尔值，向浏览器指示，只会在 HTTPS 和 SSL 等安全协议中传输此类 Cookie。\npublic void setComment(String purpose)   该方法规定了描述 cookie 目的的注释。该注释在浏览器向用户呈现 cookie 时非常有用。\npublic String getComment()               该方法返回了描述 cookie 目的的注释，如果 cookie 没有注释则返回 null。\n\n\n# Cookie 的有效期\n\nCookie的maxAge决定着 Cookie 的有效期，单位为秒。\n\n如果 maxAge 为 0，则表示删除该 Cookie；\n\n如果为负数，表示该 Cookie 仅在本浏览器中以及本窗口打开的子窗口内有效，关闭窗口后该 Cookie 即失效。\n\nCookie 中提供getMaxAge()和setMaxAge(int expiry)方法来读写maxAge属性。\n\n\n# Cookie 的域名\n\nCookie 是不可以跨域名的。域名 www.google.com 颁发的 Cookie 不会被提交到域名 www.baidu.com 去。这是由 Cookie 的隐私安全机制决定的。隐私安全机制能够禁止网站非法获取其他网站的 Cookie。\n\n正常情况下，同一个一级域名的两个二级域名之间也不能互相使用 Cookie。如果想让某域名下的子域名也可以使用该 Cookie，需要设置 Cookie 的 domain 参数。\n\nJava 中使用setDomain(Stringdomain)和getDomain()方法来设置、获取 domain。\n\n\n# Cookie 的路径\n\nPath 属性决定允许访问 Cookie 的路径。\n\nJava 中使用setPath(Stringuri)和getPath()方法来设置、获取 path。\n\n\n# Cookie 的安全属性\n\nHTTP 协议不仅是无状态的，而且是不安全的。\n\n使用 HTTP 协议的数据不经过任何加密就直接在网络上传播，有被截获的可能。如果不希望 Cookie 在 HTTP 等非安全协议中传输，可以设置 Cookie 的 secure 属性为 true。浏览器只会在 HTTPS 和 SSL 等安全协议中传输此类 Cookie。\n\nJava 中使用setSecure(booleanflag)和getSecure ()方法来设置、获取 Secure。\n\n\n# Cookie 实例\n\n# 添加 Cookie\n\n通过 Servlet 添加 Cookies 包括三个步骤：\n\n 1. 创建一个 Cookie 对象：您可以调用带有 cookie 名称和 cookie 值的 Cookie 构造函数，cookie 名称和 cookie 值都是字符串。\n\n 2. 设置最大生存周期：您可以使用 setMaxAge 方法来指定 cookie 能够保持有效的时间（以秒为单位）。\n\n 3. 发送 Cookie 到 HTTP 响应头：您可以使用 response.addCookie 来添加 HTTP 响应头中的 Cookies。\n\nAddCookies.java\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.net.URLEncoder;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.Cookie;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet("/servlet/AddCookies")\npublic class AddCookies extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n\n    /**\n     * @see HttpServlet#HttpServlet()\n     */\n    public AddCookies() {\n        super();\n    }\n\n    /**\n     * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)\n     */\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n                    throws ServletException, IOException {\n        // 为名字和姓氏创建 Cookie\n        Cookie name = new Cookie("name", URLEncoder.encode(request.getParameter("name"), "UTF-8")); // 中文转码\n        Cookie url = new Cookie("url", request.getParameter("url"));\n\n        // 为两个 Cookie 设置过期日期为 24 小时后\n        name.setMaxAge(60 * 60 * 24);\n        url.setMaxAge(60 * 60 * 24);\n\n        // 在响应头中添加两个 Cookie\n        response.addCookie(name);\n        response.addCookie(url);\n\n        // 设置响应内容类型\n        response.setContentType("text/html;charset=UTF-8");\n\n        PrintWriter out = response.getWriter();\n        String title = "设置 Cookie 实例";\n        String docType = "<!DOCTYPE html>\\n";\n        out.println(docType + "<html>\\n" + "<head><title>" + title + "</title></head>\\n"\n                        + "<body bgcolor=\\"#f0f0f0\\">\\n" + "<h1 align=\\"center\\">" + title\n                        + "</h1>\\n" + "<ul>\\n" + "  <li><b>站点名：</b>：" + request.getParameter("name")\n                        + "\\n</li>" + "  <li><b>站点 URL：</b>：" + request.getParameter("url")\n                        + "\\n</li>" + "</ul>\\n" + "</body></html>");\n    }\n\n    /**\n     * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)\n     */\n    protected void doPost(HttpServletRequest request, HttpServletResponse response)\n                    throws ServletException, IOException {\n        doGet(request, response);\n    }\n\n}\n\n\naddCookies.jsp\n\n<%@ page language="java" pageEncoding="UTF-8" %>\n<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">\n<html>\n<head>\n  <meta charset="utf-8">\n  <title>添加Cookie</title>\n</head>\n<body>\n<form action=/servlet/AddCookies method="GET">\n  站点名 ：<input type="text" name="name">\n  <br/>\n  站点 URL：<input type="text" name="url"/><br>\n  <input type="submit" value="提交"/>\n</form>\n</body>\n</html>\n\n\n# 显示 Cookie\n\n要读取 Cookies，您需要通过调用 HttpServletRequest 的 getCookies() 方法创建一个 javax.servlet.http.Cookie 对象的数组。然后循环遍历数组，并使用 getName() 和 getValue() 方法来访问每个 cookie 和关联的值。\n\nReadCookies.java\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.net.URLDecoder;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.Cookie;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet("/servlet/ReadCookies")\npublic class ReadCookies extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n\n    /**\n     * @see HttpServlet#HttpServlet()\n     */\n    public ReadCookies() {\n        super();\n    }\n\n    /**\n     * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)\n     */\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n                    throws ServletException, IOException {\n        Cookie cookie = null;\n        Cookie[] cookies = null;\n        // 获取与该域相关的 Cookie 的数组\n        cookies = request.getCookies();\n\n        // 设置响应内容类型\n        response.setContentType("text/html;charset=UTF-8");\n\n        PrintWriter out = response.getWriter();\n        String title = "Delete Cookie Example";\n        String docType = "<!DOCTYPE html>\\n";\n        out.println(docType + "<html>\\n" + "<head><title>" + title + "</title></head>\\n"\n                        + "<body bgcolor=\\"#f0f0f0\\">\\n");\n        if (cookies != null) {\n            out.println("<h2>Cookie 名称和值</h2>");\n            for (int i = 0; i < cookies.length; i++) {\n                cookie = cookies[i];\n                if ((cookie.getName()).compareTo("name") == 0) {\n                    cookie.setMaxAge(0);\n                    response.addCookie(cookie);\n                    out.print("已删除的 cookie：" + cookie.getName() + "<br/>");\n                }\n                out.print("名称：" + cookie.getName() + "，");\n                out.print("值：" + URLDecoder.decode(cookie.getValue(), "utf-8") + " <br/>");\n            }\n        } else {\n            out.println("<h2 class=\\"tutheader\\">No Cookie founds</h2>");\n        }\n        out.println("</body>");\n        out.println("</html>");\n    }\n\n    /**\n     * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)\n     */\n    protected void doPost(HttpServletRequest request, HttpServletResponse response)\n                    throws ServletException, IOException {\n        doGet(request, response);\n    }\n\n}\n\n\n# 删除 Cookie\n\nJava 中并没有提供直接删除 Cookie 的方法，如果想要删除一个 Cookie，直接将这个 Cookie 的有效期设为 0 就可以了。步骤如下：\n\n 1. 读取一个现有的 cookie，并把它存储在 Cookie 对象中。\n\n 2. 使用 setMaxAge() 方法设置 cookie 的年龄为零，来删除现有的 cookie。\n\n 3. 把这个 cookie 添加到响应头。\n\nDeleteCookies.java\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.Cookie;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet("/servlet/DeleteCookies")\npublic class DeleteCookies extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n\n    /**\n     * @see HttpServlet#HttpServlet()\n     */\n    public DeleteCookies() {\n        super();\n    }\n\n    /**\n     * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)\n     */\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n                    throws ServletException, IOException {\n        Cookie cookie = null;\n        Cookie[] cookies = null;\n        // 获取与该域相关的 Cookie 的数组\n        cookies = request.getCookies();\n\n        // 设置响应内容类型\n        response.setContentType("text/html;charset=UTF-8");\n\n        PrintWriter out = response.getWriter();\n        String title = "删除 Cookie 实例";\n        String docType = "<!DOCTYPE html>\\n";\n        out.println(docType + "<html>\\n" + "<head><title>" + title + "</title></head>\\n"\n                        + "<body bgcolor=\\"#f0f0f0\\">\\n");\n        if (cookies != null) {\n            out.println("<h2>Cookie 名称和值</h2>");\n            for (int i = 0; i < cookies.length; i++) {\n                cookie = cookies[i];\n                if ((cookie.getName()).compareTo("url") == 0) {\n                    cookie.setMaxAge(0);\n                    response.addCookie(cookie);\n                    out.print("已删除的 cookie：" + cookie.getName() + "<br/>");\n                }\n                out.print("名称：" + cookie.getName() + "，");\n                out.print("值：" + cookie.getValue() + " <br/>");\n            }\n        } else {\n            out.println("<h2 class=\\"tutheader\\">No Cookie founds</h2>");\n        }\n        out.println("</body>");\n        out.println("</html>");\n    }\n\n    /**\n     * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)\n     */\n    protected void doPost(HttpServletRequest request, HttpServletResponse response)\n                    throws ServletException, IOException {\n        doGet(request, response);\n    }\n\n}\n\n\n\n# Session\n\n\n# Session 是什么\n\n不同于 Cookie 保存在客户端浏览器中，Session 保存在服务器上。\n\n如果说 Cookie 机制是通过检查客户身上的“通行证”来确定客户身份的话，那么 Session 机制就是通过检查服务器上的“客户明细表”来确认客户身份。\n\nSession 对应的类为 javax.servlet.http.HttpSession 类。Session 对象是在客户第一次请求服务器时创建的。\n\n\n# Session 类中的方法\n\njavax.servlet.http.HttpSession 类中的方法：\n\n方法                                                    功能\npublic Object getAttribute(String name)               该方法返回在该 session 会话中具有指定名称的对象，如果没有指定名称的对象，则返回 null。\npublic Enumeration getAttributeNames()                该方法返回 String 对象的枚举，String 对象包含所有绑定到该 session 会话的对象的名称。\npublic long getCreationTime()                         该方法返回该 session 会话被创建的时间，自格林尼治标准时间 1970 年 1 月 1 日午夜算起，以毫秒为单位。\npublic String getId()                                 该方法返回一个包含分配给该 session 会话的唯一标识符的字符串。\npublic long getLastAccessedTime()                     该方法返回客户端最后一次发送与该 session 会话相关的请求的时间自格林尼治标准时间 1970 年 1 月 1\n                                                      日午夜算起，以毫秒为单位。\npublic int getMaxInactiveInterval()                   该方法返回 Servlet 容器在客户端访问时保持 session 会话打开的最大时间间隔，以秒为单位。\npublic void invalidate()                              该方法指示该 session 会话无效，并解除绑定到它上面的任何对象。\npublic boolean isNew()                                如果客户端还不知道该 session 会话，或者如果客户选择不参入该 session 会话，则该方法返回 true。\npublic void removeAttribute(String name)              该方法将从该 session 会话移除指定名称的对象。\npublic void setAttribute(String name, Object value)   该方法使用指定的名称绑定一个对象到该 session 会话。\npublic void setMaxInactiveInterval(int interval)      该方法在 Servlet 容器指示该 session 会话无效之前，指定客户端请求之间的时间，以秒为单位。\n\n\n# Session 的有效期\n\n由于会有越来越多的用户访问服务器，因此 Session 也会越来越多。为防止内存溢出，服务器会把长时间没有活跃的 Session 从内存中删除。\n\nSession 的超时时间为maxInactiveInterval属性，可以通过getMaxInactiveInterval()、setMaxInactiveInterval(longinterval)来读写这个属性。\n\nTomcat 中 Session 的默认超时时间为 20 分钟。可以修改 web.xml 改变 Session 的默认超时时间。\n\n例：\n\n<session-config>\n  <session-timeout>60</session-timeout>\n</session-config>\n\n\n\n# Session 对浏览器的要求\n\nHTTP 协议是无状态的，Session 不能依据 HTTP 连接来判断是否为同一客户。因此服务器向客户端浏览器发送一个名为 JESSIONID 的 Cookie，他的值为该 Session 的 id（也就是 HttpSession.getId()的返回值）。Session 依据该 Cookie 来识别是否为同一用户。\n\n该 Cookie 为服务器自动生成的，它的maxAge属性一般为-1，表示仅当前浏览器内有效，并且各浏览器窗口间不共享，关闭浏览器就会失效。\n\n\n# URL 地址重写\n\nURL 地址重写的原理是将该用户 Session 的 id 信息重写到 URL 地址中。服务器能够解析重写后的 URL 获取 Session 的 id。这样即使客户端不支持 Cookie，也可以使用 Session 来记录用户状态。\n\nHttpServletResponse类提供了encodeURL(Stringurl)实现 URL 地址重写。\n\n\n# Session 中禁用 Cookie\n\n在META-INF/context.xml中编辑如下：\n\n<Context path="/SessionNotes" cookies="true">\n</Context>\n\n\n部署后，TOMCAT 便不会自动生成名 JESSIONID 的 Cookie，Session 也不会以 Cookie 为识别标志，而仅仅以重写后的 URL 地址为识别标志了。\n\n\n# Session 实例\n\n# Session 跟踪\n\nSessionTrackServlet.java\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpSession;\n\n@WebServlet("/servlet/SessionTrackServlet")\npublic class SessionTrackServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n                    throws ServletException, IOException {\n        // 如果不存在 session 会话，则创建一个 session 对象\n        HttpSession session = request.getSession(true);\n        // 获取 session 创建时间\n        Date createTime = new Date(session.getCreationTime());\n        // 获取该网页的最后一次访问时间\n        Date lastAccessTime = new Date(session.getLastAccessedTime());\n\n        // 设置日期输出的格式\n        SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");\n\n        String title = "Servlet Session 实例";\n        Integer visitCount = new Integer(0);\n        String visitCountKey = new String("visitCount");\n        String userIDKey = new String("userID");\n        String userID = new String("admin");\n\n        // 检查网页上是否有新的访问者\n        if (session.isNew()) {\n            session.setAttribute(userIDKey, userID);\n        } else {\n            visitCount = (Integer) session.getAttribute(visitCountKey);\n            visitCount = visitCount + 1;\n            userID = (String) session.getAttribute(userIDKey);\n        }\n        session.setAttribute(visitCountKey, visitCount);\n\n        // 设置响应内容类型\n        response.setContentType("text/html;charset=UTF-8");\n        PrintWriter out = response.getWriter();\n\n        String docType = "<!DOCTYPE html>\\n";\n        out.println(docType + "<html>\\n" + "<head><title>" + title + "</title></head>\\n"\n                        + "<body bgcolor=\\"#f0f0f0\\">\\n" + "<h1 align=\\"center\\">" + title\n                        + "</h1>\\n" + "<h2 align=\\"center\\">Session 信息</h2>\\n"\n                        + "<table border=\\"1\\" align=\\"center\\">\\n" + "<tr bgcolor=\\"#949494\\">\\n"\n                        + "  <th>Session 信息</th><th>值</th></tr>\\n" + "<tr>\\n" + "  <td>id</td>\\n"\n                        + "  <td>" + session.getId() + "</td></tr>\\n" + "<tr>\\n"\n                        + "  <td>创建时间</td>\\n" + "  <td>" + df.format(createTime) + "  </td></tr>\\n"\n                        + "<tr>\\n" + "  <td>最后访问时间</td>\\n" + "  <td>" + df.format(lastAccessTime)\n                        + "  </td></tr>\\n" + "<tr>\\n" + "  <td>用户 ID</td>\\n" + "  <td>" + userID\n                        + "  </td></tr>\\n" + "<tr>\\n" + "  <td>访问统计：</td>\\n" + "  <td>" + visitCount\n                        + "</td></tr>\\n" + "</table>\\n" + "</body></html>");\n    }\n}\n\n\nweb.xml\n\n<servlet>\n  <servlet-name>SessionTrackServlet</servlet-name>\n  <servlet-class>SessionTrackServlet</servlet-class>\n</servlet>\n<servlet-mapping>\n  <servlet-name>SessionTrackServlet</servlet-name>\n  <url-pattern>/servlet/SessionTrackServlet</url-pattern>\n</servlet-mapping>\n\n\n# 删除 Session 会话数据\n\n当您完成了一个用户的 session 会话数据，您有以下几种选择：\n\n**移除一个特定的属性：**您可以调用 removeAttribute(String name) 方法来删除与特定的键相关联的值。\n\n**删除整个 session 会话：**您可以调用 invalidate() 方法来丢弃整个 session 会话。\n\n**设置 session 会话过期时间：**您可以调用 setMaxInactiveInterval(int interval) 方法来单独设置 session 会话超时。\n\n**注销用户：**如果使用的是支持 servlet 2.4 的服务器，您可以调用 logout 来注销 Web 服务器的客户端，并把属于所有用户的所有 session 会话设置为无效。\n\n**web.xml 配置：**如果您使用的是 Tomcat，除了上述方法，您还可以在 web.xml 文件中配置 session 会话超时，如下所示：\n\n<session-config>\n  <session-timeout>15</session-timeout>\n</session-config>\n\n\n上面实例中的超时时间是以分钟为单位，将覆盖 Tomcat 中默认的 30 分钟超时时间。\n\n在一个 Servlet 中的 getMaxInactiveInterval() 方法会返回 session 会话的超时时间，以秒为单位。所以，如果在 web.xml 中配置 session 会话超时时间为 15 分钟，那么getMaxInactiveInterval() 会返回 900。\n\n\n# Cookie vs Session\n\n\n# 存取方式\n\nCookie 只能保存ASCII字符串，如果需要存取 Unicode 字符或二进制数据，需要进行UTF-8、GBK或BASE64等方式的编码。\n\nSession 可以存取任何类型的数据，甚至是任何 Java 类。可以将 Session 看成是一个 Java 容器类。\n\n\n# 隐私安全\n\nCookie 存于客户端浏览器，一些客户端的程序可能会窥探、复制或修改 Cookie 内容。\n\nSession 存于服务器，对客户端是透明的，不存在敏感信息泄露的危险。\n\n\n# 有效期\n\n使用 Cookie 可以保证长时间登录有效，只要设置 Cookie 的maxAge属性为一个很大的数字。\n\n而 Session 虽然理论上也可以通过设置很大的数值来保持长时间登录有效，但是，由于 Session 依赖于名为JESSIONID的 Cookie，而 Cookie JESSIONID的maxAge默认为-1，只要关闭了浏览器该 Session 就会失效，因此，Session 不能实现信息永久有效的效果。使用 URL 地址重写也不能实现。\n\n\n# 服务器的开销\n\n由于 Session 是保存在服务器的，每个用户都会产生一个 Session，如果并发访问的用户非常多，会产生很多的 Session，消耗大量的内存。\n\n而 Cookie 由于保存在客户端浏览器上，所以不占用服务器资源。\n\n\n# 浏览器的支持\n\nCookie 需要浏览器支持才能使用。\n\n如果浏览器不支持 Cookie，需要使用 Session 以及 URL 地址重写。\n\n需要注意的事所有的用到 Session 程序的 URL 都要使用response.encodeURL(StringURL) 或response.encodeRediretURL(String URL)进行 URL 地址重写，否则导致 Session 会话跟踪失效。\n\n\n# 跨域名\n\n * Cookie 支持跨域名。\n * Session 不支持跨域名。',normalizedContent:'# javaweb 之 cookie 和 session\n\n\n# cookie\n\n由于 http 是一种无状态的协议，服务器单从网络连接上无从知道客户身份。\n\n会话跟踪是 web 程序中常用的技术，用来跟踪用户的整个会话。常用会话跟踪技术是 cookie 与 session。\n\n\n# cookie 是什么\n\ncookie 实际上是存储在客户端上的文本信息，并保留了各种跟踪的信息。\n\ncookie 工作步骤：\n\n 1. 客户端请求服务器，如果服务器需要记录该用户的状态，就是用 response 向客户端浏览器颁发一个 cookie。\n 2. 客户端浏览器会把 cookie 保存下来。\n 3. 当浏览器再请求该网站时，浏览器把该请求的网址连同 cookie 一同提交给服务器。服务器检查该 cookie，以此来辨认用户状态。\n\n注：cookie 功能需要浏览器的支持，如果浏览器不支持 cookie 或者 cookie 禁用了，cookie 功能就会失效。\n\njava 中把 cookie 封装成了javax.servlet.http.cookie类。\n\n\n# cookie 剖析\n\ncookies 通常设置在 http 头信息中（虽然 javascript 也可以直接在浏览器上设置一个 cookie）。\n\n设置 cookie 的 servlet 会发送如下的头信息：\n\nhttp/1.1 200 ok\ndate: fri, 04 feb 2000 21:03:38 gmt\nserver: apache/1.3.9 (unix) php/4.0b3\nset-cookie: name=xyz; expires=friday, 04-feb-07 22:03:38 gmt;\n                 path=/; domain=w3cschool.cc\nconnection: close\ncontent-type: text/html\n\n\n正如您所看到的，set-cookie 头包含了一个名称值对、一个 gmt 日期、一个路径和一个域。名称和值会被 url 编码。expires 字段是一个指令，告诉浏览器在给定的时间和日期之后"忘记"该 cookie。\n\n如果浏览器被配置为存储 cookies，它将会保留此信息直到到期日期。如果用户的浏览器指向任何匹配该 cookie 的路径和域的页面，它会重新发送 cookie 到服务器。浏览器的头信息可能如下所示：\n\nget / http/1.0\nconnection: keep-alive\nuser-agent: mozilla/4.6 (x11; i; linux 2.2.6-15apmac ppc)\nhost: zink.demon.co.uk:1126\naccept: image/gif, */*\naccept-encoding: gzip\naccept-language: en\naccept-charset: iso-8859-1,*,utf-8\ncookie: name=xyz\n\n\n\n# cookie 类中的方法\n\n方法                                       功能\npublic void setdomain(string pattern)    该方法设置 cookie 适用的域。\npublic string getdomain()                该方法获取 cookie 适用的域。\npublic void setmaxage(int expiry)        该方法设置 cookie 过期的时间（以秒为单位）。如果不这样设置，cookie 只会在当前 session\n                                         会话中持续有效。\npublic int getmaxage()                   该方法返回 cookie 的最大生存周期（以秒为单位），默认情况下，-1 表示 cookie\n                                         将持续下去，直到浏览器关闭。\npublic string getname()                  该方法返回 cookie 的名称。名称在创建后不能改变。\npublic void setvalue(string newvalue)    该方法设置与 cookie 关联的值。\npublic string getvalue()                 该方法获取与 cookie 关联的值。\npublic void setpath(string uri)          该方法设置 cookie 适用的路径。如果您不指定路径，与当前页面相同目录下的（包括子目录下的）所有 url 都会返回\n                                         cookie。\npublic string getpath()                  该方法获取 cookie 适用的路径。\npublic void setsecure(boolean flag)      该方法设置布尔值，向浏览器指示，只会在 https 和 ssl 等安全协议中传输此类 cookie。\npublic void setcomment(string purpose)   该方法规定了描述 cookie 目的的注释。该注释在浏览器向用户呈现 cookie 时非常有用。\npublic string getcomment()               该方法返回了描述 cookie 目的的注释，如果 cookie 没有注释则返回 null。\n\n\n# cookie 的有效期\n\ncookie的maxage决定着 cookie 的有效期，单位为秒。\n\n如果 maxage 为 0，则表示删除该 cookie；\n\n如果为负数，表示该 cookie 仅在本浏览器中以及本窗口打开的子窗口内有效，关闭窗口后该 cookie 即失效。\n\ncookie 中提供getmaxage()和setmaxage(int expiry)方法来读写maxage属性。\n\n\n# cookie 的域名\n\ncookie 是不可以跨域名的。域名 www.google.com 颁发的 cookie 不会被提交到域名 www.baidu.com 去。这是由 cookie 的隐私安全机制决定的。隐私安全机制能够禁止网站非法获取其他网站的 cookie。\n\n正常情况下，同一个一级域名的两个二级域名之间也不能互相使用 cookie。如果想让某域名下的子域名也可以使用该 cookie，需要设置 cookie 的 domain 参数。\n\njava 中使用setdomain(stringdomain)和getdomain()方法来设置、获取 domain。\n\n\n# cookie 的路径\n\npath 属性决定允许访问 cookie 的路径。\n\njava 中使用setpath(stringuri)和getpath()方法来设置、获取 path。\n\n\n# cookie 的安全属性\n\nhttp 协议不仅是无状态的，而且是不安全的。\n\n使用 http 协议的数据不经过任何加密就直接在网络上传播，有被截获的可能。如果不希望 cookie 在 http 等非安全协议中传输，可以设置 cookie 的 secure 属性为 true。浏览器只会在 https 和 ssl 等安全协议中传输此类 cookie。\n\njava 中使用setsecure(booleanflag)和getsecure ()方法来设置、获取 secure。\n\n\n# cookie 实例\n\n# 添加 cookie\n\n通过 servlet 添加 cookies 包括三个步骤：\n\n 1. 创建一个 cookie 对象：您可以调用带有 cookie 名称和 cookie 值的 cookie 构造函数，cookie 名称和 cookie 值都是字符串。\n\n 2. 设置最大生存周期：您可以使用 setmaxage 方法来指定 cookie 能够保持有效的时间（以秒为单位）。\n\n 3. 发送 cookie 到 http 响应头：您可以使用 response.addcookie 来添加 http 响应头中的 cookies。\n\naddcookies.java\n\nimport java.io.ioexception;\nimport java.io.printwriter;\nimport java.net.urlencoder;\n\nimport javax.servlet.servletexception;\nimport javax.servlet.annotation.webservlet;\nimport javax.servlet.http.cookie;\nimport javax.servlet.http.httpservlet;\nimport javax.servlet.http.httpservletrequest;\nimport javax.servlet.http.httpservletresponse;\n\n@webservlet("/servlet/addcookies")\npublic class addcookies extends httpservlet {\n    private static final long serialversionuid = 1l;\n\n    /**\n     * @see httpservlet#httpservlet()\n     */\n    public addcookies() {\n        super();\n    }\n\n    /**\n     * @see httpservlet#doget(httpservletrequest request, httpservletresponse response)\n     */\n    public void doget(httpservletrequest request, httpservletresponse response)\n                    throws servletexception, ioexception {\n        // 为名字和姓氏创建 cookie\n        cookie name = new cookie("name", urlencoder.encode(request.getparameter("name"), "utf-8")); // 中文转码\n        cookie url = new cookie("url", request.getparameter("url"));\n\n        // 为两个 cookie 设置过期日期为 24 小时后\n        name.setmaxage(60 * 60 * 24);\n        url.setmaxage(60 * 60 * 24);\n\n        // 在响应头中添加两个 cookie\n        response.addcookie(name);\n        response.addcookie(url);\n\n        // 设置响应内容类型\n        response.setcontenttype("text/html;charset=utf-8");\n\n        printwriter out = response.getwriter();\n        string title = "设置 cookie 实例";\n        string doctype = "<!doctype html>\\n";\n        out.println(doctype + "<html>\\n" + "<head><title>" + title + "</title></head>\\n"\n                        + "<body bgcolor=\\"#f0f0f0\\">\\n" + "<h1 align=\\"center\\">" + title\n                        + "</h1>\\n" + "<ul>\\n" + "  <li><b>站点名：</b>：" + request.getparameter("name")\n                        + "\\n</li>" + "  <li><b>站点 url：</b>：" + request.getparameter("url")\n                        + "\\n</li>" + "</ul>\\n" + "</body></html>");\n    }\n\n    /**\n     * @see httpservlet#dopost(httpservletrequest request, httpservletresponse response)\n     */\n    protected void dopost(httpservletrequest request, httpservletresponse response)\n                    throws servletexception, ioexception {\n        doget(request, response);\n    }\n\n}\n\n\naddcookies.jsp\n\n<%@ page language="java" pageencoding="utf-8" %>\n<!doctype html public "-//w3c//dtd html 4.01 transitional//en">\n<html>\n<head>\n  <meta charset="utf-8">\n  <title>添加cookie</title>\n</head>\n<body>\n<form action=/servlet/addcookies method="get">\n  站点名 ：<input type="text" name="name">\n  <br/>\n  站点 url：<input type="text" name="url"/><br>\n  <input type="submit" value="提交"/>\n</form>\n</body>\n</html>\n\n\n# 显示 cookie\n\n要读取 cookies，您需要通过调用 httpservletrequest 的 getcookies() 方法创建一个 javax.servlet.http.cookie 对象的数组。然后循环遍历数组，并使用 getname() 和 getvalue() 方法来访问每个 cookie 和关联的值。\n\nreadcookies.java\n\nimport java.io.ioexception;\nimport java.io.printwriter;\nimport java.net.urldecoder;\n\nimport javax.servlet.servletexception;\nimport javax.servlet.annotation.webservlet;\nimport javax.servlet.http.cookie;\nimport javax.servlet.http.httpservlet;\nimport javax.servlet.http.httpservletrequest;\nimport javax.servlet.http.httpservletresponse;\n\n@webservlet("/servlet/readcookies")\npublic class readcookies extends httpservlet {\n    private static final long serialversionuid = 1l;\n\n    /**\n     * @see httpservlet#httpservlet()\n     */\n    public readcookies() {\n        super();\n    }\n\n    /**\n     * @see httpservlet#doget(httpservletrequest request, httpservletresponse response)\n     */\n    public void doget(httpservletrequest request, httpservletresponse response)\n                    throws servletexception, ioexception {\n        cookie cookie = null;\n        cookie[] cookies = null;\n        // 获取与该域相关的 cookie 的数组\n        cookies = request.getcookies();\n\n        // 设置响应内容类型\n        response.setcontenttype("text/html;charset=utf-8");\n\n        printwriter out = response.getwriter();\n        string title = "delete cookie example";\n        string doctype = "<!doctype html>\\n";\n        out.println(doctype + "<html>\\n" + "<head><title>" + title + "</title></head>\\n"\n                        + "<body bgcolor=\\"#f0f0f0\\">\\n");\n        if (cookies != null) {\n            out.println("<h2>cookie 名称和值</h2>");\n            for (int i = 0; i < cookies.length; i++) {\n                cookie = cookies[i];\n                if ((cookie.getname()).compareto("name") == 0) {\n                    cookie.setmaxage(0);\n                    response.addcookie(cookie);\n                    out.print("已删除的 cookie：" + cookie.getname() + "<br/>");\n                }\n                out.print("名称：" + cookie.getname() + "，");\n                out.print("值：" + urldecoder.decode(cookie.getvalue(), "utf-8") + " <br/>");\n            }\n        } else {\n            out.println("<h2 class=\\"tutheader\\">no cookie founds</h2>");\n        }\n        out.println("</body>");\n        out.println("</html>");\n    }\n\n    /**\n     * @see httpservlet#dopost(httpservletrequest request, httpservletresponse response)\n     */\n    protected void dopost(httpservletrequest request, httpservletresponse response)\n                    throws servletexception, ioexception {\n        doget(request, response);\n    }\n\n}\n\n\n# 删除 cookie\n\njava 中并没有提供直接删除 cookie 的方法，如果想要删除一个 cookie，直接将这个 cookie 的有效期设为 0 就可以了。步骤如下：\n\n 1. 读取一个现有的 cookie，并把它存储在 cookie 对象中。\n\n 2. 使用 setmaxage() 方法设置 cookie 的年龄为零，来删除现有的 cookie。\n\n 3. 把这个 cookie 添加到响应头。\n\ndeletecookies.java\n\nimport java.io.ioexception;\nimport java.io.printwriter;\n\nimport javax.servlet.servletexception;\nimport javax.servlet.annotation.webservlet;\nimport javax.servlet.http.cookie;\nimport javax.servlet.http.httpservlet;\nimport javax.servlet.http.httpservletrequest;\nimport javax.servlet.http.httpservletresponse;\n\n@webservlet("/servlet/deletecookies")\npublic class deletecookies extends httpservlet {\n    private static final long serialversionuid = 1l;\n\n    /**\n     * @see httpservlet#httpservlet()\n     */\n    public deletecookies() {\n        super();\n    }\n\n    /**\n     * @see httpservlet#doget(httpservletrequest request, httpservletresponse response)\n     */\n    public void doget(httpservletrequest request, httpservletresponse response)\n                    throws servletexception, ioexception {\n        cookie cookie = null;\n        cookie[] cookies = null;\n        // 获取与该域相关的 cookie 的数组\n        cookies = request.getcookies();\n\n        // 设置响应内容类型\n        response.setcontenttype("text/html;charset=utf-8");\n\n        printwriter out = response.getwriter();\n        string title = "删除 cookie 实例";\n        string doctype = "<!doctype html>\\n";\n        out.println(doctype + "<html>\\n" + "<head><title>" + title + "</title></head>\\n"\n                        + "<body bgcolor=\\"#f0f0f0\\">\\n");\n        if (cookies != null) {\n            out.println("<h2>cookie 名称和值</h2>");\n            for (int i = 0; i < cookies.length; i++) {\n                cookie = cookies[i];\n                if ((cookie.getname()).compareto("url") == 0) {\n                    cookie.setmaxage(0);\n                    response.addcookie(cookie);\n                    out.print("已删除的 cookie：" + cookie.getname() + "<br/>");\n                }\n                out.print("名称：" + cookie.getname() + "，");\n                out.print("值：" + cookie.getvalue() + " <br/>");\n            }\n        } else {\n            out.println("<h2 class=\\"tutheader\\">no cookie founds</h2>");\n        }\n        out.println("</body>");\n        out.println("</html>");\n    }\n\n    /**\n     * @see httpservlet#dopost(httpservletrequest request, httpservletresponse response)\n     */\n    protected void dopost(httpservletrequest request, httpservletresponse response)\n                    throws servletexception, ioexception {\n        doget(request, response);\n    }\n\n}\n\n\n\n# session\n\n\n# session 是什么\n\n不同于 cookie 保存在客户端浏览器中，session 保存在服务器上。\n\n如果说 cookie 机制是通过检查客户身上的“通行证”来确定客户身份的话，那么 session 机制就是通过检查服务器上的“客户明细表”来确认客户身份。\n\nsession 对应的类为 javax.servlet.http.httpsession 类。session 对象是在客户第一次请求服务器时创建的。\n\n\n# session 类中的方法\n\njavax.servlet.http.httpsession 类中的方法：\n\n方法                                                    功能\npublic object getattribute(string name)               该方法返回在该 session 会话中具有指定名称的对象，如果没有指定名称的对象，则返回 null。\npublic enumeration getattributenames()                该方法返回 string 对象的枚举，string 对象包含所有绑定到该 session 会话的对象的名称。\npublic long getcreationtime()                         该方法返回该 session 会话被创建的时间，自格林尼治标准时间 1970 年 1 月 1 日午夜算起，以毫秒为单位。\npublic string getid()                                 该方法返回一个包含分配给该 session 会话的唯一标识符的字符串。\npublic long getlastaccessedtime()                     该方法返回客户端最后一次发送与该 session 会话相关的请求的时间自格林尼治标准时间 1970 年 1 月 1\n                                                      日午夜算起，以毫秒为单位。\npublic int getmaxinactiveinterval()                   该方法返回 servlet 容器在客户端访问时保持 session 会话打开的最大时间间隔，以秒为单位。\npublic void invalidate()                              该方法指示该 session 会话无效，并解除绑定到它上面的任何对象。\npublic boolean isnew()                                如果客户端还不知道该 session 会话，或者如果客户选择不参入该 session 会话，则该方法返回 true。\npublic void removeattribute(string name)              该方法将从该 session 会话移除指定名称的对象。\npublic void setattribute(string name, object value)   该方法使用指定的名称绑定一个对象到该 session 会话。\npublic void setmaxinactiveinterval(int interval)      该方法在 servlet 容器指示该 session 会话无效之前，指定客户端请求之间的时间，以秒为单位。\n\n\n# session 的有效期\n\n由于会有越来越多的用户访问服务器，因此 session 也会越来越多。为防止内存溢出，服务器会把长时间没有活跃的 session 从内存中删除。\n\nsession 的超时时间为maxinactiveinterval属性，可以通过getmaxinactiveinterval()、setmaxinactiveinterval(longinterval)来读写这个属性。\n\ntomcat 中 session 的默认超时时间为 20 分钟。可以修改 web.xml 改变 session 的默认超时时间。\n\n例：\n\n<session-config>\n  <session-timeout>60</session-timeout>\n</session-config>\n\n\n\n# session 对浏览器的要求\n\nhttp 协议是无状态的，session 不能依据 http 连接来判断是否为同一客户。因此服务器向客户端浏览器发送一个名为 jessionid 的 cookie，他的值为该 session 的 id（也就是 httpsession.getid()的返回值）。session 依据该 cookie 来识别是否为同一用户。\n\n该 cookie 为服务器自动生成的，它的maxage属性一般为-1，表示仅当前浏览器内有效，并且各浏览器窗口间不共享，关闭浏览器就会失效。\n\n\n# url 地址重写\n\nurl 地址重写的原理是将该用户 session 的 id 信息重写到 url 地址中。服务器能够解析重写后的 url 获取 session 的 id。这样即使客户端不支持 cookie，也可以使用 session 来记录用户状态。\n\nhttpservletresponse类提供了encodeurl(stringurl)实现 url 地址重写。\n\n\n# session 中禁用 cookie\n\n在meta-inf/context.xml中编辑如下：\n\n<context path="/sessionnotes" cookies="true">\n</context>\n\n\n部署后，tomcat 便不会自动生成名 jessionid 的 cookie，session 也不会以 cookie 为识别标志，而仅仅以重写后的 url 地址为识别标志了。\n\n\n# session 实例\n\n# session 跟踪\n\nsessiontrackservlet.java\n\nimport java.io.ioexception;\nimport java.io.printwriter;\nimport java.text.simpledateformat;\nimport java.util.date;\n\nimport javax.servlet.servletexception;\nimport javax.servlet.annotation.webservlet;\nimport javax.servlet.http.httpservlet;\nimport javax.servlet.http.httpservletrequest;\nimport javax.servlet.http.httpservletresponse;\nimport javax.servlet.http.httpsession;\n\n@webservlet("/servlet/sessiontrackservlet")\npublic class sessiontrackservlet extends httpservlet {\n    private static final long serialversionuid = 1l;\n\n    public void doget(httpservletrequest request, httpservletresponse response)\n                    throws servletexception, ioexception {\n        // 如果不存在 session 会话，则创建一个 session 对象\n        httpsession session = request.getsession(true);\n        // 获取 session 创建时间\n        date createtime = new date(session.getcreationtime());\n        // 获取该网页的最后一次访问时间\n        date lastaccesstime = new date(session.getlastaccessedtime());\n\n        // 设置日期输出的格式\n        simpledateformat df = new simpledateformat("yyyy-mm-dd hh:mm:ss");\n\n        string title = "servlet session 实例";\n        integer visitcount = new integer(0);\n        string visitcountkey = new string("visitcount");\n        string useridkey = new string("userid");\n        string userid = new string("admin");\n\n        // 检查网页上是否有新的访问者\n        if (session.isnew()) {\n            session.setattribute(useridkey, userid);\n        } else {\n            visitcount = (integer) session.getattribute(visitcountkey);\n            visitcount = visitcount + 1;\n            userid = (string) session.getattribute(useridkey);\n        }\n        session.setattribute(visitcountkey, visitcount);\n\n        // 设置响应内容类型\n        response.setcontenttype("text/html;charset=utf-8");\n        printwriter out = response.getwriter();\n\n        string doctype = "<!doctype html>\\n";\n        out.println(doctype + "<html>\\n" + "<head><title>" + title + "</title></head>\\n"\n                        + "<body bgcolor=\\"#f0f0f0\\">\\n" + "<h1 align=\\"center\\">" + title\n                        + "</h1>\\n" + "<h2 align=\\"center\\">session 信息</h2>\\n"\n                        + "<table border=\\"1\\" align=\\"center\\">\\n" + "<tr bgcolor=\\"#949494\\">\\n"\n                        + "  <th>session 信息</th><th>值</th></tr>\\n" + "<tr>\\n" + "  <td>id</td>\\n"\n                        + "  <td>" + session.getid() + "</td></tr>\\n" + "<tr>\\n"\n                        + "  <td>创建时间</td>\\n" + "  <td>" + df.format(createtime) + "  </td></tr>\\n"\n                        + "<tr>\\n" + "  <td>最后访问时间</td>\\n" + "  <td>" + df.format(lastaccesstime)\n                        + "  </td></tr>\\n" + "<tr>\\n" + "  <td>用户 id</td>\\n" + "  <td>" + userid\n                        + "  </td></tr>\\n" + "<tr>\\n" + "  <td>访问统计：</td>\\n" + "  <td>" + visitcount\n                        + "</td></tr>\\n" + "</table>\\n" + "</body></html>");\n    }\n}\n\n\nweb.xml\n\n<servlet>\n  <servlet-name>sessiontrackservlet</servlet-name>\n  <servlet-class>sessiontrackservlet</servlet-class>\n</servlet>\n<servlet-mapping>\n  <servlet-name>sessiontrackservlet</servlet-name>\n  <url-pattern>/servlet/sessiontrackservlet</url-pattern>\n</servlet-mapping>\n\n\n# 删除 session 会话数据\n\n当您完成了一个用户的 session 会话数据，您有以下几种选择：\n\n**移除一个特定的属性：**您可以调用 removeattribute(string name) 方法来删除与特定的键相关联的值。\n\n**删除整个 session 会话：**您可以调用 invalidate() 方法来丢弃整个 session 会话。\n\n**设置 session 会话过期时间：**您可以调用 setmaxinactiveinterval(int interval) 方法来单独设置 session 会话超时。\n\n**注销用户：**如果使用的是支持 servlet 2.4 的服务器，您可以调用 logout 来注销 web 服务器的客户端，并把属于所有用户的所有 session 会话设置为无效。\n\n**web.xml 配置：**如果您使用的是 tomcat，除了上述方法，您还可以在 web.xml 文件中配置 session 会话超时，如下所示：\n\n<session-config>\n  <session-timeout>15</session-timeout>\n</session-config>\n\n\n上面实例中的超时时间是以分钟为单位，将覆盖 tomcat 中默认的 30 分钟超时时间。\n\n在一个 servlet 中的 getmaxinactiveinterval() 方法会返回 session 会话的超时时间，以秒为单位。所以，如果在 web.xml 中配置 session 会话超时时间为 15 分钟，那么getmaxinactiveinterval() 会返回 900。\n\n\n# cookie vs session\n\n\n# 存取方式\n\ncookie 只能保存ascii字符串，如果需要存取 unicode 字符或二进制数据，需要进行utf-8、gbk或base64等方式的编码。\n\nsession 可以存取任何类型的数据，甚至是任何 java 类。可以将 session 看成是一个 java 容器类。\n\n\n# 隐私安全\n\ncookie 存于客户端浏览器，一些客户端的程序可能会窥探、复制或修改 cookie 内容。\n\nsession 存于服务器，对客户端是透明的，不存在敏感信息泄露的危险。\n\n\n# 有效期\n\n使用 cookie 可以保证长时间登录有效，只要设置 cookie 的maxage属性为一个很大的数字。\n\n而 session 虽然理论上也可以通过设置很大的数值来保持长时间登录有效，但是，由于 session 依赖于名为jessionid的 cookie，而 cookie jessionid的maxage默认为-1，只要关闭了浏览器该 session 就会失效，因此，session 不能实现信息永久有效的效果。使用 url 地址重写也不能实现。\n\n\n# 服务器的开销\n\n由于 session 是保存在服务器的，每个用户都会产生一个 session，如果并发访问的用户非常多，会产生很多的 session，消耗大量的内存。\n\n而 cookie 由于保存在客户端浏览器上，所以不占用服务器资源。\n\n\n# 浏览器的支持\n\ncookie 需要浏览器支持才能使用。\n\n如果浏览器不支持 cookie，需要使用 session 以及 url 地址重写。\n\n需要注意的事所有的用到 session 程序的 url 都要使用response.encodeurl(stringurl) 或response.encoderedireturl(string url)进行 url 地址重写，否则导致 session 会话跟踪失效。\n\n\n# 跨域名\n\n * cookie 支持跨域名。\n * session 不支持跨域名。',charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"JavaWeb",frontmatter:{title:"JavaWeb",date:"2020-02-07T23:04:47.000Z",categories:["Java","JavaEE","JavaWeb"],tags:["JavaWeb"],permalink:"/pages/50f49f/",hidden:!0,index:!1},regularPath:"/01.Java/02.JavaEE/01.JavaWeb/",relativePath:"01.Java/02.JavaEE/01.JavaWeb/README.md",key:"v-84fd370c",path:"/pages/50f49f/",headers:[{level:2,title:"知识点",slug:"知识点",normalizedTitle:"知识点",charIndex:16},{level:2,title:"学习资料",slug:"学习资料",normalizedTitle:"学习资料",charIndex:144}],headersStr:"知识点 学习资料",content:"# ☕ JavaWeb\n\n\n# 知识点\n\n * JavaWeb 之 Servlet 指南\n * JavaWeb 之 Jsp 指南\n * JavaWeb 之 Filter 和 Listener\n * JavaWeb 之 Cookie 和 Session\n * JavaWeb 面经\n\n\n# 学习资料\n\n * 书籍\n   * Java Web 整合开发王者归来\n   * Head First Servlets & JSP\n * 教程\n   * 深入拆解 Tomcat & Jetty\n   * Servlet 教程\n   * 博客园孤傲苍狼 JavaWeb 学习总结\n   * JSP 教程",normalizedContent:"# ☕ javaweb\n\n\n# 知识点\n\n * javaweb 之 servlet 指南\n * javaweb 之 jsp 指南\n * javaweb 之 filter 和 listener\n * javaweb 之 cookie 和 session\n * javaweb 面经\n\n\n# 学习资料\n\n * 书籍\n   * java web 整合开发王者归来\n   * head first servlets & jsp\n * 教程\n   * 深入拆解 tomcat & jetty\n   * servlet 教程\n   * 博客园孤傲苍狼 javaweb 学习总结\n   * jsp 教程",charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"JavaWeb 面经",frontmatter:{title:"JavaWeb 面经",date:"2020-02-07T23:04:47.000Z",order:99,categories:["Java","JavaEE","JavaWeb"],tags:["Java","JavaWeb","Servlet"],permalink:"/pages/e175ce/"},regularPath:"/01.Java/02.JavaEE/01.JavaWeb/99.JavaWeb%E9%9D%A2%E7%BB%8F.html",relativePath:"01.Java/02.JavaEE/01.JavaWeb/99.JavaWeb面经.md",key:"v-6ec25090",path:"/pages/e175ce/",headers:[{level:2,title:"Servlet",slug:"servlet",normalizedTitle:"servlet",charIndex:17},{level:3,title:"什么是 Servlet",slug:"什么是-servlet",normalizedTitle:"什么是 servlet",charIndex:29},{level:3,title:"Servlet 和 CGI 的区别",slug:"servlet-和-cgi-的区别",normalizedTitle:"servlet 和 cgi 的区别",charIndex:321},{level:3,title:"Servlet 版本以及主要特性",slug:"servlet-版本以及主要特性",normalizedTitle:"servlet 版本以及主要特性",charIndex:548},{level:3,title:"Servlet 和 JSP 的区别",slug:"servlet-和-jsp-的区别",normalizedTitle:"servlet 和 jsp 的区别",charIndex:1386},{level:3,title:"简述 Servlet 生命周期",slug:"简述-servlet-生命周期",normalizedTitle:"简述 servlet 生命周期",charIndex:1684},{level:3,title:"如何现实 servlet 的单线程模式",slug:"如何现实-servlet-的单线程模式",normalizedTitle:"如何现实 servlet 的单线程模式",charIndex:1967},{level:3,title:"Servlet 中如何获取用户提交的查询参数或者表单数据",slug:"servlet-中如何获取用户提交的查询参数或者表单数据",normalizedTitle:"servlet 中如何获取用户提交的查询参数或者表单数据",charIndex:2026},{level:3,title:"request 的主要方法",slug:"request-的主要方法",normalizedTitle:"request 的主要方法",charIndex:2198},{level:2,title:"JSP",slug:"jsp",normalizedTitle:"jsp",charIndex:1396},{level:3,title:"JSP 的内置对象",slug:"jsp-的内置对象",normalizedTitle:"jsp 的内置对象",charIndex:3265},{level:3,title:"JSP 的作用域",slug:"jsp-的作用域",normalizedTitle:"jsp 的作用域",charIndex:3605},{level:3,title:"JSP 中 7 个动作指令和作用",slug:"jsp-中-7-个动作指令和作用",normalizedTitle:"jsp 中 7 个动作指令和作用",charIndex:3697},{level:3,title:"JSP 中动态 INCLUDE 和静态 INCLUDE 有什么区别",slug:"jsp-中动态-include-和静态-include-有什么区别",normalizedTitle:"jsp 中动态 include 和静态 include 有什么区别",charIndex:3999},{level:2,title:"原理",slug:"原理",normalizedTitle:"原理",charIndex:249},{level:3,title:"请求转发(forward)和重定向(redirect)的区别",slug:"请求转发-forward-和重定向-redirect-的区别",normalizedTitle:"请求转发(forward)和重定向(redirect)的区别",charIndex:4251},{level:3,title:"get 请求和 post 请求的区别",slug:"get-请求和-post-请求的区别",normalizedTitle:"get 请求和 post 请求的区别",charIndex:4500},{level:3,title:"用户在浏览器中输入 URL 之后，发什么了什么？写出请求和响应的流程",slug:"用户在浏览器中输入-url-之后-发什么了什么-写出请求和响应的流程",normalizedTitle:"用户在浏览器中输入 url 之后，发什么了什么？写出请求和响应的流程",charIndex:4770},{level:3,title:"什么是 Web Service?",slug:"什么是-web-service",normalizedTitle:"什么是 web service?",charIndex:4933},{level:3,title:"会话跟踪技术有哪些?",slug:"会话跟踪技术有哪些",normalizedTitle:"会话跟踪技术有哪些?",charIndex:5082},{level:3,title:"响应结果状态码有哪些，并给出中文含义？",slug:"响应结果状态码有哪些-并给出中文含义",normalizedTitle:"响应结果状态码有哪些，并给出中文含义？",charIndex:6245},{level:3,title:"XML 文档定义有几种形式？它们之间有何本质区别？解析 XML 文档有哪几种方式？",slug:"xml-文档定义有几种形式-它们之间有何本质区别-解析-xml-文档有哪几种方式",normalizedTitle:"xml 文档定义有几种形式？它们之间有何本质区别？解析 xml 文档有哪几种方式？",charIndex:6640},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:7566}],headersStr:"Servlet 什么是 Servlet Servlet 和 CGI 的区别 Servlet 版本以及主要特性 Servlet 和 JSP 的区别 简述 Servlet 生命周期 如何现实 servlet 的单线程模式 Servlet 中如何获取用户提交的查询参数或者表单数据 request 的主要方法 JSP JSP 的内置对象 JSP 的作用域 JSP 中 7 个动作指令和作用 JSP 中动态 INCLUDE 和静态 INCLUDE 有什么区别 原理 请求转发(forward)和重定向(redirect)的区别 get 请求和 post 请求的区别 用户在浏览器中输入 URL 之后，发什么了什么？写出请求和响应的流程 什么是 Web Service? 会话跟踪技术有哪些? 响应结果状态码有哪些，并给出中文含义？ XML 文档定义有几种形式？它们之间有何本质区别？解析 XML 文档有哪几种方式？ 参考资料",content:'# JavaWeb 面经\n\n\n# Servlet\n\n\n# 什么是 Servlet\n\nServlet（Server Applet），即小服务程序或服务连接器。Servlet 是 Java 编写的服务器端程序，具有独立于平台和协议的特性，主要功能在于交互式地浏览和生成数据，生成动态 Web 内容。\n\n * 狭义的 Servlet 是指 Java 实现的一个接口。\n * 广义的 Servlet 是指任何实现了这个 Servlet 接口的类。\n\nServlet 运行于支持 Java 的应用服务器中。从原理上讲，Servlet 可以响应任何类型的请求，但绝大多数情况下 Servlet 只用来扩展基于 HTTP 协议的 Web 服务器。\n\n\n# Servlet 和 CGI 的区别\n\nServlet 技术出现之前，Web 主要使用 CGI 技术。它们的区别如下：\n\n * Servlet 是基于 Java 编写的，处于服务器进程中，他能够通过多线程方式运行 service() 方法，一个实例可以服务于多个请求，而且一般不会销毁；\n * CGI(Common Gateway Interface)，即通用网关接口。它会为每个请求产生新的进程，服务完成后销毁，所以效率上低于 Servlet。\n\n\n# Servlet 版本以及主要特性\n\n版本            日期            JAVA EE/JDK 版本       特性\nServlet 4.0   2017 年 10 月   JavaEE 8             HTTP2\nServlet 3.1   2013 年 5 月    JavaEE 7             非阻塞 I/O，HTTP 协议升级机制\nServlet 3.0   2009 年 12 月   JavaEE 6, JavaSE 6   可插拔性，易于开发，异步 Servlet，安全性，文件上传\nServlet 2.5   2005 年 10 月   JavaEE 5, JavaSE 5   依赖 JavaSE 5，支持注解\nServlet 2.4   2003 年 11 月   J2EE 1.4, J2SE 1.3   web.xml 使用 XML Schema\nServlet 2.3   2001 年 8 月    J2EE 1.3, J2SE 1.2   Filter\nServlet 2.2   1999 年 8 月    J2EE 1.2, J2SE 1.2   成为 J2EE 标准\nServlet 2.1   1998 年 11 月   未指定                  First official specification, added RequestDispatcher,\n                                                 ServletContext\nServlet 2.0                 JDK 1.1              Part of Java Servlet Development Kit 2.0\nServlet 1.0   1997 年 6 月                         \n\n\n# Servlet 和 JSP 的区别\n\n 1. Servlet 是一个运行在服务器上的 Java 类,依靠服务器支持向浏览器传输数据。\n 2. JSP 本质上就是 Servlet，每次运行的时候 JSP 都会被编译成 .java 文件，然后再被编译成 .class 文件。\n 3. 有了 JSP，Servlet 不再负责动态生成页面，转而去负责控制程序逻辑的作用，控制 JSP 与 JavaBean 之间的流转。\n 4. JSP 侧重于视图,而 Servlet 侧重于控制逻辑,在 MVC 架构模式中,JSP 适合充当视图 View,Servlet 适合充当控制器 Controller。\n\n\n# 简述 Servlet 生命周期\n\n\n\nServlet 生命周期如下：\n\n 1. 加载 - 第一个到达服务器的 HTTP 请求被委派到 Servlet 容器。容器通过类加载器使用 Servlet 类对应的文件加载 servlet；\n 2. 初始化 - Servlet 通过调用 init () 方法进行初始化。\n 3. 服务 - Servlet 调用 service() 方法来处理客户端的请求。\n 4. 销毁 - Servlet 通过调用 destroy() 方法终止（结束）。\n 5. 卸载 - Servlet 是由 JVM 的垃圾回收器进行垃圾回收的。\n\n\n# 如何现实 servlet 的单线程模式\n\n<%@ page isThreadSafe="false" %>\n\n\n\n# Servlet 中如何获取用户提交的查询参数或者表单数据\n\n * HttpServletRequest 的 getParameter() 方法。\n * HttpServletRequest 的 getParameterValues() 方法。\n * HttpServletRequest 的 getParameterMap() 方法。\n\n\n# request 的主要方法\n\n * setAttribute(String name,Object)：设置名字为 name 的 request 的参数值\n * getAttribute(String name)：返回由 name 指定的属性值\n * getAttributeNames()：返回 request 对象所有属性的名字集合，结果是一个枚举的实例\n * getCookies()：返回客户端的所有 Cookie 对象，结果是一个 Cookie 数组\n * getCharacterEncoding()：返回请求中的字符编码方式\n * getContentLength()：返回请求的 Body 的长度\n * getHeader(String name)：获得 HTTP 协议定义的文件头信息\n * getHeaders(String name)：返回指定名字的 request Header 的所有值，结果是一个枚举的实例\n * getHeaderNames()：返回所以 request Header 的名字，结果是一个枚举的实例\n * getInputStream()：返回请求的输入流，用于获得请求中的数据 getMethod()：获得客户端向服务器端传送数据的方法\n * getParameter(String name)：获得客户端传送给服务器端的有 name 指定的参数值\n * getParameterNames()：获得客户端传送给服务器端的所有参数的名字，结果是一个枚举的实例\n * getParameterValues(String name)：获得有 name 指定的参数的所有值\n * getProtocol()：获取客户端向服务器端传送数据所依据的协议名称\n * getQueryString()：获得查询字符串\n * getRequestURI()：获取发出请求字符串的客户端地址\n * getRemoteAddr()：获取客户端的 IP 地址\n * getRemoteHost()：获取客户端的名字\n * getSession([Boolean create])：返回和请求相关\n * Session getServerName()：获取服务器的名字\n * getServletPath()：获取客户端所请求的脚本文件的路径\n * getServerPort()：获取服务器的端口号\n * removeAttribute(String name)：删除请求中的一个属性\n\n\n# JSP\n\n\n# JSP 的内置对象\n\n 1. request：包含客户端请求的信息；\n 2. response：包含服务器传回客户端的响应信息；\n 3. session：主要用来区分每个用户信息和会话状态；\n 4. pageContext：管理页面属性；\n 5. application：服务器启动时创建，服务器关闭时停止，保存所有应用系统中的共有数据，一个共享的内置对象（即一个容器中的多个用户共享一个 application 对象）；\n 6. out：向客户端输出数据；\n 7. config：代码片段配置对象，用于初始化 Servlet 的配置参数；\n 8. page：指网页本身；\n 9. exception：处理 JSP 文件执行时发生的错误和异常，只要在错误页面里才能使用。\n\n\n# JSP 的作用域\n\n 1. page：一个页面；\n 2. request：一次请求；\n 3. session：一次会话；\n 4. application：服务器从启动到停止。\n\n\n# JSP 中 7 个动作指令和作用\n\n 1. jsp:forward - 执行页面转向，把请求转发到下一个页面；\n 2. jsp:param - 用于传递参数，必须与其他支持参数的标签一起使用；\n 3. jsp:include - 用于动态引入一个 JSP 页面；\n 4. jsp:plugin - 用于下载 JavaBean 或 Applet 到客户端执行；\n 5. jsp:useBean - 寻求或者实例化一个 JavaBean；\n 6. jsp:setProperty - 设置 JavaBean 的属性值；\n 7. jsp:getProperty - 获取 JavaBean 的属性值。\n\n\n# JSP 中动态 INCLUDE 和静态 INCLUDE 有什么区别\n\n * 静态 INCLUDE：用 include 伪码实现，不会检查所含文件的变化，适用于包含静态页面<%@ include file="页面名称.html" %>。先合并再编译。\n * 动态 INCLUDE：用 jsp:include 动作实现 <jsp:include page="页面名称 .jsp" flush="true"> 它总是会检查文件中的变化，适用于包含动态页面，并且可以带参数。先编译再合并。\n\n\n# 原理\n\n\n# 请求转发(forward)和重定向(redirect)的区别\n\n * 效率上\n   * 转发（forward） > 重定向（redirect）\n * 显示上\n   * 重定向（redirect）：显示新的 URL\n   * 转发（forward）：地址栏不变\n * 数据上\n   * 转发（forward）：可以共享 request 里面的数据\n   * 重定向（redirect）：不能\n * 请求次数\n   * 重定向（redirect）是两次\n   * 转发（forward）是一次\n\n\n# get 请求和 post 请求的区别\n\n\n\n * GET：\n   * 从服务器上获取数据，一般不能使用在写操作接口\n   * 由 URL 所限制，GET 方式传输的数据大小有所限制，传送的数据量不超过 2KB\n   * 请求的数据会附加在 URL 之后，以？分隔 URL 和传输数据，多个参数用&连接\n   * 安全性差\n * POST:\n   * 向服务器提交数据,一般处理写业务\n   * POST 方式传送的数据量比较大，一般被默认为没有限制\n   * 安全性高\n   * 请的求的数据内容放置在 HTML HEADER 中\n\n\n# 用户在浏览器中输入 URL 之后，发什么了什么？写出请求和响应的流程\n\n 1. 域名解析\n 2. TCP 三次握手\n 3. 浏览器向服务器发送 http 请求\n 4. 浏览器发送请求头信息\n 5. 服务器处理请求\n 6. 服务器做出应答\n 7. 服务器发送应答头信息\n 8. 服务器发送数据\n 9. TCP 连接关闭\n\n\n# 什么是 Web Service?\n\n 1. WebService 就是一个应用程序，它向外界暴露出一个能够通过 Web 进行调用的 API。\n 2. 它是基于 HTTP 协议传输数据，这使得运行在不同机上的不同应用程序，无须借助附加的、专门的第三方 软件或硬件，就可以相互交换数据或集成。\n\n\n# 会话跟踪技术有哪些?\n\n由于 HTTP 协议本身是无状态的，服务器为了区分不同的用户，就需要对用户会话进行跟踪，简单的说就是为用户进行登记，为用户分配唯一的 ID，下一次用户在请求中包含此 ID，服务器根据此判断到底是哪一个用户。\n\n * URL 重写：在 URL 中添加会话信息作为请求的参数，或者将唯一的会话 ID 添加到 URL 结尾，以表示一个会话。设置表单隐藏域：将和会话跟踪相关的字段添加到隐藏域中，这些信息不会在浏览器显示，但是提交表单时会提交给服务器。\n * cookie：cookie 有两种：\n   * 一种是基于窗口的，浏览器关闭后，cookie 就没有了；\n   * 另一种是将信息存储在一个临时文件中，并设置其有效路径和最大存活时间。当用户通过浏览器和服务器建立一次会话后，会话 ID 就会随相应信息储存在基于窗口的 cookie 中，那就意味着只要浏览器没有关闭，会话没有超时，下一次请求时这个会话 ID 又会提交给服务器，让服务器识别用户身份。\n   * 在使用 cookie 时要注意几点：\n     * 首先不要在 cookie 中存放敏 感信息；\n     * 其次 cookie 存储的数据量有限（4k），不能将过多的内容存储 cookie 中；\n     * 再者浏览器通常只允许一个站点最多存放 20 个 cookie。\n     * 当然，和用户会话相关的其他信息（除了会话 ID）也可以存在 cookie 方便进行会话 跟踪;\n * HttpSession：在所有会话跟踪技术中，HttpSession 对象是最强大也是功能最多的。当一个用户第一次访问某个网站时会自动创建 HttpSession，每个用户可以访问他自己的 HttpSession。可以通过 HttpServletRequest 对象的 getSession 方法获得 HttpSession，通过 HttpSession 的 setAttribute 方法可以将一个值放在 HttpSession 中，通过调用 HttpSession 对象的 getAttribute 方法，同时传入属性名就可以获取保存在 HttpSession 中的对象。\n   * 与上面三种方式不同的是，HttpSession 放在服务器的内存中，因此不要将过大的对象放在里面，即使目前的 Servlet 容器可以在内存将满时将 HttpSession 中的对象移到其他存储设备中，但是这样势必影响性能。\n   * 添加到 HttpSession 中 的值可以是任意 Java 对象，这个对象最好实现了 Serializable 接口，这样 Servlet 容器在必要的时候可以将其序列 化到文件中，否则在序列化时就会出现异常。\n\n\n# 响应结果状态码有哪些，并给出中文含义？\n\n * 1**：信息性状态码\n * 2**：成功状态码\n   * 200：请求正常成功\n   * 204：指示请求成功但没有返回新信息\n   * 206：指示服务器已完成对资源的部分 GET 请求\n * 3**：重定向状态码\n   * 301：永久性重定向\n   * 302：临时性重定向\n   * 304：服务器端允许请求访问资源，但未满足条件\n * 4**：客户端错误状态码\n   * 400：请求报文中存在语法错误\n   * 401：发送的请求需要有通过 HTTP 认证的认证信息\n   * 403：对请求资源的访问被服务器拒绝了\n   * 404：服务器上无法找到请求的资源\n * 5**：服务器错误状态码\n   * 500：服务器端在执行请求时发生了错误\n   * 503：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求\n\n\n# XML 文档定义有几种形式？它们之间有何本质区别？解析 XML 文档有哪几种方式？\n\n（1）XML 文档有两种约束方式：\n\n 1. DTD 约束\n 2. Schema 约束\n\n（2）XML 文档区别： 1 DTD 不符合 XML 的语法结构，schema 符合 XML 的语法结构； 2 DTD 的约束扩展性比较差，XML 文档只能引入一个 DTD 的文件。schema 可以引入多个文件； 3 DTD 不支持名称空间（理解包结构），schema 支持名称空间； 4 DTD 支持数据比较少，schema 支持更多的数据类型；\n\n（3）解析方式主要有三种：\n\n * DOM 解析：\n   * （a）加载整个 xml 的文档到内存中，形成树状结构，生成对象；\n   * （b）容易产生内存溢出；\n   * （c）可以做增删改\n * SAX 解析\n   * （a）边读边解析；\n   * （b）不可以做增删改\n * DOM4J 解析（hibernate 底层采用)\n   * （a）可让 SAX 解析也产生树状结构。\n   * （b）主要 api 开发步骤：\n     * 1）SAXReader.read(xxx.xml)代表解析 xml 的文档，返回对象是 Document；\n     * 2）Document.getRootElement(),返回的是文档的根节点，是 Element 对象；\n     * 3）Element:\n       * .element(...)-- 获得指定名称第一个子元素。可以不指定名称;\n       * .elements(...)-- 获得指定名称的所有子元素。可以不指定名称;\n       * .getText()-- 获得当前元素的文本内容；\n       * .elementText(...)-- 获得指定名称子元素的文本值\n       * .addElement()-- 添加子节点\n       * .setText()-- 设置子标签内容\n     * 4）XMLWriter.write("..")-- 写出\n     * 5）XMLWriter.close()-- 关闭输出流\n\n\n# 参考资料\n\n * https://blog.csdn.net/YM_IlY/article/details/81266959\n * https://www.jianshu.com/p/f073dde56262',normalizedContent:'# javaweb 面经\n\n\n# servlet\n\n\n# 什么是 servlet\n\nservlet（server applet），即小服务程序或服务连接器。servlet 是 java 编写的服务器端程序，具有独立于平台和协议的特性，主要功能在于交互式地浏览和生成数据，生成动态 web 内容。\n\n * 狭义的 servlet 是指 java 实现的一个接口。\n * 广义的 servlet 是指任何实现了这个 servlet 接口的类。\n\nservlet 运行于支持 java 的应用服务器中。从原理上讲，servlet 可以响应任何类型的请求，但绝大多数情况下 servlet 只用来扩展基于 http 协议的 web 服务器。\n\n\n# servlet 和 cgi 的区别\n\nservlet 技术出现之前，web 主要使用 cgi 技术。它们的区别如下：\n\n * servlet 是基于 java 编写的，处于服务器进程中，他能够通过多线程方式运行 service() 方法，一个实例可以服务于多个请求，而且一般不会销毁；\n * cgi(common gateway interface)，即通用网关接口。它会为每个请求产生新的进程，服务完成后销毁，所以效率上低于 servlet。\n\n\n# servlet 版本以及主要特性\n\n版本            日期            java ee/jdk 版本       特性\nservlet 4.0   2017 年 10 月   javaee 8             http2\nservlet 3.1   2013 年 5 月    javaee 7             非阻塞 i/o，http 协议升级机制\nservlet 3.0   2009 年 12 月   javaee 6, javase 6   可插拔性，易于开发，异步 servlet，安全性，文件上传\nservlet 2.5   2005 年 10 月   javaee 5, javase 5   依赖 javase 5，支持注解\nservlet 2.4   2003 年 11 月   j2ee 1.4, j2se 1.3   web.xml 使用 xml schema\nservlet 2.3   2001 年 8 月    j2ee 1.3, j2se 1.2   filter\nservlet 2.2   1999 年 8 月    j2ee 1.2, j2se 1.2   成为 j2ee 标准\nservlet 2.1   1998 年 11 月   未指定                  first official specification, added requestdispatcher,\n                                                 servletcontext\nservlet 2.0                 jdk 1.1              part of java servlet development kit 2.0\nservlet 1.0   1997 年 6 月                         \n\n\n# servlet 和 jsp 的区别\n\n 1. servlet 是一个运行在服务器上的 java 类,依靠服务器支持向浏览器传输数据。\n 2. jsp 本质上就是 servlet，每次运行的时候 jsp 都会被编译成 .java 文件，然后再被编译成 .class 文件。\n 3. 有了 jsp，servlet 不再负责动态生成页面，转而去负责控制程序逻辑的作用，控制 jsp 与 javabean 之间的流转。\n 4. jsp 侧重于视图,而 servlet 侧重于控制逻辑,在 mvc 架构模式中,jsp 适合充当视图 view,servlet 适合充当控制器 controller。\n\n\n# 简述 servlet 生命周期\n\n\n\nservlet 生命周期如下：\n\n 1. 加载 - 第一个到达服务器的 http 请求被委派到 servlet 容器。容器通过类加载器使用 servlet 类对应的文件加载 servlet；\n 2. 初始化 - servlet 通过调用 init () 方法进行初始化。\n 3. 服务 - servlet 调用 service() 方法来处理客户端的请求。\n 4. 销毁 - servlet 通过调用 destroy() 方法终止（结束）。\n 5. 卸载 - servlet 是由 jvm 的垃圾回收器进行垃圾回收的。\n\n\n# 如何现实 servlet 的单线程模式\n\n<%@ page isthreadsafe="false" %>\n\n\n\n# servlet 中如何获取用户提交的查询参数或者表单数据\n\n * httpservletrequest 的 getparameter() 方法。\n * httpservletrequest 的 getparametervalues() 方法。\n * httpservletrequest 的 getparametermap() 方法。\n\n\n# request 的主要方法\n\n * setattribute(string name,object)：设置名字为 name 的 request 的参数值\n * getattribute(string name)：返回由 name 指定的属性值\n * getattributenames()：返回 request 对象所有属性的名字集合，结果是一个枚举的实例\n * getcookies()：返回客户端的所有 cookie 对象，结果是一个 cookie 数组\n * getcharacterencoding()：返回请求中的字符编码方式\n * getcontentlength()：返回请求的 body 的长度\n * getheader(string name)：获得 http 协议定义的文件头信息\n * getheaders(string name)：返回指定名字的 request header 的所有值，结果是一个枚举的实例\n * getheadernames()：返回所以 request header 的名字，结果是一个枚举的实例\n * getinputstream()：返回请求的输入流，用于获得请求中的数据 getmethod()：获得客户端向服务器端传送数据的方法\n * getparameter(string name)：获得客户端传送给服务器端的有 name 指定的参数值\n * getparameternames()：获得客户端传送给服务器端的所有参数的名字，结果是一个枚举的实例\n * getparametervalues(string name)：获得有 name 指定的参数的所有值\n * getprotocol()：获取客户端向服务器端传送数据所依据的协议名称\n * getquerystring()：获得查询字符串\n * getrequesturi()：获取发出请求字符串的客户端地址\n * getremoteaddr()：获取客户端的 ip 地址\n * getremotehost()：获取客户端的名字\n * getsession([boolean create])：返回和请求相关\n * session getservername()：获取服务器的名字\n * getservletpath()：获取客户端所请求的脚本文件的路径\n * getserverport()：获取服务器的端口号\n * removeattribute(string name)：删除请求中的一个属性\n\n\n# jsp\n\n\n# jsp 的内置对象\n\n 1. request：包含客户端请求的信息；\n 2. response：包含服务器传回客户端的响应信息；\n 3. session：主要用来区分每个用户信息和会话状态；\n 4. pagecontext：管理页面属性；\n 5. application：服务器启动时创建，服务器关闭时停止，保存所有应用系统中的共有数据，一个共享的内置对象（即一个容器中的多个用户共享一个 application 对象）；\n 6. out：向客户端输出数据；\n 7. config：代码片段配置对象，用于初始化 servlet 的配置参数；\n 8. page：指网页本身；\n 9. exception：处理 jsp 文件执行时发生的错误和异常，只要在错误页面里才能使用。\n\n\n# jsp 的作用域\n\n 1. page：一个页面；\n 2. request：一次请求；\n 3. session：一次会话；\n 4. application：服务器从启动到停止。\n\n\n# jsp 中 7 个动作指令和作用\n\n 1. jsp:forward - 执行页面转向，把请求转发到下一个页面；\n 2. jsp:param - 用于传递参数，必须与其他支持参数的标签一起使用；\n 3. jsp:include - 用于动态引入一个 jsp 页面；\n 4. jsp:plugin - 用于下载 javabean 或 applet 到客户端执行；\n 5. jsp:usebean - 寻求或者实例化一个 javabean；\n 6. jsp:setproperty - 设置 javabean 的属性值；\n 7. jsp:getproperty - 获取 javabean 的属性值。\n\n\n# jsp 中动态 include 和静态 include 有什么区别\n\n * 静态 include：用 include 伪码实现，不会检查所含文件的变化，适用于包含静态页面<%@ include file="页面名称.html" %>。先合并再编译。\n * 动态 include：用 jsp:include 动作实现 <jsp:include page="页面名称 .jsp" flush="true"> 它总是会检查文件中的变化，适用于包含动态页面，并且可以带参数。先编译再合并。\n\n\n# 原理\n\n\n# 请求转发(forward)和重定向(redirect)的区别\n\n * 效率上\n   * 转发（forward） > 重定向（redirect）\n * 显示上\n   * 重定向（redirect）：显示新的 url\n   * 转发（forward）：地址栏不变\n * 数据上\n   * 转发（forward）：可以共享 request 里面的数据\n   * 重定向（redirect）：不能\n * 请求次数\n   * 重定向（redirect）是两次\n   * 转发（forward）是一次\n\n\n# get 请求和 post 请求的区别\n\n\n\n * get：\n   * 从服务器上获取数据，一般不能使用在写操作接口\n   * 由 url 所限制，get 方式传输的数据大小有所限制，传送的数据量不超过 2kb\n   * 请求的数据会附加在 url 之后，以？分隔 url 和传输数据，多个参数用&连接\n   * 安全性差\n * post:\n   * 向服务器提交数据,一般处理写业务\n   * post 方式传送的数据量比较大，一般被默认为没有限制\n   * 安全性高\n   * 请的求的数据内容放置在 html header 中\n\n\n# 用户在浏览器中输入 url 之后，发什么了什么？写出请求和响应的流程\n\n 1. 域名解析\n 2. tcp 三次握手\n 3. 浏览器向服务器发送 http 请求\n 4. 浏览器发送请求头信息\n 5. 服务器处理请求\n 6. 服务器做出应答\n 7. 服务器发送应答头信息\n 8. 服务器发送数据\n 9. tcp 连接关闭\n\n\n# 什么是 web service?\n\n 1. webservice 就是一个应用程序，它向外界暴露出一个能够通过 web 进行调用的 api。\n 2. 它是基于 http 协议传输数据，这使得运行在不同机上的不同应用程序，无须借助附加的、专门的第三方 软件或硬件，就可以相互交换数据或集成。\n\n\n# 会话跟踪技术有哪些?\n\n由于 http 协议本身是无状态的，服务器为了区分不同的用户，就需要对用户会话进行跟踪，简单的说就是为用户进行登记，为用户分配唯一的 id，下一次用户在请求中包含此 id，服务器根据此判断到底是哪一个用户。\n\n * url 重写：在 url 中添加会话信息作为请求的参数，或者将唯一的会话 id 添加到 url 结尾，以表示一个会话。设置表单隐藏域：将和会话跟踪相关的字段添加到隐藏域中，这些信息不会在浏览器显示，但是提交表单时会提交给服务器。\n * cookie：cookie 有两种：\n   * 一种是基于窗口的，浏览器关闭后，cookie 就没有了；\n   * 另一种是将信息存储在一个临时文件中，并设置其有效路径和最大存活时间。当用户通过浏览器和服务器建立一次会话后，会话 id 就会随相应信息储存在基于窗口的 cookie 中，那就意味着只要浏览器没有关闭，会话没有超时，下一次请求时这个会话 id 又会提交给服务器，让服务器识别用户身份。\n   * 在使用 cookie 时要注意几点：\n     * 首先不要在 cookie 中存放敏 感信息；\n     * 其次 cookie 存储的数据量有限（4k），不能将过多的内容存储 cookie 中；\n     * 再者浏览器通常只允许一个站点最多存放 20 个 cookie。\n     * 当然，和用户会话相关的其他信息（除了会话 id）也可以存在 cookie 方便进行会话 跟踪;\n * httpsession：在所有会话跟踪技术中，httpsession 对象是最强大也是功能最多的。当一个用户第一次访问某个网站时会自动创建 httpsession，每个用户可以访问他自己的 httpsession。可以通过 httpservletrequest 对象的 getsession 方法获得 httpsession，通过 httpsession 的 setattribute 方法可以将一个值放在 httpsession 中，通过调用 httpsession 对象的 getattribute 方法，同时传入属性名就可以获取保存在 httpsession 中的对象。\n   * 与上面三种方式不同的是，httpsession 放在服务器的内存中，因此不要将过大的对象放在里面，即使目前的 servlet 容器可以在内存将满时将 httpsession 中的对象移到其他存储设备中，但是这样势必影响性能。\n   * 添加到 httpsession 中 的值可以是任意 java 对象，这个对象最好实现了 serializable 接口，这样 servlet 容器在必要的时候可以将其序列 化到文件中，否则在序列化时就会出现异常。\n\n\n# 响应结果状态码有哪些，并给出中文含义？\n\n * 1**：信息性状态码\n * 2**：成功状态码\n   * 200：请求正常成功\n   * 204：指示请求成功但没有返回新信息\n   * 206：指示服务器已完成对资源的部分 get 请求\n * 3**：重定向状态码\n   * 301：永久性重定向\n   * 302：临时性重定向\n   * 304：服务器端允许请求访问资源，但未满足条件\n * 4**：客户端错误状态码\n   * 400：请求报文中存在语法错误\n   * 401：发送的请求需要有通过 http 认证的认证信息\n   * 403：对请求资源的访问被服务器拒绝了\n   * 404：服务器上无法找到请求的资源\n * 5**：服务器错误状态码\n   * 500：服务器端在执行请求时发生了错误\n   * 503：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求\n\n\n# xml 文档定义有几种形式？它们之间有何本质区别？解析 xml 文档有哪几种方式？\n\n（1）xml 文档有两种约束方式：\n\n 1. dtd 约束\n 2. schema 约束\n\n（2）xml 文档区别： 1 dtd 不符合 xml 的语法结构，schema 符合 xml 的语法结构； 2 dtd 的约束扩展性比较差，xml 文档只能引入一个 dtd 的文件。schema 可以引入多个文件； 3 dtd 不支持名称空间（理解包结构），schema 支持名称空间； 4 dtd 支持数据比较少，schema 支持更多的数据类型；\n\n（3）解析方式主要有三种：\n\n * dom 解析：\n   * （a）加载整个 xml 的文档到内存中，形成树状结构，生成对象；\n   * （b）容易产生内存溢出；\n   * （c）可以做增删改\n * sax 解析\n   * （a）边读边解析；\n   * （b）不可以做增删改\n * dom4j 解析（hibernate 底层采用)\n   * （a）可让 sax 解析也产生树状结构。\n   * （b）主要 api 开发步骤：\n     * 1）saxreader.read(xxx.xml)代表解析 xml 的文档，返回对象是 document；\n     * 2）document.getrootelement(),返回的是文档的根节点，是 element 对象；\n     * 3）element:\n       * .element(...)-- 获得指定名称第一个子元素。可以不指定名称;\n       * .elements(...)-- 获得指定名称的所有子元素。可以不指定名称;\n       * .gettext()-- 获得当前元素的文本内容；\n       * .elementtext(...)-- 获得指定名称子元素的文本值\n       * .addelement()-- 添加子节点\n       * .settext()-- 设置子标签内容\n     * 4）xmlwriter.write("..")-- 写出\n     * 5）xmlwriter.close()-- 关闭输出流\n\n\n# 参考资料\n\n * https://blog.csdn.net/ym_ily/article/details/81266959\n * https://www.jianshu.com/p/f073dde56262',charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Tomcat 快速入门",frontmatter:{title:"Tomcat 快速入门",date:"2022-02-17T22:34:30.000Z",order:1,categories:["Java","JavaEE","服务器","Tomcat"],tags:["Java","JavaWeb","服务器","Tomcat"],permalink:"/pages/4a4c02/"},regularPath:"/01.Java/02.JavaEE/02.%E6%9C%8D%E5%8A%A1%E5%99%A8/01.Tomcat/01.Tomcat%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8.html",relativePath:"01.Java/02.JavaEE/02.服务器/01.Tomcat/01.Tomcat快速入门.md",key:"v-197081d4",path:"/pages/4a4c02/",headers:[{level:2,title:"1. Tomcat 简介",slug:"_1-tomcat-简介",normalizedTitle:"1. tomcat 简介",charIndex:71},{level:3,title:"1.1. Tomcat 是什么",slug:"_1-1-tomcat-是什么",normalizedTitle:"1.1. tomcat 是什么",charIndex:88},{level:3,title:"1.2. Tomcat 重要目录",slug:"_1-2-tomcat-重要目录",normalizedTitle:"1.2. tomcat 重要目录",charIndex:422},{level:3,title:"1.3. web 工程发布目录结构",slug:"_1-3-web-工程发布目录结构",normalizedTitle:"1.3. web 工程发布目录结构",charIndex:601},{level:3,title:"1.4. Tomcat 功能",slug:"_1-4-tomcat-功能",normalizedTitle:"1.4. tomcat 功能",charIndex:1548},{level:2,title:"2. Tomcat 入门",slug:"_2-tomcat-入门",normalizedTitle:"2. tomcat 入门",charIndex:1823},{level:3,title:"2.1. 安装",slug:"_2-1-安装",normalizedTitle:"2.1. 安装",charIndex:1840},{level:3,title:"2.2. 配置",slug:"_2-2-配置",normalizedTitle:"2.2. 配置",charIndex:2317},{level:4,title:"2.2.1. Server",slug:"_2-2-1-server",normalizedTitle:"2.2.1. server",charIndex:2385},{level:4,title:"2.2.2. Service",slug:"_2-2-2-service",normalizedTitle:"2.2.2. service",charIndex:2864},{level:4,title:"2.2.3. Executor",slug:"_2-2-3-executor",normalizedTitle:"2.2.3. executor",charIndex:3378},{level:4,title:"2.2.4. Connector",slug:"_2-2-4-connector",normalizedTitle:"2.2.4. connector",charIndex:4212},{level:4,title:"2.2.5. Context",slug:"_2-2-5-context",normalizedTitle:"2.2.5. context",charIndex:6442},{level:4,title:"2.2.6. Engine",slug:"_2-2-6-engine",normalizedTitle:"2.2.6. engine",charIndex:7503},{level:4,title:"2.2.7. Host",slug:"_2-2-7-host",normalizedTitle:"2.2.7. host",charIndex:7857},{level:4,title:"2.2.8. Cluster",slug:"_2-2-8-cluster",normalizedTitle:"2.2.8. cluster",charIndex:8899},{level:3,title:"2.3. 启动",slug:"_2-3-启动",normalizedTitle:"2.3. 启动",charIndex:8953},{level:4,title:"2.3.1. 部署方式",slug:"_2-3-1-部署方式",normalizedTitle:"2.3.1. 部署方式",charIndex:8964},{level:4,title:"2.3.2. 嵌入式",slug:"_2-3-2-嵌入式",normalizedTitle:"2.3.2. 嵌入式",charIndex:9269},{level:5,title:"2.3.2.1. API 方式",slug:"_2-3-2-1-api-方式",normalizedTitle:"2.3.2.1. api 方式",charIndex:9283},{level:5,title:"2.3.2.2. 使用 maven 插件启动（不推荐）",slug:"_2-3-2-2-使用-maven-插件启动-不推荐",normalizedTitle:"2.3.2.2. 使用 maven 插件启动（不推荐）",charIndex:10857},{level:4,title:"2.3.3. IDE 插件",slug:"_2-3-3-ide-插件",normalizedTitle:"2.3.3. ide 插件",charIndex:11396},{level:2,title:"3. Tomcat 架构",slug:"_3-tomcat-架构",normalizedTitle:"3. tomcat 架构",charIndex:11891},{level:3,title:"3.1. Service",slug:"_3-1-service",normalizedTitle:"3.1. service",charIndex:12093},{level:3,title:"3.2. 连接器",slug:"_3-2-连接器",normalizedTitle:"3.2. 连接器",charIndex:12681},{level:4,title:"3.2.1. ProtocolHandler 组件",slug:"_3-2-1-protocolhandler-组件",normalizedTitle:"3.2.1. protocolhandler 组件",charIndex:13459},{level:5,title:"3.2.1.1. EndPoint",slug:"_3-2-1-1-endpoint",normalizedTitle:"3.2.1.1. endpoint",charIndex:13622},{level:5,title:"3.2.1.2. Processor",slug:"_3-2-1-2-processor",normalizedTitle:"3.2.1.2. processor",charIndex:14040},{level:4,title:"3.2.2. Adapter",slug:"_3-2-2-adapter",normalizedTitle:"3.2.2. adapter",charIndex:14552},{level:3,title:"3.3. 容器",slug:"_3-3-容器",normalizedTitle:"3.3. 容器",charIndex:14939},{level:4,title:"3.3.1. 请求分发 Servlet 过程",slug:"_3-3-1-请求分发-servlet-过程",normalizedTitle:"3.3.1. 请求分发 servlet 过程",charIndex:15214},{level:4,title:"3.3.2. Pipeline-Value",slug:"_3-3-2-pipeline-value",normalizedTitle:"3.3.2. pipeline-value",charIndex:15876},{level:2,title:"4. Tomcat 生命周期",slug:"_4-tomcat-生命周期",normalizedTitle:"4. tomcat 生命周期",charIndex:17055},{level:3,title:"4.1. Tomcat 的启动过程",slug:"_4-1-tomcat-的启动过程",normalizedTitle:"4.1. tomcat 的启动过程",charIndex:17074},{level:4,title:"4.1.1. Catalina 组件",slug:"_4-1-1-catalina-组件",normalizedTitle:"4.1.1. catalina 组件",charIndex:17447},{level:4,title:"4.1.2. Server 组件",slug:"_4-1-2-server-组件",normalizedTitle:"4.1.2. server 组件",charIndex:18843},{level:4,title:"4.1.3. Service 组件",slug:"_4-1-3-service-组件",normalizedTitle:"4.1.3. service 组件",charIndex:20100},{level:4,title:"4.1.4. Engine 组件",slug:"_4-1-4-engine-组件",normalizedTitle:"4.1.4. engine 组件",charIndex:21714},{level:3,title:"4.2. Web 应用的部署方式",slug:"_4-2-web-应用的部署方式",normalizedTitle:"4.2. web 应用的部署方式",charIndex:21792},{level:3,title:"4.3. LifeCycle",slug:"_4-3-lifecycle",normalizedTitle:"4.3. lifecycle",charIndex:23040},{level:4,title:"4.3.1. 请求处理过程",slug:"_4-3-1-请求处理过程",normalizedTitle:"4.3.1. 请求处理过程",charIndex:23060},{level:3,title:"4.4. Connector 流程",slug:"_4-4-connector-流程",normalizedTitle:"4.4. connector 流程",charIndex:23294},{level:4,title:"4.4.1. 阻塞 IO",slug:"_4-4-1-阻塞-io",normalizedTitle:"4.4.1. 阻塞 io",charIndex:23317},{level:4,title:"4.4.2. 非阻塞 IO",slug:"_4-4-2-非阻塞-io",normalizedTitle:"4.4.2. 非阻塞 io",charIndex:23335},{level:4,title:"4.4.3. IO 多路复用",slug:"_4-4-3-io-多路复用",normalizedTitle:"4.4.3. io 多路复用",charIndex:23354},{level:4,title:"4.4.4. Tomcat 各类 Connector 对比",slug:"_4-4-4-tomcat-各类-connector-对比",normalizedTitle:"4.4.4. tomcat 各类 connector 对比",charIndex:23505},{level:3,title:"4.5. Comet",slug:"_4-5-comet",normalizedTitle:"4.5. comet",charIndex:24579},{level:3,title:"4.6. 异步 Servlet",slug:"_4-6-异步-servlet",normalizedTitle:"4.6. 异步 servlet",charIndex:25291},{level:2,title:"5. 参考资料",slug:"_5-参考资料",normalizedTitle:"5. 参考资料",charIndex:26192}],headersStr:"1. Tomcat 简介 1.1. Tomcat 是什么 1.2. Tomcat 重要目录 1.3. web 工程发布目录结构 1.4. Tomcat 功能 2. Tomcat 入门 2.1. 安装 2.2. 配置 2.2.1. Server 2.2.2. Service 2.2.3. Executor 2.2.4. Connector 2.2.5. Context 2.2.6. Engine 2.2.7. Host 2.2.8. Cluster 2.3. 启动 2.3.1. 部署方式 2.3.2. 嵌入式 2.3.2.1. API 方式 2.3.2.2. 使用 maven 插件启动（不推荐） 2.3.3. IDE 插件 3. Tomcat 架构 3.1. Service 3.2. 连接器 3.2.1. ProtocolHandler 组件 3.2.1.1. EndPoint 3.2.1.2. Processor 3.2.2. Adapter 3.3. 容器 3.3.1. 请求分发 Servlet 过程 3.3.2. Pipeline-Value 4. Tomcat 生命周期 4.1. Tomcat 的启动过程 4.1.1. Catalina 组件 4.1.2. Server 组件 4.1.3. Service 组件 4.1.4. Engine 组件 4.2. Web 应用的部署方式 4.3. LifeCycle 4.3.1. 请求处理过程 4.4. Connector 流程 4.4.1. 阻塞 IO 4.4.2. 非阻塞 IO 4.4.3. IO 多路复用 4.4.4. Tomcat 各类 Connector 对比 4.5. Comet 4.6. 异步 Servlet 5. 参考资料",content:'# Tomcat 快速入门\n\n> 🎁 版本说明\n> \n> 当前最新版本：Tomcat 8.5.24\n> \n> 环境要求：JDK7+\n\n\n# 1. Tomcat 简介\n\n\n# 1.1. Tomcat 是什么\n\nTomcat 是由 Apache 开发的一个 Servlet 容器，实现了对 Servlet 和 JSP 的支持，并提供了作为 Web 服务器的一些特有功能，如 Tomcat 管理和控制平台、安全域管理和 Tomcat 阀等。\n\n由于 Tomcat 本身也内含了一个 HTTP 服务器，它也可以被视作一个单独的 Web 服务器。但是，不能将 Tomcat 和 Apache HTTP 服务器混淆，Apache HTTP 服务器是一个用 C 语言实现的 HTTP Web 服务器；这两个 HTTP web server 不是捆绑在一起的。Tomcat 包含了一个配置管理工具，也可以通过编辑 XML 格式的配置文件来进行配置。\n\n\n# 1.2. Tomcat 重要目录\n\n * /bin - Tomcat 脚本存放目录（如启动、关闭脚本）。 *.sh 文件用于 Unix 系统； *.bat 文件用于 Windows 系统。\n * /conf - Tomcat 配置文件目录。\n * /logs - Tomcat 默认日志目录。\n * /webapps - webapp 运行的目录。\n\n\n# 1.3. web 工程发布目录结构\n\n一般 web 项目路径结构\n\n|-- webapp                         # 站点根目录\n    |-- META-INF                   # META-INF 目录\n    |   `-- MANIFEST.MF            # 配置清单文件\n    |-- WEB-INF                    # WEB-INF 目录\n    |   |-- classes                # class文件目录\n    |   |   |-- *.class            # 程序需要的 class 文件\n    |   |   `-- *.xml              # 程序需要的 xml 文件\n    |   |-- lib                    # 库文件夹\n    |   |   `-- *.jar              # 程序需要的 jar 包\n    |   `-- web.xml                # Web应用程序的部署描述文件\n    |-- <userdir>                  # 自定义的目录\n    |-- <userfiles>                # 自定义的资源文件\n\n\n * webapp：工程发布文件夹。其实每个 war 包都可以视为 webapp 的压缩包。\n\n * META-INF：META-INF 目录用于存放工程自身相关的一些信息，元文件信息，通常由开发工具，环境自动生成。\n\n * WEB-INF：Java web 应用的安全目录。所谓安全就是客户端无法访问，只有服务端可以访问的目录。\n\n * /WEB-INF/classes：存放程序所需要的所有 Java class 文件。\n\n * /WEB-INF/lib：存放程序所需要的所有 jar 文件。\n\n * /WEB-INF/web.xml：web 应用的部署配置文件。它是工程中最重要的配置文件，它描述了 servlet 和组成应用的其它组件，以及应用初始化参数、安全管理约束等。\n\n\n# 1.4. Tomcat 功能\n\nTomcat 支持的 I/O 模型有：\n\n * NIO：非阻塞 I/O，采用 Java NIO 类库实现。\n * NIO2：异步 I/O，采用 JDK 7 最新的 NIO2 类库实现。\n * APR：采用 Apache 可移植运行库实现，是 C/C++ 编写的本地库。\n\nTomcat 支持的应用层协议有：\n\n * HTTP/1.1：这是大部分 Web 应用采用的访问协议。\n * AJP：用于和 Web 服务器集成（如 Apache）。\n * HTTP/2：HTTP 2.0 大幅度的提升了 Web 性能。\n\n\n# 2. Tomcat 入门\n\n\n# 2.1. 安装\n\n前提条件\n\nTomcat 8.5 要求 JDK 版本为 1.7 以上。\n\n进入 Tomcat 官方下载地址 选择合适版本下载，并解压到本地。\n\nWindows\n\n添加环境变量 CATALINA_HOME ，值为 Tomcat 的安装路径。\n\n进入安装目录下的 bin 目录，运行 startup.bat 文件，启动 Tomcat\n\nLinux / Unix\n\n下面的示例以 8.5.24 版本为例，包含了下载、解压、启动操作。\n\n# 下载解压到本地\nwget http://mirrors.hust.edu.cn/apache/tomcat/tomcat-8/v8.5.24/bin/apache-tomcat-8.5.24.tar.gz\ntar -zxf apache-tomcat-8.5.24.tar.gz\n# 启动 Tomcat\n./apache-tomcat-8.5.24/bin/startup.sh\n\n\n启动后，访问 http://localhost:8080 ，可以看到 Tomcat 安装成功的测试页面。\n\n\n\n\n# 2.2. 配置\n\n本节将列举一些重要、常见的配置项。详细的 Tomcat8 配置可以参考 Tomcat 8 配置官方参考文档 。\n\n# 2.2.1. Server\n\n> Server 元素表示整个 Catalina servlet 容器。\n> \n> 因此，它必须是 conf/server.xml 配置文件中的根元素。它的属性代表了整个 servlet 容器的特性。\n\n属性表\n\n属性          描述                                               备注\nclassName   这个类必须实现 org.apache.catalina.Server 接口。           默认 org.apache.catalina.core.StandardServer\naddress     服务器等待关机命令的 TCP / IP 地址。如果没有指定地址，则使用 localhost。   \nport        服务器等待关机命令的 TCP / IP 端口号。设置为-1 以禁用关闭端口。           \nshutdown    必须通过 TCP / IP 连接接收到指定端口号的命令字符串，以关闭 Tomcat。       \n\n# 2.2.2. Service\n\n> Service 元素表示一个或多个连接器组件的组合，这些组件共享一个用于处理传入请求的引擎组件。Server 中可以有多个 Service。\n\n属性表\n\n属性          描述                                      备注\nclassName   这个类必须实现org.apache.catalina.Service接口。   默认 org.apache.catalina.core.StandardService\nname        此服务的显示名称，如果您使用标准 Catalina               \n            组件，将包含在日志消息中。与特定服务器关联的每个服务的名称必须是唯一的。\n\n实例 - conf/server.xml 配置文件示例\n\n<?xml version="1.0" encoding="UTF-8"?>\n<Server port="8080" shutdown="SHUTDOWN">\n  <Service name="xxx">\n  ...\n  </Service>\n</Server>\n\n\n# 2.2.3. Executor\n\n> Executor 表示可以在 Tomcat 中的组件之间共享的线程池。\n\n属性表\n\n属性                描述                                          备注\nclassName         这个类必须实现org.apache.catalina.Executor接口。      默认 org.apache.catalina.core.StandardThreadExecutor\nname              线程池名称。                                      要求唯一, 供 Connector 元素的 executor 属性使用\nnamePrefix        线程名称前缀。                                     \nmaxThreads        最大活跃线程数。                                    默认 200\nminSpareThreads   最小活跃线程数。                                    默认 25\nmaxIdleTime       当前活跃线程大于 minSpareThreads 时,空闲线程关闭的等待最大时间。   默认 60000ms\nmaxQueueSize      线程池满情况下的请求排队大小。                             默认 Integer.MAX_VALUE\n\n<Service name="xxx">\n  <Executor name="tomcatThreadPool" namePrefix="catalina-exec-" maxThreads="300" minSpareThreads="25"/>\n</Service>\n\n\n# 2.2.4. Connector\n\n> Connector 代表连接组件。Tomcat 支持三种协议：HTTP/1.1、HTTP/2.0、AJP。\n\n属性表\n\n属性                      说明                                                             备注\nasyncTimeout            Servlet3.0 规范中的异步请求超时                                          默认 30s\nport                    请求连接的 TCP Port                                                 设置为 0,则会随机选取一个未占用的端口号\nprotocol                协议. 一般情况下设置为 HTTP/1.1,这种情况下连接模型会在 NIO 和 APR/native 中自动根据配置选择   \nURIEncoding             对 URI 的编码方式.                                                   如果设置系统变量 org.apache.catalina.STRICT_SERVLET_COMPLIANCE 为\n                                                                                       true,使用 ISO-8859-1 编码;如果未设置此系统变量且未设置此属性, 使用 UTF-8 编码\nuseBodyEncodingForURI   是否采用指定的 contentType 而不是 URIEncoding 来编码 URI 中的请求参数             \n\n以下属性在标准的 Connector(NIO, NIO2 和 APR/native)中有效:\n\n属性                  说明                                                  备注\nacceptCount         当最大请求连接 maxConnections 满时的最大排队大小                    默认 100,注意此属性和 Executor 中属性 maxQueueSize\n                                                                        的区别.这个指的是请求连接满时的堆栈大小,Executor 的 maxQueueSize 指的是处理线程满时的堆栈大小\nconnectionTimeout   请求连接超时                                              默认 60000ms\nexecutor            指定配置的线程池名称                                          \nkeepAliveTimeout    keeAlive 超时时间                                       默认值为 connectionTimeout 配置值.-1 表示不超时\nmaxConnections      最大连接数                                               连接满时后续连接放入最大为 acceptCount 的队列中. 对 NIO 和 NIO2 连接,默认值为 10000;对\n                                                                        APR/native,默认值为 8192\nmaxThreads          如果指定了 Executor, 此属性忽略;否则为 Connector 创建的内部线程池最大值     默认 200\nminSpareThreads     如果指定了 Executor, 此属性忽略;否则为 Connector 创建线程池的最小活跃线程数   默认 10\nprocessorCache      协议处理器缓存 Processor 对象的大小                             -1 表示不限制.当不使用 servlet3.0 的异步处理情况下: 如果配置 Executor,配置为\n                                                                        Executor 的 maxThreads;否则配置为 Connnector 的 maxThreads. 如果使用\n                                                                        Serlvet3.0 异步处理, 取 maxThreads 和 maxConnections 的最大值\n\n# 2.2.5. Context\n\n> Context 元素表示一个 Web 应用程序，它在特定的虚拟主机中运行。每个 Web 应用程序都基于 Web 应用程序存档（WAR）文件，或者包含相应的解包内容的相应目录，如 Servlet 规范中所述。\n\n属性表\n\n属性                           说明                                                          备注\naltDDName                    web.xml 部署描述符路径                                             默认 /WEB-INF/web.xml\ndocBase                      Context 的 Root 路径                                           和 Host 的 appBase 相结合, 可确定 web 应用的实际目录\nfailCtxIfServletStartFails   同 Host 中的 failCtxIfServletStartFails, 只对当前 Context 有效       默认为 false\nlogEffectiveWebXml           是否日志打印 web.xml 内容(web.xml 由默认的 web.xml 和应用中的 web.xml 组成)    默认为 false\npath                         web 应用的 context path                                        如果为根路径,则配置为空字符串(""), 不能不配置\nprivileged                   是否使用 Tomcat 提供的 manager servlet                             \nreloadable                   /WEB-INF/classes/ 和/WEB-INF/lib/ 目录中 class 文件发生变化是否自动重新加载   默认为 false\nswallowOutput                true 情况下, System.out 和 System.err 输出将被定向到 web 应用日志中         默认为 false\n\n# 2.2.6. Engine\n\n> Engine 元素表示与特定的 Catalina 服务相关联的整个请求处理机器。它接收并处理来自一个或多个连接器的所有请求，并将完成的响应返回给连接器，以便最终传输回客户端。\n\n属性表\n\n属性            描述                                           备注\ndefaultHost   默认主机名，用于标识将处理指向此服务器上主机名称但未在此配置文件中配置的请求的主机。   这个名字必须匹配其中一个嵌套的主机元素的名字属性。\nname          此引擎的逻辑名称，用于日志和错误消息。                          在同一服务器中使用多个服务元素时，每个引擎必须分配一个唯一的名称。\n\n# 2.2.7. Host\n\n> Host 元素表示一个虚拟主机，它是一个服务器的网络名称（如“www.mycompany.com”）与运行 Tomcat 的特定服务器的关联。\n\n属性表\n\n属性                           说明                                                         备注\nname                         名称                                                         用于日志输出\nappBase                      虚拟主机对应的应用基础路径                                              可以是个绝对路径, 或${CATALINA_BASE}相对路径\nxmlBase                      虚拟主机 XML 基础路径,里面应该有 Context xml 配置文件                       可以是个绝对路径, 或${CATALINA_BASE}相对路径\ncreateDirs                   当 appBase 和 xmlBase 不存在时,是否创建目录                            默认为 true\nautoDeploy                   是否周期性的检查 appBase 和 xmlBase 并 deploy web 应用和 context 描述符    默认为 true\ndeployIgnore                 忽略 deploy 的正则                                              \ndeployOnStartup              Tomcat 启动时是否自动 deploy                                      默认为 true\nfailCtxIfServletStartFails   配置为 true 情况下,任何 load-on-startup >=0 的 servlet 启动失败,则其对应的   默认为 false\n                             Contxt 也启动失败\n\n# 2.2.8. Cluster\n\n由于在实际开发中，我从未用过 Tomcat 集群配置，所以没研究。\n\n\n# 2.3. 启动\n\n# 2.3.1. 部署方式\n\n这种方式要求本地必须安装 Tomcat 。\n\n将打包好的 war 包放在 Tomcat 安装目录下的 webapps 目录下，然后在 bin 目录下执行 startup.bat 或 startup.sh ，Tomcat 会自动解压 webapps 目录下的 war 包。\n\n成功后，可以访问 http://localhost:8080/xxx （xxx 是 war 包文件名）。\n\n> 注意\n> \n> 以上步骤是最简单的示例。步骤中的 war 包解压路径、启动端口以及一些更多的功能都可以修改配置文件来定制 （主要是 server.xml 或 context.xml 文件）。\n\n# 2.3.2. 嵌入式\n\n# 2.3.2.1. API 方式\n\n在 pom.xml 中添加依赖\n\n<dependency>\n  <groupId>org.apache.tomcat.embed</groupId>\n  <artifactId>tomcat-embed-core</artifactId>\n  <version>8.5.24</version>\n</dependency>\n\n\n添加 SimpleEmbedTomcatServer.java 文件，内容如下：\n\nimport java.util.Optional;\nimport org.apache.catalina.startup.Tomcat;\n\npublic class SimpleTomcatServer {\n    private static final int PORT = 8080;\n    private static final String CONTEXT_PATH = "/javatool-server";\n\n    public static void main(String[] args) throws Exception {\n        // 设定 profile\n        Optional<String> profile = Optional.ofNullable(System.getProperty("spring.profiles.active"));\n        System.setProperty("spring.profiles.active", profile.orElse("develop"));\n\n        Tomcat tomcat = new Tomcat();\n        tomcat.setPort(PORT);\n        tomcat.getHost().setAppBase(".");\n        tomcat.addWebapp(CONTEXT_PATH, getAbsolutePath() + "src/main/webapp");\n        tomcat.start();\n        tomcat.getServer().await();\n    }\n\n    private static String getAbsolutePath() {\n        String path = null;\n        String folderPath = SimpleEmbedTomcatServer.class.getProtectionDomain().getCodeSource().getLocation().getPath()\n                .substring(1);\n        if (folderPath.indexOf("target") > 0) {\n            path = folderPath.substring(0, folderPath.indexOf("target"));\n        }\n        return path;\n    }\n}\n\n\n成功后，可以访问 http://localhost:8080/javatool-server 。\n\n> 说明\n> \n> 本示例是使用 org.apache.tomcat.embed 启动嵌入式 Tomcat 的最简示例。\n> \n> 这个示例中使用的是 Tomcat 默认的配置，但通常，我们需要对 Tomcat 配置进行一些定制和调优。为了加载配置文件，启动类就要稍微再复杂一些。这里不想再贴代码，有兴趣的同学可以参考：\n> \n> 示例项目\n\n# 2.3.2.2. 使用 maven 插件启动（不推荐）\n\n不推荐理由：这种方式启动 maven 虽然最简单，但是有一个很大的问题是，真的很久很久没发布新版本了（最新版本发布时间：2013-11-11）。且貌似只能找到 Tomcat6 、Tomcat7 插件。\n\n使用方法\n\n在 pom.xml 中引入插件\n\n<plugin>\n  <groupId>org.apache.tomcat.maven</groupId>\n  <artifactId>tomcat7-maven-plugin</artifactId>\n  <version>2.2</version>\n  <configuration>\n    <port>8080</port>\n    <path>/${project.artifactId}</path>\n    <uriEncoding>UTF-8</uriEncoding>\n  </configuration>\n</plugin>\n\n\n运行 mvn tomcat7:run 命令，启动 Tomcat。\n\n成功后，可以访问 http://localhost:8080/xxx （xxx 是 ${project.artifactId} 指定的项目名）。\n\n# 2.3.3. IDE 插件\n\n常见 Java IDE 一般都有对 Tomcat 的支持。\n\n以 Intellij IDEA 为例，提供了 Tomcat and TomEE Integration 插件（一般默认会安装）。\n\n使用步骤\n\n * 点击 Run/Debug Configurations > New Tomcat Server > local ，打开 Tomcat 配置页面。\n * 点击 Confiure... 按钮，设置 Tomcat 安装路径。\n * 点击 Deployment 标签页，设置要启动的应用。\n * 设置启动应用的端口、JVM 参数、启动浏览器等。\n * 成功后，可以访问 http://localhost:8080/（当然，你也可以在 url 中设置上下文名称）。\n\n\n\n> 说明\n> \n> 个人认为这个插件不如 Eclipse 的 Tomcat 插件好用，Eclipse 的 Tomcat 插件支持对 Tomcat xml 配置文件进行配置。而这里，你只能自己去 Tomcat 安装路径下修改配置文件。\n\n文中的嵌入式启动示例可以参考我的示例项目\n\n\n# 3. Tomcat 架构\n\n\n\nTomcat 要实现 2 个核心功能：\n\n * 处理 Socket 连接，负责网络字节流与 Request 和 Response 对象的转化。\n * 加载和管理 Servlet，以及处理具体的 Request 请求。\n\n为此，Tomcat 设计了两个核心组件：\n\n * 连接器（Connector）：负责和外部通信\n * 容器（Container）：负责内部处理\n\n\n# 3.1. Service\n\nTomcat 支持的 I/O 模型有：\n\n * NIO：非阻塞 I/O，采用 Java NIO 类库实现。\n * NIO2：异步 I/O，采用 JDK 7 最新的 NIO2 类库实现。\n * APR：采用 Apache 可移植运行库实现，是 C/C++ 编写的本地库。\n\nTomcat 支持的应用层协议有：\n\n * HTTP/1.1：这是大部分 Web 应用采用的访问协议。\n * AJP：用于和 Web 服务器集成（如 Apache）。\n * HTTP/2：HTTP 2.0 大幅度的提升了 Web 性能。\n\nTomcat 支持多种 I/O 模型和应用层协议。为了实现这点，一个容器可能对接多个连接器。但是，单独的连接器或容器都不能对外提供服务，需要把它们组装起来才能工作，组装后这个整体叫作 Service 组件。Tomcat 内可能有多个 Service，通过在 Tomcat 中配置多个 Service，可以实现通过不同的端口号来访问同一台机器上部署的不同应用。\n\n\n\n一个 Tomcat 实例有一个或多个 Service；一个 Service 有多个 Connector 和 Container。Connector 和 Container 之间通过标准的 ServletRequest 和 ServletResponse 通信。\n\n\n# 3.2. 连接器\n\n连接器对 Servlet 容器屏蔽了协议及 I/O 模型等的区别，无论是 HTTP 还是 AJP，在容器中获取到的都是一个标准的 ServletRequest 对象。\n\n连接器的主要功能是：\n\n * 网络通信\n * 应用层协议解析\n * Tomcat Request/Response 与 ServletRequest/ServletResponse 的转化\n\nTomcat 设计了 3 个组件来实现这 3 个功能，分别是 EndPoint、Processor 和 Adapter。\n\n\n\n组件间通过抽象接口交互。这样做还有一个好处是**封装变化。**这是面向对象设计的精髓，将系统中经常变化的部分和稳定的部分隔离，有助于增加复用性，并降低系统耦合度。网络通信的 I/O 模型是变化的，可能是非阻塞 I/O、异步 I/O 或者 APR。应用层协议也是变化的，可能是 HTTP、HTTPS、AJP。浏览器端发送的请求信息也是变化的。但是整体的处理逻辑是不变的，EndPoint 负责提供字节流给 Processor，Processor 负责提供 Tomcat Request 对象给 Adapter，Adapter 负责提供 ServletRequest 对象给容器。\n\n如果要支持新的 I/O 方案、新的应用层协议，只需要实现相关的具体子类，上层通用的处理逻辑是不变的。由于 I/O 模型和应用层协议可以自由组合，比如 NIO + HTTP 或者 NIO2 + AJP。Tomcat 的设计者将网络通信和应用层协议解析放在一起考虑，设计了一个叫 ProtocolHandler 的接口来封装这两种变化点。各种协议和通信模型的组合有相应的具体实现类。比如：Http11NioProtocol 和 AjpNioProtocol。\n\n\n\n# 3.2.1. ProtocolHandler 组件\n\n连接器用 ProtocolHandler 接口来封装通信协议和 I/O 模型的差异。ProtocolHandler 内部又分为 EndPoint 和 Processor 模块，EndPoint 负责底层 Socket 通信，Proccesor 负责应用层协议解析。\n\n# 3.2.1.1. EndPoint\n\nEndPoint 是通信端点，即通信监听的接口，是具体的 Socket 接收和发送处理器，是对传输层的抽象，因此 EndPoint 是用来实现 TCP/IP 协议的。\n\nEndPoint 是一个接口，对应的抽象实现类是 AbstractEndpoint，而 AbstractEndpoint 的具体子类，比如在 NioEndpoint 和 Nio2Endpoint 中，有两个重要的子组件：Acceptor 和 SocketProcessor。\n\n其中 Acceptor 用于监听 Socket 连接请求。SocketProcessor 用于处理接收到的 Socket 请求，它实现 Runnable 接口，在 Run 方法里调用协议处理组件 Processor 进行处理。为了提高处理能力，SocketProcessor 被提交到线程池来执行。而这个线程池叫作执行器（Executor)。\n\n# 3.2.1.2. Processor\n\n如果说 EndPoint 是用来实现 TCP/IP 协议的，那么 Processor 用来实现 HTTP 协议，Processor 接收来自 EndPoint 的 Socket，读取字节流解析成 Tomcat Request 和 Response 对象，并通过 Adapter 将其提交到容器处理，Processor 是对应用层协议的抽象。\n\nProcessor 是一个接口，定义了请求的处理等方法。它的抽象实现类 AbstractProcessor 对一些协议共有的属性进行封装，没有对方法进行实现。具体的实现有 AJPProcessor、HTTP11Processor 等，这些具体实现类实现了特定协议的解析方法和请求处理方式。\n\n\n\n从图中我们看到，EndPoint 接收到 Socket 连接后，生成一个 SocketProcessor 任务提交到线程池去处理，SocketProcessor 的 Run 方法会调用 Processor 组件去解析应用层协议，Processor 通过解析生成 Request 对象后，会调用 Adapter 的 Service 方法。\n\n# 3.2.2. Adapter\n\n连接器通过适配器 Adapter 调用容器。\n\n由于协议不同，客户端发过来的请求信息也不尽相同，Tomcat 定义了自己的 Request 类来适配这些请求信息。\n\nProtocolHandler 接口负责解析请求并生成 Tomcat Request 类。但是这个 Request 对象不是标准的 ServletRequest，也就意味着，不能用 Tomcat Request 作为参数来调用容器。Tomcat 的解决方案是引入 CoyoteAdapter，这是适配器模式的经典运用，连接器调用 CoyoteAdapter 的 Sevice 方法，传入的是 Tomcat Request 对象，CoyoteAdapter 负责将 Tomcat Request 转成 ServletRequest，再调用容器的 Service 方法。\n\n\n# 3.3. 容器\n\nTomcat 设计了 4 种容器，分别是 Engine、Host、Context 和 Wrapper。\n\n * Engine - Servlet 的顶层容器，包含一 个或多个 Host 子容器；\n * Host - 虚拟主机，负责 web 应用的部署和 Context 的创建；\n * Context - Web 应用上下文，包含多个 Wrapper，负责 web 配置的解析、管理所有的 Web 资源；\n * Wrapper - 最底层的容器，是对 Servlet 的封装，负责 Servlet 实例的创 建、执行和销毁。\n\n# 3.3.1. 请求分发 Servlet 过程\n\nTomcat 是怎么确定请求是由哪个 Wrapper 容器里的 Servlet 来处理的呢？答案是，Tomcat 是用 Mapper 组件来完成这个任务的。\n\n举例来说，假如有一个网购系统，有面向网站管理人员的后台管理系统，还有面向终端客户的在线购物系统。这两个系统跑在同一个 Tomcat 上，为了隔离它们的访问域名，配置了两个虚拟域名：manage.shopping.com和user.shopping.com，网站管理人员通过manage.shopping.com域名访问 Tomcat 去管理用户和商品，而用户管理和商品管理是两个单独的 Web 应用。终端客户通过user.shopping.com域名去搜索商品和下订单，搜索功能和订单管理也是两个独立的 Web 应用。如下所示，演示了 url 应声 Servlet 的处理流程。\n\n\n\n假如有用户访问一个 URL，比如图中的http://user.shopping.com:8080/order/buy，Tomcat 如何将这个 URL 定位到一个 Servlet 呢？\n\n 1. 首先，根据协议和端口号选定 Service 和 Engine。\n 2. 然后，根据域名选定 Host。\n 3. 之后，根据 URL 路径找到 Context 组件。\n 4. 最后，根据 URL 路径找到 Wrapper（Servlet）。\n\n这个路由分发过程具体是怎么实现的呢？答案是使用 Pipeline-Valve 管道。\n\n# 3.3.2. Pipeline-Value\n\nPipeline 可以理解为现实中的管道，Valve 为管道中的阀门，Request 和 Response 对象在管道中经过各个阀门的处理和控制。\n\nPipeline-Valve 是责任链模式，责任链模式是指在一个请求处理的过程中有很多处理者依次对请求进行处理，每个处理者负责做自己相应的处理，处理完之后将再调用下一个处理者继续处理。Valve 表示一个处理点，比如权限认证和记录日志。\n\n先来了解一下 Valve 和 Pipeline 接口的设计：\n\n\n\n * 每一个容器都有一个 Pipeline 对象，只要触发这个 Pipeline 的第一个 Valve，这个容器里 Pipeline 中的 Valve 就都会被调用到。但是，不同容器的 Pipeline 是怎么链式触发的呢，比如 Engine 中 Pipeline 需要调用下层容器 Host 中的 Pipeline。\n * 这是因为 Pipeline 中还有个 getBasic 方法。这个 BasicValve 处于 Valve 链表的末端，它是 Pipeline 中必不可少的一个 Valve，负责调用下层容器的 Pipeline 里的第一个 Valve。\n * Pipeline 中有 addValve 方法。Pipeline 中维护了 Valve 链表，Valve 可以插入到 Pipeline 中，对请求做某些处理。我们还发现 Pipeline 中没有 invoke 方法，因为整个调用链的触发是 Valve 来完成的，Valve 完成自己的处理后，调用 getNext.invoke() 来触发下一个 Valve 调用。\n * Valve 中主要的三个方法：setNext、getNext、invoke。Valve 之间的关系是单向链式结构，本身 invoke 方法中会调用下一个 Valve 的 invoke 方法。\n * 各层容器对应的 basic valve 分别是 StandardEngineValve、StandardHostValve、 StandardContextValve、StandardWrapperValve。\n * 由于 Valve 是一个处理点，因此 invoke 方法就是来处理请求的。注意到 Valve 中有 getNext 和 setNext 方法，因此我们大概可以猜到有一个链表将 Valve 链起来了。\n\n\n\n整个调用过程由连接器中的 Adapter 触发的，它会调用 Engine 的第一个 Valve：\n\nconnector.getService().getContainer().getPipeline().getFirst().invoke(request, response);\n\n\n\n# 4. Tomcat 生命周期\n\n\n# 4.1. Tomcat 的启动过程\n\n\n\n 1. Tomcat 是一个 Java 程序，它的运行从执行 startup.sh 脚本开始。startup.sh 会启动一个 JVM 来运行 Tomcat 的启动类 Bootstrap。\n 2. Bootstrap 会初始化 Tomcat 的类加载器并实例化 Catalina。\n 3. Catalina 会通过 Digester 解析 server.xml，根据其中的配置信息来创建相应组件，并调用 Server 的 start 方法。\n 4. Server 负责管理 Service 组件，它会调用 Service 的 start 方法。\n 5. Service 负责管理 Connector 和顶层容器 Engine，它会调用 Connector 和 Engine 的 start 方法。\n\n# 4.1.1. Catalina 组件\n\nCatalina 的职责就是解析 server.xml 配置，并据此实例化 Server。接下来，调用 Server 组件的 init 方法和 start 方法，将 Tomcat 启动起来。\n\nCatalina 还需要处理各种“异常”情况，比如当我们通过“Ctrl + C”关闭 Tomcat 时，Tomcat 将如何优雅的停止并且清理资源呢？因此 Catalina 在 JVM 中注册一个“关闭钩子”。\n\npublic void start() {\n    //1. 如果持有的 Server 实例为空，就解析 server.xml 创建出来\n    if (getServer() == null) {\n        load();\n    }\n\n    //2. 如果创建失败，报错退出\n    if (getServer() == null) {\n        log.fatal(sm.getString("catalina.noServer"));\n        return;\n    }\n\n    //3. 启动 Server\n    try {\n        getServer().start();\n    } catch (LifecycleException e) {\n        return;\n    }\n\n    // 创建并注册关闭钩子\n    if (useShutdownHook) {\n        if (shutdownHook == null) {\n            shutdownHook = new CatalinaShutdownHook();\n        }\n        Runtime.getRuntime().addShutdownHook(shutdownHook);\n    }\n\n    // 用 await 方法监听停止请求\n    if (await) {\n        await();\n        stop();\n    }\n}\n\n\n为什么需要关闭钩子？\n\n如果我们需要在 JVM 关闭时做一些清理工作，比如将缓存数据刷到磁盘上，或者清理一些临时文件，可以向 JVM 注册一个“关闭钩子”。“关闭钩子”其实就是一个线程，JVM 在停止之前会尝试执行这个线程的 run 方法。\n\nTomcat 的“关闭钩子”—— CatalinaShutdownHook 做了些什么呢？\n\nprotected class CatalinaShutdownHook extends Thread {\n\n    @Override\n    public void run() {\n        try {\n            if (getServer() != null) {\n                Catalina.this.stop();\n            }\n        } catch (Throwable ex) {\n           ...\n        }\n    }\n}\n\n\nTomcat 的“关闭钩子”实际上就执行了 Server 的 stop 方法，Server 的 stop 方法会释放和清理所有的资源。\n\n# 4.1.2. Server 组件\n\nServer 组件的具体实现类是 StandardServer，Server 继承了 LifeCycleBase，它的生命周期被统一管理，并且它的子组件是 Service，因此它还需要管理 Service 的生命周期，也就是说在启动时调用 Service 组件的启动方法，在停止时调用它们的停止方法。Server 在内部维护了若干 Service 组件，它是以数组来保存的。\n\n@Override\npublic void addService(Service service) {\n\n    service.setServer(this);\n\n    synchronized (servicesLock) {\n        // 创建一个长度 +1 的新数组\n        Service results[] = new Service[services.length + 1];\n\n        // 将老的数据复制过去\n        System.arraycopy(services, 0, results, 0, services.length);\n        results[services.length] = service;\n        services = results;\n\n        // 启动 Service 组件\n        if (getState().isAvailable()) {\n            try {\n                service.start();\n            } catch (LifecycleException e) {\n                // Ignore\n            }\n        }\n\n        // 触发监听事件\n        support.firePropertyChange("service", null, service);\n    }\n\n}\n\n\nServer 并没有一开始就分配一个很长的数组，而是在添加的过程中动态地扩展数组长度，当添加一个新的 Service 实例时，会创建一个新数组并把原来数组内容复制到新数组，这样做的目的其实是为了节省内存空间。\n\n除此之外，Server 组件还有一个重要的任务是启动一个 Socket 来监听停止端口，这就是为什么你能通过 shutdown 命令来关闭 Tomcat。不知道你留意到没有，上面 Caralina 的启动方法的最后一行代码就是调用了 Server 的 await 方法。\n\n在 await 方法里会创建一个 Socket 监听 8005 端口，并在一个死循环里接收 Socket 上的连接请求，如果有新的连接到来就建立连接，然后从 Socket 中读取数据；如果读到的数据是停止命令“SHUTDOWN”，就退出循环，进入 stop 流程。\n\n# 4.1.3. Service 组件\n\nService 组件的具体实现类是 StandardService。\n\n【源码】StandardService 源码定义\n\npublic class StandardService extends LifecycleBase implements Service {\n    // 名字\n    private String name = null;\n\n    //Server 实例\n    private Server server = null;\n\n    // 连接器数组\n    protected Connector connectors[] = new Connector[0];\n    private final Object connectorsLock = new Object();\n\n    // 对应的 Engine 容器\n    private Engine engine = null;\n\n    // 映射器及其监听器\n    protected final Mapper mapper = new Mapper();\n    protected final MapperListener mapperListener = new MapperListener(this);\n\n\t// ...\n}\n\n\nStandardService 继承了 LifecycleBase 抽象类。\n\nStandardService 维护了一个 MapperListener 用于支持 Tomcat 热部署。当 Web 应用的部署发生变化时，Mapper 中的映射信息也要跟着变化，MapperListener 就是一个监听器，它监听容器的变化，并把信息更新到 Mapper 中，这是典型的观察者模式。\n\n作为“管理”角色的组件，最重要的是维护其他组件的生命周期。此外在启动各种组件时，要注意它们的依赖关系，也就是说，要注意启动的顺序。\n\nprotected void startInternal() throws LifecycleException {\n\n    //1. 触发启动监听器\n    setState(LifecycleState.STARTING);\n\n    //2. 先启动 Engine，Engine 会启动它子容器\n    if (engine != null) {\n        synchronized (engine) {\n            engine.start();\n        }\n    }\n\n    //3. 再启动 Mapper 监听器\n    mapperListener.start();\n\n    //4. 最后启动连接器，连接器会启动它子组件，比如 Endpoint\n    synchronized (connectorsLock) {\n        for (Connector connector: connectors) {\n            if (connector.getState() != LifecycleState.FAILED) {\n                connector.start();\n            }\n        }\n    }\n}\n\n\n从启动方法可以看到，Service 先启动了 Engine 组件，再启动 Mapper 监听器，最后才是启动连接器。这很好理解，因为内层组件启动好了才能对外提供服务，才能启动外层的连接器组件。而 Mapper 也依赖容器组件，容器组件启动好了才能监听它们的变化，因此 Mapper 和 MapperListener 在容器组件之后启动。组件停止的顺序跟启动顺序正好相反的，也是基于它们的依赖关系。\n\n# 4.1.4. Engine 组件\n\nEngine 本质是一个容器，因此它继承了 ContainerBase 基类，并且实现了 Engine 接口。\n\n\n# 4.2. Web 应用的部署方式\n\n注：catalina.home：安装目录;catalina.base：工作目录;默认值 user.dir\n\n * Server.xml 配置 Host 元素，指定 appBase 属性，默认$catalina.base/webapps/\n * Server.xml 配置 Context 元素，指定 docBase，元素，指定 web 应用的路径\n * 自定义配置：在$catalina.base/EngineName/HostName/XXX.xml 配置 Context 元素\n\nHostConfig 监听了 StandardHost 容器的事件，在 start 方法中解析上述配置文件：\n\n * 扫描 appbase 路径下的所有文件夹和 war 包，解析各个应用的 META-INF/context.xml，并 创建 StandardContext，并将 Context 加入到 Host 的子容器中。\n * 解析$catalina.base/EngineName/HostName/下的所有 Context 配置，找到相应 web 应 用的位置，解析各个应用的 META-INF/context.xml，并创建 StandardContext，并将 Context 加入到 Host 的子容器中。\n\n注：\n\n * HostConfig 并没有实际解析 Context.xml，而是在 ContextConfig 中进行的。\n * HostConfig 中会定期检查 watched 资源文件(context.xml 配置文件)\n\nContextConfig 解析 context.xml 顺序：\n\n * 先解析全局的配置 config/context.xml\n * 然后解析 Host 的默认配置 EngineName/HostName/context.xml.default\n * 最后解析应用的 META-INF/context.xml\n\nContextConfig 解析 web.xml 顺序：\n\n * 先解析全局的配置 config/web.xml\n * 然后解析 Host 的默认配置 EngineName/HostName/web.xml.default 接着解析应用的 MEB-INF/web.xml\n * 扫描应用 WEB-INF/lib/下的 jar 文件，解析其中的 META-INF/web-fragment.xml 最后合并 xml 封装成 WebXml，并设置 Context\n\n注：\n\n * 扫描 web 应用和 jar 中的注解(Filter、Listener、Servlet)就是上述步骤中进行的。\n * 容器的定期执行：backgroundProcess，由 ContainerBase 来实现的，并且只有在顶层容器 中才会开启线程。(backgroundProcessorDelay=10 标志位来控制)\n\n\n# 4.3. LifeCycle\n\n\n\n# 4.3.1. 请求处理过程\n\n\n 1. 根据 server.xml 配置的指定的 connector 以及端口监听 http、或者 ajp 请求\n 2. 请求到来时建立连接,解析请求参数,创建 Request 和 Response 对象,调用顶层容器 pipeline 的 invoke 方法\n 3. 容器之间层层调用,最终调用业务 servlet 的 service 方法\n 4. Connector 将 response 流中的数据写到 socket 中\n\n\n# 4.4. Connector 流程\n\n\n\n# 4.4.1. 阻塞 IO\n\n\n\n# 4.4.2. 非阻塞 IO\n\n\n\n# 4.4.3. IO 多路复用\n\n\n\n阻塞与非阻塞的区别在于进行读操作和写操作的系统调用时，如果此时内核态没有数据可读或者没有缓冲空间可写时，是否阻塞。\n\nIO 多路复用的好处在于可同时监听多个 socket 的可读和可写事件，这样就能使得应用可以同时监听多个 socket，释放了应用线程资源。\n\n# 4.4.4. Tomcat 各类 Connector 对比\n\n\n * JIO：用 java.io 编写的 TCP 模块，阻塞 IO\n * NIO：用 java.nio 编写的 TCP 模块，非阻塞 IO，（IO 多路复用）\n * APR：全称 Apache Portable Runtime，使用 JNI 的方式来进行读取文件以及进行网络传输\n\nApache Portable Runtime 是一个高度可移植的库，它是 Apache HTTP Server 2.x 的核心。 APR 具有许多用途，包括访问高级 IO 功能（如 sendfile，epoll 和 OpenSSL），操作系统级功能（随机数生成，系统状态等）和本地进程处理（共享内存，NT 管道和 Unix 套接字）。\n\n表格中字段含义说明：\n\n * Support Polling - 是否支持基于 IO 多路复用的 socket 事件轮询\n * Polling Size - 轮询的最大连接数\n * Wait for next Request - 在等待下一个请求时，处理线程是否释放，BIO 是没有释放的，所以在 keep-alive=true 的情况下处理的并发连接数有限\n * Read Request Headers - 由于 request header 数据较少，可以由容器提前解析完毕，不需要阻塞\n * Read Request Body - 读取 request body 的数据是应用业务逻辑的事情，同时 Servlet 的限制，是需要阻塞读取的\n * Write Response - 跟读取 request body 的逻辑类似，同样需要阻塞写\n\nNIO 处理相关类\n\n\n\nPoller 线程从 EventQueue 获取 PollerEvent，并执行 PollerEvent 的 run 方法，调用 Selector 的 select 方法，如果有可读的 Socket 则创建 Http11NioProcessor，放入到线程池中执行；\n\nCoyoteAdapter 是 Connector 到 Container 的适配器，Http11NioProcessor 调用其提供的 service 方法，内部创建 Request 和 Response 对象，并调用最顶层容器的 Pipeline 中的第一个 Valve 的 invoke 方法\n\nMapper 主要处理 http url 到 servlet 的映射规则的解析，对外提供 map 方法\n\n\n# 4.5. Comet\n\nComet 是一种用于 web 的推送技术，能使服务器实时地将更新的信息传送到客户端，而无须客户端发出请求 在 WebSocket 出来之前，如果不适用 comet，只能通过浏览器端轮询 Server 来模拟实现服务器端推送。 Comet 支持 servlet 异步处理 IO，当连接上数据可读时触发事件，并异步写数据(阻塞)\n\nTomcat 要实现 Comet，只需继承 HttpServlet 同时，实现 CometProcessor 接口\n\n * Begin：新的请求连接接入调用，可进行与 Request 和 Response 相关的对象初始化操作，并保存 response 对象，用于后续写入数据\n * Read：请求连接有数据可读时调用\n * End：当数据可用时，如果读取到文件结束或者 response 被关闭时则被调用\n * Error：在连接上发生异常时调用，数据读取异常、连接断开、处理异常、socket 超时\n\nNote：\n\n * Read：在 post 请求有数据，但在 begin 事件中没有处理，则会调用 read，如果 read 没有读取数据，在会触发 Error 回调，关闭 socket\n * End：当 socket 超时，并且 response 被关闭时也会调用；server 被关闭时调用\n * Error：除了 socket 超时不会关闭 socket，其他都会关闭 socket\n * End 和 Error 时间触发时应关闭当前 comet 会话，即调用 CometEvent 的 close 方法 Note：在事件触发时要做好线程安全的操作\n\n\n# 4.6. 异步 Servlet\n\n\n\n传统流程：\n\n * 首先，Servlet 接收到请求之后，request 数据解析；\n * 接着，调用业务接口的某些方法，以完成业务处理；\n * 最后，根据处理的结果提交响应，Servlet 线程结束\n\n\n\n异步处理流程：\n\n * 客户端发送一个请求\n * Servlet 容器分配一个线程来处理容器中的一个 servlet\n * servlet 调用 request.startAsync()，保存 AsyncContext, 然后返回\n * 任何方式存在的容器线程都将退出，但是 response 仍然保持开放\n * 业务线程使用保存的 AsyncContext 来完成响应（线程池）\n * 客户端收到响应\n\nServlet 线程将请求转交给一个异步线程来执行业务处理，线程本身返回至容器，此时 Servlet 还没有生成响应数据，异步线程处理完业务以后，可以直接生成响应数据（异步线程拥有 ServletRequest 和 ServletResponse 对象的引用）\n\n为什么 web 应用中支持异步？\n\n推出异步，主要是针对那些比较耗时的请求：比如一次缓慢的数据库查询，一次外部 REST API 调用, 或者是其他一些 I/O 密集型操作。这种耗时的请求会很快的耗光 Servlet 容器的线程池，继而影响可扩展性。\n\nNote：从客户端的角度来看，request 仍然像任何其他的 HTTP 的 request-response 交互一样，只是耗费了更长的时间而已\n\n异步事件监听\n\n * onStartAsync：Request 调用 startAsync 方法时触发\n * onComplete：syncContext 调用 complete 方法时触发\n * onError：处理请求的过程出现异常时触发\n * onTimeout：socket 超时触发\n\nNote : onError/ onTimeout 触发后，会紧接着回调 onComplete onComplete 执行后，就不可再操作 request 和 response\n\n\n# 5. 参考资料\n\n * 官方\n   \n   * Tomcat 官方网站\n   * Tomcat Wiki\n   * Tomee 官方网站\n\n * 文章\n   \n   * Creating a Web App with Bootstrap and Tomcat Embedded\n   * Tomcat 组成与工作原理\n   * Tomcat 工作原理\n   * Tomcat 设计模式分析',normalizedContent:'# tomcat 快速入门\n\n> 🎁 版本说明\n> \n> 当前最新版本：tomcat 8.5.24\n> \n> 环境要求：jdk7+\n\n\n# 1. tomcat 简介\n\n\n# 1.1. tomcat 是什么\n\ntomcat 是由 apache 开发的一个 servlet 容器，实现了对 servlet 和 jsp 的支持，并提供了作为 web 服务器的一些特有功能，如 tomcat 管理和控制平台、安全域管理和 tomcat 阀等。\n\n由于 tomcat 本身也内含了一个 http 服务器，它也可以被视作一个单独的 web 服务器。但是，不能将 tomcat 和 apache http 服务器混淆，apache http 服务器是一个用 c 语言实现的 http web 服务器；这两个 http web server 不是捆绑在一起的。tomcat 包含了一个配置管理工具，也可以通过编辑 xml 格式的配置文件来进行配置。\n\n\n# 1.2. tomcat 重要目录\n\n * /bin - tomcat 脚本存放目录（如启动、关闭脚本）。 *.sh 文件用于 unix 系统； *.bat 文件用于 windows 系统。\n * /conf - tomcat 配置文件目录。\n * /logs - tomcat 默认日志目录。\n * /webapps - webapp 运行的目录。\n\n\n# 1.3. web 工程发布目录结构\n\n一般 web 项目路径结构\n\n|-- webapp                         # 站点根目录\n    |-- meta-inf                   # meta-inf 目录\n    |   `-- manifest.mf            # 配置清单文件\n    |-- web-inf                    # web-inf 目录\n    |   |-- classes                # class文件目录\n    |   |   |-- *.class            # 程序需要的 class 文件\n    |   |   `-- *.xml              # 程序需要的 xml 文件\n    |   |-- lib                    # 库文件夹\n    |   |   `-- *.jar              # 程序需要的 jar 包\n    |   `-- web.xml                # web应用程序的部署描述文件\n    |-- <userdir>                  # 自定义的目录\n    |-- <userfiles>                # 自定义的资源文件\n\n\n * webapp：工程发布文件夹。其实每个 war 包都可以视为 webapp 的压缩包。\n\n * meta-inf：meta-inf 目录用于存放工程自身相关的一些信息，元文件信息，通常由开发工具，环境自动生成。\n\n * web-inf：java web 应用的安全目录。所谓安全就是客户端无法访问，只有服务端可以访问的目录。\n\n * /web-inf/classes：存放程序所需要的所有 java class 文件。\n\n * /web-inf/lib：存放程序所需要的所有 jar 文件。\n\n * /web-inf/web.xml：web 应用的部署配置文件。它是工程中最重要的配置文件，它描述了 servlet 和组成应用的其它组件，以及应用初始化参数、安全管理约束等。\n\n\n# 1.4. tomcat 功能\n\ntomcat 支持的 i/o 模型有：\n\n * nio：非阻塞 i/o，采用 java nio 类库实现。\n * nio2：异步 i/o，采用 jdk 7 最新的 nio2 类库实现。\n * apr：采用 apache 可移植运行库实现，是 c/c++ 编写的本地库。\n\ntomcat 支持的应用层协议有：\n\n * http/1.1：这是大部分 web 应用采用的访问协议。\n * ajp：用于和 web 服务器集成（如 apache）。\n * http/2：http 2.0 大幅度的提升了 web 性能。\n\n\n# 2. tomcat 入门\n\n\n# 2.1. 安装\n\n前提条件\n\ntomcat 8.5 要求 jdk 版本为 1.7 以上。\n\n进入 tomcat 官方下载地址 选择合适版本下载，并解压到本地。\n\nwindows\n\n添加环境变量 catalina_home ，值为 tomcat 的安装路径。\n\n进入安装目录下的 bin 目录，运行 startup.bat 文件，启动 tomcat\n\nlinux / unix\n\n下面的示例以 8.5.24 版本为例，包含了下载、解压、启动操作。\n\n# 下载解压到本地\nwget http://mirrors.hust.edu.cn/apache/tomcat/tomcat-8/v8.5.24/bin/apache-tomcat-8.5.24.tar.gz\ntar -zxf apache-tomcat-8.5.24.tar.gz\n# 启动 tomcat\n./apache-tomcat-8.5.24/bin/startup.sh\n\n\n启动后，访问 http://localhost:8080 ，可以看到 tomcat 安装成功的测试页面。\n\n\n\n\n# 2.2. 配置\n\n本节将列举一些重要、常见的配置项。详细的 tomcat8 配置可以参考 tomcat 8 配置官方参考文档 。\n\n# 2.2.1. server\n\n> server 元素表示整个 catalina servlet 容器。\n> \n> 因此，它必须是 conf/server.xml 配置文件中的根元素。它的属性代表了整个 servlet 容器的特性。\n\n属性表\n\n属性          描述                                               备注\nclassname   这个类必须实现 org.apache.catalina.server 接口。           默认 org.apache.catalina.core.standardserver\naddress     服务器等待关机命令的 tcp / ip 地址。如果没有指定地址，则使用 localhost。   \nport        服务器等待关机命令的 tcp / ip 端口号。设置为-1 以禁用关闭端口。           \nshutdown    必须通过 tcp / ip 连接接收到指定端口号的命令字符串，以关闭 tomcat。       \n\n# 2.2.2. service\n\n> service 元素表示一个或多个连接器组件的组合，这些组件共享一个用于处理传入请求的引擎组件。server 中可以有多个 service。\n\n属性表\n\n属性          描述                                      备注\nclassname   这个类必须实现org.apache.catalina.service接口。   默认 org.apache.catalina.core.standardservice\nname        此服务的显示名称，如果您使用标准 catalina               \n            组件，将包含在日志消息中。与特定服务器关联的每个服务的名称必须是唯一的。\n\n实例 - conf/server.xml 配置文件示例\n\n<?xml version="1.0" encoding="utf-8"?>\n<server port="8080" shutdown="shutdown">\n  <service name="xxx">\n  ...\n  </service>\n</server>\n\n\n# 2.2.3. executor\n\n> executor 表示可以在 tomcat 中的组件之间共享的线程池。\n\n属性表\n\n属性                描述                                          备注\nclassname         这个类必须实现org.apache.catalina.executor接口。      默认 org.apache.catalina.core.standardthreadexecutor\nname              线程池名称。                                      要求唯一, 供 connector 元素的 executor 属性使用\nnameprefix        线程名称前缀。                                     \nmaxthreads        最大活跃线程数。                                    默认 200\nminsparethreads   最小活跃线程数。                                    默认 25\nmaxidletime       当前活跃线程大于 minsparethreads 时,空闲线程关闭的等待最大时间。   默认 60000ms\nmaxqueuesize      线程池满情况下的请求排队大小。                             默认 integer.max_value\n\n<service name="xxx">\n  <executor name="tomcatthreadpool" nameprefix="catalina-exec-" maxthreads="300" minsparethreads="25"/>\n</service>\n\n\n# 2.2.4. connector\n\n> connector 代表连接组件。tomcat 支持三种协议：http/1.1、http/2.0、ajp。\n\n属性表\n\n属性                      说明                                                             备注\nasynctimeout            servlet3.0 规范中的异步请求超时                                          默认 30s\nport                    请求连接的 tcp port                                                 设置为 0,则会随机选取一个未占用的端口号\nprotocol                协议. 一般情况下设置为 http/1.1,这种情况下连接模型会在 nio 和 apr/native 中自动根据配置选择   \nuriencoding             对 uri 的编码方式.                                                   如果设置系统变量 org.apache.catalina.strict_servlet_compliance 为\n                                                                                       true,使用 iso-8859-1 编码;如果未设置此系统变量且未设置此属性, 使用 utf-8 编码\nusebodyencodingforuri   是否采用指定的 contenttype 而不是 uriencoding 来编码 uri 中的请求参数             \n\n以下属性在标准的 connector(nio, nio2 和 apr/native)中有效:\n\n属性                  说明                                                  备注\nacceptcount         当最大请求连接 maxconnections 满时的最大排队大小                    默认 100,注意此属性和 executor 中属性 maxqueuesize\n                                                                        的区别.这个指的是请求连接满时的堆栈大小,executor 的 maxqueuesize 指的是处理线程满时的堆栈大小\nconnectiontimeout   请求连接超时                                              默认 60000ms\nexecutor            指定配置的线程池名称                                          \nkeepalivetimeout    keealive 超时时间                                       默认值为 connectiontimeout 配置值.-1 表示不超时\nmaxconnections      最大连接数                                               连接满时后续连接放入最大为 acceptcount 的队列中. 对 nio 和 nio2 连接,默认值为 10000;对\n                                                                        apr/native,默认值为 8192\nmaxthreads          如果指定了 executor, 此属性忽略;否则为 connector 创建的内部线程池最大值     默认 200\nminsparethreads     如果指定了 executor, 此属性忽略;否则为 connector 创建线程池的最小活跃线程数   默认 10\nprocessorcache      协议处理器缓存 processor 对象的大小                             -1 表示不限制.当不使用 servlet3.0 的异步处理情况下: 如果配置 executor,配置为\n                                                                        executor 的 maxthreads;否则配置为 connnector 的 maxthreads. 如果使用\n                                                                        serlvet3.0 异步处理, 取 maxthreads 和 maxconnections 的最大值\n\n# 2.2.5. context\n\n> context 元素表示一个 web 应用程序，它在特定的虚拟主机中运行。每个 web 应用程序都基于 web 应用程序存档（war）文件，或者包含相应的解包内容的相应目录，如 servlet 规范中所述。\n\n属性表\n\n属性                           说明                                                          备注\naltddname                    web.xml 部署描述符路径                                             默认 /web-inf/web.xml\ndocbase                      context 的 root 路径                                           和 host 的 appbase 相结合, 可确定 web 应用的实际目录\nfailctxifservletstartfails   同 host 中的 failctxifservletstartfails, 只对当前 context 有效       默认为 false\nlogeffectivewebxml           是否日志打印 web.xml 内容(web.xml 由默认的 web.xml 和应用中的 web.xml 组成)    默认为 false\npath                         web 应用的 context path                                        如果为根路径,则配置为空字符串(""), 不能不配置\nprivileged                   是否使用 tomcat 提供的 manager servlet                             \nreloadable                   /web-inf/classes/ 和/web-inf/lib/ 目录中 class 文件发生变化是否自动重新加载   默认为 false\nswallowoutput                true 情况下, system.out 和 system.err 输出将被定向到 web 应用日志中         默认为 false\n\n# 2.2.6. engine\n\n> engine 元素表示与特定的 catalina 服务相关联的整个请求处理机器。它接收并处理来自一个或多个连接器的所有请求，并将完成的响应返回给连接器，以便最终传输回客户端。\n\n属性表\n\n属性            描述                                           备注\ndefaulthost   默认主机名，用于标识将处理指向此服务器上主机名称但未在此配置文件中配置的请求的主机。   这个名字必须匹配其中一个嵌套的主机元素的名字属性。\nname          此引擎的逻辑名称，用于日志和错误消息。                          在同一服务器中使用多个服务元素时，每个引擎必须分配一个唯一的名称。\n\n# 2.2.7. host\n\n> host 元素表示一个虚拟主机，它是一个服务器的网络名称（如“www.mycompany.com”）与运行 tomcat 的特定服务器的关联。\n\n属性表\n\n属性                           说明                                                         备注\nname                         名称                                                         用于日志输出\nappbase                      虚拟主机对应的应用基础路径                                              可以是个绝对路径, 或${catalina_base}相对路径\nxmlbase                      虚拟主机 xml 基础路径,里面应该有 context xml 配置文件                       可以是个绝对路径, 或${catalina_base}相对路径\ncreatedirs                   当 appbase 和 xmlbase 不存在时,是否创建目录                            默认为 true\nautodeploy                   是否周期性的检查 appbase 和 xmlbase 并 deploy web 应用和 context 描述符    默认为 true\ndeployignore                 忽略 deploy 的正则                                              \ndeployonstartup              tomcat 启动时是否自动 deploy                                      默认为 true\nfailctxifservletstartfails   配置为 true 情况下,任何 load-on-startup >=0 的 servlet 启动失败,则其对应的   默认为 false\n                             contxt 也启动失败\n\n# 2.2.8. cluster\n\n由于在实际开发中，我从未用过 tomcat 集群配置，所以没研究。\n\n\n# 2.3. 启动\n\n# 2.3.1. 部署方式\n\n这种方式要求本地必须安装 tomcat 。\n\n将打包好的 war 包放在 tomcat 安装目录下的 webapps 目录下，然后在 bin 目录下执行 startup.bat 或 startup.sh ，tomcat 会自动解压 webapps 目录下的 war 包。\n\n成功后，可以访问 http://localhost:8080/xxx （xxx 是 war 包文件名）。\n\n> 注意\n> \n> 以上步骤是最简单的示例。步骤中的 war 包解压路径、启动端口以及一些更多的功能都可以修改配置文件来定制 （主要是 server.xml 或 context.xml 文件）。\n\n# 2.3.2. 嵌入式\n\n# 2.3.2.1. api 方式\n\n在 pom.xml 中添加依赖\n\n<dependency>\n  <groupid>org.apache.tomcat.embed</groupid>\n  <artifactid>tomcat-embed-core</artifactid>\n  <version>8.5.24</version>\n</dependency>\n\n\n添加 simpleembedtomcatserver.java 文件，内容如下：\n\nimport java.util.optional;\nimport org.apache.catalina.startup.tomcat;\n\npublic class simpletomcatserver {\n    private static final int port = 8080;\n    private static final string context_path = "/javatool-server";\n\n    public static void main(string[] args) throws exception {\n        // 设定 profile\n        optional<string> profile = optional.ofnullable(system.getproperty("spring.profiles.active"));\n        system.setproperty("spring.profiles.active", profile.orelse("develop"));\n\n        tomcat tomcat = new tomcat();\n        tomcat.setport(port);\n        tomcat.gethost().setappbase(".");\n        tomcat.addwebapp(context_path, getabsolutepath() + "src/main/webapp");\n        tomcat.start();\n        tomcat.getserver().await();\n    }\n\n    private static string getabsolutepath() {\n        string path = null;\n        string folderpath = simpleembedtomcatserver.class.getprotectiondomain().getcodesource().getlocation().getpath()\n                .substring(1);\n        if (folderpath.indexof("target") > 0) {\n            path = folderpath.substring(0, folderpath.indexof("target"));\n        }\n        return path;\n    }\n}\n\n\n成功后，可以访问 http://localhost:8080/javatool-server 。\n\n> 说明\n> \n> 本示例是使用 org.apache.tomcat.embed 启动嵌入式 tomcat 的最简示例。\n> \n> 这个示例中使用的是 tomcat 默认的配置，但通常，我们需要对 tomcat 配置进行一些定制和调优。为了加载配置文件，启动类就要稍微再复杂一些。这里不想再贴代码，有兴趣的同学可以参考：\n> \n> 示例项目\n\n# 2.3.2.2. 使用 maven 插件启动（不推荐）\n\n不推荐理由：这种方式启动 maven 虽然最简单，但是有一个很大的问题是，真的很久很久没发布新版本了（最新版本发布时间：2013-11-11）。且貌似只能找到 tomcat6 、tomcat7 插件。\n\n使用方法\n\n在 pom.xml 中引入插件\n\n<plugin>\n  <groupid>org.apache.tomcat.maven</groupid>\n  <artifactid>tomcat7-maven-plugin</artifactid>\n  <version>2.2</version>\n  <configuration>\n    <port>8080</port>\n    <path>/${project.artifactid}</path>\n    <uriencoding>utf-8</uriencoding>\n  </configuration>\n</plugin>\n\n\n运行 mvn tomcat7:run 命令，启动 tomcat。\n\n成功后，可以访问 http://localhost:8080/xxx （xxx 是 ${project.artifactid} 指定的项目名）。\n\n# 2.3.3. ide 插件\n\n常见 java ide 一般都有对 tomcat 的支持。\n\n以 intellij idea 为例，提供了 tomcat and tomee integration 插件（一般默认会安装）。\n\n使用步骤\n\n * 点击 run/debug configurations > new tomcat server > local ，打开 tomcat 配置页面。\n * 点击 confiure... 按钮，设置 tomcat 安装路径。\n * 点击 deployment 标签页，设置要启动的应用。\n * 设置启动应用的端口、jvm 参数、启动浏览器等。\n * 成功后，可以访问 http://localhost:8080/（当然，你也可以在 url 中设置上下文名称）。\n\n\n\n> 说明\n> \n> 个人认为这个插件不如 eclipse 的 tomcat 插件好用，eclipse 的 tomcat 插件支持对 tomcat xml 配置文件进行配置。而这里，你只能自己去 tomcat 安装路径下修改配置文件。\n\n文中的嵌入式启动示例可以参考我的示例项目\n\n\n# 3. tomcat 架构\n\n\n\ntomcat 要实现 2 个核心功能：\n\n * 处理 socket 连接，负责网络字节流与 request 和 response 对象的转化。\n * 加载和管理 servlet，以及处理具体的 request 请求。\n\n为此，tomcat 设计了两个核心组件：\n\n * 连接器（connector）：负责和外部通信\n * 容器（container）：负责内部处理\n\n\n# 3.1. service\n\ntomcat 支持的 i/o 模型有：\n\n * nio：非阻塞 i/o，采用 java nio 类库实现。\n * nio2：异步 i/o，采用 jdk 7 最新的 nio2 类库实现。\n * apr：采用 apache 可移植运行库实现，是 c/c++ 编写的本地库。\n\ntomcat 支持的应用层协议有：\n\n * http/1.1：这是大部分 web 应用采用的访问协议。\n * ajp：用于和 web 服务器集成（如 apache）。\n * http/2：http 2.0 大幅度的提升了 web 性能。\n\ntomcat 支持多种 i/o 模型和应用层协议。为了实现这点，一个容器可能对接多个连接器。但是，单独的连接器或容器都不能对外提供服务，需要把它们组装起来才能工作，组装后这个整体叫作 service 组件。tomcat 内可能有多个 service，通过在 tomcat 中配置多个 service，可以实现通过不同的端口号来访问同一台机器上部署的不同应用。\n\n\n\n一个 tomcat 实例有一个或多个 service；一个 service 有多个 connector 和 container。connector 和 container 之间通过标准的 servletrequest 和 servletresponse 通信。\n\n\n# 3.2. 连接器\n\n连接器对 servlet 容器屏蔽了协议及 i/o 模型等的区别，无论是 http 还是 ajp，在容器中获取到的都是一个标准的 servletrequest 对象。\n\n连接器的主要功能是：\n\n * 网络通信\n * 应用层协议解析\n * tomcat request/response 与 servletrequest/servletresponse 的转化\n\ntomcat 设计了 3 个组件来实现这 3 个功能，分别是 endpoint、processor 和 adapter。\n\n\n\n组件间通过抽象接口交互。这样做还有一个好处是**封装变化。**这是面向对象设计的精髓，将系统中经常变化的部分和稳定的部分隔离，有助于增加复用性，并降低系统耦合度。网络通信的 i/o 模型是变化的，可能是非阻塞 i/o、异步 i/o 或者 apr。应用层协议也是变化的，可能是 http、https、ajp。浏览器端发送的请求信息也是变化的。但是整体的处理逻辑是不变的，endpoint 负责提供字节流给 processor，processor 负责提供 tomcat request 对象给 adapter，adapter 负责提供 servletrequest 对象给容器。\n\n如果要支持新的 i/o 方案、新的应用层协议，只需要实现相关的具体子类，上层通用的处理逻辑是不变的。由于 i/o 模型和应用层协议可以自由组合，比如 nio + http 或者 nio2 + ajp。tomcat 的设计者将网络通信和应用层协议解析放在一起考虑，设计了一个叫 protocolhandler 的接口来封装这两种变化点。各种协议和通信模型的组合有相应的具体实现类。比如：http11nioprotocol 和 ajpnioprotocol。\n\n\n\n# 3.2.1. protocolhandler 组件\n\n连接器用 protocolhandler 接口来封装通信协议和 i/o 模型的差异。protocolhandler 内部又分为 endpoint 和 processor 模块，endpoint 负责底层 socket 通信，proccesor 负责应用层协议解析。\n\n# 3.2.1.1. endpoint\n\nendpoint 是通信端点，即通信监听的接口，是具体的 socket 接收和发送处理器，是对传输层的抽象，因此 endpoint 是用来实现 tcp/ip 协议的。\n\nendpoint 是一个接口，对应的抽象实现类是 abstractendpoint，而 abstractendpoint 的具体子类，比如在 nioendpoint 和 nio2endpoint 中，有两个重要的子组件：acceptor 和 socketprocessor。\n\n其中 acceptor 用于监听 socket 连接请求。socketprocessor 用于处理接收到的 socket 请求，它实现 runnable 接口，在 run 方法里调用协议处理组件 processor 进行处理。为了提高处理能力，socketprocessor 被提交到线程池来执行。而这个线程池叫作执行器（executor)。\n\n# 3.2.1.2. processor\n\n如果说 endpoint 是用来实现 tcp/ip 协议的，那么 processor 用来实现 http 协议，processor 接收来自 endpoint 的 socket，读取字节流解析成 tomcat request 和 response 对象，并通过 adapter 将其提交到容器处理，processor 是对应用层协议的抽象。\n\nprocessor 是一个接口，定义了请求的处理等方法。它的抽象实现类 abstractprocessor 对一些协议共有的属性进行封装，没有对方法进行实现。具体的实现有 ajpprocessor、http11processor 等，这些具体实现类实现了特定协议的解析方法和请求处理方式。\n\n\n\n从图中我们看到，endpoint 接收到 socket 连接后，生成一个 socketprocessor 任务提交到线程池去处理，socketprocessor 的 run 方法会调用 processor 组件去解析应用层协议，processor 通过解析生成 request 对象后，会调用 adapter 的 service 方法。\n\n# 3.2.2. adapter\n\n连接器通过适配器 adapter 调用容器。\n\n由于协议不同，客户端发过来的请求信息也不尽相同，tomcat 定义了自己的 request 类来适配这些请求信息。\n\nprotocolhandler 接口负责解析请求并生成 tomcat request 类。但是这个 request 对象不是标准的 servletrequest，也就意味着，不能用 tomcat request 作为参数来调用容器。tomcat 的解决方案是引入 coyoteadapter，这是适配器模式的经典运用，连接器调用 coyoteadapter 的 sevice 方法，传入的是 tomcat request 对象，coyoteadapter 负责将 tomcat request 转成 servletrequest，再调用容器的 service 方法。\n\n\n# 3.3. 容器\n\ntomcat 设计了 4 种容器，分别是 engine、host、context 和 wrapper。\n\n * engine - servlet 的顶层容器，包含一 个或多个 host 子容器；\n * host - 虚拟主机，负责 web 应用的部署和 context 的创建；\n * context - web 应用上下文，包含多个 wrapper，负责 web 配置的解析、管理所有的 web 资源；\n * wrapper - 最底层的容器，是对 servlet 的封装，负责 servlet 实例的创 建、执行和销毁。\n\n# 3.3.1. 请求分发 servlet 过程\n\ntomcat 是怎么确定请求是由哪个 wrapper 容器里的 servlet 来处理的呢？答案是，tomcat 是用 mapper 组件来完成这个任务的。\n\n举例来说，假如有一个网购系统，有面向网站管理人员的后台管理系统，还有面向终端客户的在线购物系统。这两个系统跑在同一个 tomcat 上，为了隔离它们的访问域名，配置了两个虚拟域名：manage.shopping.com和user.shopping.com，网站管理人员通过manage.shopping.com域名访问 tomcat 去管理用户和商品，而用户管理和商品管理是两个单独的 web 应用。终端客户通过user.shopping.com域名去搜索商品和下订单，搜索功能和订单管理也是两个独立的 web 应用。如下所示，演示了 url 应声 servlet 的处理流程。\n\n\n\n假如有用户访问一个 url，比如图中的http://user.shopping.com:8080/order/buy，tomcat 如何将这个 url 定位到一个 servlet 呢？\n\n 1. 首先，根据协议和端口号选定 service 和 engine。\n 2. 然后，根据域名选定 host。\n 3. 之后，根据 url 路径找到 context 组件。\n 4. 最后，根据 url 路径找到 wrapper（servlet）。\n\n这个路由分发过程具体是怎么实现的呢？答案是使用 pipeline-valve 管道。\n\n# 3.3.2. pipeline-value\n\npipeline 可以理解为现实中的管道，valve 为管道中的阀门，request 和 response 对象在管道中经过各个阀门的处理和控制。\n\npipeline-valve 是责任链模式，责任链模式是指在一个请求处理的过程中有很多处理者依次对请求进行处理，每个处理者负责做自己相应的处理，处理完之后将再调用下一个处理者继续处理。valve 表示一个处理点，比如权限认证和记录日志。\n\n先来了解一下 valve 和 pipeline 接口的设计：\n\n\n\n * 每一个容器都有一个 pipeline 对象，只要触发这个 pipeline 的第一个 valve，这个容器里 pipeline 中的 valve 就都会被调用到。但是，不同容器的 pipeline 是怎么链式触发的呢，比如 engine 中 pipeline 需要调用下层容器 host 中的 pipeline。\n * 这是因为 pipeline 中还有个 getbasic 方法。这个 basicvalve 处于 valve 链表的末端，它是 pipeline 中必不可少的一个 valve，负责调用下层容器的 pipeline 里的第一个 valve。\n * pipeline 中有 addvalve 方法。pipeline 中维护了 valve 链表，valve 可以插入到 pipeline 中，对请求做某些处理。我们还发现 pipeline 中没有 invoke 方法，因为整个调用链的触发是 valve 来完成的，valve 完成自己的处理后，调用 getnext.invoke() 来触发下一个 valve 调用。\n * valve 中主要的三个方法：setnext、getnext、invoke。valve 之间的关系是单向链式结构，本身 invoke 方法中会调用下一个 valve 的 invoke 方法。\n * 各层容器对应的 basic valve 分别是 standardenginevalve、standardhostvalve、 standardcontextvalve、standardwrappervalve。\n * 由于 valve 是一个处理点，因此 invoke 方法就是来处理请求的。注意到 valve 中有 getnext 和 setnext 方法，因此我们大概可以猜到有一个链表将 valve 链起来了。\n\n\n\n整个调用过程由连接器中的 adapter 触发的，它会调用 engine 的第一个 valve：\n\nconnector.getservice().getcontainer().getpipeline().getfirst().invoke(request, response);\n\n\n\n# 4. tomcat 生命周期\n\n\n# 4.1. tomcat 的启动过程\n\n\n\n 1. tomcat 是一个 java 程序，它的运行从执行 startup.sh 脚本开始。startup.sh 会启动一个 jvm 来运行 tomcat 的启动类 bootstrap。\n 2. bootstrap 会初始化 tomcat 的类加载器并实例化 catalina。\n 3. catalina 会通过 digester 解析 server.xml，根据其中的配置信息来创建相应组件，并调用 server 的 start 方法。\n 4. server 负责管理 service 组件，它会调用 service 的 start 方法。\n 5. service 负责管理 connector 和顶层容器 engine，它会调用 connector 和 engine 的 start 方法。\n\n# 4.1.1. catalina 组件\n\ncatalina 的职责就是解析 server.xml 配置，并据此实例化 server。接下来，调用 server 组件的 init 方法和 start 方法，将 tomcat 启动起来。\n\ncatalina 还需要处理各种“异常”情况，比如当我们通过“ctrl + c”关闭 tomcat 时，tomcat 将如何优雅的停止并且清理资源呢？因此 catalina 在 jvm 中注册一个“关闭钩子”。\n\npublic void start() {\n    //1. 如果持有的 server 实例为空，就解析 server.xml 创建出来\n    if (getserver() == null) {\n        load();\n    }\n\n    //2. 如果创建失败，报错退出\n    if (getserver() == null) {\n        log.fatal(sm.getstring("catalina.noserver"));\n        return;\n    }\n\n    //3. 启动 server\n    try {\n        getserver().start();\n    } catch (lifecycleexception e) {\n        return;\n    }\n\n    // 创建并注册关闭钩子\n    if (useshutdownhook) {\n        if (shutdownhook == null) {\n            shutdownhook = new catalinashutdownhook();\n        }\n        runtime.getruntime().addshutdownhook(shutdownhook);\n    }\n\n    // 用 await 方法监听停止请求\n    if (await) {\n        await();\n        stop();\n    }\n}\n\n\n为什么需要关闭钩子？\n\n如果我们需要在 jvm 关闭时做一些清理工作，比如将缓存数据刷到磁盘上，或者清理一些临时文件，可以向 jvm 注册一个“关闭钩子”。“关闭钩子”其实就是一个线程，jvm 在停止之前会尝试执行这个线程的 run 方法。\n\ntomcat 的“关闭钩子”—— catalinashutdownhook 做了些什么呢？\n\nprotected class catalinashutdownhook extends thread {\n\n    @override\n    public void run() {\n        try {\n            if (getserver() != null) {\n                catalina.this.stop();\n            }\n        } catch (throwable ex) {\n           ...\n        }\n    }\n}\n\n\ntomcat 的“关闭钩子”实际上就执行了 server 的 stop 方法，server 的 stop 方法会释放和清理所有的资源。\n\n# 4.1.2. server 组件\n\nserver 组件的具体实现类是 standardserver，server 继承了 lifecyclebase，它的生命周期被统一管理，并且它的子组件是 service，因此它还需要管理 service 的生命周期，也就是说在启动时调用 service 组件的启动方法，在停止时调用它们的停止方法。server 在内部维护了若干 service 组件，它是以数组来保存的。\n\n@override\npublic void addservice(service service) {\n\n    service.setserver(this);\n\n    synchronized (serviceslock) {\n        // 创建一个长度 +1 的新数组\n        service results[] = new service[services.length + 1];\n\n        // 将老的数据复制过去\n        system.arraycopy(services, 0, results, 0, services.length);\n        results[services.length] = service;\n        services = results;\n\n        // 启动 service 组件\n        if (getstate().isavailable()) {\n            try {\n                service.start();\n            } catch (lifecycleexception e) {\n                // ignore\n            }\n        }\n\n        // 触发监听事件\n        support.firepropertychange("service", null, service);\n    }\n\n}\n\n\nserver 并没有一开始就分配一个很长的数组，而是在添加的过程中动态地扩展数组长度，当添加一个新的 service 实例时，会创建一个新数组并把原来数组内容复制到新数组，这样做的目的其实是为了节省内存空间。\n\n除此之外，server 组件还有一个重要的任务是启动一个 socket 来监听停止端口，这就是为什么你能通过 shutdown 命令来关闭 tomcat。不知道你留意到没有，上面 caralina 的启动方法的最后一行代码就是调用了 server 的 await 方法。\n\n在 await 方法里会创建一个 socket 监听 8005 端口，并在一个死循环里接收 socket 上的连接请求，如果有新的连接到来就建立连接，然后从 socket 中读取数据；如果读到的数据是停止命令“shutdown”，就退出循环，进入 stop 流程。\n\n# 4.1.3. service 组件\n\nservice 组件的具体实现类是 standardservice。\n\n【源码】standardservice 源码定义\n\npublic class standardservice extends lifecyclebase implements service {\n    // 名字\n    private string name = null;\n\n    //server 实例\n    private server server = null;\n\n    // 连接器数组\n    protected connector connectors[] = new connector[0];\n    private final object connectorslock = new object();\n\n    // 对应的 engine 容器\n    private engine engine = null;\n\n    // 映射器及其监听器\n    protected final mapper mapper = new mapper();\n    protected final mapperlistener mapperlistener = new mapperlistener(this);\n\n\t// ...\n}\n\n\nstandardservice 继承了 lifecyclebase 抽象类。\n\nstandardservice 维护了一个 mapperlistener 用于支持 tomcat 热部署。当 web 应用的部署发生变化时，mapper 中的映射信息也要跟着变化，mapperlistener 就是一个监听器，它监听容器的变化，并把信息更新到 mapper 中，这是典型的观察者模式。\n\n作为“管理”角色的组件，最重要的是维护其他组件的生命周期。此外在启动各种组件时，要注意它们的依赖关系，也就是说，要注意启动的顺序。\n\nprotected void startinternal() throws lifecycleexception {\n\n    //1. 触发启动监听器\n    setstate(lifecyclestate.starting);\n\n    //2. 先启动 engine，engine 会启动它子容器\n    if (engine != null) {\n        synchronized (engine) {\n            engine.start();\n        }\n    }\n\n    //3. 再启动 mapper 监听器\n    mapperlistener.start();\n\n    //4. 最后启动连接器，连接器会启动它子组件，比如 endpoint\n    synchronized (connectorslock) {\n        for (connector connector: connectors) {\n            if (connector.getstate() != lifecyclestate.failed) {\n                connector.start();\n            }\n        }\n    }\n}\n\n\n从启动方法可以看到，service 先启动了 engine 组件，再启动 mapper 监听器，最后才是启动连接器。这很好理解，因为内层组件启动好了才能对外提供服务，才能启动外层的连接器组件。而 mapper 也依赖容器组件，容器组件启动好了才能监听它们的变化，因此 mapper 和 mapperlistener 在容器组件之后启动。组件停止的顺序跟启动顺序正好相反的，也是基于它们的依赖关系。\n\n# 4.1.4. engine 组件\n\nengine 本质是一个容器，因此它继承了 containerbase 基类，并且实现了 engine 接口。\n\n\n# 4.2. web 应用的部署方式\n\n注：catalina.home：安装目录;catalina.base：工作目录;默认值 user.dir\n\n * server.xml 配置 host 元素，指定 appbase 属性，默认$catalina.base/webapps/\n * server.xml 配置 context 元素，指定 docbase，元素，指定 web 应用的路径\n * 自定义配置：在$catalina.base/enginename/hostname/xxx.xml 配置 context 元素\n\nhostconfig 监听了 standardhost 容器的事件，在 start 方法中解析上述配置文件：\n\n * 扫描 appbase 路径下的所有文件夹和 war 包，解析各个应用的 meta-inf/context.xml，并 创建 standardcontext，并将 context 加入到 host 的子容器中。\n * 解析$catalina.base/enginename/hostname/下的所有 context 配置，找到相应 web 应 用的位置，解析各个应用的 meta-inf/context.xml，并创建 standardcontext，并将 context 加入到 host 的子容器中。\n\n注：\n\n * hostconfig 并没有实际解析 context.xml，而是在 contextconfig 中进行的。\n * hostconfig 中会定期检查 watched 资源文件(context.xml 配置文件)\n\ncontextconfig 解析 context.xml 顺序：\n\n * 先解析全局的配置 config/context.xml\n * 然后解析 host 的默认配置 enginename/hostname/context.xml.default\n * 最后解析应用的 meta-inf/context.xml\n\ncontextconfig 解析 web.xml 顺序：\n\n * 先解析全局的配置 config/web.xml\n * 然后解析 host 的默认配置 enginename/hostname/web.xml.default 接着解析应用的 meb-inf/web.xml\n * 扫描应用 web-inf/lib/下的 jar 文件，解析其中的 meta-inf/web-fragment.xml 最后合并 xml 封装成 webxml，并设置 context\n\n注：\n\n * 扫描 web 应用和 jar 中的注解(filter、listener、servlet)就是上述步骤中进行的。\n * 容器的定期执行：backgroundprocess，由 containerbase 来实现的，并且只有在顶层容器 中才会开启线程。(backgroundprocessordelay=10 标志位来控制)\n\n\n# 4.3. lifecycle\n\n\n\n# 4.3.1. 请求处理过程\n\n\n 1. 根据 server.xml 配置的指定的 connector 以及端口监听 http、或者 ajp 请求\n 2. 请求到来时建立连接,解析请求参数,创建 request 和 response 对象,调用顶层容器 pipeline 的 invoke 方法\n 3. 容器之间层层调用,最终调用业务 servlet 的 service 方法\n 4. connector 将 response 流中的数据写到 socket 中\n\n\n# 4.4. connector 流程\n\n\n\n# 4.4.1. 阻塞 io\n\n\n\n# 4.4.2. 非阻塞 io\n\n\n\n# 4.4.3. io 多路复用\n\n\n\n阻塞与非阻塞的区别在于进行读操作和写操作的系统调用时，如果此时内核态没有数据可读或者没有缓冲空间可写时，是否阻塞。\n\nio 多路复用的好处在于可同时监听多个 socket 的可读和可写事件，这样就能使得应用可以同时监听多个 socket，释放了应用线程资源。\n\n# 4.4.4. tomcat 各类 connector 对比\n\n\n * jio：用 java.io 编写的 tcp 模块，阻塞 io\n * nio：用 java.nio 编写的 tcp 模块，非阻塞 io，（io 多路复用）\n * apr：全称 apache portable runtime，使用 jni 的方式来进行读取文件以及进行网络传输\n\napache portable runtime 是一个高度可移植的库，它是 apache http server 2.x 的核心。 apr 具有许多用途，包括访问高级 io 功能（如 sendfile，epoll 和 openssl），操作系统级功能（随机数生成，系统状态等）和本地进程处理（共享内存，nt 管道和 unix 套接字）。\n\n表格中字段含义说明：\n\n * support polling - 是否支持基于 io 多路复用的 socket 事件轮询\n * polling size - 轮询的最大连接数\n * wait for next request - 在等待下一个请求时，处理线程是否释放，bio 是没有释放的，所以在 keep-alive=true 的情况下处理的并发连接数有限\n * read request headers - 由于 request header 数据较少，可以由容器提前解析完毕，不需要阻塞\n * read request body - 读取 request body 的数据是应用业务逻辑的事情，同时 servlet 的限制，是需要阻塞读取的\n * write response - 跟读取 request body 的逻辑类似，同样需要阻塞写\n\nnio 处理相关类\n\n\n\npoller 线程从 eventqueue 获取 pollerevent，并执行 pollerevent 的 run 方法，调用 selector 的 select 方法，如果有可读的 socket 则创建 http11nioprocessor，放入到线程池中执行；\n\ncoyoteadapter 是 connector 到 container 的适配器，http11nioprocessor 调用其提供的 service 方法，内部创建 request 和 response 对象，并调用最顶层容器的 pipeline 中的第一个 valve 的 invoke 方法\n\nmapper 主要处理 http url 到 servlet 的映射规则的解析，对外提供 map 方法\n\n\n# 4.5. comet\n\ncomet 是一种用于 web 的推送技术，能使服务器实时地将更新的信息传送到客户端，而无须客户端发出请求 在 websocket 出来之前，如果不适用 comet，只能通过浏览器端轮询 server 来模拟实现服务器端推送。 comet 支持 servlet 异步处理 io，当连接上数据可读时触发事件，并异步写数据(阻塞)\n\ntomcat 要实现 comet，只需继承 httpservlet 同时，实现 cometprocessor 接口\n\n * begin：新的请求连接接入调用，可进行与 request 和 response 相关的对象初始化操作，并保存 response 对象，用于后续写入数据\n * read：请求连接有数据可读时调用\n * end：当数据可用时，如果读取到文件结束或者 response 被关闭时则被调用\n * error：在连接上发生异常时调用，数据读取异常、连接断开、处理异常、socket 超时\n\nnote：\n\n * read：在 post 请求有数据，但在 begin 事件中没有处理，则会调用 read，如果 read 没有读取数据，在会触发 error 回调，关闭 socket\n * end：当 socket 超时，并且 response 被关闭时也会调用；server 被关闭时调用\n * error：除了 socket 超时不会关闭 socket，其他都会关闭 socket\n * end 和 error 时间触发时应关闭当前 comet 会话，即调用 cometevent 的 close 方法 note：在事件触发时要做好线程安全的操作\n\n\n# 4.6. 异步 servlet\n\n\n\n传统流程：\n\n * 首先，servlet 接收到请求之后，request 数据解析；\n * 接着，调用业务接口的某些方法，以完成业务处理；\n * 最后，根据处理的结果提交响应，servlet 线程结束\n\n\n\n异步处理流程：\n\n * 客户端发送一个请求\n * servlet 容器分配一个线程来处理容器中的一个 servlet\n * servlet 调用 request.startasync()，保存 asynccontext, 然后返回\n * 任何方式存在的容器线程都将退出，但是 response 仍然保持开放\n * 业务线程使用保存的 asynccontext 来完成响应（线程池）\n * 客户端收到响应\n\nservlet 线程将请求转交给一个异步线程来执行业务处理，线程本身返回至容器，此时 servlet 还没有生成响应数据，异步线程处理完业务以后，可以直接生成响应数据（异步线程拥有 servletrequest 和 servletresponse 对象的引用）\n\n为什么 web 应用中支持异步？\n\n推出异步，主要是针对那些比较耗时的请求：比如一次缓慢的数据库查询，一次外部 rest api 调用, 或者是其他一些 i/o 密集型操作。这种耗时的请求会很快的耗光 servlet 容器的线程池，继而影响可扩展性。\n\nnote：从客户端的角度来看，request 仍然像任何其他的 http 的 request-response 交互一样，只是耗费了更长的时间而已\n\n异步事件监听\n\n * onstartasync：request 调用 startasync 方法时触发\n * oncomplete：synccontext 调用 complete 方法时触发\n * onerror：处理请求的过程出现异常时触发\n * ontimeout：socket 超时触发\n\nnote : onerror/ ontimeout 触发后，会紧接着回调 oncomplete oncomplete 执行后，就不可再操作 request 和 response\n\n\n# 5. 参考资料\n\n * 官方\n   \n   * tomcat 官方网站\n   * tomcat wiki\n   * tomee 官方网站\n\n * 文章\n   \n   * creating a web app with bootstrap and tomcat embedded\n   * tomcat 组成与工作原理\n   * tomcat 工作原理\n   * tomcat 设计模式分析',charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Tomcat连接器",frontmatter:{title:"Tomcat连接器",date:"2022-02-17T22:34:30.000Z",order:2,categories:["Java","JavaEE","服务器","Tomcat"],tags:["Java","JavaWeb","服务器","Tomcat"],permalink:"/pages/13f070/"},regularPath:"/01.Java/02.JavaEE/02.%E6%9C%8D%E5%8A%A1%E5%99%A8/01.Tomcat/02.Tomcat%E8%BF%9E%E6%8E%A5%E5%99%A8.html",relativePath:"01.Java/02.JavaEE/02.服务器/01.Tomcat/02.Tomcat连接器.md",key:"v-f182b6d2",path:"/pages/13f070/",headers:[{level:2,title:"1. NioEndpoint 组件",slug:"_1-nioendpoint-组件",normalizedTitle:"1. nioendpoint 组件",charIndex:17},{level:3,title:"1.1. LimitLatch",slug:"_1-1-limitlatch",normalizedTitle:"1.1. limitlatch",charIndex:891},{level:3,title:"1.2. Acceptor",slug:"_1-2-acceptor",normalizedTitle:"1.2. acceptor",charIndex:2483},{level:3,title:"1.3. Poller",slug:"_1-3-poller",normalizedTitle:"1.3. poller",charIndex:3163},{level:3,title:"1.4. SocketProcessor",slug:"_1-4-socketprocessor",normalizedTitle:"1.4. socketprocessor",charIndex:3708},{level:2,title:"2. Nio2Endpoint 组件",slug:"_2-nio2endpoint-组件",normalizedTitle:"2. nio2endpoint 组件",charIndex:4180},{level:3,title:"2.1. Nio2Acceptor",slug:"_2-1-nio2acceptor",normalizedTitle:"2.1. nio2acceptor",charIndex:4852},{level:3,title:"2.2. Nio2SocketWrapper",slug:"_2-2-nio2socketwrapper",normalizedTitle:"2.2. nio2socketwrapper",charIndex:6316},{level:2,title:"3. AprEndpoint 组件",slug:"_3-aprendpoint-组件",normalizedTitle:"3. aprendpoint 组件",charIndex:7769},{level:3,title:"3.1. AprEndpoint 工作流程",slug:"_3-1-aprendpoint-工作流程",normalizedTitle:"3.1. aprendpoint 工作流程",charIndex:8655},{level:4,title:"3.1.1. Acceptor",slug:"_3-1-1-acceptor",normalizedTitle:"3.1.1. acceptor",charIndex:8682},{level:4,title:"3.1.2. Poller",slug:"_3-1-2-poller",normalizedTitle:"3.1.2. poller",charIndex:9767},{level:3,title:"3.2. APR 提升性能的秘密",slug:"_3-2-apr-提升性能的秘密",normalizedTitle:"3.2. apr 提升性能的秘密",charIndex:10320},{level:4,title:"3.2.1. sendfile",slug:"_3-2-1-sendfile",normalizedTitle:"3.2.1. sendfile",charIndex:12292},{level:2,title:"4. Executor 组件",slug:"_4-executor-组件",normalizedTitle:"4. executor 组件",charIndex:12966},{level:3,title:"4.1. Tomcat 定制线程池",slug:"_4-1-tomcat-定制线程池",normalizedTitle:"4.1. tomcat 定制线程池",charIndex:13067},{level:3,title:"4.2. Tomcat 定制任务队列",slug:"_4-2-tomcat-定制任务队列",normalizedTitle:"4.2. tomcat 定制任务队列",charIndex:15220},{level:2,title:"5. WebSocket 组件",slug:"_5-websocket-组件",normalizedTitle:"5. websocket 组件",charIndex:17124},{level:3,title:"5.1. WebSocket 加载",slug:"_5-1-websocket-加载",normalizedTitle:"5.1. websocket 加载",charIndex:17531},{level:3,title:"5.2. WebSocket 请求处理",slug:"_5-2-websocket-请求处理",normalizedTitle:"5.2. websocket 请求处理",charIndex:18654},{level:2,title:"6. 参考资料",slug:"_6-参考资料",normalizedTitle:"6. 参考资料",charIndex:19738}],headersStr:"1. NioEndpoint 组件 1.1. LimitLatch 1.2. Acceptor 1.3. Poller 1.4. SocketProcessor 2. Nio2Endpoint 组件 2.1. Nio2Acceptor 2.2. Nio2SocketWrapper 3. AprEndpoint 组件 3.1. AprEndpoint 工作流程 3.1.1. Acceptor 3.1.2. Poller 3.2. APR 提升性能的秘密 3.2.1. sendfile 4. Executor 组件 4.1. Tomcat 定制线程池 4.2. Tomcat 定制任务队列 5. WebSocket 组件 5.1. WebSocket 加载 5.2. WebSocket 请求处理 6. 参考资料",content:'# Tomcat 连接器\n\n\n# 1. NioEndpoint 组件\n\nTomcat 的 NioEndPoint 组件利用 Java NIO 实现了 I/O 多路复用模型。\n\n\n\nNioEndPoint 子组件功能简介：\n\n * LimitLatch 是连接控制器，负责控制最大连接数。NIO 模式下默认是 10000，达到这个阈值后，连接请求被拒绝。\n * Acceptor 负责监听连接请求。Acceptor 运行在一个单独的线程里，它在一个死循环里调用 accept 方法来接收新连接，一旦有新的连接请求到来，accept 方法返回一个 Channel 对象，接着把 Channel 对象交给 Poller 去处理。\n * Poller 的本质是一个 Selector，也运行在单独线程里。Poller 内部维护一个 Channel 数组，它在一个死循环里不断检测 Channel 的数据就绪状态，一旦有 Channel 可读，就生成一个 SocketProcessor 任务对象扔给 Executor 去处理。\n * Executor 就是线程池，负责运行 SocketProcessor 任务类，SocketProcessor 的 run 方法会调用 Http11Processor 来读取和解析请求数据。我们知道，Http11Processor 是应用层协议的封装，它会调用容器获得响应，再把响应通过 Channel 写出。\n\nNioEndpoint 如何实现高并发的呢？\n\n要实现高并发需要合理设计线程模型充分利用 CPU 资源，尽量不要让线程阻塞；另外，就是有多少任务，就用相应规模的线程数去处理。\n\nNioEndpoint 要完成三件事情：接收连接、检测 I/O 事件以及处理请求，那么最核心的就是把这三件事情分开，用不同规模的线程去处理，比如用专门的线程组去跑 Acceptor，并且 Acceptor 的个数可以配置；用专门的线程组去跑 Poller，Poller 的个数也可以配置；最后具体任务的执行也由专门的线程池来处理，也可以配置线程池的大小。\n\n\n# 1.1. LimitLatch\n\nLimitLatch 用来控制连接个数，当连接数到达最大时阻塞线程，直到后续组件处理完一个连接后将连接数减 1。请你注意到达最大连接数后操作系统底层还是会接收客户端连接，但用户层已经不再接收。\n\npublic class LimitLatch {\n    private class Sync extends AbstractQueuedSynchronizer {\n\n        @Override\n        protected int tryAcquireShared() {\n            long newCount = count.incrementAndGet();\n            if (newCount > limit) {\n                count.decrementAndGet();\n                return -1;\n            } else {\n                return 1;\n            }\n        }\n\n        @Override\n        protected boolean tryReleaseShared(int arg) {\n            count.decrementAndGet();\n            return true;\n        }\n    }\n\n    private final Sync sync;\n    private final AtomicLong count;\n    private volatile long limit;\n\n    // 线程调用这个方法来获得接收新连接的许可，线程可能被阻塞\n    public void countUpOrAwait() throws InterruptedException {\n      sync.acquireSharedInterruptibly(1);\n    }\n\n    // 调用这个方法来释放一个连接许可，那么前面阻塞的线程可能被唤醒\n    public long countDown() {\n      sync.releaseShared(0);\n      long result = getCount();\n      return result;\n   }\n}\n\n\nLimitLatch 内步定义了内部类 Sync，而 Sync 扩展了 AQS，AQS 是 Java 并发包中的一个核心类，它在内部维护一个状态和一个线程队列，可以用来控制线程什么时候挂起，什么时候唤醒。我们可以扩展它来实现自己的同步器，实际上 Java 并发包里的锁和条件变量等等都是通过 AQS 来实现的，而这里的 LimitLatch 也不例外。\n\n理解源码要点：\n\n * 用户线程通过调用 LimitLatch 的 countUpOrAwait 方法来拿到锁，如果暂时无法获取，这个线程会被阻塞到 AQS 的队列中。那 AQS 怎么知道是阻塞还是不阻塞用户线程呢？其实这是由 AQS 的使用者来决定的，也就是内部类 Sync 来决定的，因为 Sync 类重写了 AQS 的tryAcquireShared() 方法。它的实现逻辑是如果当前连接数 count 小于 limit，线程能获取锁，返回 1，否则返回 -1。\n * 如何用户线程被阻塞到了 AQS 的队列，那什么时候唤醒呢？同样是由 Sync 内部类决定，Sync 重写了 AQS 的releaseShared() 方法，其实就是当一个连接请求处理完了，这时又可以接收一个新连接了，这样前面阻塞的线程将会被唤醒。\n\n\n# 1.2. Acceptor\n\nAcceptor 实现了 Runnable 接口，因此可以跑在单独线程里。一个端口号只能对应一个 ServerSocketChannel，因此这个 ServerSocketChannel 是在多个 Acceptor 线程之间共享的，它是 Endpoint 的属性，由 Endpoint 完成初始化和端口绑定。\n\nserverSock = ServerSocketChannel.open();\nserverSock.socket().bind(addr,getAcceptCount());\nserverSock.configureBlocking(true);\n\n\n * bind 方法的第二个参数表示操作系统的等待队列长度，我在上面提到，当应用层面的连接数到达最大值时，操作系统可以继续接收连接，那么操作系统能继续接收的最大连接数就是这个队列长度，可以通过 acceptCount 参数配置，默认是 100。\n * ServerSocketChannel 被设置成阻塞模式，也就是说它是以阻塞的方式接收连接的。ServerSocketChannel 通过 accept() 接受新的连接，accept() 方法返回获得 SocketChannel 对象，然后将 SocketChannel 对象封装在一个 PollerEvent 对象中，并将 PollerEvent 对象压入 Poller 的 Queue 里，这是个典型的生产者 - 消费者模式，Acceptor 与 Poller 线程之间通过 Queue 通信。\n\n\n# 1.3. Poller\n\nPoller 本质是一个 Selector，它内部维护一个 Queue。\n\nprivate final SynchronizedQueue<PollerEvent> events = new SynchronizedQueue<>();\n\n\nSynchronizedQueue 的核心方法都使用了 Synchronized 关键字进行修饰，用来保证同一时刻只有一个线程进行读写。\n\n使用 SynchronizedQueue，意味着同一时刻只有一个 Acceptor 线程对队列进行读写；同时有多个 Poller 线程在运行，每个 Poller 线程都有自己的队列。每个 Poller 线程可能同时被多个 Acceptor 线程调用来注册 PollerEvent。同样 Poller 的个数可以通过 pollers 参数配置。\n\nPoller 不断的通过内部的 Selector 对象向内核查询 Channel 的状态，一旦可读就生成任务类 SocketProcessor 交给 Executor 去处理。Poller 的另一个重要任务是循环遍历检查自己所管理的 SocketChannel 是否已经超时，如果有超时就关闭这个 SocketChannel。\n\n\n# 1.4. SocketProcessor\n\n我们知道，Poller 会创建 SocketProcessor 任务类交给线程池处理，而 SocketProcessor 实现了 Runnable 接口，用来定义 Executor 中线程所执行的任务，主要就是调用 Http11Processor 组件来处理请求。Http11Processor 读取 Channel 的数据来生成 ServletRequest 对象，这里请你注意：\n\nHttp11Processor 并不是直接读取 Channel 的。这是因为 Tomcat 支持同步非阻塞 I/O 模型和异步 I/O 模型，在 Java API 中，相应的 Channel 类也是不一样的，比如有 AsynchronousSocketChannel 和 SocketChannel，为了对 Http11Processor 屏蔽这些差异，Tomcat 设计了一个包装类叫作 SocketWrapper，Http11Processor 只调用 SocketWrapper 的方法去读写数据。\n\n\n# 2. Nio2Endpoint 组件\n\nNio2Endpoint 工作流程跟 NioEndpoint 较为相似。\n\n\n\nNio2Endpoint 子组件功能说明：\n\n * LimitLatch 是连接控制器，它负责控制最大连接数。\n * Nio2Acceptor 扩展了 Acceptor，用异步 I/O 的方式来接收连接，跑在一个单独的线程里，也是一个线程组。Nio2Acceptor 接收新的连接后，得到一个 AsynchronousSocketChannel，Nio2Acceptor 把 AsynchronousSocketChannel 封装成一个 Nio2SocketWrapper，并创建一个 SocketProcessor 任务类交给线程池处理，并且 SocketProcessor 持有 Nio2SocketWrapper 对象。\n * Executor 在执行 SocketProcessor 时，SocketProcessor 的 run 方法会调用 Http11Processor 来处理请求，Http11Processor 会通过 Nio2SocketWrapper 读取和解析请求数据，请求经过容器处理后，再把响应通过 Nio2SocketWrapper 写出。\n\nNio2Endpoint 跟 NioEndpoint 的一个明显不同点是，Nio2Endpoint 中没有 Poller 组件，也就是没有 Selector。这是为什么呢？因为在异步 I/O 模式下，Selector 的工作交给内核来做了。\n\n\n# 2.1. Nio2Acceptor\n\n和 NioEndpint 一样，Nio2Endpoint 的基本思路是用 LimitLatch 组件来控制连接数。\n\n但是 Nio2Acceptor 的监听连接的过程不是在一个死循环里不断的调 accept 方法，而是通过回调函数来完成的。我们来看看它的连接监听方法：\n\nserverSock.accept(null, this);\n\n\n其实就是调用了 accept 方法，注意它的第二个参数是 this，表明 Nio2Acceptor 自己就是处理连接的回调类，因此 Nio2Acceptor 实现了 CompletionHandler 接口。那么它是如何实现 CompletionHandler 接口的呢？\n\nprotected class Nio2Acceptor extends Acceptor<AsynchronousSocketChannel>\n    implements CompletionHandler<AsynchronousSocketChannel, Void> {\n\n    @Override\n    public void completed(AsynchronousSocketChannel socket,\n        Void attachment) {\n\n        if (isRunning() && !isPaused()) {\n            if (getMaxConnections() == -1) {\n                // 如果没有连接限制，继续接收新的连接\n                serverSock.accept(null, this);\n            } else {\n                // 如果有连接限制，就在线程池里跑 Run 方法，Run 方法会检查连接数\n                getExecutor().execute(this);\n            }\n            // 处理请求\n            if (!setSocketOptions(socket)) {\n                closeSocket(socket);\n            }\n        }\n    }\n}\n\n\n可以看到 CompletionHandler 的两个模板参数分别是 AsynchronousServerSocketChannel 和 Void，我在前面说过第一个参数就是 accept 方法的返回值，第二个参数是附件类，由用户自己决定，这里为 Void。completed 方法的处理逻辑比较简单：\n\n * 如果没有连接限制，继续在本线程中调用 accept 方法接收新的连接。\n * 如果有连接限制，就在线程池里跑 run 方法去接收新的连接。那为什么要跑 run 方法呢，因为在 run 方法里会检查连接数，当连接达到最大数时，线程可能会被 LimitLatch 阻塞。为什么要放在线程池里跑呢？这是因为如果放在当前线程里执行，completed 方法可能被阻塞，会导致这个回调方法一直不返回。\n\n接着 completed 方法会调用 setSocketOptions 方法，在这个方法里，会创建 Nio2SocketWrapper 和 SocketProcessor，并交给线程池处理。\n\n\n# 2.2. Nio2SocketWrapper\n\nNio2SocketWrapper 的主要作用是封装 Channel，并提供接口给 Http11Processor 读写数据。讲到这里你是不是有个疑问：Http11Processor 是不能阻塞等待数据的，按照异步 I/O 的套路，Http11Processor 在调用 Nio2SocketWrapper 的 read 方法时需要注册回调类，read 调用会立即返回，问题是立即返回后 Http11Processor 还没有读到数据， 怎么办呢？这个请求的处理不就失败了吗？\n\n为了解决这个问题，Http11Processor 是通过 2 次 read 调用来完成数据读取操作的。\n\n * 第一次 read 调用：连接刚刚建立好后，Acceptor 创建 SocketProcessor 任务类交给线程池去处理，Http11Processor 在处理请求的过程中，会调用 Nio2SocketWrapper 的 read 方法发出第一次读请求，同时注册了回调类 readCompletionHandler，因为数据没读到，Http11Processor 把当前的 Nio2SocketWrapper 标记为数据不完整。接着 SocketProcessor 线程被回收，Http11Processor 并没有阻塞等待数据。这里请注意，Http11Processor 维护了一个 Nio2SocketWrapper 列表，也就是维护了连接的状态。\n * 第二次 read 调用：当数据到达后，内核已经把数据拷贝到 Http11Processor 指定的 Buffer 里，同时回调类 readCompletionHandler 被调用，在这个回调处理方法里会重新创建一个新的 SocketProcessor 任务来继续处理这个连接，而这个新的 SocketProcessor 任务类持有原来那个 Nio2SocketWrapper，这一次 Http11Processor 可以通过 Nio2SocketWrapper 读取数据了，因为数据已经到了应用层的 Buffer。\n\n这个回调类 readCompletionHandler 的源码如下，最关键的一点是，Nio2SocketWrapper 是作为附件类来传递的，这样在回调函数里能拿到所有的上下文。\n\nthis.readCompletionHandler = new CompletionHandler<Integer, SocketWrapperBase<Nio2Channel>>() {\n    public void completed(Integer nBytes, SocketWrapperBase<Nio2Channel> attachment) {\n        ...\n        // 通过附件类 SocketWrapper 拿到所有的上下文\n        Nio2SocketWrapper.this.getEndpoint().processSocket(attachment, SocketEvent.OPEN_READ, false);\n    }\n\n    public void failed(Throwable exc, SocketWrapperBase<Nio2Channel> attachment) {\n        ...\n    }\n}\n\n\n\n# 3. AprEndpoint 组件\n\n我们在使用 Tomcat 时，可能会在启动日志里看到这样的提示信息：\n\n> The APR based Apache Tomcat Native library which allows optimal performance in production environments was not found on the java.library.path: ***\n\n这句话的意思就是推荐你去安装 APR 库，可以提高系统性能。\n\nAPR（Apache Portable Runtime Libraries）是 Apache 可移植运行时库，它是用 C 语言实现的，其目的是向上层应用程序提供一个跨平台的操作系统接口库。Tomcat 可以用它来处理包括文件和网络 I/O，从而提升性能。Tomcat 支持的连接器有 NIO、NIO.2 和 APR。跟 NioEndpoint 一样，AprEndpoint 也实现了非阻塞 I/O，它们的区别是：NioEndpoint 通过调用 Java 的 NIO API 来实现非阻塞 I/O，而 AprEndpoint 是通过 JNI 调用 APR 本地库而实现非阻塞 I/O 的。\n\n同样是非阻塞 I/O，为什么 Tomcat 会提示使用 APR 本地库的性能会更好呢？这是因为在某些场景下，比如需要频繁与操作系统进行交互，Socket 网络通信就是这样一个场景，特别是如果你的 Web 应用使用了 TLS 来加密传输，我们知道 TLS 协议在握手过程中有多次网络交互，在这种情况下 Java 跟 C 语言程序相比还是有一定的差距，而这正是 APR 的强项。\n\nTomcat 本身是 Java 编写的，为了调用 C 语言编写的 APR，需要通过 JNI 方式来调用。JNI（Java Native Interface） 是 JDK 提供的一个编程接口，它允许 Java 程序调用其他语言编写的程序或者代码库，其实 JDK 本身的实现也大量用到 JNI 技术来调用本地 C 程序库。\n\n\n# 3.1. AprEndpoint 工作流程\n\n\n\n# 3.1.1. Acceptor\n\nAccpetor 的功能就是监听连接，接收并建立连接。它的本质就是调用了四个操作系统 API：socket、bind、listen 和 accept。那 Java 语言如何直接调用 C 语言 API 呢？答案就是通过 JNI。具体来说就是两步：先封装一个 Java 类，在里面定义一堆用native 关键字修饰的方法，像下面这样。\n\npublic class Socket {\n  ...\n  // 用 native 修饰这个方法，表明这个函数是 C 语言实现\n  public static native long create(int family, int type,\n                                 int protocol, long cont)\n\n  public static native int bind(long sock, long sa);\n\n  public static native int listen(long sock, int backlog);\n\n  public static native long accept(long sock)\n}\n\n\n接着用 C 代码实现这些方法，比如 bind 函数就是这样实现的：\n\n// 注意函数的名字要符合 JNI 规范的要求\nJNIEXPORT jint JNICALL\nJava_org_apache_tomcat_jni_Socket_bind(JNIEnv *e, jlong sock,jlong sa)\n\t{\n\t    jint rv = APR_SUCCESS;\n\t    tcn_socket_t *s = (tcn_socket_t *）sock;\n\t    apr_sockaddr_t *a = (apr_sockaddr_t *) sa;\n\n        // 调用 APR 库自己实现的 bind 函数\n\t    rv = (jint)apr_socket_bind(s->sock, a);\n\t    return rv;\n\t}\n\n\n专栏里我就不展开 JNI 的细节了，你可以扩展阅读获得更多信息和例子。我们要注意的是函数名字要符合 JNI 的规范，以及 Java 和 C 语言如何互相传递参数，比如在 C 语言有指针，Java 没有指针的概念，所以在 Java 中用 long 类型来表示指针。AprEndpoint 的 Acceptor 组件就是调用了 APR 实现的四个 API。\n\n# 3.1.2. Poller\n\nAcceptor 接收到一个新的 Socket 连接后，按照 NioEndpoint 的实现，它会把这个 Socket 交给 Poller 去查询 I/O 事件。AprEndpoint 也是这样做的，不过 AprEndpoint 的 Poller 并不是调用 Java NIO 里的 Selector 来查询 Socket 的状态，而是通过 JNI 调用 APR 中的 poll 方法，而 APR 又是调用了操作系统的 epoll API 来实现的。\n\n这里有个特别的地方是在 AprEndpoint 中，我们可以配置一个叫deferAccept的参数，它对应的是 TCP 协议中的TCP_DEFER_ACCEPT，设置这个参数后，当 TCP 客户端有新的连接请求到达时，TCP 服务端先不建立连接，而是再等等，直到客户端有请求数据发过来时再建立连接。这样的好处是服务端不需要用 Selector 去反复查询请求数据是否就绪。\n\n这是一种 TCP 协议层的优化，不是每个操作系统内核都支持，因为 Java 作为一种跨平台语言，需要屏蔽各种操作系统的差异，因此并没有把这个参数提供给用户；但是对于 APR 来说，它的目的就是尽可能提升性能，因此它向用户暴露了这个参数。\n\n\n# 3.2. APR 提升性能的秘密\n\nAPR 连接器之所以能提高 Tomcat 的性能，除了 APR 本身是 C 程序库之外，还有哪些提速的秘密呢？\n\nJVM 堆 VS 本地内存\n\n我们知道 Java 的类实例一般在 JVM 堆上分配，而 Java 是通过 JNI 调用 C 代码来实现 Socket 通信的，那么 C 代码在运行过程中需要的内存又是从哪里分配的呢？C 代码能否直接操作 Java 堆？\n\n为了回答这些问题，我先来说说 JVM 和用户进程的关系。如果你想运行一个 Java 类文件，可以用下面的 Java 命令来执行。\n\njava my.class\n\n\n这个命令行中的java其实是一个可执行程序，这个程序会创建 JVM 来加载和运行你的 Java 类。操作系统会创建一个进程来执行这个java可执行程序，而每个进程都有自己的虚拟地址空间，JVM 用到的内存（包括堆、栈和方法区）就是从进程的虚拟地址空间上分配的。请你注意的是，JVM 内存只是进程空间的一部分，除此之外进程空间内还有代码段、数据段、内存映射区、内核空间等。从 JVM 的角度看，JVM 内存之外的部分叫作本地内存，C 程序代码在运行过程中用到的内存就是本地内存中分配的。下面我们通过一张图来理解一下。\n\n\n\nTomcat 的 Endpoint 组件在接收网络数据时需要预先分配好一块 Buffer，所谓的 Buffer 就是字节数组byte[]，Java 通过 JNI 调用把这块 Buffer 的地址传给 C 代码，C 代码通过操作系统 API 读取 Socket 并把数据填充到这块 Buffer。Java NIO API 提供了两种 Buffer 来接收数据：HeapByteBuffer 和 DirectByteBuffer，下面的代码演示了如何创建两种 Buffer。\n\n// 分配 HeapByteBuffer\nByteBuffer buf = ByteBuffer.allocate(1024);\n\n// 分配 DirectByteBuffer\nByteBuffer buf = ByteBuffer.allocateDirect(1024);\n\n\n创建好 Buffer 后直接传给 Channel 的 read 或者 write 函数，最终这块 Buffer 会通过 JNI 调用传递给 C 程序。\n\n// 将 buf 作为 read 函数的参数\nint bytesRead = socketChannel.read(buf);\n\n\n那 HeapByteBuffer 和 DirectByteBuffer 有什么区别呢？HeapByteBuffer 对象本身在 JVM 堆上分配，并且它持有的字节数组byte[]也是在 JVM 堆上分配。但是如果用HeapByteBuffer来接收网络数据，需要把数据从内核先拷贝到一个临时的本地内存，再从临时本地内存拷贝到 JVM 堆，而不是直接从内核拷贝到 JVM 堆上。这是为什么呢？这是因为数据从内核拷贝到 JVM 堆的过程中，JVM 可能会发生 GC，GC 过程中对象可能会被移动，也就是说 JVM 堆上的字节数组可能会被移动，这样的话 Buffer 地址就失效了。如果这中间经过本地内存中转，从本地内存到 JVM 堆的拷贝过程中 JVM 可以保证不做 GC。\n\n如果使用 HeapByteBuffer，你会发现 JVM 堆和内核之间多了一层中转，而 DirectByteBuffer 用来解决这个问题，DirectByteBuffer 对象本身在 JVM 堆上，但是它持有的字节数组不是从 JVM 堆上分配的，而是从本地内存分配的。DirectByteBuffer 对象中有个 long 类型字段 address，记录着本地内存的地址，这样在接收数据的时候，直接把这个本地内存地址传递给 C 程序，C 程序会将网络数据从内核拷贝到这个本地内存，JVM 可以直接读取这个本地内存，这种方式比 HeapByteBuffer 少了一次拷贝，因此一般来说它的速度会比 HeapByteBuffer 快好几倍。你可以通过上面的图加深理解。\n\nTomcat 中的 AprEndpoint 就是通过 DirectByteBuffer 来接收数据的，而 NioEndpoint 和 Nio2Endpoint 是通过 HeapByteBuffer 来接收数据的。你可能会问，NioEndpoint 和 Nio2Endpoint 为什么不用 DirectByteBuffer 呢？这是因为本地内存不好管理，发生内存泄漏难以定位，从稳定性考虑，NioEndpoint 和 Nio2Endpoint 没有去冒这个险。\n\n# 3.2.1. sendfile\n\n我们再来考虑另一个网络通信的场景，也就是静态文件的处理。浏览器通过 Tomcat 来获取一个 HTML 文件，而 Tomcat 的处理逻辑无非是两步：\n\n 1. 从磁盘读取 HTML 到内存。\n 2. 将这段内存的内容通过 Socket 发送出去。\n\n但是在传统方式下，有很多次的内存拷贝：\n\n * 读取文件时，首先是内核把文件内容读取到内核缓冲区。\n * 如果使用 HeapByteBuffer，文件数据从内核到 JVM 堆内存需要经过本地内存中转。\n * 同样在将文件内容推入网络时，从 JVM 堆到内核缓冲区需要经过本地内存中转。\n * 最后还需要把文件从内核缓冲区拷贝到网卡缓冲区。\n\n从下面的图你会发现这个过程有 6 次内存拷贝，并且 read 和 write 等系统调用将导致进程从用户态到内核态的切换，会耗费大量的 CPU 和内存资源。\n\n\n\n而 Tomcat 的 AprEndpoint 通过操作系统层面的 sendfile 特性解决了这个问题，sendfile 系统调用方式非常简洁。\n\nsendfile(socket, file, len);\n\n\n它带有两个关键参数：Socket 和文件句柄。将文件从磁盘写入 Socket 的过程只有两步：\n\n第一步：将文件内容读取到内核缓冲区。\n\n第二步：数据并没有从内核缓冲区复制到 Socket 关联的缓冲区，只有记录数据位置和长度的描述符被添加到 Socket 缓冲区中；接着把数据直接从内核缓冲区传递给网卡。这个过程你可以看下面的图。\n\n\n\n\n# 4. Executor 组件\n\n为了提高处理能力和并发度，Web 容器一般会把处理请求的工作放到线程池里来执行，Tomcat 扩展了原生的 Java 线程池，来满足 Web 容器高并发的需求。\n\n\n# 4.1. Tomcat 定制线程池\n\nTomcat 的线程池也是一个定制版的 ThreadPoolExecutor。Tomcat 传入的参数是这样的：\n\n// 定制版的任务队列\ntaskqueue = new TaskQueue(maxQueueSize);\n\n// 定制版的线程工厂\nTaskThreadFactory tf = new TaskThreadFactory(namePrefix,daemon,getThreadPriority());\n\n// 定制版的线程池\nexecutor = new ThreadPoolExecutor(getMinSpareThreads(), getMaxThreads(), maxIdleTime, TimeUnit.MILLISECONDS,taskqueue, tf);\n\n\n其中的两个关键点：\n\n * Tomcat 有自己的定制版任务队列和线程工厂，并且可以限制任务队列的长度，它的最大长度是 maxQueueSize。\n * Tomcat 对线程数也有限制，设置了核心线程数（minSpareThreads）和最大线程池数（maxThreads）。\n\n除了资源限制以外，Tomcat 线程池还定制自己的任务处理流程。我们知道 Java 原生线程池的任务处理逻辑比较简单：\n\n 1. 前 corePoolSize 个任务时，来一个任务就创建一个新线程。\n 2. 后面再来任务，就把任务添加到任务队列里让所有的线程去抢，如果队列满了就创建临时线程。\n 3. 如果总线程数达到 maximumPoolSize，执行拒绝策略。\n\nTomcat 线程池扩展了原生的 ThreadPoolExecutor，通过重写 execute 方法实现了自己的任务处理逻辑：\n\n 1. 前 corePoolSize 个任务时，来一个任务就创建一个新线程。\n 2. 再来任务的话，就把任务添加到任务队列里让所有的线程去抢，如果队列满了就创建临时线程。\n 3. 如果总线程数达到 maximumPoolSize，则继续尝试把任务添加到任务队列中去。\n 4. 如果缓冲队列也满了，插入失败，执行拒绝策略。\n\n观察 Tomcat 线程池和 Java 原生线程池的区别，其实就是在第 3 步，Tomcat 在线程总数达到最大数时，不是立即执行拒绝策略，而是再尝试向任务队列添加任务，添加失败后再执行拒绝策略。那具体如何实现呢，其实很简单，我们来看一下 Tomcat 线程池的 execute 方法的核心代码。\n\npublic class ThreadPoolExecutor extends java.util.concurrent.ThreadPoolExecutor {\n\n  ...\n\n  public void execute(Runnable command, long timeout, TimeUnit unit) {\n      submittedCount.incrementAndGet();\n      try {\n          // 调用 Java 原生线程池的 execute 去执行任务\n          super.execute(command);\n      } catch (RejectedExecutionException rx) {\n         // 如果总线程数达到 maximumPoolSize，Java 原生线程池执行拒绝策略\n          if (super.getQueue() instanceof TaskQueue) {\n              final TaskQueue queue = (TaskQueue)super.getQueue();\n              try {\n                  // 继续尝试把任务放到任务队列中去\n                  if (!queue.force(command, timeout, unit)) {\n                      submittedCount.decrementAndGet();\n                      // 如果缓冲队列也满了，插入失败，执行拒绝策略。\n                      throw new RejectedExecutionException("...");\n                  }\n              }\n          }\n      }\n}\n\n\n从这个方法你可以看到，Tomcat 线程池的 execute 方法会调用 Java 原生线程池的 execute 去执行任务，如果总线程数达到 maximumPoolSize，Java 原生线程池的 execute 方法会抛出 RejectedExecutionException 异常，但是这个异常会被 Tomcat 线程池的 execute 方法捕获到，并继续尝试把这个任务放到任务队列中去；如果任务队列也满了，再执行拒绝策略。\n\n\n# 4.2. Tomcat 定制任务队列\n\n细心的你有没有发现，在 Tomcat 线程池的 execute 方法最开始有这么一行：\n\nsubmittedCount.incrementAndGet();\n\n\n这行代码的意思把 submittedCount 这个原子变量加一，并且在任务执行失败，抛出拒绝异常时，将这个原子变量减一：\n\nsubmittedCount.decrementAndGet();\n\n\n其实 Tomcat 线程池是用这个变量 submittedCount 来维护已经提交到了线程池，但是还没有执行完的任务个数。Tomcat 为什么要维护这个变量呢？这跟 Tomcat 的定制版的任务队列有关。Tomcat 的任务队列 TaskQueue 扩展了 Java 中的 LinkedBlockingQueue，我们知道 LinkedBlockingQueue 默认情况下长度是没有限制的，除非给它一个 capacity。因此 Tomcat 给了它一个 capacity，TaskQueue 的构造函数中有个整型的参数 capacity，TaskQueue 将 capacity 传给父类 LinkedBlockingQueue 的构造函数。\n\npublic class TaskQueue extends LinkedBlockingQueue<Runnable> {\n\n  public TaskQueue(int capacity) {\n      super(capacity);\n  }\n  ...\n}\n\n\n这个 capacity 参数是通过 Tomcat 的 maxQueueSize 参数来设置的，但问题是默认情况下 maxQueueSize 的值是Integer.MAX_VALUE，等于没有限制，这样就带来一个问题：当前线程数达到核心线程数之后，再来任务的话线程池会把任务添加到任务队列，并且总是会成功，这样永远不会有机会创建新线程了。\n\n为了解决这个问题，TaskQueue 重写了 LinkedBlockingQueue 的 offer 方法，在合适的时机返回 false，返回 false 表示任务添加失败，这时线程池会创建新的线程。那什么是合适的时机呢？请看下面 offer 方法的核心源码：\n\npublic class TaskQueue extends LinkedBlockingQueue<Runnable> {\n\n  ...\n   @Override\n  // 线程池调用任务队列的方法时，当前线程数肯定已经大于核心线程数了\n  public boolean offer(Runnable o) {\n\n      // 如果线程数已经到了最大值，不能创建新线程了，只能把任务添加到任务队列。\n      if (parent.getPoolSize() == parent.getMaximumPoolSize())\n          return super.offer(o);\n\n      // 执行到这里，表明当前线程数大于核心线程数，并且小于最大线程数。\n      // 表明是可以创建新线程的，那到底要不要创建呢？分两种情况：\n\n      //1. 如果已提交的任务数小于当前线程数，表示还有空闲线程，无需创建新线程\n      if (parent.getSubmittedCount()<=(parent.getPoolSize()))\n          return super.offer(o);\n\n      //2. 如果已提交的任务数大于当前线程数，线程不够用了，返回 false 去创建新线程\n      if (parent.getPoolSize()<parent.getMaximumPoolSize())\n          return false;\n\n      // 默认情况下总是把任务添加到任务队列\n      return super.offer(o);\n  }\n\n}\n\n\n从上面的代码我们看到，只有当前线程数大于核心线程数、小于最大线程数，并且已提交的任务个数大于当前线程数时，也就是说线程不够用了，但是线程数又没达到极限，才会去创建新的线程。这就是为什么 Tomcat 需要维护已提交任务数这个变量，它的目的就是在任务队列的长度无限制的情况下，让线程池有机会创建新的线程。\n\n当然默认情况下 Tomcat 的任务队列是没有限制的，你可以通过设置 maxQueueSize 参数来限制任务队列的长度。\n\n\n# 5. WebSocket 组件\n\nHTTP 协议是“请求 - 响应”模式，浏览器必须先发请求给服务器，服务器才会响应这个请求。也就是说，服务器不会主动发送数据给浏览器。\n\n对于实时性要求比较的高的应用，比如在线游戏、股票基金实时报价和在线协同编辑等，浏览器需要实时显示服务器上最新的数据，因此出现了 Ajax 和 Comet 技术。Ajax 本质上还是轮询，而 Comet 是在 HTTP 长连接的基础上做了一些 hack，但是它们的实时性不高，另外频繁的请求会给服务器带来压力，也会浪费网络流量和带宽。于是 HTML5 推出了 WebSocket 标准，使得浏览器和服务器之间任何一方都可以主动发消息给对方，这样服务器有新数据时可以主动推送给浏览器。\n\nTomcat 如何支持 WebSocket？简单来说，Tomcat 做了两件事：\n\n * Endpoint 加载\n * WebSocket 请求处理\n\n\n# 5.1. WebSocket 加载\n\nTomcat 的 WebSocket 加载是通过 SCI 机制完成的。SCI 全称 ServletContainerInitializer，是 Servlet 3.0 规范中定义的用来接收 Web 应用启动事件的接口。那为什么要监听 Servlet 容器的启动事件呢？因为这样我们有机会在 Web 应用启动时做一些初始化工作，比如 WebSocket 需要扫描和加载 Endpoint 类。SCI 的使用也比较简单，将实现 ServletContainerInitializer 接口的类增加 HandlesTypes 注解，并且在注解内指定的一系列类和接口集合。比如 Tomcat 为了扫描和加载 Endpoint 而定义的 SCI 类如下：\n\n@HandlesTypes({ServerEndpoint.class, ServerApplicationConfig.class, Endpoint.class})\npublic class WsSci implements ServletContainerInitializer {\n\n  public void onStartup(Set<Class<?>> clazzes, ServletContext ctx) throws ServletException {\n  ...\n  }\n}\n\n\n一旦定义好了 SCI，Tomcat 在启动阶段扫描类时，会将 HandlesTypes 注解中指定的类都扫描出来，作为 SCI 的 onStartup 方法的参数，并调用 SCI 的 onStartup 方法。注意到 WsSci 的 HandlesTypes 注解中定义了ServerEndpoint.class、ServerApplicationConfig.class和Endpoint.class，因此在 Tomcat 的启动阶段会将这些类的类实例（注意不是对象实例）传递给 WsSci 的 onStartup 方法。那么 WsSci 的 onStartup 方法又做了什么事呢？\n\n它会构造一个 WebSocketContainer 实例，你可以把 WebSocketContainer 理解成一个专门处理 WebSocket 请求的Endpoint 容器。也就是说 Tomcat 会把扫描到的 Endpoint 子类和添加了注解@ServerEndpoint的类注册到这个容器中，并且这个容器还维护了 URL 到 Endpoint 的映射关系，这样通过请求 URL 就能找到具体的 Endpoint 来处理 WebSocket 请求。\n\n\n# 5.2. WebSocket 请求处理\n\nTomcat 用 ProtocolHandler 组件屏蔽应用层协议的差异，其中 ProtocolHandler 中有两个关键组件：Endpoint 和 Processor。需要注意，这里的 Endpoint 跟上文提到的 WebSocket 中的 Endpoint 完全是两回事，连接器中的 Endpoint 组件用来处理 I/O 通信。WebSocket 本质就是一个应用层协议，因此不能用 HttpProcessor 来处理 WebSocket 请求，而要用专门 Processor 来处理，而在 Tomcat 中这样的 Processor 叫作 UpgradeProcessor。\n\n为什么叫 Upgrade Processor 呢？这是因为 Tomcat 是将 HTTP 协议升级成 WebSocket 协议的。\n\nWebSocket 是通过 HTTP 协议来进行握手的，因此当 WebSocket 的握手请求到来时，HttpProtocolHandler 首先接收到这个请求，在处理这个 HTTP 请求时，Tomcat 通过一个特殊的 Filter 判断该当前 HTTP 请求是否是一个 WebSocket Upgrade 请求（即包含Upgrade: websocket的 HTTP 头信息），如果是，则在 HTTP 响应里添加 WebSocket 相关的响应头信息，并进行协议升级。具体来说就是用 UpgradeProtocolHandler 替换当前的 HttpProtocolHandler，相应的，把当前 Socket 的 Processor 替换成 UpgradeProcessor，同时 Tomcat 会创建 WebSocket Session 实例和 Endpoint 实例，并跟当前的 WebSocket 连接一一对应起来。这个 WebSocket 连接不会立即关闭，并且在请求处理中，不再使用原有的 HttpProcessor，而是用专门的 UpgradeProcessor，UpgradeProcessor 最终会调用相应的 Endpoint 实例来处理请求。\n\n\n\n你可以看到，Tomcat 对 WebSocket 请求的处理没有经过 Servlet 容器，而是通过 UpgradeProcessor 组件直接把请求发到 ServerEndpoint 实例，并且 Tomcat 的 WebSocket 实现不需要关注具体 I/O 模型的细节，从而实现了与具体 I/O 方式的解耦。\n\n\n# 6. 参考资料\n\n * 官方\n   * Tomcat 官方网站\n   * Tomcat Wiki\n   * Tomee 官方网站\n * 教程\n   * 深入拆解 Tomcat & Jetty',normalizedContent:'# tomcat 连接器\n\n\n# 1. nioendpoint 组件\n\ntomcat 的 nioendpoint 组件利用 java nio 实现了 i/o 多路复用模型。\n\n\n\nnioendpoint 子组件功能简介：\n\n * limitlatch 是连接控制器，负责控制最大连接数。nio 模式下默认是 10000，达到这个阈值后，连接请求被拒绝。\n * acceptor 负责监听连接请求。acceptor 运行在一个单独的线程里，它在一个死循环里调用 accept 方法来接收新连接，一旦有新的连接请求到来，accept 方法返回一个 channel 对象，接着把 channel 对象交给 poller 去处理。\n * poller 的本质是一个 selector，也运行在单独线程里。poller 内部维护一个 channel 数组，它在一个死循环里不断检测 channel 的数据就绪状态，一旦有 channel 可读，就生成一个 socketprocessor 任务对象扔给 executor 去处理。\n * executor 就是线程池，负责运行 socketprocessor 任务类，socketprocessor 的 run 方法会调用 http11processor 来读取和解析请求数据。我们知道，http11processor 是应用层协议的封装，它会调用容器获得响应，再把响应通过 channel 写出。\n\nnioendpoint 如何实现高并发的呢？\n\n要实现高并发需要合理设计线程模型充分利用 cpu 资源，尽量不要让线程阻塞；另外，就是有多少任务，就用相应规模的线程数去处理。\n\nnioendpoint 要完成三件事情：接收连接、检测 i/o 事件以及处理请求，那么最核心的就是把这三件事情分开，用不同规模的线程去处理，比如用专门的线程组去跑 acceptor，并且 acceptor 的个数可以配置；用专门的线程组去跑 poller，poller 的个数也可以配置；最后具体任务的执行也由专门的线程池来处理，也可以配置线程池的大小。\n\n\n# 1.1. limitlatch\n\nlimitlatch 用来控制连接个数，当连接数到达最大时阻塞线程，直到后续组件处理完一个连接后将连接数减 1。请你注意到达最大连接数后操作系统底层还是会接收客户端连接，但用户层已经不再接收。\n\npublic class limitlatch {\n    private class sync extends abstractqueuedsynchronizer {\n\n        @override\n        protected int tryacquireshared() {\n            long newcount = count.incrementandget();\n            if (newcount > limit) {\n                count.decrementandget();\n                return -1;\n            } else {\n                return 1;\n            }\n        }\n\n        @override\n        protected boolean tryreleaseshared(int arg) {\n            count.decrementandget();\n            return true;\n        }\n    }\n\n    private final sync sync;\n    private final atomiclong count;\n    private volatile long limit;\n\n    // 线程调用这个方法来获得接收新连接的许可，线程可能被阻塞\n    public void countuporawait() throws interruptedexception {\n      sync.acquiresharedinterruptibly(1);\n    }\n\n    // 调用这个方法来释放一个连接许可，那么前面阻塞的线程可能被唤醒\n    public long countdown() {\n      sync.releaseshared(0);\n      long result = getcount();\n      return result;\n   }\n}\n\n\nlimitlatch 内步定义了内部类 sync，而 sync 扩展了 aqs，aqs 是 java 并发包中的一个核心类，它在内部维护一个状态和一个线程队列，可以用来控制线程什么时候挂起，什么时候唤醒。我们可以扩展它来实现自己的同步器，实际上 java 并发包里的锁和条件变量等等都是通过 aqs 来实现的，而这里的 limitlatch 也不例外。\n\n理解源码要点：\n\n * 用户线程通过调用 limitlatch 的 countuporawait 方法来拿到锁，如果暂时无法获取，这个线程会被阻塞到 aqs 的队列中。那 aqs 怎么知道是阻塞还是不阻塞用户线程呢？其实这是由 aqs 的使用者来决定的，也就是内部类 sync 来决定的，因为 sync 类重写了 aqs 的tryacquireshared() 方法。它的实现逻辑是如果当前连接数 count 小于 limit，线程能获取锁，返回 1，否则返回 -1。\n * 如何用户线程被阻塞到了 aqs 的队列，那什么时候唤醒呢？同样是由 sync 内部类决定，sync 重写了 aqs 的releaseshared() 方法，其实就是当一个连接请求处理完了，这时又可以接收一个新连接了，这样前面阻塞的线程将会被唤醒。\n\n\n# 1.2. acceptor\n\nacceptor 实现了 runnable 接口，因此可以跑在单独线程里。一个端口号只能对应一个 serversocketchannel，因此这个 serversocketchannel 是在多个 acceptor 线程之间共享的，它是 endpoint 的属性，由 endpoint 完成初始化和端口绑定。\n\nserversock = serversocketchannel.open();\nserversock.socket().bind(addr,getacceptcount());\nserversock.configureblocking(true);\n\n\n * bind 方法的第二个参数表示操作系统的等待队列长度，我在上面提到，当应用层面的连接数到达最大值时，操作系统可以继续接收连接，那么操作系统能继续接收的最大连接数就是这个队列长度，可以通过 acceptcount 参数配置，默认是 100。\n * serversocketchannel 被设置成阻塞模式，也就是说它是以阻塞的方式接收连接的。serversocketchannel 通过 accept() 接受新的连接，accept() 方法返回获得 socketchannel 对象，然后将 socketchannel 对象封装在一个 pollerevent 对象中，并将 pollerevent 对象压入 poller 的 queue 里，这是个典型的生产者 - 消费者模式，acceptor 与 poller 线程之间通过 queue 通信。\n\n\n# 1.3. poller\n\npoller 本质是一个 selector，它内部维护一个 queue。\n\nprivate final synchronizedqueue<pollerevent> events = new synchronizedqueue<>();\n\n\nsynchronizedqueue 的核心方法都使用了 synchronized 关键字进行修饰，用来保证同一时刻只有一个线程进行读写。\n\n使用 synchronizedqueue，意味着同一时刻只有一个 acceptor 线程对队列进行读写；同时有多个 poller 线程在运行，每个 poller 线程都有自己的队列。每个 poller 线程可能同时被多个 acceptor 线程调用来注册 pollerevent。同样 poller 的个数可以通过 pollers 参数配置。\n\npoller 不断的通过内部的 selector 对象向内核查询 channel 的状态，一旦可读就生成任务类 socketprocessor 交给 executor 去处理。poller 的另一个重要任务是循环遍历检查自己所管理的 socketchannel 是否已经超时，如果有超时就关闭这个 socketchannel。\n\n\n# 1.4. socketprocessor\n\n我们知道，poller 会创建 socketprocessor 任务类交给线程池处理，而 socketprocessor 实现了 runnable 接口，用来定义 executor 中线程所执行的任务，主要就是调用 http11processor 组件来处理请求。http11processor 读取 channel 的数据来生成 servletrequest 对象，这里请你注意：\n\nhttp11processor 并不是直接读取 channel 的。这是因为 tomcat 支持同步非阻塞 i/o 模型和异步 i/o 模型，在 java api 中，相应的 channel 类也是不一样的，比如有 asynchronoussocketchannel 和 socketchannel，为了对 http11processor 屏蔽这些差异，tomcat 设计了一个包装类叫作 socketwrapper，http11processor 只调用 socketwrapper 的方法去读写数据。\n\n\n# 2. nio2endpoint 组件\n\nnio2endpoint 工作流程跟 nioendpoint 较为相似。\n\n\n\nnio2endpoint 子组件功能说明：\n\n * limitlatch 是连接控制器，它负责控制最大连接数。\n * nio2acceptor 扩展了 acceptor，用异步 i/o 的方式来接收连接，跑在一个单独的线程里，也是一个线程组。nio2acceptor 接收新的连接后，得到一个 asynchronoussocketchannel，nio2acceptor 把 asynchronoussocketchannel 封装成一个 nio2socketwrapper，并创建一个 socketprocessor 任务类交给线程池处理，并且 socketprocessor 持有 nio2socketwrapper 对象。\n * executor 在执行 socketprocessor 时，socketprocessor 的 run 方法会调用 http11processor 来处理请求，http11processor 会通过 nio2socketwrapper 读取和解析请求数据，请求经过容器处理后，再把响应通过 nio2socketwrapper 写出。\n\nnio2endpoint 跟 nioendpoint 的一个明显不同点是，nio2endpoint 中没有 poller 组件，也就是没有 selector。这是为什么呢？因为在异步 i/o 模式下，selector 的工作交给内核来做了。\n\n\n# 2.1. nio2acceptor\n\n和 nioendpint 一样，nio2endpoint 的基本思路是用 limitlatch 组件来控制连接数。\n\n但是 nio2acceptor 的监听连接的过程不是在一个死循环里不断的调 accept 方法，而是通过回调函数来完成的。我们来看看它的连接监听方法：\n\nserversock.accept(null, this);\n\n\n其实就是调用了 accept 方法，注意它的第二个参数是 this，表明 nio2acceptor 自己就是处理连接的回调类，因此 nio2acceptor 实现了 completionhandler 接口。那么它是如何实现 completionhandler 接口的呢？\n\nprotected class nio2acceptor extends acceptor<asynchronoussocketchannel>\n    implements completionhandler<asynchronoussocketchannel, void> {\n\n    @override\n    public void completed(asynchronoussocketchannel socket,\n        void attachment) {\n\n        if (isrunning() && !ispaused()) {\n            if (getmaxconnections() == -1) {\n                // 如果没有连接限制，继续接收新的连接\n                serversock.accept(null, this);\n            } else {\n                // 如果有连接限制，就在线程池里跑 run 方法，run 方法会检查连接数\n                getexecutor().execute(this);\n            }\n            // 处理请求\n            if (!setsocketoptions(socket)) {\n                closesocket(socket);\n            }\n        }\n    }\n}\n\n\n可以看到 completionhandler 的两个模板参数分别是 asynchronousserversocketchannel 和 void，我在前面说过第一个参数就是 accept 方法的返回值，第二个参数是附件类，由用户自己决定，这里为 void。completed 方法的处理逻辑比较简单：\n\n * 如果没有连接限制，继续在本线程中调用 accept 方法接收新的连接。\n * 如果有连接限制，就在线程池里跑 run 方法去接收新的连接。那为什么要跑 run 方法呢，因为在 run 方法里会检查连接数，当连接达到最大数时，线程可能会被 limitlatch 阻塞。为什么要放在线程池里跑呢？这是因为如果放在当前线程里执行，completed 方法可能被阻塞，会导致这个回调方法一直不返回。\n\n接着 completed 方法会调用 setsocketoptions 方法，在这个方法里，会创建 nio2socketwrapper 和 socketprocessor，并交给线程池处理。\n\n\n# 2.2. nio2socketwrapper\n\nnio2socketwrapper 的主要作用是封装 channel，并提供接口给 http11processor 读写数据。讲到这里你是不是有个疑问：http11processor 是不能阻塞等待数据的，按照异步 i/o 的套路，http11processor 在调用 nio2socketwrapper 的 read 方法时需要注册回调类，read 调用会立即返回，问题是立即返回后 http11processor 还没有读到数据， 怎么办呢？这个请求的处理不就失败了吗？\n\n为了解决这个问题，http11processor 是通过 2 次 read 调用来完成数据读取操作的。\n\n * 第一次 read 调用：连接刚刚建立好后，acceptor 创建 socketprocessor 任务类交给线程池去处理，http11processor 在处理请求的过程中，会调用 nio2socketwrapper 的 read 方法发出第一次读请求，同时注册了回调类 readcompletionhandler，因为数据没读到，http11processor 把当前的 nio2socketwrapper 标记为数据不完整。接着 socketprocessor 线程被回收，http11processor 并没有阻塞等待数据。这里请注意，http11processor 维护了一个 nio2socketwrapper 列表，也就是维护了连接的状态。\n * 第二次 read 调用：当数据到达后，内核已经把数据拷贝到 http11processor 指定的 buffer 里，同时回调类 readcompletionhandler 被调用，在这个回调处理方法里会重新创建一个新的 socketprocessor 任务来继续处理这个连接，而这个新的 socketprocessor 任务类持有原来那个 nio2socketwrapper，这一次 http11processor 可以通过 nio2socketwrapper 读取数据了，因为数据已经到了应用层的 buffer。\n\n这个回调类 readcompletionhandler 的源码如下，最关键的一点是，nio2socketwrapper 是作为附件类来传递的，这样在回调函数里能拿到所有的上下文。\n\nthis.readcompletionhandler = new completionhandler<integer, socketwrapperbase<nio2channel>>() {\n    public void completed(integer nbytes, socketwrapperbase<nio2channel> attachment) {\n        ...\n        // 通过附件类 socketwrapper 拿到所有的上下文\n        nio2socketwrapper.this.getendpoint().processsocket(attachment, socketevent.open_read, false);\n    }\n\n    public void failed(throwable exc, socketwrapperbase<nio2channel> attachment) {\n        ...\n    }\n}\n\n\n\n# 3. aprendpoint 组件\n\n我们在使用 tomcat 时，可能会在启动日志里看到这样的提示信息：\n\n> the apr based apache tomcat native library which allows optimal performance in production environments was not found on the java.library.path: ***\n\n这句话的意思就是推荐你去安装 apr 库，可以提高系统性能。\n\napr（apache portable runtime libraries）是 apache 可移植运行时库，它是用 c 语言实现的，其目的是向上层应用程序提供一个跨平台的操作系统接口库。tomcat 可以用它来处理包括文件和网络 i/o，从而提升性能。tomcat 支持的连接器有 nio、nio.2 和 apr。跟 nioendpoint 一样，aprendpoint 也实现了非阻塞 i/o，它们的区别是：nioendpoint 通过调用 java 的 nio api 来实现非阻塞 i/o，而 aprendpoint 是通过 jni 调用 apr 本地库而实现非阻塞 i/o 的。\n\n同样是非阻塞 i/o，为什么 tomcat 会提示使用 apr 本地库的性能会更好呢？这是因为在某些场景下，比如需要频繁与操作系统进行交互，socket 网络通信就是这样一个场景，特别是如果你的 web 应用使用了 tls 来加密传输，我们知道 tls 协议在握手过程中有多次网络交互，在这种情况下 java 跟 c 语言程序相比还是有一定的差距，而这正是 apr 的强项。\n\ntomcat 本身是 java 编写的，为了调用 c 语言编写的 apr，需要通过 jni 方式来调用。jni（java native interface） 是 jdk 提供的一个编程接口，它允许 java 程序调用其他语言编写的程序或者代码库，其实 jdk 本身的实现也大量用到 jni 技术来调用本地 c 程序库。\n\n\n# 3.1. aprendpoint 工作流程\n\n\n\n# 3.1.1. acceptor\n\naccpetor 的功能就是监听连接，接收并建立连接。它的本质就是调用了四个操作系统 api：socket、bind、listen 和 accept。那 java 语言如何直接调用 c 语言 api 呢？答案就是通过 jni。具体来说就是两步：先封装一个 java 类，在里面定义一堆用native 关键字修饰的方法，像下面这样。\n\npublic class socket {\n  ...\n  // 用 native 修饰这个方法，表明这个函数是 c 语言实现\n  public static native long create(int family, int type,\n                                 int protocol, long cont)\n\n  public static native int bind(long sock, long sa);\n\n  public static native int listen(long sock, int backlog);\n\n  public static native long accept(long sock)\n}\n\n\n接着用 c 代码实现这些方法，比如 bind 函数就是这样实现的：\n\n// 注意函数的名字要符合 jni 规范的要求\njniexport jint jnicall\njava_org_apache_tomcat_jni_socket_bind(jnienv *e, jlong sock,jlong sa)\n\t{\n\t    jint rv = apr_success;\n\t    tcn_socket_t *s = (tcn_socket_t *）sock;\n\t    apr_sockaddr_t *a = (apr_sockaddr_t *) sa;\n\n        // 调用 apr 库自己实现的 bind 函数\n\t    rv = (jint)apr_socket_bind(s->sock, a);\n\t    return rv;\n\t}\n\n\n专栏里我就不展开 jni 的细节了，你可以扩展阅读获得更多信息和例子。我们要注意的是函数名字要符合 jni 的规范，以及 java 和 c 语言如何互相传递参数，比如在 c 语言有指针，java 没有指针的概念，所以在 java 中用 long 类型来表示指针。aprendpoint 的 acceptor 组件就是调用了 apr 实现的四个 api。\n\n# 3.1.2. poller\n\nacceptor 接收到一个新的 socket 连接后，按照 nioendpoint 的实现，它会把这个 socket 交给 poller 去查询 i/o 事件。aprendpoint 也是这样做的，不过 aprendpoint 的 poller 并不是调用 java nio 里的 selector 来查询 socket 的状态，而是通过 jni 调用 apr 中的 poll 方法，而 apr 又是调用了操作系统的 epoll api 来实现的。\n\n这里有个特别的地方是在 aprendpoint 中，我们可以配置一个叫deferaccept的参数，它对应的是 tcp 协议中的tcp_defer_accept，设置这个参数后，当 tcp 客户端有新的连接请求到达时，tcp 服务端先不建立连接，而是再等等，直到客户端有请求数据发过来时再建立连接。这样的好处是服务端不需要用 selector 去反复查询请求数据是否就绪。\n\n这是一种 tcp 协议层的优化，不是每个操作系统内核都支持，因为 java 作为一种跨平台语言，需要屏蔽各种操作系统的差异，因此并没有把这个参数提供给用户；但是对于 apr 来说，它的目的就是尽可能提升性能，因此它向用户暴露了这个参数。\n\n\n# 3.2. apr 提升性能的秘密\n\napr 连接器之所以能提高 tomcat 的性能，除了 apr 本身是 c 程序库之外，还有哪些提速的秘密呢？\n\njvm 堆 vs 本地内存\n\n我们知道 java 的类实例一般在 jvm 堆上分配，而 java 是通过 jni 调用 c 代码来实现 socket 通信的，那么 c 代码在运行过程中需要的内存又是从哪里分配的呢？c 代码能否直接操作 java 堆？\n\n为了回答这些问题，我先来说说 jvm 和用户进程的关系。如果你想运行一个 java 类文件，可以用下面的 java 命令来执行。\n\njava my.class\n\n\n这个命令行中的java其实是一个可执行程序，这个程序会创建 jvm 来加载和运行你的 java 类。操作系统会创建一个进程来执行这个java可执行程序，而每个进程都有自己的虚拟地址空间，jvm 用到的内存（包括堆、栈和方法区）就是从进程的虚拟地址空间上分配的。请你注意的是，jvm 内存只是进程空间的一部分，除此之外进程空间内还有代码段、数据段、内存映射区、内核空间等。从 jvm 的角度看，jvm 内存之外的部分叫作本地内存，c 程序代码在运行过程中用到的内存就是本地内存中分配的。下面我们通过一张图来理解一下。\n\n\n\ntomcat 的 endpoint 组件在接收网络数据时需要预先分配好一块 buffer，所谓的 buffer 就是字节数组byte[]，java 通过 jni 调用把这块 buffer 的地址传给 c 代码，c 代码通过操作系统 api 读取 socket 并把数据填充到这块 buffer。java nio api 提供了两种 buffer 来接收数据：heapbytebuffer 和 directbytebuffer，下面的代码演示了如何创建两种 buffer。\n\n// 分配 heapbytebuffer\nbytebuffer buf = bytebuffer.allocate(1024);\n\n// 分配 directbytebuffer\nbytebuffer buf = bytebuffer.allocatedirect(1024);\n\n\n创建好 buffer 后直接传给 channel 的 read 或者 write 函数，最终这块 buffer 会通过 jni 调用传递给 c 程序。\n\n// 将 buf 作为 read 函数的参数\nint bytesread = socketchannel.read(buf);\n\n\n那 heapbytebuffer 和 directbytebuffer 有什么区别呢？heapbytebuffer 对象本身在 jvm 堆上分配，并且它持有的字节数组byte[]也是在 jvm 堆上分配。但是如果用heapbytebuffer来接收网络数据，需要把数据从内核先拷贝到一个临时的本地内存，再从临时本地内存拷贝到 jvm 堆，而不是直接从内核拷贝到 jvm 堆上。这是为什么呢？这是因为数据从内核拷贝到 jvm 堆的过程中，jvm 可能会发生 gc，gc 过程中对象可能会被移动，也就是说 jvm 堆上的字节数组可能会被移动，这样的话 buffer 地址就失效了。如果这中间经过本地内存中转，从本地内存到 jvm 堆的拷贝过程中 jvm 可以保证不做 gc。\n\n如果使用 heapbytebuffer，你会发现 jvm 堆和内核之间多了一层中转，而 directbytebuffer 用来解决这个问题，directbytebuffer 对象本身在 jvm 堆上，但是它持有的字节数组不是从 jvm 堆上分配的，而是从本地内存分配的。directbytebuffer 对象中有个 long 类型字段 address，记录着本地内存的地址，这样在接收数据的时候，直接把这个本地内存地址传递给 c 程序，c 程序会将网络数据从内核拷贝到这个本地内存，jvm 可以直接读取这个本地内存，这种方式比 heapbytebuffer 少了一次拷贝，因此一般来说它的速度会比 heapbytebuffer 快好几倍。你可以通过上面的图加深理解。\n\ntomcat 中的 aprendpoint 就是通过 directbytebuffer 来接收数据的，而 nioendpoint 和 nio2endpoint 是通过 heapbytebuffer 来接收数据的。你可能会问，nioendpoint 和 nio2endpoint 为什么不用 directbytebuffer 呢？这是因为本地内存不好管理，发生内存泄漏难以定位，从稳定性考虑，nioendpoint 和 nio2endpoint 没有去冒这个险。\n\n# 3.2.1. sendfile\n\n我们再来考虑另一个网络通信的场景，也就是静态文件的处理。浏览器通过 tomcat 来获取一个 html 文件，而 tomcat 的处理逻辑无非是两步：\n\n 1. 从磁盘读取 html 到内存。\n 2. 将这段内存的内容通过 socket 发送出去。\n\n但是在传统方式下，有很多次的内存拷贝：\n\n * 读取文件时，首先是内核把文件内容读取到内核缓冲区。\n * 如果使用 heapbytebuffer，文件数据从内核到 jvm 堆内存需要经过本地内存中转。\n * 同样在将文件内容推入网络时，从 jvm 堆到内核缓冲区需要经过本地内存中转。\n * 最后还需要把文件从内核缓冲区拷贝到网卡缓冲区。\n\n从下面的图你会发现这个过程有 6 次内存拷贝，并且 read 和 write 等系统调用将导致进程从用户态到内核态的切换，会耗费大量的 cpu 和内存资源。\n\n\n\n而 tomcat 的 aprendpoint 通过操作系统层面的 sendfile 特性解决了这个问题，sendfile 系统调用方式非常简洁。\n\nsendfile(socket, file, len);\n\n\n它带有两个关键参数：socket 和文件句柄。将文件从磁盘写入 socket 的过程只有两步：\n\n第一步：将文件内容读取到内核缓冲区。\n\n第二步：数据并没有从内核缓冲区复制到 socket 关联的缓冲区，只有记录数据位置和长度的描述符被添加到 socket 缓冲区中；接着把数据直接从内核缓冲区传递给网卡。这个过程你可以看下面的图。\n\n\n\n\n# 4. executor 组件\n\n为了提高处理能力和并发度，web 容器一般会把处理请求的工作放到线程池里来执行，tomcat 扩展了原生的 java 线程池，来满足 web 容器高并发的需求。\n\n\n# 4.1. tomcat 定制线程池\n\ntomcat 的线程池也是一个定制版的 threadpoolexecutor。tomcat 传入的参数是这样的：\n\n// 定制版的任务队列\ntaskqueue = new taskqueue(maxqueuesize);\n\n// 定制版的线程工厂\ntaskthreadfactory tf = new taskthreadfactory(nameprefix,daemon,getthreadpriority());\n\n// 定制版的线程池\nexecutor = new threadpoolexecutor(getminsparethreads(), getmaxthreads(), maxidletime, timeunit.milliseconds,taskqueue, tf);\n\n\n其中的两个关键点：\n\n * tomcat 有自己的定制版任务队列和线程工厂，并且可以限制任务队列的长度，它的最大长度是 maxqueuesize。\n * tomcat 对线程数也有限制，设置了核心线程数（minsparethreads）和最大线程池数（maxthreads）。\n\n除了资源限制以外，tomcat 线程池还定制自己的任务处理流程。我们知道 java 原生线程池的任务处理逻辑比较简单：\n\n 1. 前 corepoolsize 个任务时，来一个任务就创建一个新线程。\n 2. 后面再来任务，就把任务添加到任务队列里让所有的线程去抢，如果队列满了就创建临时线程。\n 3. 如果总线程数达到 maximumpoolsize，执行拒绝策略。\n\ntomcat 线程池扩展了原生的 threadpoolexecutor，通过重写 execute 方法实现了自己的任务处理逻辑：\n\n 1. 前 corepoolsize 个任务时，来一个任务就创建一个新线程。\n 2. 再来任务的话，就把任务添加到任务队列里让所有的线程去抢，如果队列满了就创建临时线程。\n 3. 如果总线程数达到 maximumpoolsize，则继续尝试把任务添加到任务队列中去。\n 4. 如果缓冲队列也满了，插入失败，执行拒绝策略。\n\n观察 tomcat 线程池和 java 原生线程池的区别，其实就是在第 3 步，tomcat 在线程总数达到最大数时，不是立即执行拒绝策略，而是再尝试向任务队列添加任务，添加失败后再执行拒绝策略。那具体如何实现呢，其实很简单，我们来看一下 tomcat 线程池的 execute 方法的核心代码。\n\npublic class threadpoolexecutor extends java.util.concurrent.threadpoolexecutor {\n\n  ...\n\n  public void execute(runnable command, long timeout, timeunit unit) {\n      submittedcount.incrementandget();\n      try {\n          // 调用 java 原生线程池的 execute 去执行任务\n          super.execute(command);\n      } catch (rejectedexecutionexception rx) {\n         // 如果总线程数达到 maximumpoolsize，java 原生线程池执行拒绝策略\n          if (super.getqueue() instanceof taskqueue) {\n              final taskqueue queue = (taskqueue)super.getqueue();\n              try {\n                  // 继续尝试把任务放到任务队列中去\n                  if (!queue.force(command, timeout, unit)) {\n                      submittedcount.decrementandget();\n                      // 如果缓冲队列也满了，插入失败，执行拒绝策略。\n                      throw new rejectedexecutionexception("...");\n                  }\n              }\n          }\n      }\n}\n\n\n从这个方法你可以看到，tomcat 线程池的 execute 方法会调用 java 原生线程池的 execute 去执行任务，如果总线程数达到 maximumpoolsize，java 原生线程池的 execute 方法会抛出 rejectedexecutionexception 异常，但是这个异常会被 tomcat 线程池的 execute 方法捕获到，并继续尝试把这个任务放到任务队列中去；如果任务队列也满了，再执行拒绝策略。\n\n\n# 4.2. tomcat 定制任务队列\n\n细心的你有没有发现，在 tomcat 线程池的 execute 方法最开始有这么一行：\n\nsubmittedcount.incrementandget();\n\n\n这行代码的意思把 submittedcount 这个原子变量加一，并且在任务执行失败，抛出拒绝异常时，将这个原子变量减一：\n\nsubmittedcount.decrementandget();\n\n\n其实 tomcat 线程池是用这个变量 submittedcount 来维护已经提交到了线程池，但是还没有执行完的任务个数。tomcat 为什么要维护这个变量呢？这跟 tomcat 的定制版的任务队列有关。tomcat 的任务队列 taskqueue 扩展了 java 中的 linkedblockingqueue，我们知道 linkedblockingqueue 默认情况下长度是没有限制的，除非给它一个 capacity。因此 tomcat 给了它一个 capacity，taskqueue 的构造函数中有个整型的参数 capacity，taskqueue 将 capacity 传给父类 linkedblockingqueue 的构造函数。\n\npublic class taskqueue extends linkedblockingqueue<runnable> {\n\n  public taskqueue(int capacity) {\n      super(capacity);\n  }\n  ...\n}\n\n\n这个 capacity 参数是通过 tomcat 的 maxqueuesize 参数来设置的，但问题是默认情况下 maxqueuesize 的值是integer.max_value，等于没有限制，这样就带来一个问题：当前线程数达到核心线程数之后，再来任务的话线程池会把任务添加到任务队列，并且总是会成功，这样永远不会有机会创建新线程了。\n\n为了解决这个问题，taskqueue 重写了 linkedblockingqueue 的 offer 方法，在合适的时机返回 false，返回 false 表示任务添加失败，这时线程池会创建新的线程。那什么是合适的时机呢？请看下面 offer 方法的核心源码：\n\npublic class taskqueue extends linkedblockingqueue<runnable> {\n\n  ...\n   @override\n  // 线程池调用任务队列的方法时，当前线程数肯定已经大于核心线程数了\n  public boolean offer(runnable o) {\n\n      // 如果线程数已经到了最大值，不能创建新线程了，只能把任务添加到任务队列。\n      if (parent.getpoolsize() == parent.getmaximumpoolsize())\n          return super.offer(o);\n\n      // 执行到这里，表明当前线程数大于核心线程数，并且小于最大线程数。\n      // 表明是可以创建新线程的，那到底要不要创建呢？分两种情况：\n\n      //1. 如果已提交的任务数小于当前线程数，表示还有空闲线程，无需创建新线程\n      if (parent.getsubmittedcount()<=(parent.getpoolsize()))\n          return super.offer(o);\n\n      //2. 如果已提交的任务数大于当前线程数，线程不够用了，返回 false 去创建新线程\n      if (parent.getpoolsize()<parent.getmaximumpoolsize())\n          return false;\n\n      // 默认情况下总是把任务添加到任务队列\n      return super.offer(o);\n  }\n\n}\n\n\n从上面的代码我们看到，只有当前线程数大于核心线程数、小于最大线程数，并且已提交的任务个数大于当前线程数时，也就是说线程不够用了，但是线程数又没达到极限，才会去创建新的线程。这就是为什么 tomcat 需要维护已提交任务数这个变量，它的目的就是在任务队列的长度无限制的情况下，让线程池有机会创建新的线程。\n\n当然默认情况下 tomcat 的任务队列是没有限制的，你可以通过设置 maxqueuesize 参数来限制任务队列的长度。\n\n\n# 5. websocket 组件\n\nhttp 协议是“请求 - 响应”模式，浏览器必须先发请求给服务器，服务器才会响应这个请求。也就是说，服务器不会主动发送数据给浏览器。\n\n对于实时性要求比较的高的应用，比如在线游戏、股票基金实时报价和在线协同编辑等，浏览器需要实时显示服务器上最新的数据，因此出现了 ajax 和 comet 技术。ajax 本质上还是轮询，而 comet 是在 http 长连接的基础上做了一些 hack，但是它们的实时性不高，另外频繁的请求会给服务器带来压力，也会浪费网络流量和带宽。于是 html5 推出了 websocket 标准，使得浏览器和服务器之间任何一方都可以主动发消息给对方，这样服务器有新数据时可以主动推送给浏览器。\n\ntomcat 如何支持 websocket？简单来说，tomcat 做了两件事：\n\n * endpoint 加载\n * websocket 请求处理\n\n\n# 5.1. websocket 加载\n\ntomcat 的 websocket 加载是通过 sci 机制完成的。sci 全称 servletcontainerinitializer，是 servlet 3.0 规范中定义的用来接收 web 应用启动事件的接口。那为什么要监听 servlet 容器的启动事件呢？因为这样我们有机会在 web 应用启动时做一些初始化工作，比如 websocket 需要扫描和加载 endpoint 类。sci 的使用也比较简单，将实现 servletcontainerinitializer 接口的类增加 handlestypes 注解，并且在注解内指定的一系列类和接口集合。比如 tomcat 为了扫描和加载 endpoint 而定义的 sci 类如下：\n\n@handlestypes({serverendpoint.class, serverapplicationconfig.class, endpoint.class})\npublic class wssci implements servletcontainerinitializer {\n\n  public void onstartup(set<class<?>> clazzes, servletcontext ctx) throws servletexception {\n  ...\n  }\n}\n\n\n一旦定义好了 sci，tomcat 在启动阶段扫描类时，会将 handlestypes 注解中指定的类都扫描出来，作为 sci 的 onstartup 方法的参数，并调用 sci 的 onstartup 方法。注意到 wssci 的 handlestypes 注解中定义了serverendpoint.class、serverapplicationconfig.class和endpoint.class，因此在 tomcat 的启动阶段会将这些类的类实例（注意不是对象实例）传递给 wssci 的 onstartup 方法。那么 wssci 的 onstartup 方法又做了什么事呢？\n\n它会构造一个 websocketcontainer 实例，你可以把 websocketcontainer 理解成一个专门处理 websocket 请求的endpoint 容器。也就是说 tomcat 会把扫描到的 endpoint 子类和添加了注解@serverendpoint的类注册到这个容器中，并且这个容器还维护了 url 到 endpoint 的映射关系，这样通过请求 url 就能找到具体的 endpoint 来处理 websocket 请求。\n\n\n# 5.2. websocket 请求处理\n\ntomcat 用 protocolhandler 组件屏蔽应用层协议的差异，其中 protocolhandler 中有两个关键组件：endpoint 和 processor。需要注意，这里的 endpoint 跟上文提到的 websocket 中的 endpoint 完全是两回事，连接器中的 endpoint 组件用来处理 i/o 通信。websocket 本质就是一个应用层协议，因此不能用 httpprocessor 来处理 websocket 请求，而要用专门 processor 来处理，而在 tomcat 中这样的 processor 叫作 upgradeprocessor。\n\n为什么叫 upgrade processor 呢？这是因为 tomcat 是将 http 协议升级成 websocket 协议的。\n\nwebsocket 是通过 http 协议来进行握手的，因此当 websocket 的握手请求到来时，httpprotocolhandler 首先接收到这个请求，在处理这个 http 请求时，tomcat 通过一个特殊的 filter 判断该当前 http 请求是否是一个 websocket upgrade 请求（即包含upgrade: websocket的 http 头信息），如果是，则在 http 响应里添加 websocket 相关的响应头信息，并进行协议升级。具体来说就是用 upgradeprotocolhandler 替换当前的 httpprotocolhandler，相应的，把当前 socket 的 processor 替换成 upgradeprocessor，同时 tomcat 会创建 websocket session 实例和 endpoint 实例，并跟当前的 websocket 连接一一对应起来。这个 websocket 连接不会立即关闭，并且在请求处理中，不再使用原有的 httpprocessor，而是用专门的 upgradeprocessor，upgradeprocessor 最终会调用相应的 endpoint 实例来处理请求。\n\n\n\n你可以看到，tomcat 对 websocket 请求的处理没有经过 servlet 容器，而是通过 upgradeprocessor 组件直接把请求发到 serverendpoint 实例，并且 tomcat 的 websocket 实现不需要关注具体 i/o 模型的细节，从而实现了与具体 i/o 方式的解耦。\n\n\n# 6. 参考资料\n\n * 官方\n   * tomcat 官方网站\n   * tomcat wiki\n   * tomee 官方网站\n * 教程\n   * 深入拆解 tomcat & jetty',charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Tomcat容器",frontmatter:{title:"Tomcat容器",date:"2022-02-17T22:34:30.000Z",order:3,categories:["Java","JavaEE","服务器","Tomcat"],tags:["Java","JavaWeb","服务器","Tomcat"],permalink:"/pages/d5076a/"},regularPath:"/01.Java/02.JavaEE/02.%E6%9C%8D%E5%8A%A1%E5%99%A8/01.Tomcat/03.Tomcat%E5%AE%B9%E5%99%A8.html",relativePath:"01.Java/02.JavaEE/02.服务器/01.Tomcat/03.Tomcat容器.md",key:"v-372bea40",path:"/pages/d5076a/",headers:[{level:2,title:"Tomcat 实现热部署和热加载",slug:"tomcat-实现热部署和热加载",normalizedTitle:"tomcat 实现热部署和热加载",charIndex:16},{level:3,title:"ContainerBackgroundProcessor 实现",slug:"containerbackgroundprocessor-实现",normalizedTitle:"containerbackgroundprocessor 实现",charIndex:732},{level:3,title:"backgroundProcess 方法",slug:"backgroundprocess-方法",normalizedTitle:"backgroundprocess 方法",charIndex:1101},{level:3,title:"Tomcat 热加载",slug:"tomcat-热加载",normalizedTitle:"tomcat 热加载",charIndex:3363},{level:3,title:"Tomcat 热部署",slug:"tomcat-热部署",normalizedTitle:"tomcat 热部署",charIndex:4898},{level:2,title:"Tomcat 的类加载机制",slug:"tomcat-的类加载机制",normalizedTitle:"tomcat 的类加载机制",charIndex:6049},{level:3,title:"findClass 方法",slug:"findclass-方法",normalizedTitle:"findclass 方法",charIndex:6213},{level:3,title:"loadClass 方法",slug:"loadclass-方法",normalizedTitle:"loadclass 方法",charIndex:7015},{level:3,title:"Tomcat 实现应用隔离",slug:"tomcat-实现应用隔离",normalizedTitle:"tomcat 实现应用隔离",charIndex:9756},{level:4,title:"WebAppClassLoader",slug:"webappclassloader",normalizedTitle:"webappclassloader",charIndex:6080},{level:4,title:"SharedClassLoader",slug:"sharedclassloader",normalizedTitle:"sharedclassloader",charIndex:10577},{level:4,title:"CatalinaClassloader",slug:"catalinaclassloader",normalizedTitle:"catalinaclassloader",charIndex:10953},{level:4,title:"CommonClassLoader",slug:"commonclassloader",normalizedTitle:"commonclassloader",charIndex:11185},{level:2,title:"Tomcat 实现 Servlet 规范",slug:"tomcat-实现-servlet-规范",normalizedTitle:"tomcat 实现 servlet 规范",charIndex:11493},{level:3,title:"Servlet 管理",slug:"servlet-管理",normalizedTitle:"servlet 管理",charIndex:11984},{level:3,title:"Filter 管理",slug:"filter-管理",normalizedTitle:"filter 管理",charIndex:14030},{level:3,title:"Listener 管理",slug:"listener-管理",normalizedTitle:"listener 管理",charIndex:16214},{level:2,title:"Tomcat 支持异步 Servlet",slug:"tomcat-支持异步-servlet",normalizedTitle:"tomcat 支持异步 servlet",charIndex:17460},{level:3,title:"异步示例",slug:"异步示例",normalizedTitle:"异步示例",charIndex:17484},{level:3,title:"异步 Servlet 原理",slug:"异步-servlet-原理",normalizedTitle:"异步 servlet 原理",charIndex:18733},{level:4,title:"startAsync 方法",slug:"startasync-方法",normalizedTitle:"startasync 方法",charIndex:18426},{level:4,title:"complete 方法",slug:"complete-方法",normalizedTitle:"complete 方法",charIndex:18208},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:22919}],headersStr:"Tomcat 实现热部署和热加载 ContainerBackgroundProcessor 实现 backgroundProcess 方法 Tomcat 热加载 Tomcat 热部署 Tomcat 的类加载机制 findClass 方法 loadClass 方法 Tomcat 实现应用隔离 WebAppClassLoader SharedClassLoader CatalinaClassloader CommonClassLoader Tomcat 实现 Servlet 规范 Servlet 管理 Filter 管理 Listener 管理 Tomcat 支持异步 Servlet 异步示例 异步 Servlet 原理 startAsync 方法 complete 方法 参考资料",content:'# Tomcat 容器\n\n\n# Tomcat 实现热部署和热加载\n\n * 热加载的实现方式是 Web 容器启动一个后台线程，定期检测类文件的变化，如果有变化，就重新加载类，在这个过程中不会清空 Session ，一般用在开发环境。\n * 热部署原理类似，也是由后台线程定时检测 Web 应用的变化，但它会重新加载整个 Web 应用。这种方式会清空 Session，比热加载更加干净、彻底，一般用在生产环境。\n\nTomcat 通过开启后台线程，使得各个层次的容器组件都有机会完成一些周期性任务。Tomcat 是基于 ScheduledThreadPoolExecutor 实现周期性任务的：\n\nbgFuture = exec.scheduleWithFixedDelay(\n              new ContainerBackgroundProcessor(),// 要执行的 Runnable\n              backgroundProcessorDelay, // 第一次执行延迟多久\n              backgroundProcessorDelay, // 之后每次执行间隔多久\n              TimeUnit.SECONDS);        // 时间单位\n\n\n第一个参数就是要周期性执行的任务类 ContainerBackgroundProcessor，它是一个 Runnable，同时也是 ContainerBase 的内部类，ContainerBase 是所有容器组件的基类，我们来回忆一下容器组件有哪些，有 Engine、Host、Context 和 Wrapper 等，它们具有父子关系。\n\n\n# ContainerBackgroundProcessor 实现\n\n我们接来看 ContainerBackgroundProcessor 具体是如何实现的。\n\nprotected class ContainerBackgroundProcessor implements Runnable {\n\n    @Override\n    public void run() {\n        // 请注意这里传入的参数是 " 宿主类 " 的实例\n        processChildren(ContainerBase.this);\n    }\n\n    protected void processChildren(Container container) {\n        try {\n            //1. 调用当前容器的 backgroundProcess 方法。\n            container.backgroundProcess();\n\n            //2. 遍历所有的子容器，递归调用 processChildren，\n            // 这样当前容器的子孙都会被处理\n            Container[] children = container.findChildren();\n            for (int i = 0; i < children.length; i++) {\n            // 这里请你注意，容器基类有个变量叫做 backgroundProcessorDelay，如果大于 0，表明子容器有自己的后台线程，无需父容器来调用它的 processChildren 方法。\n                if (children[i].getBackgroundProcessorDelay() <= 0) {\n                    processChildren(children[i]);\n                }\n            }\n        } catch (Throwable t) { ... }\n\n\n上面的代码逻辑也是比较清晰的，首先 ContainerBackgroundProcessor 是一个 Runnable，它需要实现 run 方法，它的 run 很简单，就是调用了 processChildren 方法。这里有个小技巧，它把“宿主类”，也就是ContainerBase 的类实例当成参数传给了 run 方法。\n\n而在 processChildren 方法里，就做了两步：调用当前容器的 backgroundProcess 方法，以及递归调用子孙的 backgroundProcess 方法。请你注意 backgroundProcess 是 Container 接口中的方法，也就是说所有类型的容器都可以实现这个方法，在这个方法里完成需要周期性执行的任务。\n\n这样的设计意味着什么呢？我们只需要在顶层容器，也就是 Engine 容器中启动一个后台线程，那么这个线程不但会执行 Engine 容器的周期性任务，它还会执行所有子容器的周期性任务。\n\n\n# backgroundProcess 方法\n\n上述代码都是在基类 ContainerBase 中实现的，那具体容器类需要做什么呢？其实很简单，如果有周期性任务要执行，就实现 backgroundProcess 方法；如果没有，就重用基类 ContainerBase 的方法。ContainerBase 的 backgroundProcess 方法实现如下：\n\npublic void backgroundProcess() {\n\n    //1. 执行容器中 Cluster 组件的周期性任务\n    Cluster cluster = getClusterInternal();\n    if (cluster != null) {\n        cluster.backgroundProcess();\n    }\n\n    //2. 执行容器中 Realm 组件的周期性任务\n    Realm realm = getRealmInternal();\n    if (realm != null) {\n        realm.backgroundProcess();\n   }\n\n   //3. 执行容器中 Valve 组件的周期性任务\n    Valve current = pipeline.getFirst();\n    while (current != null) {\n       current.backgroundProcess();\n       current = current.getNext();\n    }\n\n    //4. 触发容器的 " 周期事件 "，Host 容器的监听器 HostConfig 就靠它来调用\n    fireLifecycleEvent(Lifecycle.PERIODIC_EVENT, null);\n}\n\n\n从上面的代码可以看到，不仅每个容器可以有周期性任务，每个容器中的其他通用组件，比如跟集群管理有关的 Cluster 组件、跟安全管理有关的 Realm 组件都可以有自己的周期性任务。\n\n我在前面的专栏里提到过，容器之间的链式调用是通过 Pipeline-Valve 机制来实现的，从上面的代码你可以看到容器中的 Valve 也可以有周期性任务，并且被 ContainerBase 统一处理。\n\n请你特别注意的是，在 backgroundProcess 方法的最后，还触发了容器的“周期事件”。我们知道容器的生命周期事件有初始化、启动和停止等，那“周期事件”又是什么呢？它跟生命周期事件一样，是一种扩展机制，你可以这样理解：\n\n又一段时间过去了，容器还活着，你想做点什么吗？如果你想做点什么，就创建一个监听器来监听这个“周期事件”，事件到了我负责调用你的方法。\n\n总之，有了 ContainerBase 中的后台线程和 backgroundProcess 方法，各种子容器和通用组件不需要各自弄一个后台线程来处理周期性任务，这样的设计显得优雅和整洁。\n\n\n# Tomcat 热加载\n\n有了 ContainerBase 的周期性任务处理“框架”，作为具体容器子类，只需要实现自己的周期性任务就行。而 Tomcat 的热加载，就是在 Context 容器中实现的。Context 容器的 backgroundProcess 方法是这样实现的：\n\npublic void backgroundProcess() {\n\n    //WebappLoader 周期性的检查 WEB-INF/classes 和 WEB-INF/lib 目录下的类文件\n    Loader loader = getLoader();\n    if (loader != null) {\n        loader.backgroundProcess();\n    }\n\n    //Session 管理器周期性的检查是否有过期的 Session\n    Manager manager = getManager();\n    if (manager != null) {\n        manager.backgroundProcess();\n    }\n\n    // 周期性的检查静态资源是否有变化\n    WebResourceRoot resources = getResources();\n    if (resources != null) {\n        resources.backgroundProcess();\n    }\n\n    // 调用父类 ContainerBase 的 backgroundProcess 方法\n    super.backgroundProcess();\n}\n\n\n从上面的代码我们看到 Context 容器通过 WebappLoader 来检查类文件是否有更新，通过 Session 管理器来检查是否有 Session 过期，并且通过资源管理器来检查静态资源是否有更新，最后还调用了父类 ContainerBase 的 backgroundProcess 方法。\n\n这里我们要重点关注，WebappLoader 是如何实现热加载的，它主要是调用了 Context 容器的 reload 方法，而 Context 的 reload 方法比较复杂，总结起来，主要完成了下面这些任务：\n\n 1. 停止和销毁 Context 容器及其所有子容器，子容器其实就是 Wrapper，也就是说 Wrapper 里面 Servlet 实例也被销毁了。\n 2. 停止和销毁 Context 容器关联的 Listener 和 Filter。\n 3. 停止和销毁 Context 下的 Pipeline 和各种 Valve。\n 4. 停止和销毁 Context 的类加载器，以及类加载器加载的类文件资源。\n 5. 启动 Context 容器，在这个过程中会重新创建前面四步被销毁的资源。\n\n在这个过程中，类加载器发挥着关键作用。一个 Context 容器对应一个类加载器，类加载器在销毁的过程中会把它加载的所有类也全部销毁。Context 容器在启动过程中，会创建一个新的类加载器来加载新的类文件。\n\n在 Context 的 reload 方法里，并没有调用 Session 管理器的 distroy 方法，也就是说这个 Context 关联的 Session 是没有销毁的。你还需要注意的是，Tomcat 的热加载默认是关闭的，你需要在 conf 目录下的 Context.xml 文件中设置 reloadable 参数来开启这个功能，像下面这样：\n\n<Context reloadable="true"/>\n\n\n\n# Tomcat 热部署\n\n我们再来看看热部署，热部署跟热加载的本质区别是，热部署会重新部署 Web 应用，原来的 Context 对象会整个被销毁掉，因此这个 Context 所关联的一切资源都会被销毁，包括 Session。\n\n那么 Tomcat 热部署又是由哪个容器来实现的呢？应该不是由 Context，因为热部署过程中 Context 容器被销毁了，那么这个重担就落在 Host 身上了，因为它是 Context 的父容器。\n\n跟 Context 不一样，Host 容器并没有在 backgroundProcess 方法中实现周期性检测的任务，而是通过监听器 HostConfig 来实现的，HostConfig 就是前面提到的“周期事件”的监听器，那“周期事件”达到时，HostConfig 会做什么事呢？\n\npublic void lifecycleEvent(LifecycleEvent event) {\n    // 执行 check 方法。\n    if (event.getType().equals(Lifecycle.PERIODIC_EVENT)) {\n        check();\n    }\n}\n\n\n它执行了 check 方法，我们接着来看 check 方法里做了什么。\n\nprotected void check() {\n\n    if (host.getAutoDeploy()) {\n        // 检查这个 Host 下所有已经部署的 Web 应用\n        DeployedApplication[] apps =\n            deployed.values().toArray(new DeployedApplication[0]);\n\n        for (int i = 0; i < apps.length; i++) {\n            // 检查 Web 应用目录是否有变化\n            checkResources(apps[i], false);\n        }\n\n        // 执行部署\n        deployApps();\n    }\n}\n\n\n其实 HostConfig 会检查 webapps 目录下的所有 Web 应用：\n\n * 如果原来 Web 应用目录被删掉了，就把相应 Context 容器整个销毁掉。\n * 是否有新的 Web 应用目录放进来了，或者有新的 WAR 包放进来了，就部署相应的 Web 应用。\n\n因此 HostConfig 做的事情都是比较“宏观”的，它不会去检查具体类文件或者资源文件是否有变化，而是检查 Web 应用目录级别的变化。\n\n\n# Tomcat 的类加载机制\n\nTomcat 的自定义类加载器 WebAppClassLoader 打破了双亲委派机制，它首先自己尝试去加载某个类，如果找不到再代理给父类加载器，其目的是优先加载 Web 应用自己定义的类。具体实现就是重写 ClassLoader 的两个方法：findClass 和 loadClass。\n\n\n# findClass 方法\n\n我们先来看看 findClass 方法的实现，为了方便理解和阅读，我去掉了一些细节：\n\npublic Class<?> findClass(String name) throws ClassNotFoundException {\n    ...\n\n    Class<?> clazz = null;\n    try {\n            //1. 先在 Web 应用目录下查找类\n            clazz = findClassInternal(name);\n    }  catch (RuntimeException e) {\n           throw e;\n       }\n\n    if (clazz == null) {\n    try {\n            //2. 如果在本地目录没有找到，交给父加载器去查找\n            clazz = super.findClass(name);\n    }  catch (RuntimeException e) {\n           throw e;\n       }\n\n    //3. 如果父类也没找到，抛出 ClassNotFoundException\n    if (clazz == null) {\n        throw new ClassNotFoundException(name);\n     }\n\n    return clazz;\n}\n\n\n在 findClass 方法里，主要有三个步骤：\n\n 1. 先在 Web 应用本地目录下查找要加载的类。\n 2. 如果没有找到，交给父加载器去查找，它的父加载器就是上面提到的系统类加载器 AppClassLoader。\n 3. 如何父加载器也没找到这个类，抛出 ClassNotFound 异常。\n\n\n# loadClass 方法\n\n接着我们再来看 Tomcat 类加载器的 loadClass 方法的实现，同样我也去掉了一些细节：\n\npublic Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {\n\n    synchronized (getClassLoadingLock(name)) {\n\n        Class<?> clazz = null;\n\n        //1. 先在本地 cache 查找该类是否已经加载过\n        clazz = findLoadedClass0(name);\n        if (clazz != null) {\n            if (resolve)\n                resolveClass(clazz);\n            return clazz;\n        }\n\n        //2. 从系统类加载器的 cache 中查找是否加载过\n        clazz = findLoadedClass(name);\n        if (clazz != null) {\n            if (resolve)\n                resolveClass(clazz);\n            return clazz;\n        }\n\n        // 3. 尝试用 ExtClassLoader 类加载器类加载，为什么？\n        ClassLoader javaseLoader = getJavaseClassLoader();\n        try {\n            clazz = javaseLoader.loadClass(name);\n            if (clazz != null) {\n                if (resolve)\n                    resolveClass(clazz);\n                return clazz;\n            }\n        } catch (ClassNotFoundException e) {\n            // Ignore\n        }\n\n        // 4. 尝试在本地目录搜索 class 并加载\n        try {\n            clazz = findClass(name);\n            if (clazz != null) {\n                if (resolve)\n                    resolveClass(clazz);\n                return clazz;\n            }\n        } catch (ClassNotFoundException e) {\n            // Ignore\n        }\n\n        // 5. 尝试用系统类加载器 (也就是 AppClassLoader) 来加载\n            try {\n                clazz = Class.forName(name, false, parent);\n                if (clazz != null) {\n                    if (resolve)\n                        resolveClass(clazz);\n                    return clazz;\n                }\n            } catch (ClassNotFoundException e) {\n                // Ignore\n            }\n       }\n\n    //6. 上述过程都加载失败，抛出异常\n    throw new ClassNotFoundException(name);\n}\n\n\nloadClass 方法稍微复杂一点，主要有六个步骤：\n\n 1. 先在本地 Cache 查找该类是否已经加载过，也就是说 Tomcat 的类加载器是否已经加载过这个类。\n 2. 如果 Tomcat 类加载器没有加载过这个类，再看看系统类加载器是否加载过。\n 3. 如果都没有，就让ExtClassLoader去加载，这一步比较关键，目的防止 Web 应用自己的类覆盖 JRE 的核心类。因为 Tomcat 需要打破双亲委派机制，假如 Web 应用里自定义了一个叫 Object 的类，如果先加载这个 Object 类，就会覆盖 JRE 里面的那个 Object 类，这就是为什么 Tomcat 的类加载器会优先尝试用 ExtClassLoader 去加载，因为 ExtClassLoader 会委托给 BootstrapClassLoader 去加载，BootstrapClassLoader 发现自己已经加载了 Object 类，直接返回给 Tomcat 的类加载器，这样 Tomcat 的类加载器就不会去加载 Web 应用下的 Object 类了，也就避免了覆盖 JRE 核心类的问题。\n 4. 如果 ExtClassLoader 加载器加载失败，也就是说 JRE 核心类中没有这类，那么就在本地 Web 应用目录下查找并加载。\n 5. 如果本地目录下没有这个类，说明不是 Web 应用自己定义的类，那么由系统类加载器去加载。这里请你注意，Web 应用是通过Class.forName调用交给系统类加载器的，因为Class.forName的默认加载器就是系统类加载器。\n 6. 如果上述加载过程全部失败，抛出 ClassNotFound 异常。\n\n从上面的过程我们可以看到，Tomcat 的类加载器打破了双亲委派机制，没有一上来就直接委托给父加载器，而是先在本地目录下加载，为了避免本地目录下的类覆盖 JRE 的核心类，先尝试用 JVM 扩展类加载器 ExtClassLoader 去加载。那为什么不先用系统类加载器 AppClassLoader 去加载？很显然，如果是这样的话，那就变成双亲委派机制了，这就是 Tomcat 类加载器的巧妙之处。\n\n\n# Tomcat 实现应用隔离\n\nTomcat 作为 Web 容器，需要解决以下问题：\n\n 1. 如果在 Tomcat 中运行了两个 Web 应用程序，两个 Web 应用中有同名的 Servlet，但是功能不同，Tomcat 需要同时加载和管理这两个同名的 Servlet 类，保证它们不会冲突，因此 Web 应用之间的类需要隔离。\n 2. 两个 Web 应用都依赖同一个第三方的 JAR 包，比如 Spring，那 Spring 的 JAR 包被加载到内存后，Tomcat 要保证这两个 Web 应用能够共享，也就是说 Spring 的 JAR 包只被加载一次，否则随着依赖的第三方 JAR 包增多，JVM 的内存会膨胀。\n 3. 需要隔离 Tomcat 本身的类和 Web 应用的类。\n\n\n\n# WebAppClassLoader\n\n针对第一个问题：\n\n如果使用 JVM 默认 AppClassLoader 来加载 Web 应用，AppClassLoader 只能加载一个 Servlet 类，在加载第二个同名 Servlet 类时，AppClassLoader 会返回第一个 Servlet 类的 Class 实例，这是因为在 AppClassLoader 看来，同名的 Servlet 类只被加载一次。\n\nTomcat 的解决方案是自定义一个类加载器 WebAppClassLoader， 并且给每个 Web 应用创建一个类加载器实例。我们知道，Context 容器组件对应一个 Web 应用，因此，每个 Context 容器负责创建和维护一个 WebAppClassLoader 加载器实例。这背后的原理是，不同的加载器实例加载的类被认为是不同的类，即使它们的类名相同。这就相当于在 Java 虚拟机内部创建了一个个相互隔离的 Java 类空间，每一个 Web 应用都有自己的类空间，Web 应用之间通过各自的类加载器互相隔离。\n\n# SharedClassLoader\n\n针对第二个问题：\n\n本质需求是两个 Web 应用之间怎么共享库类，并且不能重复加载相同的类。我们知道，在双亲委派机制里，各个子加载器都可以通过父加载器去加载类，那么把需要共享的类放到父加载器的加载路径下不就行了吗，应用程序也正是通过这种方式共享 JRE 的核心类。因此 Tomcat 的设计者又加了一个类加载器 SharedClassLoader，作为 WebAppClassLoader 的父加载器，专门来加载 Web 应用之间共享的类。如果 WebAppClassLoader 自己没有加载到某个类，就会委托父加载器 SharedClassLoader 去加载这个类，SharedClassLoader 会在指定目录下加载共享类，之后返回给 WebAppClassLoader，这样共享的问题就解决了。\n\n# CatalinaClassloader\n\n如何隔离 Tomcat 本身的类和 Web 应用的类？\n\n要共享可以通过父子关系，要隔离那就需要兄弟关系了。兄弟关系就是指两个类加载器是平行的，它们可能拥有同一个父加载器，但是两个兄弟类加载器加载的类是隔离的。基于此 Tomcat 又设计一个类加载器 CatalinaClassloader，专门来加载 Tomcat 自身的类。这样设计有个问题，那 Tomcat 和各 Web 应用之间需要共享一些类时该怎么办呢？\n\n# CommonClassLoader\n\n老办法，还是再增加一个 CommonClassLoader，作为 CatalinaClassloader 和 SharedClassLoader 的父加载器。CommonClassLoader 能加载的类都可以被 CatalinaClassLoader 和 SharedClassLoader 使用，而 CatalinaClassLoader 和 SharedClassLoader 能加载的类则与对方相互隔离。WebAppClassLoader 可以使用 SharedClassLoader 加载到的类，但各个 WebAppClassLoader 实例之间相互隔离。\n\n\n# Tomcat 实现 Servlet 规范\n\nServlet 容器最重要的任务就是创建 Servlet 的实例并且调用 Servlet。\n\n一个 Web 应用里往往有多个 Servlet，而在 Tomcat 中一个 Web 应用对应一个 Context 容器，也就是说一个 Context 容器需要管理多个 Servlet 实例。但 Context 容器并不直接持有 Servlet 实例，而是通过子容器 Wrapper 来管理 Servlet，你可以把 Wrapper 容器看作是 Servlet 的包装。\n\n为什么需要 Wrapper 呢？Context 容器直接维护一个 Servlet 数组不就行了吗？这是因为 Servlet 不仅仅是一个类实例，它还有相关的配置信息，比如它的 URL 映射、它的初始化参数，因此设计出了一个包装器，把 Servlet 本身和它相关的数据包起来，没错，这就是面向对象的思想。\n\n除此以外，Servlet 规范中还有两个重要特性：Listener 和 Filter，Tomcat 也需要创建它们的实例，并在合适的时机去调用它们的方法。\n\n\n# Servlet 管理\n\nTomcat 是用 Wrapper 容器来管理 Servlet 的，那 Wrapper 容器具体长什么样子呢？我们先来看看它里面有哪些关键的成员变量：\n\nprotected volatile Servlet instance = null;\n\n\n它拥有一个 Servlet 实例，并且 Wrapper 通过 loadServlet 方法来实例化 Servlet。为了方便你阅读，我简化了代码：\n\npublic synchronized Servlet loadServlet() throws ServletException {\n    Servlet servlet;\n\n    //1. 创建一个 Servlet 实例\n    servlet = (Servlet) instanceManager.newInstance(servletClass);\n\n    //2. 调用了 Servlet 的 init 方法，这是 Servlet 规范要求的\n    initServlet(servlet);\n\n    return servlet;\n}\n\n\n其实 loadServlet 主要做了两件事：创建 Servlet 的实例，并且调用 Servlet 的 init 方法，因为这是 Servlet 规范要求的。\n\n那接下来的问题是，什么时候会调到这个 loadServlet 方法呢？为了加快系统的启动速度，我们往往会采取资源延迟加载的策略，Tomcat 也不例外，默认情况下 Tomcat 在启动时不会加载你的 Servlet，除非你把 Servlet 的loadOnStartup参数设置为true。\n\n这里还需要你注意的是，虽然 Tomcat 在启动时不会创建 Servlet 实例，但是会创建 Wrapper 容器，就好比尽管枪里面还没有子弹，先把枪造出来。那子弹什么时候造呢？是真正需要开枪的时候，也就是说有请求来访问某个 Servlet 时，这个 Servlet 的实例才会被创建。\n\n那 Servlet 是被谁调用的呢？我们回忆一下专栏前面提到过 Tomcat 的 Pipeline-Valve 机制，每个容器组件都有自己的 Pipeline，每个 Pipeline 中有一个 Valve 链，并且每个容器组件有一个 BasicValve（基础阀）。Wrapper 作为一个容器组件，它也有自己的 Pipeline 和 BasicValve，Wrapper 的 BasicValve 叫 StandardWrapperValve。\n\n你可以想到，当请求到来时，Context 容器的 BasicValve 会调用 Wrapper 容器中 Pipeline 中的第一个 Valve，然后会调用到 StandardWrapperValve。我们先来看看它的 invoke 方法是如何实现的，同样为了方便你阅读，我简化了代码：\n\npublic final void invoke(Request request, Response response) {\n\n    //1. 实例化 Servlet\n    servlet = wrapper.allocate();\n\n    //2. 给当前请求创建一个 Filter 链\n    ApplicationFilterChain filterChain =\n        ApplicationFilterFactory.createFilterChain(request, wrapper, servlet);\n\n   //3. 调用这个 Filter 链，Filter 链中的最后一个 Filter 会调用 Servlet\n   filterChain.doFilter(request.getRequest(), response.getResponse());\n\n}\n\n\nStandardWrapperValve 的 invoke 方法比较复杂，去掉其他异常处理的一些细节，本质上就是三步：\n\n * 第一步，创建 Servlet 实例；\n * 第二步，给当前请求创建一个 Filter 链；\n * 第三步，调用这个 Filter 链。\n\n你可能会问，为什么需要给每个请求创建一个 Filter 链？这是因为每个请求的请求路径都不一样，而 Filter 都有相应的路径映射，因此不是所有的 Filter 都需要来处理当前的请求，我们需要根据请求的路径来选择特定的一些 Filter 来处理。\n\n第二个问题是，为什么没有看到调到 Servlet 的 service 方法？这是因为 Filter 链的 doFilter 方法会负责调用 Servlet，具体来说就是 Filter 链中的最后一个 Filter 会负责调用 Servlet。\n\n接下来我们来看 Filter 的实现原理。\n\n\n# Filter 管理\n\n我们知道，跟 Servlet 一样，Filter 也可以在web.xml文件里进行配置，不同的是，Filter 的作用域是整个 Web 应用，因此 Filter 的实例是在 Context 容器中进行管理的，Context 容器用 Map 集合来保存 Filter。\n\nprivate Map<String, FilterDef> filterDefs = new HashMap<>();\n\n\n那上面提到的 Filter 链又是什么呢？Filter 链的存活期很短，它是跟每个请求对应的。一个新的请求来了，就动态创建一个 FIlter 链，请求处理完了，Filter 链也就被回收了。理解它的原理也非常关键，我们还是来看看源码：\n\npublic final class ApplicationFilterChain implements FilterChain {\n\n  //Filter 链中有 Filter 数组，这个好理解\n  private ApplicationFilterConfig[] filters = new ApplicationFilterConfig[0];\n\n  //Filter 链中的当前的调用位置\n  private int pos = 0;\n\n  // 总共有多少了 Filter\n  private int n = 0;\n\n  // 每个 Filter 链对应一个 Servlet，也就是它要调用的 Servlet\n  private Servlet servlet = null;\n\n  public void doFilter(ServletRequest req, ServletResponse res) {\n        internalDoFilter(request,response);\n  }\n\n  private void internalDoFilter(ServletRequest req,\n                                ServletResponse res){\n\n    // 每个 Filter 链在内部维护了一个 Filter 数组\n    if (pos < n) {\n        ApplicationFilterConfig filterConfig = filters[pos++];\n        Filter filter = filterConfig.getFilter();\n\n        filter.doFilter(request, response, this);\n        return;\n    }\n\n    servlet.service(request, response);\n\n}\n\n\n从 ApplicationFilterChain 的源码我们可以看到几个关键信息：\n\n * Filter 链中除了有 Filter 对象的数组，还有一个整数变量 pos，这个变量用来记录当前被调用的 Filter 在数组中的位置。\n * Filter 链中有个 Servlet 实例，这个好理解，因为上面提到了，每个 Filter 链最后都会调到一个 Servlet。\n * Filter 链本身也实现了 doFilter 方法，直接调用了一个内部方法 internalDoFilter。\n * internalDoFilter 方法的实现比较有意思，它做了一个判断，如果当前 Filter 的位置小于 Filter 数组的长度，也就是说 Filter 还没调完，就从 Filter 数组拿下一个 Filter，调用它的 doFilter 方法。否则，意味着所有 Filter 都调到了，就调用 Servlet 的 service 方法。\n\n但问题是，方法体里没看到循环，谁在不停地调用 Filter 链的 doFIlter 方法呢？Filter 是怎么依次调到的呢？\n\n答案是Filter 本身的 doFilter 方法会调用 Filter 链的 doFilter 方法，我们还是来看看代码就明白了：\n\npublic void doFilter(ServletRequest request, ServletResponse response,\n        FilterChain chain){\n\n          ...\n\n          // 调用 Filter 的方法\n          chain.doFilter(request, response);\n\n      }\n\n\n注意 Filter 的 doFilter 方法有个关键参数 FilterChain，就是 Filter 链。并且每个 Filter 在实现 doFilter 时，必须要调用 Filter 链的 doFilter 方法，而 Filter 链中保存当前 FIlter 的位置，会调用下一个 FIlter 的 doFilter 方法，这样链式调用就完成了。\n\nFilter 链跟 Tomcat 的 Pipeline-Valve 本质都是责任链模式，但是在具体实现上稍有不同，你可以细细体会一下。\n\n\n# Listener 管理\n\n我们接着聊 Servlet 规范里 Listener。跟 Filter 一样，Listener 也是一种扩展机制，你可以监听容器内部发生的事件，主要有两类事件：\n\n * 第一类是生命状态的变化，比如 Context 容器启动和停止、Session 的创建和销毁。\n * 第二类是属性的变化，比如 Context 容器某个属性值变了、Session 的某个属性值变了以及新的请求来了等。\n\n我们可以在web.xml配置或者通过注解的方式来添加监听器，在监听器里实现我们的业务逻辑。对于 Tomcat 来说，它需要读取配置文件，拿到监听器类的名字，实例化这些类，并且在合适的时机调用这些监听器的方法。\n\nTomcat 是通过 Context 容器来管理这些监听器的。Context 容器将两类事件分开来管理，分别用不同的集合来存放不同类型事件的监听器：\n\n// 监听属性值变化的监听器\nprivate List<Object> applicationEventListenersList = new CopyOnWriteArrayList<>();\n\n// 监听生命事件的监听器\nprivate Object applicationLifecycleListenersObjects[] = new Object[0];\n\n\n剩下的事情就是触发监听器了，比如在 Context 容器的启动方法里，就触发了所有的 ServletContextListener：\n\n//1. 拿到所有的生命周期监听器\nObject instances[] = getApplicationLifecycleListeners();\n\nfor (int i = 0; i < instances.length; i++) {\n   //2. 判断 Listener 的类型是不是 ServletContextListener\n   if (!(instances[i] instanceof ServletContextListener))\n      continue;\n\n   //3. 触发 Listener 的方法\n   ServletContextListener lr = (ServletContextListener) instances[i];\n   lr.contextInitialized(event);\n}\n\n\n需要注意的是，这里的 ServletContextListener 接口是一种留给用户的扩展机制，用户可以实现这个接口来定义自己的监听器，监听 Context 容器的启停事件。Spring 就是这么做的。ServletContextListener 跟 Tomcat 自己的生命周期事件 LifecycleListener 是不同的。LifecycleListener 定义在生命周期管理组件中，由基类 LifeCycleBase 统一管理。\n\n\n# Tomcat 支持异步 Servlet\n\n\n# 异步示例\n\n@WebServlet(urlPatterns = {"/async"}, asyncSupported = true)\npublic class AsyncServlet extends HttpServlet {\n\n    //Web 应用线程池，用来处理异步 Servlet\n    ExecutorService executor = Executors.newSingleThreadExecutor();\n\n    public void service(HttpServletRequest req, HttpServletResponse resp) {\n        //1. 调用 startAsync 或者异步上下文\n        final AsyncContext ctx = req.startAsync();\n\n       // 用线程池来执行耗时操作\n        executor.execute(new Runnable() {\n\n            @Override\n            public void run() {\n\n                // 在这里做耗时的操作\n                try {\n                    ctx.getResponse().getWriter().println("Handling Async Servlet");\n                } catch (IOException e) {}\n\n                //3. 异步 Servlet 处理完了调用异步上下文的 complete 方法\n                ctx.complete();\n            }\n\n        });\n    }\n}\n\n\n有三个要点：\n\n 1. 通过注解的方式来注册 Servlet，除了 @WebServlet 注解，还需要加上 asyncSupported=true 的属性，表明当前的 Servlet 是一个异步 Servlet。\n 2. Web 应用程序需要调用 Request 对象的 startAsync 方法来拿到一个异步上下文 AsyncContext。这个上下文保存了请求和响应对象。\n 3. Web 应用需要开启一个新线程来处理耗时的操作，处理完成后需要调用 AsyncContext 的 complete 方法。目的是告诉 Tomcat，请求已经处理完成。\n\n这里请你注意，虽然异步 Servlet 允许用更长的时间来处理请求，但是也有超时限制的，默认是 30 秒，如果 30 秒内请求还没处理完，Tomcat 会触发超时机制，向浏览器返回超时错误，如果这个时候你的 Web 应用再调用ctx.complete方法，会得到一个 IllegalStateException 异常。\n\n\n# 异步 Servlet 原理\n\n通过上面的例子，相信你对 Servlet 的异步实现有了基本的理解。要理解 Tomcat 在这个过程都做了什么事情，关键就是要弄清楚req.startAsync方法和ctx.complete方法都做了什么。\n\n# startAsync 方法\n\nstartAsync 方法其实就是创建了一个异步上下文 AsyncContext 对象，AsyncContext 对象的作用是保存请求的中间信息，比如 Request 和 Response 对象等上下文信息。你来思考一下为什么需要保存这些信息呢？\n\n这是因为 Tomcat 的工作线程在Request.startAsync调用之后，就直接结束回到线程池中了，线程本身不会保存任何信息。也就是说一个请求到服务端，执行到一半，你的 Web 应用正在处理，这个时候 Tomcat 的工作线程没了，这就需要有个缓存能够保存原始的 Request 和 Response 对象，而这个缓存就是 AsyncContext。\n\n有了 AsyncContext，你的 Web 应用通过它拿到 request 和 response 对象，拿到 Request 对象后就可以读取请求信息，请求处理完了还需要通过 Response 对象将 HTTP 响应发送给浏览器。\n\n除了创建 AsyncContext 对象，startAsync 还需要完成一个关键任务，那就是告诉 Tomcat 当前的 Servlet 处理方法返回时，不要把响应发到浏览器，因为这个时候，响应还没生成呢；并且不能把 Request 对象和 Response 对象销毁，因为后面 Web 应用还要用呢。\n\n在 Tomcat 中，负责 flush 响应数据的是 CoyoteAdaptor，它还会销毁 Request 对象和 Response 对象，因此需要通过某种机制通知 CoyoteAdaptor，具体来说是通过下面这行代码：\n\nthis.request.getCoyoteRequest().action(ActionCode.ASYNC_START, this);\n\n\n你可以把它理解为一个 Callback，在这个 action 方法里设置了 Request 对象的状态，设置它为一个异步 Servlet 请求。\n\n我们知道连接器是调用 CoyoteAdapter 的 service 方法来处理请求的，而 CoyoteAdapter 会调用容器的 service 方法，当容器的 service 方法返回时，CoyoteAdapter 判断当前的请求是不是异步 Servlet 请求，如果是，就不会销毁 Request 和 Response 对象，也不会把响应信息发到浏览器。你可以通过下面的代码理解一下，这是 CoyoteAdapter 的 service 方法，我对它进行了简化：\n\npublic void service(org.apache.coyote.Request req, org.apache.coyote.Response res) {\n\n   // 调用容器的 service 方法处理请求\n    connector.getService().getContainer().getPipeline().\n           getFirst().invoke(request, response);\n\n   // 如果是异步 Servlet 请求，仅仅设置一个标志，\n   // 否则说明是同步 Servlet 请求，就将响应数据刷到浏览器\n    if (request.isAsync()) {\n        async = true;\n    } else {\n        request.finishRequest();\n        response.finishResponse();\n    }\n\n   // 如果不是异步 Servlet 请求，就销毁 Request 对象和 Response 对象\n    if (!async) {\n        request.recycle();\n        response.recycle();\n    }\n}\n\n\n接下来，当 CoyoteAdaptor 的 service 方法返回到 ProtocolHandler 组件时，ProtocolHandler 判断返回值，如果当前请求是一个异步 Servlet 请求，它会把当前 Socket 的协议处理者 Processor 缓存起来，将 SocketWrapper 对象和相应的 Processor 存到一个 Map 数据结构里。\n\nprivate final Map<S,Processor> connections = new ConcurrentHashMap<>();\n\n\n之所以要缓存是因为这个请求接下来还要接着处理，还是由原来的 Processor 来处理，通过 SocketWrapper 就能从 Map 里找到相应的 Processor。\n\n# complete 方法\n\n接着我们再来看关键的ctx.complete方法，当请求处理完成时，Web 应用调用这个方法。那么这个方法做了些什么事情呢？最重要的就是把响应数据发送到浏览器。\n\n这件事情不能由 Web 应用线程来做，也就是说ctx.complete方法不能直接把响应数据发送到浏览器，因为这件事情应该由 Tomcat 线程来做，但具体怎么做呢？\n\n我们知道，连接器中的 Endpoint 组件检测到有请求数据达到时，会创建一个 SocketProcessor 对象交给线程池去处理，因此 Endpoint 的通信处理和具体请求处理在两个线程里运行。\n\n在异步 Servlet 的场景里，Web 应用通过调用ctx.complete方法时，也可以生成一个新的 SocketProcessor 任务类，交给线程池处理。对于异步 Servlet 请求来说，相应的 Socket 和协议处理组件 Processor 都被缓存起来了，并且这些对象都可以通过 Request 对象拿到。\n\n讲到这里，你可能已经猜到ctx.complete是如何实现的了：\n\npublic void complete() {\n    // 检查状态合法性，我们先忽略这句\n    check();\n\n    // 调用 Request 对象的 action 方法，其实就是通知连接器，这个异步请求处理完了\nrequest.getCoyoteRequest().action(ActionCode.ASYNC_COMPLETE, null);\n\n}\n\n\n我们可以看到 complete 方法调用了 Request 对象的 action 方法。而在 action 方法里，则是调用了 Processor 的 processSocketEvent 方法，并且传入了操作码 OPEN_READ。\n\ncase ASYNC_COMPLETE: {\n    clearDispatches();\n    if (asyncStateMachine.asyncComplete()) {\n        processSocketEvent(SocketEvent.OPEN_READ, true);\n    }\n    break;\n}\n\n\n我们接着看 processSocketEvent 方法，它调用 SocketWrapper 的 processSocket 方法：\n\nprotected void processSocketEvent(SocketEvent event, boolean dispatch) {\n    SocketWrapperBase<?> socketWrapper = getSocketWrapper();\n    if (socketWrapper != null) {\n        socketWrapper.processSocket(event, dispatch);\n    }\n}\n\n\n而 SocketWrapper 的 processSocket 方法会创建 SocketProcessor 任务类，并通过 Tomcat 线程池来处理：\n\npublic boolean processSocket(SocketWrapperBase<S> socketWrapper,\n        SocketEvent event, boolean dispatch) {\n\n      if (socketWrapper == null) {\n          return false;\n      }\n\n      SocketProcessorBase<S> sc = processorCache.pop();\n      if (sc == null) {\n          sc = createSocketProcessor(socketWrapper, event);\n      } else {\n          sc.reset(socketWrapper, event);\n      }\n      // 线程池运行\n      Executor executor = getExecutor();\n      if (dispatch && executor != null) {\n          executor.execute(sc);\n      } else {\n          sc.run();\n      }\n}\n\n\n请你注意 createSocketProcessor 函数的第二个参数是 SocketEvent，这里我们传入的是 OPEN_READ。通过这个参数，我们就能控制 SocketProcessor 的行为，因为我们不需要再把请求发送到容器进行处理，只需要向浏览器端发送数据，并且重新在这个 Socket 上监听新的请求就行了。\n\n\n# 参考资料\n\n * 官方\n   * Tomcat 官方网站\n   * Tomcat Wiki\n   * Tomee 官方网站\n * 教程\n   * 深入拆解 Tomcat & Jetty',normalizedContent:'# tomcat 容器\n\n\n# tomcat 实现热部署和热加载\n\n * 热加载的实现方式是 web 容器启动一个后台线程，定期检测类文件的变化，如果有变化，就重新加载类，在这个过程中不会清空 session ，一般用在开发环境。\n * 热部署原理类似，也是由后台线程定时检测 web 应用的变化，但它会重新加载整个 web 应用。这种方式会清空 session，比热加载更加干净、彻底，一般用在生产环境。\n\ntomcat 通过开启后台线程，使得各个层次的容器组件都有机会完成一些周期性任务。tomcat 是基于 scheduledthreadpoolexecutor 实现周期性任务的：\n\nbgfuture = exec.schedulewithfixeddelay(\n              new containerbackgroundprocessor(),// 要执行的 runnable\n              backgroundprocessordelay, // 第一次执行延迟多久\n              backgroundprocessordelay, // 之后每次执行间隔多久\n              timeunit.seconds);        // 时间单位\n\n\n第一个参数就是要周期性执行的任务类 containerbackgroundprocessor，它是一个 runnable，同时也是 containerbase 的内部类，containerbase 是所有容器组件的基类，我们来回忆一下容器组件有哪些，有 engine、host、context 和 wrapper 等，它们具有父子关系。\n\n\n# containerbackgroundprocessor 实现\n\n我们接来看 containerbackgroundprocessor 具体是如何实现的。\n\nprotected class containerbackgroundprocessor implements runnable {\n\n    @override\n    public void run() {\n        // 请注意这里传入的参数是 " 宿主类 " 的实例\n        processchildren(containerbase.this);\n    }\n\n    protected void processchildren(container container) {\n        try {\n            //1. 调用当前容器的 backgroundprocess 方法。\n            container.backgroundprocess();\n\n            //2. 遍历所有的子容器，递归调用 processchildren，\n            // 这样当前容器的子孙都会被处理\n            container[] children = container.findchildren();\n            for (int i = 0; i < children.length; i++) {\n            // 这里请你注意，容器基类有个变量叫做 backgroundprocessordelay，如果大于 0，表明子容器有自己的后台线程，无需父容器来调用它的 processchildren 方法。\n                if (children[i].getbackgroundprocessordelay() <= 0) {\n                    processchildren(children[i]);\n                }\n            }\n        } catch (throwable t) { ... }\n\n\n上面的代码逻辑也是比较清晰的，首先 containerbackgroundprocessor 是一个 runnable，它需要实现 run 方法，它的 run 很简单，就是调用了 processchildren 方法。这里有个小技巧，它把“宿主类”，也就是containerbase 的类实例当成参数传给了 run 方法。\n\n而在 processchildren 方法里，就做了两步：调用当前容器的 backgroundprocess 方法，以及递归调用子孙的 backgroundprocess 方法。请你注意 backgroundprocess 是 container 接口中的方法，也就是说所有类型的容器都可以实现这个方法，在这个方法里完成需要周期性执行的任务。\n\n这样的设计意味着什么呢？我们只需要在顶层容器，也就是 engine 容器中启动一个后台线程，那么这个线程不但会执行 engine 容器的周期性任务，它还会执行所有子容器的周期性任务。\n\n\n# backgroundprocess 方法\n\n上述代码都是在基类 containerbase 中实现的，那具体容器类需要做什么呢？其实很简单，如果有周期性任务要执行，就实现 backgroundprocess 方法；如果没有，就重用基类 containerbase 的方法。containerbase 的 backgroundprocess 方法实现如下：\n\npublic void backgroundprocess() {\n\n    //1. 执行容器中 cluster 组件的周期性任务\n    cluster cluster = getclusterinternal();\n    if (cluster != null) {\n        cluster.backgroundprocess();\n    }\n\n    //2. 执行容器中 realm 组件的周期性任务\n    realm realm = getrealminternal();\n    if (realm != null) {\n        realm.backgroundprocess();\n   }\n\n   //3. 执行容器中 valve 组件的周期性任务\n    valve current = pipeline.getfirst();\n    while (current != null) {\n       current.backgroundprocess();\n       current = current.getnext();\n    }\n\n    //4. 触发容器的 " 周期事件 "，host 容器的监听器 hostconfig 就靠它来调用\n    firelifecycleevent(lifecycle.periodic_event, null);\n}\n\n\n从上面的代码可以看到，不仅每个容器可以有周期性任务，每个容器中的其他通用组件，比如跟集群管理有关的 cluster 组件、跟安全管理有关的 realm 组件都可以有自己的周期性任务。\n\n我在前面的专栏里提到过，容器之间的链式调用是通过 pipeline-valve 机制来实现的，从上面的代码你可以看到容器中的 valve 也可以有周期性任务，并且被 containerbase 统一处理。\n\n请你特别注意的是，在 backgroundprocess 方法的最后，还触发了容器的“周期事件”。我们知道容器的生命周期事件有初始化、启动和停止等，那“周期事件”又是什么呢？它跟生命周期事件一样，是一种扩展机制，你可以这样理解：\n\n又一段时间过去了，容器还活着，你想做点什么吗？如果你想做点什么，就创建一个监听器来监听这个“周期事件”，事件到了我负责调用你的方法。\n\n总之，有了 containerbase 中的后台线程和 backgroundprocess 方法，各种子容器和通用组件不需要各自弄一个后台线程来处理周期性任务，这样的设计显得优雅和整洁。\n\n\n# tomcat 热加载\n\n有了 containerbase 的周期性任务处理“框架”，作为具体容器子类，只需要实现自己的周期性任务就行。而 tomcat 的热加载，就是在 context 容器中实现的。context 容器的 backgroundprocess 方法是这样实现的：\n\npublic void backgroundprocess() {\n\n    //webapploader 周期性的检查 web-inf/classes 和 web-inf/lib 目录下的类文件\n    loader loader = getloader();\n    if (loader != null) {\n        loader.backgroundprocess();\n    }\n\n    //session 管理器周期性的检查是否有过期的 session\n    manager manager = getmanager();\n    if (manager != null) {\n        manager.backgroundprocess();\n    }\n\n    // 周期性的检查静态资源是否有变化\n    webresourceroot resources = getresources();\n    if (resources != null) {\n        resources.backgroundprocess();\n    }\n\n    // 调用父类 containerbase 的 backgroundprocess 方法\n    super.backgroundprocess();\n}\n\n\n从上面的代码我们看到 context 容器通过 webapploader 来检查类文件是否有更新，通过 session 管理器来检查是否有 session 过期，并且通过资源管理器来检查静态资源是否有更新，最后还调用了父类 containerbase 的 backgroundprocess 方法。\n\n这里我们要重点关注，webapploader 是如何实现热加载的，它主要是调用了 context 容器的 reload 方法，而 context 的 reload 方法比较复杂，总结起来，主要完成了下面这些任务：\n\n 1. 停止和销毁 context 容器及其所有子容器，子容器其实就是 wrapper，也就是说 wrapper 里面 servlet 实例也被销毁了。\n 2. 停止和销毁 context 容器关联的 listener 和 filter。\n 3. 停止和销毁 context 下的 pipeline 和各种 valve。\n 4. 停止和销毁 context 的类加载器，以及类加载器加载的类文件资源。\n 5. 启动 context 容器，在这个过程中会重新创建前面四步被销毁的资源。\n\n在这个过程中，类加载器发挥着关键作用。一个 context 容器对应一个类加载器，类加载器在销毁的过程中会把它加载的所有类也全部销毁。context 容器在启动过程中，会创建一个新的类加载器来加载新的类文件。\n\n在 context 的 reload 方法里，并没有调用 session 管理器的 distroy 方法，也就是说这个 context 关联的 session 是没有销毁的。你还需要注意的是，tomcat 的热加载默认是关闭的，你需要在 conf 目录下的 context.xml 文件中设置 reloadable 参数来开启这个功能，像下面这样：\n\n<context reloadable="true"/>\n\n\n\n# tomcat 热部署\n\n我们再来看看热部署，热部署跟热加载的本质区别是，热部署会重新部署 web 应用，原来的 context 对象会整个被销毁掉，因此这个 context 所关联的一切资源都会被销毁，包括 session。\n\n那么 tomcat 热部署又是由哪个容器来实现的呢？应该不是由 context，因为热部署过程中 context 容器被销毁了，那么这个重担就落在 host 身上了，因为它是 context 的父容器。\n\n跟 context 不一样，host 容器并没有在 backgroundprocess 方法中实现周期性检测的任务，而是通过监听器 hostconfig 来实现的，hostconfig 就是前面提到的“周期事件”的监听器，那“周期事件”达到时，hostconfig 会做什么事呢？\n\npublic void lifecycleevent(lifecycleevent event) {\n    // 执行 check 方法。\n    if (event.gettype().equals(lifecycle.periodic_event)) {\n        check();\n    }\n}\n\n\n它执行了 check 方法，我们接着来看 check 方法里做了什么。\n\nprotected void check() {\n\n    if (host.getautodeploy()) {\n        // 检查这个 host 下所有已经部署的 web 应用\n        deployedapplication[] apps =\n            deployed.values().toarray(new deployedapplication[0]);\n\n        for (int i = 0; i < apps.length; i++) {\n            // 检查 web 应用目录是否有变化\n            checkresources(apps[i], false);\n        }\n\n        // 执行部署\n        deployapps();\n    }\n}\n\n\n其实 hostconfig 会检查 webapps 目录下的所有 web 应用：\n\n * 如果原来 web 应用目录被删掉了，就把相应 context 容器整个销毁掉。\n * 是否有新的 web 应用目录放进来了，或者有新的 war 包放进来了，就部署相应的 web 应用。\n\n因此 hostconfig 做的事情都是比较“宏观”的，它不会去检查具体类文件或者资源文件是否有变化，而是检查 web 应用目录级别的变化。\n\n\n# tomcat 的类加载机制\n\ntomcat 的自定义类加载器 webappclassloader 打破了双亲委派机制，它首先自己尝试去加载某个类，如果找不到再代理给父类加载器，其目的是优先加载 web 应用自己定义的类。具体实现就是重写 classloader 的两个方法：findclass 和 loadclass。\n\n\n# findclass 方法\n\n我们先来看看 findclass 方法的实现，为了方便理解和阅读，我去掉了一些细节：\n\npublic class<?> findclass(string name) throws classnotfoundexception {\n    ...\n\n    class<?> clazz = null;\n    try {\n            //1. 先在 web 应用目录下查找类\n            clazz = findclassinternal(name);\n    }  catch (runtimeexception e) {\n           throw e;\n       }\n\n    if (clazz == null) {\n    try {\n            //2. 如果在本地目录没有找到，交给父加载器去查找\n            clazz = super.findclass(name);\n    }  catch (runtimeexception e) {\n           throw e;\n       }\n\n    //3. 如果父类也没找到，抛出 classnotfoundexception\n    if (clazz == null) {\n        throw new classnotfoundexception(name);\n     }\n\n    return clazz;\n}\n\n\n在 findclass 方法里，主要有三个步骤：\n\n 1. 先在 web 应用本地目录下查找要加载的类。\n 2. 如果没有找到，交给父加载器去查找，它的父加载器就是上面提到的系统类加载器 appclassloader。\n 3. 如何父加载器也没找到这个类，抛出 classnotfound 异常。\n\n\n# loadclass 方法\n\n接着我们再来看 tomcat 类加载器的 loadclass 方法的实现，同样我也去掉了一些细节：\n\npublic class<?> loadclass(string name, boolean resolve) throws classnotfoundexception {\n\n    synchronized (getclassloadinglock(name)) {\n\n        class<?> clazz = null;\n\n        //1. 先在本地 cache 查找该类是否已经加载过\n        clazz = findloadedclass0(name);\n        if (clazz != null) {\n            if (resolve)\n                resolveclass(clazz);\n            return clazz;\n        }\n\n        //2. 从系统类加载器的 cache 中查找是否加载过\n        clazz = findloadedclass(name);\n        if (clazz != null) {\n            if (resolve)\n                resolveclass(clazz);\n            return clazz;\n        }\n\n        // 3. 尝试用 extclassloader 类加载器类加载，为什么？\n        classloader javaseloader = getjavaseclassloader();\n        try {\n            clazz = javaseloader.loadclass(name);\n            if (clazz != null) {\n                if (resolve)\n                    resolveclass(clazz);\n                return clazz;\n            }\n        } catch (classnotfoundexception e) {\n            // ignore\n        }\n\n        // 4. 尝试在本地目录搜索 class 并加载\n        try {\n            clazz = findclass(name);\n            if (clazz != null) {\n                if (resolve)\n                    resolveclass(clazz);\n                return clazz;\n            }\n        } catch (classnotfoundexception e) {\n            // ignore\n        }\n\n        // 5. 尝试用系统类加载器 (也就是 appclassloader) 来加载\n            try {\n                clazz = class.forname(name, false, parent);\n                if (clazz != null) {\n                    if (resolve)\n                        resolveclass(clazz);\n                    return clazz;\n                }\n            } catch (classnotfoundexception e) {\n                // ignore\n            }\n       }\n\n    //6. 上述过程都加载失败，抛出异常\n    throw new classnotfoundexception(name);\n}\n\n\nloadclass 方法稍微复杂一点，主要有六个步骤：\n\n 1. 先在本地 cache 查找该类是否已经加载过，也就是说 tomcat 的类加载器是否已经加载过这个类。\n 2. 如果 tomcat 类加载器没有加载过这个类，再看看系统类加载器是否加载过。\n 3. 如果都没有，就让extclassloader去加载，这一步比较关键，目的防止 web 应用自己的类覆盖 jre 的核心类。因为 tomcat 需要打破双亲委派机制，假如 web 应用里自定义了一个叫 object 的类，如果先加载这个 object 类，就会覆盖 jre 里面的那个 object 类，这就是为什么 tomcat 的类加载器会优先尝试用 extclassloader 去加载，因为 extclassloader 会委托给 bootstrapclassloader 去加载，bootstrapclassloader 发现自己已经加载了 object 类，直接返回给 tomcat 的类加载器，这样 tomcat 的类加载器就不会去加载 web 应用下的 object 类了，也就避免了覆盖 jre 核心类的问题。\n 4. 如果 extclassloader 加载器加载失败，也就是说 jre 核心类中没有这类，那么就在本地 web 应用目录下查找并加载。\n 5. 如果本地目录下没有这个类，说明不是 web 应用自己定义的类，那么由系统类加载器去加载。这里请你注意，web 应用是通过class.forname调用交给系统类加载器的，因为class.forname的默认加载器就是系统类加载器。\n 6. 如果上述加载过程全部失败，抛出 classnotfound 异常。\n\n从上面的过程我们可以看到，tomcat 的类加载器打破了双亲委派机制，没有一上来就直接委托给父加载器，而是先在本地目录下加载，为了避免本地目录下的类覆盖 jre 的核心类，先尝试用 jvm 扩展类加载器 extclassloader 去加载。那为什么不先用系统类加载器 appclassloader 去加载？很显然，如果是这样的话，那就变成双亲委派机制了，这就是 tomcat 类加载器的巧妙之处。\n\n\n# tomcat 实现应用隔离\n\ntomcat 作为 web 容器，需要解决以下问题：\n\n 1. 如果在 tomcat 中运行了两个 web 应用程序，两个 web 应用中有同名的 servlet，但是功能不同，tomcat 需要同时加载和管理这两个同名的 servlet 类，保证它们不会冲突，因此 web 应用之间的类需要隔离。\n 2. 两个 web 应用都依赖同一个第三方的 jar 包，比如 spring，那 spring 的 jar 包被加载到内存后，tomcat 要保证这两个 web 应用能够共享，也就是说 spring 的 jar 包只被加载一次，否则随着依赖的第三方 jar 包增多，jvm 的内存会膨胀。\n 3. 需要隔离 tomcat 本身的类和 web 应用的类。\n\n\n\n# webappclassloader\n\n针对第一个问题：\n\n如果使用 jvm 默认 appclassloader 来加载 web 应用，appclassloader 只能加载一个 servlet 类，在加载第二个同名 servlet 类时，appclassloader 会返回第一个 servlet 类的 class 实例，这是因为在 appclassloader 看来，同名的 servlet 类只被加载一次。\n\ntomcat 的解决方案是自定义一个类加载器 webappclassloader， 并且给每个 web 应用创建一个类加载器实例。我们知道，context 容器组件对应一个 web 应用，因此，每个 context 容器负责创建和维护一个 webappclassloader 加载器实例。这背后的原理是，不同的加载器实例加载的类被认为是不同的类，即使它们的类名相同。这就相当于在 java 虚拟机内部创建了一个个相互隔离的 java 类空间，每一个 web 应用都有自己的类空间，web 应用之间通过各自的类加载器互相隔离。\n\n# sharedclassloader\n\n针对第二个问题：\n\n本质需求是两个 web 应用之间怎么共享库类，并且不能重复加载相同的类。我们知道，在双亲委派机制里，各个子加载器都可以通过父加载器去加载类，那么把需要共享的类放到父加载器的加载路径下不就行了吗，应用程序也正是通过这种方式共享 jre 的核心类。因此 tomcat 的设计者又加了一个类加载器 sharedclassloader，作为 webappclassloader 的父加载器，专门来加载 web 应用之间共享的类。如果 webappclassloader 自己没有加载到某个类，就会委托父加载器 sharedclassloader 去加载这个类，sharedclassloader 会在指定目录下加载共享类，之后返回给 webappclassloader，这样共享的问题就解决了。\n\n# catalinaclassloader\n\n如何隔离 tomcat 本身的类和 web 应用的类？\n\n要共享可以通过父子关系，要隔离那就需要兄弟关系了。兄弟关系就是指两个类加载器是平行的，它们可能拥有同一个父加载器，但是两个兄弟类加载器加载的类是隔离的。基于此 tomcat 又设计一个类加载器 catalinaclassloader，专门来加载 tomcat 自身的类。这样设计有个问题，那 tomcat 和各 web 应用之间需要共享一些类时该怎么办呢？\n\n# commonclassloader\n\n老办法，还是再增加一个 commonclassloader，作为 catalinaclassloader 和 sharedclassloader 的父加载器。commonclassloader 能加载的类都可以被 catalinaclassloader 和 sharedclassloader 使用，而 catalinaclassloader 和 sharedclassloader 能加载的类则与对方相互隔离。webappclassloader 可以使用 sharedclassloader 加载到的类，但各个 webappclassloader 实例之间相互隔离。\n\n\n# tomcat 实现 servlet 规范\n\nservlet 容器最重要的任务就是创建 servlet 的实例并且调用 servlet。\n\n一个 web 应用里往往有多个 servlet，而在 tomcat 中一个 web 应用对应一个 context 容器，也就是说一个 context 容器需要管理多个 servlet 实例。但 context 容器并不直接持有 servlet 实例，而是通过子容器 wrapper 来管理 servlet，你可以把 wrapper 容器看作是 servlet 的包装。\n\n为什么需要 wrapper 呢？context 容器直接维护一个 servlet 数组不就行了吗？这是因为 servlet 不仅仅是一个类实例，它还有相关的配置信息，比如它的 url 映射、它的初始化参数，因此设计出了一个包装器，把 servlet 本身和它相关的数据包起来，没错，这就是面向对象的思想。\n\n除此以外，servlet 规范中还有两个重要特性：listener 和 filter，tomcat 也需要创建它们的实例，并在合适的时机去调用它们的方法。\n\n\n# servlet 管理\n\ntomcat 是用 wrapper 容器来管理 servlet 的，那 wrapper 容器具体长什么样子呢？我们先来看看它里面有哪些关键的成员变量：\n\nprotected volatile servlet instance = null;\n\n\n它拥有一个 servlet 实例，并且 wrapper 通过 loadservlet 方法来实例化 servlet。为了方便你阅读，我简化了代码：\n\npublic synchronized servlet loadservlet() throws servletexception {\n    servlet servlet;\n\n    //1. 创建一个 servlet 实例\n    servlet = (servlet) instancemanager.newinstance(servletclass);\n\n    //2. 调用了 servlet 的 init 方法，这是 servlet 规范要求的\n    initservlet(servlet);\n\n    return servlet;\n}\n\n\n其实 loadservlet 主要做了两件事：创建 servlet 的实例，并且调用 servlet 的 init 方法，因为这是 servlet 规范要求的。\n\n那接下来的问题是，什么时候会调到这个 loadservlet 方法呢？为了加快系统的启动速度，我们往往会采取资源延迟加载的策略，tomcat 也不例外，默认情况下 tomcat 在启动时不会加载你的 servlet，除非你把 servlet 的loadonstartup参数设置为true。\n\n这里还需要你注意的是，虽然 tomcat 在启动时不会创建 servlet 实例，但是会创建 wrapper 容器，就好比尽管枪里面还没有子弹，先把枪造出来。那子弹什么时候造呢？是真正需要开枪的时候，也就是说有请求来访问某个 servlet 时，这个 servlet 的实例才会被创建。\n\n那 servlet 是被谁调用的呢？我们回忆一下专栏前面提到过 tomcat 的 pipeline-valve 机制，每个容器组件都有自己的 pipeline，每个 pipeline 中有一个 valve 链，并且每个容器组件有一个 basicvalve（基础阀）。wrapper 作为一个容器组件，它也有自己的 pipeline 和 basicvalve，wrapper 的 basicvalve 叫 standardwrappervalve。\n\n你可以想到，当请求到来时，context 容器的 basicvalve 会调用 wrapper 容器中 pipeline 中的第一个 valve，然后会调用到 standardwrappervalve。我们先来看看它的 invoke 方法是如何实现的，同样为了方便你阅读，我简化了代码：\n\npublic final void invoke(request request, response response) {\n\n    //1. 实例化 servlet\n    servlet = wrapper.allocate();\n\n    //2. 给当前请求创建一个 filter 链\n    applicationfilterchain filterchain =\n        applicationfilterfactory.createfilterchain(request, wrapper, servlet);\n\n   //3. 调用这个 filter 链，filter 链中的最后一个 filter 会调用 servlet\n   filterchain.dofilter(request.getrequest(), response.getresponse());\n\n}\n\n\nstandardwrappervalve 的 invoke 方法比较复杂，去掉其他异常处理的一些细节，本质上就是三步：\n\n * 第一步，创建 servlet 实例；\n * 第二步，给当前请求创建一个 filter 链；\n * 第三步，调用这个 filter 链。\n\n你可能会问，为什么需要给每个请求创建一个 filter 链？这是因为每个请求的请求路径都不一样，而 filter 都有相应的路径映射，因此不是所有的 filter 都需要来处理当前的请求，我们需要根据请求的路径来选择特定的一些 filter 来处理。\n\n第二个问题是，为什么没有看到调到 servlet 的 service 方法？这是因为 filter 链的 dofilter 方法会负责调用 servlet，具体来说就是 filter 链中的最后一个 filter 会负责调用 servlet。\n\n接下来我们来看 filter 的实现原理。\n\n\n# filter 管理\n\n我们知道，跟 servlet 一样，filter 也可以在web.xml文件里进行配置，不同的是，filter 的作用域是整个 web 应用，因此 filter 的实例是在 context 容器中进行管理的，context 容器用 map 集合来保存 filter。\n\nprivate map<string, filterdef> filterdefs = new hashmap<>();\n\n\n那上面提到的 filter 链又是什么呢？filter 链的存活期很短，它是跟每个请求对应的。一个新的请求来了，就动态创建一个 filter 链，请求处理完了，filter 链也就被回收了。理解它的原理也非常关键，我们还是来看看源码：\n\npublic final class applicationfilterchain implements filterchain {\n\n  //filter 链中有 filter 数组，这个好理解\n  private applicationfilterconfig[] filters = new applicationfilterconfig[0];\n\n  //filter 链中的当前的调用位置\n  private int pos = 0;\n\n  // 总共有多少了 filter\n  private int n = 0;\n\n  // 每个 filter 链对应一个 servlet，也就是它要调用的 servlet\n  private servlet servlet = null;\n\n  public void dofilter(servletrequest req, servletresponse res) {\n        internaldofilter(request,response);\n  }\n\n  private void internaldofilter(servletrequest req,\n                                servletresponse res){\n\n    // 每个 filter 链在内部维护了一个 filter 数组\n    if (pos < n) {\n        applicationfilterconfig filterconfig = filters[pos++];\n        filter filter = filterconfig.getfilter();\n\n        filter.dofilter(request, response, this);\n        return;\n    }\n\n    servlet.service(request, response);\n\n}\n\n\n从 applicationfilterchain 的源码我们可以看到几个关键信息：\n\n * filter 链中除了有 filter 对象的数组，还有一个整数变量 pos，这个变量用来记录当前被调用的 filter 在数组中的位置。\n * filter 链中有个 servlet 实例，这个好理解，因为上面提到了，每个 filter 链最后都会调到一个 servlet。\n * filter 链本身也实现了 dofilter 方法，直接调用了一个内部方法 internaldofilter。\n * internaldofilter 方法的实现比较有意思，它做了一个判断，如果当前 filter 的位置小于 filter 数组的长度，也就是说 filter 还没调完，就从 filter 数组拿下一个 filter，调用它的 dofilter 方法。否则，意味着所有 filter 都调到了，就调用 servlet 的 service 方法。\n\n但问题是，方法体里没看到循环，谁在不停地调用 filter 链的 dofilter 方法呢？filter 是怎么依次调到的呢？\n\n答案是filter 本身的 dofilter 方法会调用 filter 链的 dofilter 方法，我们还是来看看代码就明白了：\n\npublic void dofilter(servletrequest request, servletresponse response,\n        filterchain chain){\n\n          ...\n\n          // 调用 filter 的方法\n          chain.dofilter(request, response);\n\n      }\n\n\n注意 filter 的 dofilter 方法有个关键参数 filterchain，就是 filter 链。并且每个 filter 在实现 dofilter 时，必须要调用 filter 链的 dofilter 方法，而 filter 链中保存当前 filter 的位置，会调用下一个 filter 的 dofilter 方法，这样链式调用就完成了。\n\nfilter 链跟 tomcat 的 pipeline-valve 本质都是责任链模式，但是在具体实现上稍有不同，你可以细细体会一下。\n\n\n# listener 管理\n\n我们接着聊 servlet 规范里 listener。跟 filter 一样，listener 也是一种扩展机制，你可以监听容器内部发生的事件，主要有两类事件：\n\n * 第一类是生命状态的变化，比如 context 容器启动和停止、session 的创建和销毁。\n * 第二类是属性的变化，比如 context 容器某个属性值变了、session 的某个属性值变了以及新的请求来了等。\n\n我们可以在web.xml配置或者通过注解的方式来添加监听器，在监听器里实现我们的业务逻辑。对于 tomcat 来说，它需要读取配置文件，拿到监听器类的名字，实例化这些类，并且在合适的时机调用这些监听器的方法。\n\ntomcat 是通过 context 容器来管理这些监听器的。context 容器将两类事件分开来管理，分别用不同的集合来存放不同类型事件的监听器：\n\n// 监听属性值变化的监听器\nprivate list<object> applicationeventlistenerslist = new copyonwritearraylist<>();\n\n// 监听生命事件的监听器\nprivate object applicationlifecyclelistenersobjects[] = new object[0];\n\n\n剩下的事情就是触发监听器了，比如在 context 容器的启动方法里，就触发了所有的 servletcontextlistener：\n\n//1. 拿到所有的生命周期监听器\nobject instances[] = getapplicationlifecyclelisteners();\n\nfor (int i = 0; i < instances.length; i++) {\n   //2. 判断 listener 的类型是不是 servletcontextlistener\n   if (!(instances[i] instanceof servletcontextlistener))\n      continue;\n\n   //3. 触发 listener 的方法\n   servletcontextlistener lr = (servletcontextlistener) instances[i];\n   lr.contextinitialized(event);\n}\n\n\n需要注意的是，这里的 servletcontextlistener 接口是一种留给用户的扩展机制，用户可以实现这个接口来定义自己的监听器，监听 context 容器的启停事件。spring 就是这么做的。servletcontextlistener 跟 tomcat 自己的生命周期事件 lifecyclelistener 是不同的。lifecyclelistener 定义在生命周期管理组件中，由基类 lifecyclebase 统一管理。\n\n\n# tomcat 支持异步 servlet\n\n\n# 异步示例\n\n@webservlet(urlpatterns = {"/async"}, asyncsupported = true)\npublic class asyncservlet extends httpservlet {\n\n    //web 应用线程池，用来处理异步 servlet\n    executorservice executor = executors.newsinglethreadexecutor();\n\n    public void service(httpservletrequest req, httpservletresponse resp) {\n        //1. 调用 startasync 或者异步上下文\n        final asynccontext ctx = req.startasync();\n\n       // 用线程池来执行耗时操作\n        executor.execute(new runnable() {\n\n            @override\n            public void run() {\n\n                // 在这里做耗时的操作\n                try {\n                    ctx.getresponse().getwriter().println("handling async servlet");\n                } catch (ioexception e) {}\n\n                //3. 异步 servlet 处理完了调用异步上下文的 complete 方法\n                ctx.complete();\n            }\n\n        });\n    }\n}\n\n\n有三个要点：\n\n 1. 通过注解的方式来注册 servlet，除了 @webservlet 注解，还需要加上 asyncsupported=true 的属性，表明当前的 servlet 是一个异步 servlet。\n 2. web 应用程序需要调用 request 对象的 startasync 方法来拿到一个异步上下文 asynccontext。这个上下文保存了请求和响应对象。\n 3. web 应用需要开启一个新线程来处理耗时的操作，处理完成后需要调用 asynccontext 的 complete 方法。目的是告诉 tomcat，请求已经处理完成。\n\n这里请你注意，虽然异步 servlet 允许用更长的时间来处理请求，但是也有超时限制的，默认是 30 秒，如果 30 秒内请求还没处理完，tomcat 会触发超时机制，向浏览器返回超时错误，如果这个时候你的 web 应用再调用ctx.complete方法，会得到一个 illegalstateexception 异常。\n\n\n# 异步 servlet 原理\n\n通过上面的例子，相信你对 servlet 的异步实现有了基本的理解。要理解 tomcat 在这个过程都做了什么事情，关键就是要弄清楚req.startasync方法和ctx.complete方法都做了什么。\n\n# startasync 方法\n\nstartasync 方法其实就是创建了一个异步上下文 asynccontext 对象，asynccontext 对象的作用是保存请求的中间信息，比如 request 和 response 对象等上下文信息。你来思考一下为什么需要保存这些信息呢？\n\n这是因为 tomcat 的工作线程在request.startasync调用之后，就直接结束回到线程池中了，线程本身不会保存任何信息。也就是说一个请求到服务端，执行到一半，你的 web 应用正在处理，这个时候 tomcat 的工作线程没了，这就需要有个缓存能够保存原始的 request 和 response 对象，而这个缓存就是 asynccontext。\n\n有了 asynccontext，你的 web 应用通过它拿到 request 和 response 对象，拿到 request 对象后就可以读取请求信息，请求处理完了还需要通过 response 对象将 http 响应发送给浏览器。\n\n除了创建 asynccontext 对象，startasync 还需要完成一个关键任务，那就是告诉 tomcat 当前的 servlet 处理方法返回时，不要把响应发到浏览器，因为这个时候，响应还没生成呢；并且不能把 request 对象和 response 对象销毁，因为后面 web 应用还要用呢。\n\n在 tomcat 中，负责 flush 响应数据的是 coyoteadaptor，它还会销毁 request 对象和 response 对象，因此需要通过某种机制通知 coyoteadaptor，具体来说是通过下面这行代码：\n\nthis.request.getcoyoterequest().action(actioncode.async_start, this);\n\n\n你可以把它理解为一个 callback，在这个 action 方法里设置了 request 对象的状态，设置它为一个异步 servlet 请求。\n\n我们知道连接器是调用 coyoteadapter 的 service 方法来处理请求的，而 coyoteadapter 会调用容器的 service 方法，当容器的 service 方法返回时，coyoteadapter 判断当前的请求是不是异步 servlet 请求，如果是，就不会销毁 request 和 response 对象，也不会把响应信息发到浏览器。你可以通过下面的代码理解一下，这是 coyoteadapter 的 service 方法，我对它进行了简化：\n\npublic void service(org.apache.coyote.request req, org.apache.coyote.response res) {\n\n   // 调用容器的 service 方法处理请求\n    connector.getservice().getcontainer().getpipeline().\n           getfirst().invoke(request, response);\n\n   // 如果是异步 servlet 请求，仅仅设置一个标志，\n   // 否则说明是同步 servlet 请求，就将响应数据刷到浏览器\n    if (request.isasync()) {\n        async = true;\n    } else {\n        request.finishrequest();\n        response.finishresponse();\n    }\n\n   // 如果不是异步 servlet 请求，就销毁 request 对象和 response 对象\n    if (!async) {\n        request.recycle();\n        response.recycle();\n    }\n}\n\n\n接下来，当 coyoteadaptor 的 service 方法返回到 protocolhandler 组件时，protocolhandler 判断返回值，如果当前请求是一个异步 servlet 请求，它会把当前 socket 的协议处理者 processor 缓存起来，将 socketwrapper 对象和相应的 processor 存到一个 map 数据结构里。\n\nprivate final map<s,processor> connections = new concurrenthashmap<>();\n\n\n之所以要缓存是因为这个请求接下来还要接着处理，还是由原来的 processor 来处理，通过 socketwrapper 就能从 map 里找到相应的 processor。\n\n# complete 方法\n\n接着我们再来看关键的ctx.complete方法，当请求处理完成时，web 应用调用这个方法。那么这个方法做了些什么事情呢？最重要的就是把响应数据发送到浏览器。\n\n这件事情不能由 web 应用线程来做，也就是说ctx.complete方法不能直接把响应数据发送到浏览器，因为这件事情应该由 tomcat 线程来做，但具体怎么做呢？\n\n我们知道，连接器中的 endpoint 组件检测到有请求数据达到时，会创建一个 socketprocessor 对象交给线程池去处理，因此 endpoint 的通信处理和具体请求处理在两个线程里运行。\n\n在异步 servlet 的场景里，web 应用通过调用ctx.complete方法时，也可以生成一个新的 socketprocessor 任务类，交给线程池处理。对于异步 servlet 请求来说，相应的 socket 和协议处理组件 processor 都被缓存起来了，并且这些对象都可以通过 request 对象拿到。\n\n讲到这里，你可能已经猜到ctx.complete是如何实现的了：\n\npublic void complete() {\n    // 检查状态合法性，我们先忽略这句\n    check();\n\n    // 调用 request 对象的 action 方法，其实就是通知连接器，这个异步请求处理完了\nrequest.getcoyoterequest().action(actioncode.async_complete, null);\n\n}\n\n\n我们可以看到 complete 方法调用了 request 对象的 action 方法。而在 action 方法里，则是调用了 processor 的 processsocketevent 方法，并且传入了操作码 open_read。\n\ncase async_complete: {\n    cleardispatches();\n    if (asyncstatemachine.asynccomplete()) {\n        processsocketevent(socketevent.open_read, true);\n    }\n    break;\n}\n\n\n我们接着看 processsocketevent 方法，它调用 socketwrapper 的 processsocket 方法：\n\nprotected void processsocketevent(socketevent event, boolean dispatch) {\n    socketwrapperbase<?> socketwrapper = getsocketwrapper();\n    if (socketwrapper != null) {\n        socketwrapper.processsocket(event, dispatch);\n    }\n}\n\n\n而 socketwrapper 的 processsocket 方法会创建 socketprocessor 任务类，并通过 tomcat 线程池来处理：\n\npublic boolean processsocket(socketwrapperbase<s> socketwrapper,\n        socketevent event, boolean dispatch) {\n\n      if (socketwrapper == null) {\n          return false;\n      }\n\n      socketprocessorbase<s> sc = processorcache.pop();\n      if (sc == null) {\n          sc = createsocketprocessor(socketwrapper, event);\n      } else {\n          sc.reset(socketwrapper, event);\n      }\n      // 线程池运行\n      executor executor = getexecutor();\n      if (dispatch && executor != null) {\n          executor.execute(sc);\n      } else {\n          sc.run();\n      }\n}\n\n\n请你注意 createsocketprocessor 函数的第二个参数是 socketevent，这里我们传入的是 open_read。通过这个参数，我们就能控制 socketprocessor 的行为，因为我们不需要再把请求发送到容器进行处理，只需要向浏览器端发送数据，并且重新在这个 socket 上监听新的请求就行了。\n\n\n# 参考资料\n\n * 官方\n   * tomcat 官方网站\n   * tomcat wiki\n   * tomee 官方网站\n * 教程\n   * 深入拆解 tomcat & jetty',charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Tomcat优化",frontmatter:{title:"Tomcat优化",date:"2022-02-17T22:34:30.000Z",order:4,categories:["Java","JavaEE","服务器","Tomcat"],tags:["Java","JavaWeb","服务器","Tomcat"],permalink:"/pages/f9e1e6/"},regularPath:"/01.Java/02.JavaEE/02.%E6%9C%8D%E5%8A%A1%E5%99%A8/01.Tomcat/04.Tomcat%E4%BC%98%E5%8C%96.html",relativePath:"01.Java/02.JavaEE/02.服务器/01.Tomcat/04.Tomcat优化.md",key:"v-63c3bd02",path:"/pages/f9e1e6/",headers:[{level:2,title:"Tomcat 启动优化",slug:"tomcat-启动优化",normalizedTitle:"tomcat 启动优化",charIndex:16},{level:3,title:"清理 Tomcat",slug:"清理-tomcat",normalizedTitle:"清理 tomcat",charIndex:59},{level:3,title:"禁止 Tomcat TLD 扫描",slug:"禁止-tomcat-tld-扫描",normalizedTitle:"禁止 tomcat tld 扫描",charIndex:595},{level:3,title:"关闭 WebSocket 支持",slug:"关闭-websocket-支持",normalizedTitle:"关闭 websocket 支持",charIndex:1673},{level:3,title:"关闭 JSP 支持",slug:"关闭-jsp-支持",normalizedTitle:"关闭 jsp 支持",charIndex:2063},{level:3,title:"禁止扫描 Servlet 注解",slug:"禁止扫描-servlet-注解",normalizedTitle:"禁止扫描 servlet 注解",charIndex:2363},{level:3,title:"配置 Web-Fragment 扫描",slug:"配置-web-fragment-扫描",normalizedTitle:"配置 web-fragment 扫描",charIndex:2699},{level:3,title:"随机数熵源优化",slug:"随机数熵源优化",normalizedTitle:"随机数熵源优化",charIndex:3113},{level:3,title:"并行启动多个 Web 应用",slug:"并行启动多个-web-应用",normalizedTitle:"并行启动多个 web 应用",charIndex:3812},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:4273}],headersStr:"Tomcat 启动优化 清理 Tomcat 禁止 Tomcat TLD 扫描 关闭 WebSocket 支持 关闭 JSP 支持 禁止扫描 Servlet 注解 配置 Web-Fragment 扫描 随机数熵源优化 并行启动多个 Web 应用 参考资料",content:'# Tomcat 优化\n\n\n# Tomcat 启动优化\n\n如果 Tomcat 启动比较慢，可以考虑一些优化点\n\n\n# 清理 Tomcat\n\n * 清理不必要的 Web 应用：首先我们要做的是删除掉 webapps 文件夹下不需要的工程，一般是 host-manager、example、doc 等这些默认的工程，可能还有以前添加的但现在用不着的工程，最好把这些全都删除掉。\n * 清理 XML 配置文件：Tomcat 在启动时会解析所有的 XML 配置文件，解析 XML 较为耗时，所以应该尽量保持配置文件的简洁。\n * 清理 JAR 文件：JVM 的类加载器在加载类时，需要查找每一个 JAR 文件，去找到所需要的类。如果删除了不需要的 JAR 文件，查找的速度就会快一些。这里请注意：Web 应用中的 lib 目录下不应该出现 Servlet API 或者 Tomcat 自身的 JAR，这些 JAR 由 Tomcat 负责提供。\n * 清理其他文件：及时清理日志，删除 logs 文件夹下不需要的日志文件。同样还有 work 文件夹下的 catalina 文件夹，它其实是 Tomcat 把 JSP 转换为 Class 文件的工作目录。有时候我们也许会遇到修改了代码，重启了 Tomcat，但是仍没效果，这时候便可以删除掉这个文件夹，Tomcat 下次启动的时候会重新生成。\n\n\n# 禁止 Tomcat TLD 扫描\n\nTomcat 为了支持 JSP，在应用启动的时候会扫描 JAR 包里面的 TLD 文件，加载里面定义的标签库。所以在 Tomcat 的启动日志里，你可能会碰到这种提示：\n\n> At least one JAR was scanned for TLDs yet contained no TLDs. Enable debug logging for this logger for a complete list of JARs that were scanned but no TLDs were found in them. Skipping unneeded JARs during scanning can improve startup time and JSP compilation time.\n\nTomcat 的意思是，我扫描了你 Web 应用下的 JAR 包，发现 JAR 包里没有 TLD 文件。我建议配置一下 Tomcat 不要去扫描这些 JAR 包，这样可以提高 Tomcat 的启动速度，并节省 JSP 编译时间。\n\n如何配置不去扫描这些 JAR 包呢，这里分两种情况：\n\n * 如果你的项目没有使用 JSP 作为 Web 页面模板，而是使用 Velocity 之类的模板引擎，你完全可以把 TLD 扫描禁止掉。方法是，找到 Tomcat 的conf/目录下的context.xml文件，在这个文件里 Context 标签下，加上JarScanner和JarScanFilter子标签，像下面这样。\n   \n   <Context>\n      <JarScanner >\n         <JarScanFilter defaultTldScan="true" defaultpluggabilityScan="true" />\n      </JarScanner>\n   </Context>\n   \n\n * 如果你的项目使用了 JSP 作为 Web 页面模块，意味着 TLD 扫描无法避免，但是我们可以通过配置来告诉 Tomcat，只扫描那些包含 TLD 文件的 JAR 包。方法是，找到 Tomcat 的conf/目录下的catalina.properties文件，在这个文件里的 jarsToSkip 配置项中，加上你的 JAR 包。\n   \n   tomcat.util.scan.StandardJarScanFilter.jarsToSkip=xxx.jar\n   \n\n\n# 关闭 WebSocket 支持\n\nTomcat 会扫描 WebSocket 注解的 API 实现，比如 @ServerEndpoint 注解的类。如果不需要使用 WebSockets 就可以关闭它。具体方法是，找到 Tomcat 的 conf/ 目录下的 context.xml 文件，给 Context 标签加一个 containerSciFilter 的属性：\n\n<Context containerSciFilter="org.apache.tomcat.websocket.server.WsSci">\n...\n</Context>\n\n\n更进一步，如果你不需要 WebSockets 这个功能，你可以把 Tomcat lib 目录下的 websocket-api.jar 和 tomcat-websocket.jar 这两个 JAR 文件删除掉，进一步提高性能。\n\n\n# 关闭 JSP 支持\n\n如果不需要使用 JSP，可以关闭 JSP 功能：\n\n<Context containerSciFilter="org.apache.jasper.servlet.JasperInitializer">\n...\n</Context>\n\n\n如果要同时关闭 WebSocket 和 Jsp，可以这样配置：\n\n<Context containerSciFilter="org.apache.tomcat.websocket.server.WsSci | org.apache.jasper.servlet.JasperInitializer">\n...\n</Context>\n\n\n\n# 禁止扫描 Servlet 注解\n\nServlet 3.0 引入了注解 Servlet，Tomcat 为了支持这个特性，会在 Web 应用启动时扫描你的类文件，因此如果你没有使用 Servlet 注解这个功能，可以告诉 Tomcat 不要去扫描 Servlet 注解。具体配置方法是，在你的 Web 应用的web.xml文件中，设置<web-app>元素的属性metadata-complete="true"，像下面这样。\n\n<web-app metadata-complete="true">\n</web-app>\n\n\nmetadata-complete 的意思是，web.xml 里配置的 Servlet 是完整的，不需要再去库类中找 Servlet 的定义。\n\n\n# 配置 Web-Fragment 扫描\n\nServlet 3.0 还引入了“Web 模块部署描述符片段”的 web-fragment.xml，这是一个部署描述文件，可以完成 web.xml 的配置功能。而这个 web-fragment.xml 文件必须存放在 JAR 文件的 META-INF 目录下，而 JAR 包通常放在 WEB-INF/lib 目录下，因此 Tomcat 需要对 JAR 文件进行扫描才能支持这个功能。\n\n可以通过配置 web.xml 里面的 <absolute-ordering> 元素直接指定了哪些 JAR 包需要扫描 web fragment，如果 <absolute-ordering/> 元素是空的， 则表示不需要扫描，像下面这样。\n\n<web-app metadata-complete="true">\n...\n<absolute-ordering />\n...\n</web-app>\n\n\n\n# 随机数熵源优化\n\nTomcat 7 以上的版本依赖 Java 的 SecureRandom 类来生成随机数，比如 Session ID。而 JVM 默认使用阻塞式熵源（/dev/random）， 在某些情况下就会导致 Tomcat 启动变慢。当阻塞时间较长时， 你会看到这样一条警告日志：\n\n<DATE> org.apache.catalina.util.SessionIdGenerator createSecureRandom\nINFO: Creation of SecureRandom instance for session ID generation using [SHA1PRNG] took [8152] milliseconds.\n\n\n解决方案是通过设置，让 JVM 使用非阻塞式的熵源。\n\n我们可以设置 JVM 的参数：\n\n-Djava.security.egd=file:/dev/./urandom\n\n\n或者是设置 java.security 文件，位于 $JAVA_HOME/jre/lib/security 目录之下： securerandom.source=file:/dev/./urandom\n\n这里请你注意，/dev/./urandom 中间有个 ./ 的原因是 Oracle JRE 中的 Bug，Java 8 里面的 SecureRandom 类已经修正这个 Bug。 阻塞式的熵源（/dev/random）安全性较高， 非阻塞式的熵源（/dev/./urandom）安全性会低一些，因为如果你对随机数的要求比较高， 可以考虑使用硬件方式生成熵源。\n\n\n# 并行启动多个 Web 应用\n\nTomcat 启动的时候，默认情况下 Web 应用都是一个一个启动的，等所有 Web 应用全部启动完成，Tomcat 才算启动完毕。如果在一个 Tomcat 下有多个 Web 应用，为了优化启动速度，你可以配置多个应用程序并行启动，可以通过修改 server.xml 中 Host 元素的 startStopThreads 属性来完成。startStopThreads 的值表示你想用多少个线程来启动你的 Web 应用，如果设成 0 表示你要并行启动 Web 应用，像下面这样的配置。\n\n<Engine startStopThreads="0">\n    ...\n    <Host startStopThreads="0">\n        ...\n    </Host>\n    ...\n</Engine>\n\n\n需要注意的是，Engine 元素里也配置了这个参数，这意味着如果你的 Tomcat 配置了多个 Host（虚拟主机），Tomcat 会以并行的方式启动多个 Host。\n\n\n# 参考资料\n\n * 官方\n   * Tomcat 官方网站\n   * Tomcat Wiki\n   * Tomee 官方网站\n * 教程\n   * 深入拆解 Tomcat & Jetty',normalizedContent:'# tomcat 优化\n\n\n# tomcat 启动优化\n\n如果 tomcat 启动比较慢，可以考虑一些优化点\n\n\n# 清理 tomcat\n\n * 清理不必要的 web 应用：首先我们要做的是删除掉 webapps 文件夹下不需要的工程，一般是 host-manager、example、doc 等这些默认的工程，可能还有以前添加的但现在用不着的工程，最好把这些全都删除掉。\n * 清理 xml 配置文件：tomcat 在启动时会解析所有的 xml 配置文件，解析 xml 较为耗时，所以应该尽量保持配置文件的简洁。\n * 清理 jar 文件：jvm 的类加载器在加载类时，需要查找每一个 jar 文件，去找到所需要的类。如果删除了不需要的 jar 文件，查找的速度就会快一些。这里请注意：web 应用中的 lib 目录下不应该出现 servlet api 或者 tomcat 自身的 jar，这些 jar 由 tomcat 负责提供。\n * 清理其他文件：及时清理日志，删除 logs 文件夹下不需要的日志文件。同样还有 work 文件夹下的 catalina 文件夹，它其实是 tomcat 把 jsp 转换为 class 文件的工作目录。有时候我们也许会遇到修改了代码，重启了 tomcat，但是仍没效果，这时候便可以删除掉这个文件夹，tomcat 下次启动的时候会重新生成。\n\n\n# 禁止 tomcat tld 扫描\n\ntomcat 为了支持 jsp，在应用启动的时候会扫描 jar 包里面的 tld 文件，加载里面定义的标签库。所以在 tomcat 的启动日志里，你可能会碰到这种提示：\n\n> at least one jar was scanned for tlds yet contained no tlds. enable debug logging for this logger for a complete list of jars that were scanned but no tlds were found in them. skipping unneeded jars during scanning can improve startup time and jsp compilation time.\n\ntomcat 的意思是，我扫描了你 web 应用下的 jar 包，发现 jar 包里没有 tld 文件。我建议配置一下 tomcat 不要去扫描这些 jar 包，这样可以提高 tomcat 的启动速度，并节省 jsp 编译时间。\n\n如何配置不去扫描这些 jar 包呢，这里分两种情况：\n\n * 如果你的项目没有使用 jsp 作为 web 页面模板，而是使用 velocity 之类的模板引擎，你完全可以把 tld 扫描禁止掉。方法是，找到 tomcat 的conf/目录下的context.xml文件，在这个文件里 context 标签下，加上jarscanner和jarscanfilter子标签，像下面这样。\n   \n   <context>\n      <jarscanner >\n         <jarscanfilter defaulttldscan="true" defaultpluggabilityscan="true" />\n      </jarscanner>\n   </context>\n   \n\n * 如果你的项目使用了 jsp 作为 web 页面模块，意味着 tld 扫描无法避免，但是我们可以通过配置来告诉 tomcat，只扫描那些包含 tld 文件的 jar 包。方法是，找到 tomcat 的conf/目录下的catalina.properties文件，在这个文件里的 jarstoskip 配置项中，加上你的 jar 包。\n   \n   tomcat.util.scan.standardjarscanfilter.jarstoskip=xxx.jar\n   \n\n\n# 关闭 websocket 支持\n\ntomcat 会扫描 websocket 注解的 api 实现，比如 @serverendpoint 注解的类。如果不需要使用 websockets 就可以关闭它。具体方法是，找到 tomcat 的 conf/ 目录下的 context.xml 文件，给 context 标签加一个 containerscifilter 的属性：\n\n<context containerscifilter="org.apache.tomcat.websocket.server.wssci">\n...\n</context>\n\n\n更进一步，如果你不需要 websockets 这个功能，你可以把 tomcat lib 目录下的 websocket-api.jar 和 tomcat-websocket.jar 这两个 jar 文件删除掉，进一步提高性能。\n\n\n# 关闭 jsp 支持\n\n如果不需要使用 jsp，可以关闭 jsp 功能：\n\n<context containerscifilter="org.apache.jasper.servlet.jasperinitializer">\n...\n</context>\n\n\n如果要同时关闭 websocket 和 jsp，可以这样配置：\n\n<context containerscifilter="org.apache.tomcat.websocket.server.wssci | org.apache.jasper.servlet.jasperinitializer">\n...\n</context>\n\n\n\n# 禁止扫描 servlet 注解\n\nservlet 3.0 引入了注解 servlet，tomcat 为了支持这个特性，会在 web 应用启动时扫描你的类文件，因此如果你没有使用 servlet 注解这个功能，可以告诉 tomcat 不要去扫描 servlet 注解。具体配置方法是，在你的 web 应用的web.xml文件中，设置<web-app>元素的属性metadata-complete="true"，像下面这样。\n\n<web-app metadata-complete="true">\n</web-app>\n\n\nmetadata-complete 的意思是，web.xml 里配置的 servlet 是完整的，不需要再去库类中找 servlet 的定义。\n\n\n# 配置 web-fragment 扫描\n\nservlet 3.0 还引入了“web 模块部署描述符片段”的 web-fragment.xml，这是一个部署描述文件，可以完成 web.xml 的配置功能。而这个 web-fragment.xml 文件必须存放在 jar 文件的 meta-inf 目录下，而 jar 包通常放在 web-inf/lib 目录下，因此 tomcat 需要对 jar 文件进行扫描才能支持这个功能。\n\n可以通过配置 web.xml 里面的 <absolute-ordering> 元素直接指定了哪些 jar 包需要扫描 web fragment，如果 <absolute-ordering/> 元素是空的， 则表示不需要扫描，像下面这样。\n\n<web-app metadata-complete="true">\n...\n<absolute-ordering />\n...\n</web-app>\n\n\n\n# 随机数熵源优化\n\ntomcat 7 以上的版本依赖 java 的 securerandom 类来生成随机数，比如 session id。而 jvm 默认使用阻塞式熵源（/dev/random）， 在某些情况下就会导致 tomcat 启动变慢。当阻塞时间较长时， 你会看到这样一条警告日志：\n\n<date> org.apache.catalina.util.sessionidgenerator createsecurerandom\ninfo: creation of securerandom instance for session id generation using [sha1prng] took [8152] milliseconds.\n\n\n解决方案是通过设置，让 jvm 使用非阻塞式的熵源。\n\n我们可以设置 jvm 的参数：\n\n-djava.security.egd=file:/dev/./urandom\n\n\n或者是设置 java.security 文件，位于 $java_home/jre/lib/security 目录之下： securerandom.source=file:/dev/./urandom\n\n这里请你注意，/dev/./urandom 中间有个 ./ 的原因是 oracle jre 中的 bug，java 8 里面的 securerandom 类已经修正这个 bug。 阻塞式的熵源（/dev/random）安全性较高， 非阻塞式的熵源（/dev/./urandom）安全性会低一些，因为如果你对随机数的要求比较高， 可以考虑使用硬件方式生成熵源。\n\n\n# 并行启动多个 web 应用\n\ntomcat 启动的时候，默认情况下 web 应用都是一个一个启动的，等所有 web 应用全部启动完成，tomcat 才算启动完毕。如果在一个 tomcat 下有多个 web 应用，为了优化启动速度，你可以配置多个应用程序并行启动，可以通过修改 server.xml 中 host 元素的 startstopthreads 属性来完成。startstopthreads 的值表示你想用多少个线程来启动你的 web 应用，如果设成 0 表示你要并行启动 web 应用，像下面这样的配置。\n\n<engine startstopthreads="0">\n    ...\n    <host startstopthreads="0">\n        ...\n    </host>\n    ...\n</engine>\n\n\n需要注意的是，engine 元素里也配置了这个参数，这意味着如果你的 tomcat 配置了多个 host（虚拟主机），tomcat 会以并行的方式启动多个 host。\n\n\n# 参考资料\n\n * 官方\n   * tomcat 官方网站\n   * tomcat wiki\n   * tomee 官方网站\n * 教程\n   * 深入拆解 tomcat & jetty',charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Tomcat 和 Jetty",frontmatter:{title:"Tomcat 和 Jetty",date:"2022-02-17T22:34:30.000Z",order:5,categories:["Java","JavaEE","服务器","Tomcat"],tags:["Java","JavaWeb","服务器","Tomcat","Jetty"],permalink:"/pages/f37326/"},regularPath:"/01.Java/02.JavaEE/02.%E6%9C%8D%E5%8A%A1%E5%99%A8/01.Tomcat/05.Tomcat%E5%92%8CJetty.html",relativePath:"01.Java/02.JavaEE/02.服务器/01.Tomcat/05.Tomcat和Jetty.md",key:"v-14be4fe4",path:"/pages/f37326/",headers:[{level:2,title:"Tomcat 和 Jetty",slug:"tomcat-和-jetty",normalizedTitle:"tomcat 和 jetty",charIndex:2},{level:2,title:"Web 容器",slug:"web-容器",normalizedTitle:"web 容器",charIndex:18}],headersStr:"Tomcat 和 Jetty Web 容器",content:"# Tomcat 和 Jetty\n\nWeb 容器 Tomcat 或 Jetty，作为重要的系统中间件，连接着浏览器和你的 Web 应用，并且支撑着 Web 程序的运行，可以说，弄懂了 Tomcat 和 Jetty 的原理，Java Web 开发对你来说就毫无秘密可言。\n\n\n# Web 容器\n\n早期的 Web 应用主要用于浏览新闻等静态页面，HTTP 服务器（比如 Apache、Nginx）向浏览器返回静态 HTML，浏览器负责解析 HTML，将结果呈现给用户。\n\n随着互联网的发展，我们已经不满足于仅仅浏览静态页面，还希望通过一些交互操作，来获取动态结果，因此也就需要一些扩展机制能够让 HTTP 服务器调用服务端程序。\n\n于是 Sun 公司推出了 Servlet 技术。你可以把 Servlet 简单理解为运行在服务端的 Java 小程序，但是 Servlet 没有 main 方法，不能独立运行，因此必须把它部署到 Servlet 容器中，由容器来实例化并调用 Servlet。\n\n而 Tomcat 和 Jetty 就是一个 Servlet 容器。为了方便使用，它们也具有 HTTP 服务器的功能，因此Tomcat 或者 Jetty 就是一个“HTTP 服务器 + Servlet 容器”，我们也叫它们 Web 容器。\n\n其他应用服务器比如 JBoss 和 WebLogic，它们不仅仅有 Servlet 容器的功能，也包含 EJB 容器，是完整的 Java EE 应用服务器。从这个角度看，Tomcat 和 Jetty 算是一个轻量级的应用服务器。\n\n在微服务架构日渐流行的今天，开发人员更喜欢稳定的、轻量级的应用服务器，并且应用程序用内嵌的方式来运行 Servlet 容器也逐渐流行起来。之所以选择轻量级，是因为在微服务架构下，我们把一个大而全的单体应用，拆分成一个个功能单一的微服务，在这个过程中，服务的数量必然要增加，但为了减少资源的消耗，并且降低部署的成本，我们希望运行服务的 Web 容器也是轻量级的，Web 容器本身应该消耗较少的内存和 CPU 资源，并且由应用本身来启动一个嵌入式的 Web 容器，而不是通过 Web 容器来部署和启动应用，这样可以降低应用部署的复杂度。",normalizedContent:"# tomcat 和 jetty\n\nweb 容器 tomcat 或 jetty，作为重要的系统中间件，连接着浏览器和你的 web 应用，并且支撑着 web 程序的运行，可以说，弄懂了 tomcat 和 jetty 的原理，java web 开发对你来说就毫无秘密可言。\n\n\n# web 容器\n\n早期的 web 应用主要用于浏览新闻等静态页面，http 服务器（比如 apache、nginx）向浏览器返回静态 html，浏览器负责解析 html，将结果呈现给用户。\n\n随着互联网的发展，我们已经不满足于仅仅浏览静态页面，还希望通过一些交互操作，来获取动态结果，因此也就需要一些扩展机制能够让 http 服务器调用服务端程序。\n\n于是 sun 公司推出了 servlet 技术。你可以把 servlet 简单理解为运行在服务端的 java 小程序，但是 servlet 没有 main 方法，不能独立运行，因此必须把它部署到 servlet 容器中，由容器来实例化并调用 servlet。\n\n而 tomcat 和 jetty 就是一个 servlet 容器。为了方便使用，它们也具有 http 服务器的功能，因此tomcat 或者 jetty 就是一个“http 服务器 + servlet 容器”，我们也叫它们 web 容器。\n\n其他应用服务器比如 jboss 和 weblogic，它们不仅仅有 servlet 容器的功能，也包含 ejb 容器，是完整的 java ee 应用服务器。从这个角度看，tomcat 和 jetty 算是一个轻量级的应用服务器。\n\n在微服务架构日渐流行的今天，开发人员更喜欢稳定的、轻量级的应用服务器，并且应用程序用内嵌的方式来运行 servlet 容器也逐渐流行起来。之所以选择轻量级，是因为在微服务架构下，我们把一个大而全的单体应用，拆分成一个个功能单一的微服务，在这个过程中，服务的数量必然要增加，但为了减少资源的消耗，并且降低部署的成本，我们希望运行服务的 web 容器也是轻量级的，web 容器本身应该消耗较少的内存和 cpu 资源，并且由应用本身来启动一个嵌入式的 web 容器，而不是通过 web 容器来部署和启动应用，这样可以降低应用部署的复杂度。",charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Tomcat 教程",frontmatter:{title:"Tomcat 教程",date:"2022-02-18T08:53:11.000Z",categories:["Java","JavaEE","服务器","Tomcat"],tags:["Java","JavaWeb","服务器","Tomcat"],permalink:"/pages/33e817/",hidden:!0,index:!1},regularPath:"/01.Java/02.JavaEE/02.%E6%9C%8D%E5%8A%A1%E5%99%A8/01.Tomcat/",relativePath:"01.Java/02.JavaEE/02.服务器/01.Tomcat/README.md",key:"v-2e4483c6",path:"/pages/33e817/",headers:[{level:2,title:"📖 内容",slug:"📖-内容",normalizedTitle:"📖 内容",charIndex:16},{level:2,title:"📚 资料",slug:"📚-资料",normalizedTitle:"📚 资料",charIndex:100},{level:2,title:"🚪 传送",slug:"🚪-传送",normalizedTitle:"🚪 传送",charIndex:147}],headersStr:"📖 内容 📚 资料 🚪 传送",content:"# Tomcat 教程\n\n\n# 📖 内容\n\n * Tomcat 快速入门\n * Tomcat 连接器\n * Tomcat 容器\n * Tomcat 优化\n * Tomcat 和 Jetty\n\n\n# 📚 资料\n\n * Tomcat 官网\n * 深入拆解 Tomcat & Jetty\n\n\n# 🚪 传送\n\n◾ 💧 钝悟的 IT 知识图谱 ◾",normalizedContent:"# tomcat 教程\n\n\n# 📖 内容\n\n * tomcat 快速入门\n * tomcat 连接器\n * tomcat 容器\n * tomcat 优化\n * tomcat 和 jetty\n\n\n# 📚 资料\n\n * tomcat 官网\n * 深入拆解 tomcat & jetty\n\n\n# 🚪 传送\n\n◾ 💧 钝悟的 it 知识图谱 ◾",charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Jetty 快速入门",frontmatter:{title:"Jetty 快速入门",date:"2022-02-17T22:34:30.000Z",order:2,categories:["Java","JavaEE","服务器"],tags:["Java","JavaWeb","服务器","Jetty"],permalink:"/pages/ec364e/"},regularPath:"/01.Java/02.JavaEE/02.%E6%9C%8D%E5%8A%A1%E5%99%A8/02.Jetty.html",relativePath:"01.Java/02.JavaEE/02.服务器/02.Jetty.md",key:"v-48965ab6",path:"/pages/ec364e/",headers:[{level:2,title:"Jetty 简介",slug:"jetty-简介",normalizedTitle:"jetty 简介",charIndex:17},{level:2,title:"Jetty 的使用",slug:"jetty-的使用",normalizedTitle:"jetty 的使用",charIndex:437},{level:3,title:"API 方式",slug:"api-方式",normalizedTitle:"api 方式",charIndex:514},{level:3,title:"Maven 插件方式",slug:"maven-插件方式",normalizedTitle:"maven 插件方式",charIndex:2878},{level:2,title:"Jetty 的架构",slug:"jetty-的架构",normalizedTitle:"jetty 的架构",charIndex:5677},{level:3,title:"Jetty 架构简介",slug:"jetty-架构简介",normalizedTitle:"jetty 架构简介",charIndex:5691},{level:3,title:"Jetty 和 Tomcat 架构区别",slug:"jetty-和-tomcat-架构区别",normalizedTitle:"jetty 和 tomcat 架构区别",charIndex:6242},{level:3,title:"Connector 组件",slug:"connector-组件",normalizedTitle:"connector 组件",charIndex:5824},{level:4,title:"Acceptor",slug:"acceptor",normalizedTitle:"acceptor",charIndex:6803},{level:3,title:"Handler 组件",slug:"handler-组件",normalizedTitle:"handler 组件",charIndex:5838},{level:4,title:"Handler 继承关系",slug:"handler-继承关系",normalizedTitle:"handler 继承关系",charIndex:11406},{level:4,title:"实现 Servlet 规范",slug:"实现-servlet-规范",normalizedTitle:"实现 servlet 规范",charIndex:12865},{level:2,title:"Jetty 的线程策略",slug:"jetty-的线程策略",normalizedTitle:"jetty 的线程策略",charIndex:13927},{level:3,title:"传统 Selector 编程模型",slug:"传统-selector-编程模型",normalizedTitle:"传统 selector 编程模型",charIndex:13943},{level:3,title:"Jetty 的 Selector 编程模型",slug:"jetty-的-selector-编程模型",normalizedTitle:"jetty 的 selector 编程模型",charIndex:14210},{level:4,title:"ManagedSelector",slug:"managedselector",normalizedTitle:"managedselector",charIndex:8042},{level:4,title:"SelectorUpdate 接口",slug:"selectorupdate-接口",normalizedTitle:"selectorupdate 接口",charIndex:15533},{level:4,title:"Selectable 接口",slug:"selectable-接口",normalizedTitle:"selectable 接口",charIndex:16671},{level:4,title:"ExecutionStrategy",slug:"executionstrategy",normalizedTitle:"executionstrategy",charIndex:15206},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:20913}],headersStr:"Jetty 简介 Jetty 的使用 API 方式 Maven 插件方式 Jetty 的架构 Jetty 架构简介 Jetty 和 Tomcat 架构区别 Connector 组件 Acceptor Handler 组件 Handler 继承关系 实现 Servlet 规范 Jetty 的线程策略 传统 Selector 编程模型 Jetty 的 Selector 编程模型 ManagedSelector SelectorUpdate 接口 Selectable 接口 ExecutionStrategy 参考资料",content:'# Jetty 快速入门\n\n\n# Jetty 简介\n\njetty 是什么？\n\njetty 是轻量级的 web 服务器和 servlet 引擎。\n\n它的最大特点是：可以很方便的作为嵌入式服务器。\n\n它是 eclipse 的一个开源项目。不用怀疑，就是你常用的那个 eclipse。\n\n它是使用 Java 开发的，所以天然对 Java 支持良好。\n\n官方网址\n\ngithub 源码地址\n\n什么是嵌入式服务器？\n\n以 jetty 来说明，就是只要引入 jetty 的 jar 包，可以通过直接调用其 API 的方式来启动 web 服务。\n\n用过 Tomcat、Resin 等服务器的朋友想必不会陌生那一套安装、配置、部署的流程吧，还是挺繁琐的。使用 jetty，就不需要这些过程了。\n\njetty 非常适用于项目的开发、测试，因为非常快捷。如果想用于生产环境，则需要谨慎考虑，它不一定能像成熟的 Tomcat、Resin 等服务器一样支持企业级 Java EE 的需要。\n\n\n# Jetty 的使用\n\n我觉得嵌入式启动方式的一个好处在于：可以直接运行项目，无需每次部署都得再配置服务器。\n\njetty 的嵌入式启动使用有两种方式：\n\nAPI 方式\n\nmaven 插件方式\n\n\n# API 方式\n\n添加 maven 依赖\n\n<dependency>\n  <groupId>org.eclipse.jetty</groupId>\n  <artifactId>jetty-webapp</artifactId>\n  <version>9.3.2.v20150730</version>\n  <scope>test</scope>\n</dependency>\n<dependency>\n  <groupId>org.eclipse.jetty</groupId>\n  <artifactId>jetty-annotations</artifactId>\n  <version>9.3.2.v20150730</version>\n  <scope>test</scope>\n</dependency>\n<dependency>\n  <groupId>org.eclipse.jetty</groupId>\n  <artifactId>apache-jsp</artifactId>\n  <version>9.3.2.v20150730</version>\n  <scope>test</scope>\n</dependency>\n<dependency>\n  <groupId>org.eclipse.jetty</groupId>\n  <artifactId>apache-jstl</artifactId>\n  <version>9.3.2.v20150730</version>\n  <scope>test</scope>\n</dependency>\n\n\n官方的启动代码\n\npublic class SplitFileServer\n{\n    public static void main( String[] args ) throws Exception\n    {\n        // 创建Server对象，并绑定端口\n        Server server = new Server();\n        ServerConnector connector = new ServerConnector(server);\n        connector.setPort(8090);\n        server.setConnectors(new Connector[] { connector });\n\n        // 创建上下文句柄，绑定上下文路径。这样启动后的url就会是:http://host:port/context\n        ResourceHandler rh0 = new ResourceHandler();\n        ContextHandler context0 = new ContextHandler();\n        context0.setContextPath("/");\n\n        // 绑定测试资源目录（在本例的配置目录dir0的路径是src/test/resources/dir0）\n        File dir0 = MavenTestingUtils.getTestResourceDir("dir0");\n        context0.setBaseResource(Resource.newResource(dir0));\n        context0.setHandler(rh0);\n\n        // 和上面的例子一样\n        ResourceHandler rh1 = new ResourceHandler();\n        ContextHandler context1 = new ContextHandler();\n        context1.setContextPath("/");\n        File dir1 = MavenTestingUtils.getTestResourceDir("dir1");\n        context1.setBaseResource(Resource.newResource(dir1));\n        context1.setHandler(rh1);\n\n        // 绑定两个资源句柄\n        ContextHandlerCollection contexts = new ContextHandlerCollection();\n        contexts.setHandlers(new Handler[] { context0, context1 });\n        server.setHandler(contexts);\n\n        // 启动\n        server.start();\n\n        // 打印dump时的信息\n        System.out.println(server.dump());\n\n        // join当前线程\n        server.join();\n    }\n}\n\n\n直接运行 Main 方法，就可以启动 web 服务。\n\n注：以上代码在 eclipse 中运行没有问题，如果想在 Intellij 中运行还需要为它指定配置文件。\n\n如果想了解在 Eclipse 和 Intellij 都能运行的通用方法可以参考我的 github 代码示例。\n\n我的实现也是参考 springside 的方式。\n\n代码行数有点多，不在这里贴代码了。\n\n完整参考代码\n\n\n# Maven 插件方式\n\n如果你熟悉 maven，那么实在太简单了\n\n注： Maven 版本必须在 3.3 及以上版本。\n\n(1) 添加 maven 插件\n\n<plugin>\n  <groupId>org.eclipse.jetty</groupId>\n  <artifactId>jetty-maven-plugin</artifactId>\n  <version>9.3.12.v20160915</version>\n</plugin>\n\n\n(2) 执行 maven 命令：\n\nmvn jetty:run\n\n\n讲真，就是这么简单。jetty 默认会为你创建一个 web 服务，地址为 127.0.0.1:8080。\n\n当然，你也可以在插件中配置你的 webapp 环境\n\n<plugin>\n  <groupId>org.eclipse.jetty</groupId>\n  <artifactId>jetty-maven-plugin</artifactId>\n  <version>9.3.12.v20160915</version>\n\n  <configuration>\n <webAppSourceDirectory>${project.basedir}/src/staticfiles</webAppSourceDirectory>\n\n    \x3c!-- 配置webapp --\x3e\n <webApp>\n   <contextPath>/</contextPath>\n   <descriptor>${project.basedir}/src/over/here/web.xml</descriptor>\n   <jettyEnvXml>${project.basedir}/src/over/here/jetty-env.xml</jettyEnvXml>\n </webApp>\n\n    \x3c!-- 配置classes --\x3e\n <classesDirectory>${project.basedir}/somewhere/else</classesDirectory>\n <scanClassesPattern>\n   <excludes>\n  <exclude>**/Foo.class</exclude>\n   </excludes>\n </scanClassesPattern>\n <scanTargets>\n   <scanTarget>src/mydir</scanTarget>\n   <scanTarget>src/myfile.txt</scanTarget>\n </scanTargets>\n\n    \x3c!-- 扫描target目录下的资源文件 --\x3e\n <scanTargetPatterns>\n   <scanTargetPattern>\n <directory>src/other-resources</directory>\n <includes>\n   <include>**/*.xml</include>\n   <include>**/*.properties</include>\n </includes>\n <excludes>\n   <exclude>**/myspecial.xml</exclude>\n   <exclude>**/myspecial.properties</exclude>\n </excludes>\n   </scanTargetPattern>\n </scanTargetPatterns>\n  </configuration>\n</plugin>\n\n\n官方给的 jetty-env.xml 范例\n\n <?xml version="1.0"?>\n <!DOCTYPE Configure PUBLIC "-//Mort Bay Consulting//DTD Configure//EN" "http://jetty.mortbay.org/configure.dtd">\n\n <Configure class="org.eclipse.jetty.webapp.WebAppContext">\n\n   \x3c!-- Add an EnvEntry only valid for this webapp               --\x3e\n   <New id="gargle"  class="org.eclipse.jetty.plus.jndi.EnvEntry">\n     <Arg>gargle</Arg>\n     <Arg type="java.lang.Double">100</Arg>\n     <Arg type="boolean">true</Arg>\n   </New>\n\n  \x3c!-- Add an override for a global EnvEntry                           --\x3e\n   <New id="wiggle"  class="org.eclipse.jetty.plus.jndi.EnvEntry">\n     <Arg>wiggle</Arg>\n     <Arg type="java.lang.Double">55.0</Arg>\n     <Arg type="boolean">true</Arg>\n   </New>\n\n   \x3c!-- an XADataSource                                                --\x3e\n   <New id="mydatasource99" class="org.eclipse.jetty.plus.jndi.Resource">\n     <Arg>jdbc/mydatasource99</Arg>\n     <Arg>\n       <New class="com.atomikos.jdbc.SimpleDataSourceBean">\n         <Set name="xaDataSourceClassName">org.apache.derby.jdbc.EmbeddedXADataSource</Set>\n         <Set name="xaDataSourceProperties">databaseName=testdb99;createDatabase=create</Set>\n         <Set name="UniqueResourceName">mydatasource99</Set>\n       </New>\n     </Arg>\n   </New>\n\n </Configure>\n\n\n\n# Jetty 的架构\n\n\n# Jetty 架构简介\n\n\n\nJetty Server 就是由多个 Connector（连接器）、多个 Handler（处理器），以及一个线程池组成。\n\n跟 Tomcat 一样，Jetty 也有 HTTP 服务器和 Servlet 容器的功能，因此 Jetty 中的 Connector 组件和 Handler 组件分别来实现这两个功能，而这两个组件工作时所需要的线程资源都直接从一个全局线程池 ThreadPool 中获取。\n\nJetty Server 可以有多个 Connector 在不同的端口上监听客户请求，而对于请求处理的 Handler 组件，也可以根据具体场景使用不同的 Handler。这样的设计提高了 Jetty 的灵活性，需要支持 Servlet，则可以使用 ServletHandler；需要支持 Session，则再增加一个 SessionHandler。也就是说我们可以不使用 Servlet 或者 Session，只要不配置这个 Handler 就行了。\n\n为了启动和协调上面的核心组件工作，Jetty 提供了一个 Server 类来做这个事情，它负责创建并初始化 Connector、Handler、ThreadPool 组件，然后调用 start 方法启动它们。\n\n\n# Jetty 和 Tomcat 架构区别\n\n对比一下 Tomcat 的整体架构图，你会发现 Tomcat 在整体上跟 Jetty 很相似，它们的第一个区别是 Jetty 中没有 Service 的概念，Tomcat 中的 Service 包装了多个连接器和一个容器组件，一个 Tomcat 实例可以配置多个 Service，不同的 Service 通过不同的连接器监听不同的端口；而 Jetty 中 Connector 是被所有 Handler 共享的。\n\n第二个区别是，在 Tomcat 中每个连接器都有自己的线程池，而在 Jetty 中所有的 Connector 共享一个全局的线程池。\n\n\n# Connector 组件\n\n跟 Tomcat 一样，Connector 的主要功能是对 I/O 模型和应用层协议的封装。I/O 模型方面，最新的 Jetty 9 版本只支持 NIO，因此 Jetty 的 Connector 设计有明显的 Java NIO 通信模型的痕迹。至于应用层协议方面，跟 Tomcat 的 Processor 一样，Jetty 抽象出了 Connection 组件来封装应用层协议的差异。\n\n服务端在 NIO 通信上主要完成了三件事情：监听连接、I/O 事件查询以及数据读写。因此 Jetty 设计了Acceptor、SelectorManager 和 Connection 来分别做这三件事情\n\n# Acceptor\n\nAcceptor 用于接受请求。跟 Tomcat 一样，Jetty 也有独立的 Acceptor 线程组用于处理连接请求。在 Connector 的实现类 ServerConnector 中，有一个 _acceptors 的数组，在 Connector 启动的时候, 会根据 _acceptors 数组的长度创建对应数量的 Acceptor，而 Acceptor 的个数可以配置。\n\nfor (int i = 0; i < _acceptors.length; i++)\n{\n  Acceptor a = new Acceptor(i);\n  getExecutor().execute(a);\n}\n\n\nAcceptor 是 ServerConnector 中的一个内部类，同时也是一个 Runnable，Acceptor 线程是通过 getExecutor() 得到的线程池来执行的，前面提到这是一个全局的线程池。\n\nAcceptor 通过阻塞的方式来接受连接，这一点跟 Tomcat 也是一样的。\n\npublic void accept(int acceptorID) throws IOException\n{\n  ServerSocketChannel serverChannel = _acceptChannel;\n  if (serverChannel != null && serverChannel.isOpen())\n  {\n    // 这里是阻塞的\n    SocketChannel channel = serverChannel.accept();\n    // 执行到这里时说明有请求进来了\n    accepted(channel);\n  }\n}\n\n\n接受连接成功后会调用 accepted() 函数，accepted() 函数中会将 SocketChannel 设置为非阻塞模式，然后交给 Selector 去处理，因此这也就到了 Selector 的地界了。\n\nprivate void accepted(SocketChannel channel) throws IOException\n{\n    channel.configureBlocking(false);\n    Socket socket = channel.socket();\n    configure(socket);\n    // _manager 是 SelectorManager 实例，里面管理了所有的 Selector 实例\n    _manager.accept(channel);\n}\n\n\nSelectorManager\n\nJetty 的 Selector 由 SelectorManager 类管理，而被管理的 Selector 叫作 ManagedSelector。SelectorManager 内部有一个 ManagedSelector 数组，真正干活的是 ManagedSelector。咱们接着上面分析，看看在 SelectorManager 在 accept 方法里做了什么。\n\npublic void accept(SelectableChannel channel, Object attachment)\n{\n  // 选择一个 ManagedSelector 来处理 Channel\n  final ManagedSelector selector = chooseSelector();\n  // 提交一个任务 Accept 给 ManagedSelector\n  selector.submit(selector.new Accept(channel, attachment));\n}\n\n\nSelectorManager 从本身的 Selector 数组中选择一个 Selector 来处理这个 Channel，并创建一个任务 Accept 交给 ManagedSelector，ManagedSelector 在处理这个任务主要做了两步：\n\n第一步，调用 Selector 的 register 方法把 Channel 注册到 Selector 上，拿到一个 SelectionKey。\n\n _key = _channel.register(selector, SelectionKey.OP_ACCEPT, this);\n\n\n第二步，创建一个 EndPoint 和 Connection，并跟这个 SelectionKey（Channel）绑在一起：\n\nprivate void createEndPoint(SelectableChannel channel, SelectionKey selectionKey) throws IOException\n{\n    //1. 创建 Endpoint\n    EndPoint endPoint = _selectorManager.newEndPoint(channel, this, selectionKey);\n\n    //2. 创建 Connection\n    Connection connection = _selectorManager.newConnection(channel, endPoint, selectionKey.attachment());\n\n    //3. 把 Endpoint、Connection 和 SelectionKey 绑在一起\n    endPoint.setConnection(connection);\n    selectionKey.attach(endPoint);\n\n}\n\n\n这里需要你特别注意的是，ManagedSelector 并没有直接调用 EndPoint 的方法去处理数据，而是通过调用 EndPoint 的方法返回一个 Runnable，然后把这个 Runnable 扔给线程池执行，所以你能猜到，这个 Runnable 才会去真正读数据和处理请求。\n\nConnection\n\n这个 Runnable 是 EndPoint 的一个内部类，它会调用 Connection 的回调方法来处理请求。Jetty 的 Connection 组件类比就是 Tomcat 的 Processor，负责具体协议的解析，得到 Request 对象，并调用 Handler 容器进行处理。下面我简单介绍一下它的具体实现类 HttpConnection 对请求和响应的处理过程。\n\n请求处理：HttpConnection 并不会主动向 EndPoint 读取数据，而是向在 EndPoint 中注册一堆回调方法：\n\ngetEndPoint().fillInterested(_readCallback);\n\n\n这段代码就是告诉 EndPoint，数据到了你就调我这些回调方法 _readCallback 吧，有点异步 I/O 的感觉，也就是说 Jetty 在应用层面模拟了异步 I/O 模型。\n\n而在回调方法 _readCallback 里，会调用 EndPoint 的接口去读数据，读完后让 HTTP 解析器去解析字节流，HTTP 解析器会将解析后的数据，包括请求行、请求头相关信息存到 Request 对象里。\n\n响应处理：Connection 调用 Handler 进行业务处理，Handler 会通过 Response 对象来操作响应流，向流里面写入数据，HttpConnection 再通过 EndPoint 把数据写到 Channel，这样一次响应就完成了。\n\n到此你应该了解了 Connector 的工作原理，下面我画张图再来回顾一下 Connector 的工作流程。\n\n\n\n 1. Acceptor 监听连接请求，当有连接请求到达时就接受连接，一个连接对应一个 Channel，Acceptor 将 Channel 交给 ManagedSelector 来处理。\n\n 2. ManagedSelector 把 Channel 注册到 Selector 上，并创建一个 EndPoint 和 Connection 跟这个 Channel 绑定，接着就不断地检测 I/O 事件。\n\n 3. I/O 事件到了就调用 EndPoint 的方法拿到一个 Runnable，并扔给线程池执行。\n\n 4. 线程池中调度某个线程执行 Runnable。\n\n 5. Runnable 执行时，调用回调函数，这个回调函数是 Connection 注册到 EndPoint 中的。\n\n 6. 回调函数内部实现，其实就是调用 EndPoint 的接口方法来读数据。\n\n 7. Connection 解析读到的数据，生成请求对象并交给 Handler 组件去处理。\n\n\n# Handler 组件\n\nJetty 的 Handler 设计是它的一大特色，Jetty 本质就是一个 Handler 管理器，Jetty 本身就提供了一些默认 Handler 来实现 Servlet 容器的功能，你也可以定义自己的 Handler 来添加到 Jetty 中，这体现了“微内核 + 插件”的设计思想。\n\nHandler 就是一个接口，它有一堆实现类，Jetty 的 Connector 组件调用这些接口来处理 Servlet 请求。\n\npublic interface Handler extends LifeCycle, Destroyable\n{\n    // 处理请求的方法\n    public void handle(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response)\n        throws IOException, ServletException;\n\n    // 每个 Handler 都关联一个 Server 组件，被 Server 管理\n    public void setServer(Server server);\n    public Server getServer();\n\n    // 销毁方法相关的资源\n    public void destroy();\n}\n\n\n方法说明：\n\n * Handler 的 handle 方法跟 Tomcat 容器组件的 service 方法一样，它有 ServletRequest 和 ServeletResponse 两个参数。\n * 因为任何一个 Handler 都需要关联一个 Server 组件，Handler 需要被 Server 组件来管理。Handler 通过 setServer 和 getServer 方法绑定 Server。\n * Handler 会加载一些资源到内存，因此通过设置 destroy 方法来销毁。\n\n# Handler 继承关系\n\nHandler 只是一个接口，完成具体功能的还是它的子类。那么 Handler 有哪些子类呢？它们的继承关系又是怎样的？这些子类是如何实现 Servlet 容器功能的呢？\n\n\n\n在 AbstractHandler 之下有 AbstractHandlerContainer，为什么需要这个类呢？这其实是个过渡，为了实现链式调用，一个 Handler 内部必然要有其他 Handler 的引用，所以这个类的名字里才有 Container，意思就是这样的 Handler 里包含了其他 Handler 的引用。\n\nHandlerWrapper 和 HandlerCollection 都是 Handler，但是这些 Handler 里还包括其他 Handler 的引用。不同的是，HandlerWrapper 只包含一个其他 Handler 的引用，而 HandlerCollection 中有一个 Handler 数组的引用。\n\nHandlerWrapper 有两个子类：Server 和 ScopedHandler。\n\n * Server 比较好理解，它本身是 Handler 模块的入口，必然要将请求传递给其他 Handler 来处理，为了触发其他 Handler 的调用，所以它是一个 HandlerWrapper。\n * ScopedHandler 也是一个比较重要的 Handler，实现了“具有上下文信息”的责任链调用。为什么我要强调“具有上下文信息”呢？那是因为 Servlet 规范规定 Servlet 在执行过程中是有上下文的。那么这些 Handler 在执行过程中如何访问这个上下文呢？这个上下文又存在什么地方呢？答案就是通过 ScopedHandler 来实现的。\n\nHandlerCollection 其实维护了一个 Handler 数组。这是为了同时支持多个 Web 应用，如果每个 Web 应用有一个 Handler 入口，那么多个 Web 应用的 Handler 就成了一个数组，比如 Server 中就有一个 HandlerCollection，Server 会根据用户请求的 URL 从数组中选取相应的 Handler 来处理，就是选择特定的 Web 应用来处理请求。\n\nHandler 可以分成三种类型：\n\n * 第一种是协调 Handler，这种 Handler 负责将请求路由到一组 Handler 中去，比如 HandlerCollection，它内部持有一个 Handler 数组，当请求到来时，它负责将请求转发到数组中的某一个 Handler。\n * 第二种是过滤器 Handler，这种 Handler 自己会处理请求，处理完了后再把请求转发到下一个 Handler，比如图上的 HandlerWrapper，它内部持有下一个 Handler 的引用。需要注意的是，所有继承了 HandlerWrapper 的 Handler 都具有了过滤器 Handler 的特征，比如 ContextHandler、SessionHandler 和 WebAppContext 等。\n * 第三种是内容 Handler，说白了就是这些 Handler 会真正调用 Servlet 来处理请求，生成响应的内容，比如 ServletHandler。如果浏览器请求的是一个静态资源，也有相应的 ResourceHandler 来处理这个请求，返回静态页面。\n\n# 实现 Servlet 规范\n\nServletHandler、ContextHandler 以及 WebAppContext 等，它们实现了 Servlet 规范。\n\nServlet 规范中有 Context、Servlet、Filter、Listener 和 Session 等，Jetty 要支持 Servlet 规范，就需要有相应的 Handler 来分别实现这些功能。因此，Jetty 设计了 3 个组件：ContextHandler、ServletHandler 和 SessionHandler 来实现 Servle 规范中规定的功能，而WebAppContext 本身就是一个 ContextHandler，另外它还负责管理 ServletHandler 和 SessionHandler。\n\nContextHandler 会创建并初始化 Servlet 规范里的 ServletContext 对象，同时 ContextHandler 还包含了一组能够让你的 Web 应用运行起来的 Handler，可以这样理解，Context 本身也是一种 Handler，它里面包含了其他的 Handler，这些 Handler 能处理某个特定 URL 下的请求。比如，ContextHandler 包含了一个或者多个 ServletHandler。\n\nServletHandler 实现了 Servlet 规范中的 Servlet、Filter 和 Listener 的功能。ServletHandler 依赖 FilterHolder、ServletHolder、ServletMapping、FilterMapping 这四大组件。FilterHolder 和 ServletHolder 分别是 Filter 和 Servlet 的包装类，每一个 Servlet 与路径的映射会被封装成 ServletMapping，而 Filter 与拦截 URL 的映射会被封装成 FilterMapping。\n\nSessionHandler 用来管理 Session。除此之外 WebAppContext 还有一些通用功能的 Handler，比如 SecurityHandler 和 GzipHandler，同样从名字可以知道这些 Handler 的功能分别是安全控制和压缩 / 解压缩。\n\nWebAppContext 会将这些 Handler 构建成一个执行链，通过这个链会最终调用到我们的业务 Servlet。\n\n\n# Jetty 的线程策略\n\n\n# 传统 Selector 编程模型\n\n常规的 NIO 编程思路是，将 I/O 事件的侦测和请求的处理分别用不同的线程处理。具体过程是：\n\n启动一个线程，在一个死循环里不断地调用 select 方法，检测 Channel 的 I/O 状态，一旦 I/O 事件达到，比如数据就绪，就把该 I/O 事件以及一些数据包装成一个 Runnable，将 Runnable 放到新线程中去处理。\n\n在这个过程中按照职责划分，有两个线程在干活，一个是 I/O 事件检测线程，另一个是 I/O 事件处理线程。这样的好处是它们互不干扰和阻塞对方。\n\n\n# Jetty 的 Selector 编程模型\n\n将 I/O 事件检测和业务处理这两种工作分开的思路也有缺点：当 Selector 检测读就绪事件时，数据已经被拷贝到内核中的缓存了，同时 CPU 的缓存中也有这些数据了，我们知道 CPU 本身的缓存比内存快多了，这时当应用程序去读取这些数据时，如果用另一个线程去读，很有可能这个读线程使用另一个 CPU 核，而不是之前那个检测数据就绪的 CPU 核，这样 CPU 缓存中的数据就用不上了，并且线程切换也需要开销。\n\n因此 Jetty 的 Connector 做了一个大胆尝试，那就是把 I/O 事件的生产和消费放到同一个线程来处理，如果这两个任务由同一个线程来执行，如果执行过程中线程不阻塞，操作系统会用同一个 CPU 核来执行这两个任务，这样就能利用 CPU 缓存了。\n\n# ManagedSelector\n\nManagedSelector 的本质就是一个 Selector，负责 I/O 事件的检测和分发。为了方便使用，Jetty 在 Java 原生的 Selector 上做了一些扩展，就变成了 ManagedSelector，我们先来看看它有哪些成员变量：\n\npublic class ManagedSelector extends ContainerLifeCycle implements Dumpable\n{\n    // 原子变量，表明当前的 ManagedSelector 是否已经启动\n    private final AtomicBoolean _started = new AtomicBoolean(false);\n\n    // 表明是否阻塞在 select 调用上\n    private boolean _selecting = false;\n\n    // 管理器的引用，SelectorManager 管理若干 ManagedSelector 的生命周期\n    private final SelectorManager _selectorManager;\n\n    //ManagedSelector 不止一个，为它们每人分配一个 id\n    private final int _id;\n\n    // 关键的执行策略，生产者和消费者是否在同一个线程处理由它决定\n    private final ExecutionStrategy _strategy;\n\n    //Java 原生的 Selector\n    private Selector _selector;\n\n    //"Selector 更新任务 " 队列\n    private Deque<SelectorUpdate> _updates = new ArrayDeque<>();\n    private Deque<SelectorUpdate> _updateable = new ArrayDeque<>();\n\n    ...\n}\n\n\n这些成员变量中其他的都好理解，就是“Selector 更新任务”队列_updates和执行策略_strategy可能不是很直观。\n\n# SelectorUpdate 接口\n\n为什么需要一个“Selector 更新任务”队列呢，对于 Selector 的用户来说，我们对 Selector 的操作无非是将 Channel 注册到 Selector 或者告诉 Selector 我对什么 I/O 事件感兴趣，那么这些操作其实就是对 Selector 状态的更新，Jetty 把这些操作抽象成 SelectorUpdate 接口。\n\n/**\n * A selector update to be done when the selector has been woken.\n */\npublic interface SelectorUpdate\n{\n    void update(Selector selector);\n}\n\n\n这意味着如果你不能直接操作 ManageSelector 中的 Selector，而是需要向 ManagedSelector 提交一个任务类，这个类需要实现 SelectorUpdate 接口 update 方法，在 update 方法里定义你想要对 ManagedSelector 做的操作。\n\n比如 Connector 中 Endpoint 组件对读就绪事件感兴趣，它就向 ManagedSelector 提交了一个内部任务类 ManagedSelector.SelectorUpdate：\n\n_selector.submit(_updateKeyAction);\n\n\n这个_updateKeyAction就是一个 SelectorUpdate 实例，它的 update 方法实现如下：\n\nprivate final ManagedSelector.SelectorUpdate _updateKeyAction = new ManagedSelector.SelectorUpdate()\n{\n    @Override\n    public void update(Selector selector)\n    {\n        // 这里的 updateKey 其实就是调用了 SelectionKey.interestOps(OP_READ);\n        updateKey();\n    }\n};\n\n\n我们看到在 update 方法里，调用了 SelectionKey 类的 interestOps 方法，传入的参数是OP_READ，意思是现在我对这个 Channel 上的读就绪事件感兴趣了。\n\n那谁来负责执行这些 update 方法呢，答案是 ManagedSelector 自己，它在一个死循环里拉取这些 SelectorUpdate 任务类逐个执行。\n\n# Selectable 接口\n\n那 I/O 事件到达时，ManagedSelector 怎么知道应该调哪个函数来处理呢？其实也是通过一个任务类接口，这个接口就是 Selectable，它返回一个 Runnable，这个 Runnable 其实就是 I/O 事件就绪时相应的处理逻辑。\n\npublic interface Selectable\n{\n    // 当某一个 Channel 的 I/O 事件就绪后，ManagedSelector 会调用的回调函数\n    Runnable onSelected();\n\n    // 当所有事件处理完了之后 ManagedSelector 会调的回调函数，我们先忽略。\n    void updateKey();\n}\n\n\nManagedSelector 在检测到某个 Channel 上的 I/O 事件就绪时，也就是说这个 Channel 被选中了，ManagedSelector 调用这个 Channel 所绑定的附件类的 onSelected 方法来拿到一个 Runnable。\n\n这句话有点绕，其实就是 ManagedSelector 的使用者，比如 Endpoint 组件在向 ManagedSelector 注册读就绪事件时，同时也要告诉 ManagedSelector 在事件就绪时执行什么任务，具体来说就是传入一个附件类，这个附件类需要实现 Selectable 接口。ManagedSelector 通过调用这个 onSelected 拿到一个 Runnable，然后把 Runnable 扔给线程池去执行。\n\n那 Endpoint 的 onSelected 是如何实现的呢？\n\n@Override\npublic Runnable onSelected()\n{\n    int readyOps = _key.readyOps();\n\n    boolean fillable = (readyOps & SelectionKey.OP_READ) != 0;\n    boolean flushable = (readyOps & SelectionKey.OP_WRITE) != 0;\n\n    // return task to complete the job\n    Runnable task= fillable\n            ? (flushable\n                    ? _runCompleteWriteFillable\n                    : _runFillable)\n            : (flushable\n                    ? _runCompleteWrite\n                    : null);\n\n    return task;\n}\n\n\n上面的代码逻辑很简单，就是读事件到了就读，写事件到了就写。\n\n# ExecutionStrategy\n\n铺垫了这么多，终于要上主菜了。前面我主要介绍了 ManagedSelector 的使用者如何跟 ManagedSelector 交互，也就是如何注册 Channel 以及 I/O 事件，提供什么样的处理类来处理 I/O 事件，接下来我们来看看 ManagedSelector 是如何统一管理和维护用户注册的 Channel 集合。再回到今天开始的讨论，ManagedSelector 将 I/O 事件的生产和消费看作是生产者消费者模式，为了充分利用 CPU 缓存，生产和消费尽量放到同一个线程处理，那这是如何实现的呢？Jetty 定义了 ExecutionStrategy 接口：\n\npublic interface ExecutionStrategy\n{\n    // 只在 HTTP2 中用到，简单起见，我们先忽略这个方法。\n    public void dispatch();\n\n    // 实现具体执行策略，任务生产出来后可能由当前线程执行，也可能由新线程来执行\n    public void produce();\n\n    // 任务的生产委托给 Producer 内部接口，\n    public interface Producer\n    {\n        // 生产一个 Runnable(任务)\n        Runnable produce();\n    }\n}\n\n\n我们看到 ExecutionStrategy 接口比较简单，它将具体任务的生产委托内部接口 Producer，而在自己的 produce 方法里来实现具体执行逻辑，也就是生产出来的任务要么由当前线程执行，要么放到新线程中执行。Jetty 提供了一些具体策略实现类：ProduceConsume、ProduceExecuteConsume、ExecuteProduceConsume 和 EatWhatYouKill。它们的区别是：\n\n * ProduceConsume：任务生产者自己依次生产和执行任务，对应到 NIO 通信模型就是用一个线程来侦测和处理一个 ManagedSelector 上所有的 I/O 事件，后面的 I/O 事件要等待前面的 I/O 事件处理完，效率明显不高。通过图来理解，图中绿色表示生产一个任务，蓝色表示执行这个任务。\n\n\n\n * ProduceExecuteConsume：任务生产者开启新线程来运行任务，这是典型的 I/O 事件侦测和处理用不同的线程来处理，缺点是不能利用 CPU 缓存，并且线程切换成本高。同样我们通过一张图来理解，图中的棕色表示线程切换。\n\n\n\n * ExecuteProduceConsume：任务生产者自己运行任务，但是该策略可能会新建一个新线程以继续生产和执行任务。这种策略也被称为“吃掉你杀的猎物”，它来自狩猎伦理，认为一个人不应该杀死他不吃掉的东西，对应线程来说，不应该生成自己不打算运行的任务。它的优点是能利用 CPU 缓存，但是潜在的问题是如果处理 I/O 事件的业务代码执行时间过长，会导致线程大量阻塞和线程饥饿。\n\n\n\n * EatWhatYouKill：这是 Jetty 对 ExecuteProduceConsume 策略的改良，在线程池线程充足的情况下等同于 ExecuteProduceConsume；当系统比较忙线程不够时，切换成 ProduceExecuteConsume 策略。为什么要这么做呢，原因是 ExecuteProduceConsume 是在同一线程执行 I/O 事件的生产和消费，它使用的线程来自 Jetty 全局的线程池，这些线程有可能被业务代码阻塞，如果阻塞得多了，全局线程池中的线程自然就不够用了，最坏的情况是连 I/O 事件的侦测都没有线程可用了，会导致 Connector 拒绝浏览器请求。于是 Jetty 做了一个优化，在低线程情况下，就执行 ProduceExecuteConsume 策略，I/O 侦测用专门的线程处理，I/O 事件的处理扔给线程池处理，其实就是放到线程池的队列里慢慢处理。\n\n分析了这几种线程策略，我们再来看看 Jetty 是如何实现 ExecutionStrategy 接口的。答案其实就是实现 produce 接口生产任务，一旦任务生产出来，ExecutionStrategy 会负责执行这个任务。\n\nprivate class SelectorProducer implements ExecutionStrategy.Producer\n{\n    private Set<SelectionKey> _keys = Collections.emptySet();\n    private Iterator<SelectionKey> _cursor = Collections.emptyIterator();\n\n    @Override\n    public Runnable produce()\n    {\n        while (true)\n        {\n            // 如何 Channel 集合中有 I/O 事件就绪，调用前面提到的 Selectable 接口获取 Runnable, 直接返回给 ExecutionStrategy 去处理\n            Runnable task = processSelected();\n            if (task != null)\n                return task;\n\n           // 如果没有 I/O 事件就绪，就干点杂活，看看有没有客户提交了更新 Selector 的任务，就是上面提到的 SelectorUpdate 任务类。\n            processUpdates();\n            updateKeys();\n\n           // 继续执行 select 方法，侦测 I/O 就绪事件\n            if (!select())\n                return null;\n        }\n    }\n }\n\n\nSelectorProducer 是 ManagedSelector 的内部类，SelectorProducer 实现了 ExecutionStrategy 中的 Producer 接口中的 produce 方法，需要向 ExecutionStrategy 返回一个 Runnable。在这个方法里 SelectorProducer 主要干了三件事情\n\n 1. 如果 Channel 集合中有 I/O 事件就绪，调用前面提到的 Selectable 接口获取 Runnable，直接返回给 ExecutionStrategy 去处理。\n 2. 如果没有 I/O 事件就绪，就干点杂活，看看有没有客户提交了更新 Selector 上事件注册的任务，也就是上面提到的 SelectorUpdate 任务类。\n 3. 干完杂活继续执行 select 方法，侦测 I/O 就绪事件。\n\n\n# 参考资料\n\n * Jetty 官方网址\n * Jetty Github\n * Jetty wiki',normalizedContent:'# jetty 快速入门\n\n\n# jetty 简介\n\njetty 是什么？\n\njetty 是轻量级的 web 服务器和 servlet 引擎。\n\n它的最大特点是：可以很方便的作为嵌入式服务器。\n\n它是 eclipse 的一个开源项目。不用怀疑，就是你常用的那个 eclipse。\n\n它是使用 java 开发的，所以天然对 java 支持良好。\n\n官方网址\n\ngithub 源码地址\n\n什么是嵌入式服务器？\n\n以 jetty 来说明，就是只要引入 jetty 的 jar 包，可以通过直接调用其 api 的方式来启动 web 服务。\n\n用过 tomcat、resin 等服务器的朋友想必不会陌生那一套安装、配置、部署的流程吧，还是挺繁琐的。使用 jetty，就不需要这些过程了。\n\njetty 非常适用于项目的开发、测试，因为非常快捷。如果想用于生产环境，则需要谨慎考虑，它不一定能像成熟的 tomcat、resin 等服务器一样支持企业级 java ee 的需要。\n\n\n# jetty 的使用\n\n我觉得嵌入式启动方式的一个好处在于：可以直接运行项目，无需每次部署都得再配置服务器。\n\njetty 的嵌入式启动使用有两种方式：\n\napi 方式\n\nmaven 插件方式\n\n\n# api 方式\n\n添加 maven 依赖\n\n<dependency>\n  <groupid>org.eclipse.jetty</groupid>\n  <artifactid>jetty-webapp</artifactid>\n  <version>9.3.2.v20150730</version>\n  <scope>test</scope>\n</dependency>\n<dependency>\n  <groupid>org.eclipse.jetty</groupid>\n  <artifactid>jetty-annotations</artifactid>\n  <version>9.3.2.v20150730</version>\n  <scope>test</scope>\n</dependency>\n<dependency>\n  <groupid>org.eclipse.jetty</groupid>\n  <artifactid>apache-jsp</artifactid>\n  <version>9.3.2.v20150730</version>\n  <scope>test</scope>\n</dependency>\n<dependency>\n  <groupid>org.eclipse.jetty</groupid>\n  <artifactid>apache-jstl</artifactid>\n  <version>9.3.2.v20150730</version>\n  <scope>test</scope>\n</dependency>\n\n\n官方的启动代码\n\npublic class splitfileserver\n{\n    public static void main( string[] args ) throws exception\n    {\n        // 创建server对象，并绑定端口\n        server server = new server();\n        serverconnector connector = new serverconnector(server);\n        connector.setport(8090);\n        server.setconnectors(new connector[] { connector });\n\n        // 创建上下文句柄，绑定上下文路径。这样启动后的url就会是:http://host:port/context\n        resourcehandler rh0 = new resourcehandler();\n        contexthandler context0 = new contexthandler();\n        context0.setcontextpath("/");\n\n        // 绑定测试资源目录（在本例的配置目录dir0的路径是src/test/resources/dir0）\n        file dir0 = maventestingutils.gettestresourcedir("dir0");\n        context0.setbaseresource(resource.newresource(dir0));\n        context0.sethandler(rh0);\n\n        // 和上面的例子一样\n        resourcehandler rh1 = new resourcehandler();\n        contexthandler context1 = new contexthandler();\n        context1.setcontextpath("/");\n        file dir1 = maventestingutils.gettestresourcedir("dir1");\n        context1.setbaseresource(resource.newresource(dir1));\n        context1.sethandler(rh1);\n\n        // 绑定两个资源句柄\n        contexthandlercollection contexts = new contexthandlercollection();\n        contexts.sethandlers(new handler[] { context0, context1 });\n        server.sethandler(contexts);\n\n        // 启动\n        server.start();\n\n        // 打印dump时的信息\n        system.out.println(server.dump());\n\n        // join当前线程\n        server.join();\n    }\n}\n\n\n直接运行 main 方法，就可以启动 web 服务。\n\n注：以上代码在 eclipse 中运行没有问题，如果想在 intellij 中运行还需要为它指定配置文件。\n\n如果想了解在 eclipse 和 intellij 都能运行的通用方法可以参考我的 github 代码示例。\n\n我的实现也是参考 springside 的方式。\n\n代码行数有点多，不在这里贴代码了。\n\n完整参考代码\n\n\n# maven 插件方式\n\n如果你熟悉 maven，那么实在太简单了\n\n注： maven 版本必须在 3.3 及以上版本。\n\n(1) 添加 maven 插件\n\n<plugin>\n  <groupid>org.eclipse.jetty</groupid>\n  <artifactid>jetty-maven-plugin</artifactid>\n  <version>9.3.12.v20160915</version>\n</plugin>\n\n\n(2) 执行 maven 命令：\n\nmvn jetty:run\n\n\n讲真，就是这么简单。jetty 默认会为你创建一个 web 服务，地址为 127.0.0.1:8080。\n\n当然，你也可以在插件中配置你的 webapp 环境\n\n<plugin>\n  <groupid>org.eclipse.jetty</groupid>\n  <artifactid>jetty-maven-plugin</artifactid>\n  <version>9.3.12.v20160915</version>\n\n  <configuration>\n <webappsourcedirectory>${project.basedir}/src/staticfiles</webappsourcedirectory>\n\n    \x3c!-- 配置webapp --\x3e\n <webapp>\n   <contextpath>/</contextpath>\n   <descriptor>${project.basedir}/src/over/here/web.xml</descriptor>\n   <jettyenvxml>${project.basedir}/src/over/here/jetty-env.xml</jettyenvxml>\n </webapp>\n\n    \x3c!-- 配置classes --\x3e\n <classesdirectory>${project.basedir}/somewhere/else</classesdirectory>\n <scanclassespattern>\n   <excludes>\n  <exclude>**/foo.class</exclude>\n   </excludes>\n </scanclassespattern>\n <scantargets>\n   <scantarget>src/mydir</scantarget>\n   <scantarget>src/myfile.txt</scantarget>\n </scantargets>\n\n    \x3c!-- 扫描target目录下的资源文件 --\x3e\n <scantargetpatterns>\n   <scantargetpattern>\n <directory>src/other-resources</directory>\n <includes>\n   <include>**/*.xml</include>\n   <include>**/*.properties</include>\n </includes>\n <excludes>\n   <exclude>**/myspecial.xml</exclude>\n   <exclude>**/myspecial.properties</exclude>\n </excludes>\n   </scantargetpattern>\n </scantargetpatterns>\n  </configuration>\n</plugin>\n\n\n官方给的 jetty-env.xml 范例\n\n <?xml version="1.0"?>\n <!doctype configure public "-//mort bay consulting//dtd configure//en" "http://jetty.mortbay.org/configure.dtd">\n\n <configure class="org.eclipse.jetty.webapp.webappcontext">\n\n   \x3c!-- add an enventry only valid for this webapp               --\x3e\n   <new id="gargle"  class="org.eclipse.jetty.plus.jndi.enventry">\n     <arg>gargle</arg>\n     <arg type="java.lang.double">100</arg>\n     <arg type="boolean">true</arg>\n   </new>\n\n  \x3c!-- add an override for a global enventry                           --\x3e\n   <new id="wiggle"  class="org.eclipse.jetty.plus.jndi.enventry">\n     <arg>wiggle</arg>\n     <arg type="java.lang.double">55.0</arg>\n     <arg type="boolean">true</arg>\n   </new>\n\n   \x3c!-- an xadatasource                                                --\x3e\n   <new id="mydatasource99" class="org.eclipse.jetty.plus.jndi.resource">\n     <arg>jdbc/mydatasource99</arg>\n     <arg>\n       <new class="com.atomikos.jdbc.simpledatasourcebean">\n         <set name="xadatasourceclassname">org.apache.derby.jdbc.embeddedxadatasource</set>\n         <set name="xadatasourceproperties">databasename=testdb99;createdatabase=create</set>\n         <set name="uniqueresourcename">mydatasource99</set>\n       </new>\n     </arg>\n   </new>\n\n </configure>\n\n\n\n# jetty 的架构\n\n\n# jetty 架构简介\n\n\n\njetty server 就是由多个 connector（连接器）、多个 handler（处理器），以及一个线程池组成。\n\n跟 tomcat 一样，jetty 也有 http 服务器和 servlet 容器的功能，因此 jetty 中的 connector 组件和 handler 组件分别来实现这两个功能，而这两个组件工作时所需要的线程资源都直接从一个全局线程池 threadpool 中获取。\n\njetty server 可以有多个 connector 在不同的端口上监听客户请求，而对于请求处理的 handler 组件，也可以根据具体场景使用不同的 handler。这样的设计提高了 jetty 的灵活性，需要支持 servlet，则可以使用 servlethandler；需要支持 session，则再增加一个 sessionhandler。也就是说我们可以不使用 servlet 或者 session，只要不配置这个 handler 就行了。\n\n为了启动和协调上面的核心组件工作，jetty 提供了一个 server 类来做这个事情，它负责创建并初始化 connector、handler、threadpool 组件，然后调用 start 方法启动它们。\n\n\n# jetty 和 tomcat 架构区别\n\n对比一下 tomcat 的整体架构图，你会发现 tomcat 在整体上跟 jetty 很相似，它们的第一个区别是 jetty 中没有 service 的概念，tomcat 中的 service 包装了多个连接器和一个容器组件，一个 tomcat 实例可以配置多个 service，不同的 service 通过不同的连接器监听不同的端口；而 jetty 中 connector 是被所有 handler 共享的。\n\n第二个区别是，在 tomcat 中每个连接器都有自己的线程池，而在 jetty 中所有的 connector 共享一个全局的线程池。\n\n\n# connector 组件\n\n跟 tomcat 一样，connector 的主要功能是对 i/o 模型和应用层协议的封装。i/o 模型方面，最新的 jetty 9 版本只支持 nio，因此 jetty 的 connector 设计有明显的 java nio 通信模型的痕迹。至于应用层协议方面，跟 tomcat 的 processor 一样，jetty 抽象出了 connection 组件来封装应用层协议的差异。\n\n服务端在 nio 通信上主要完成了三件事情：监听连接、i/o 事件查询以及数据读写。因此 jetty 设计了acceptor、selectormanager 和 connection 来分别做这三件事情\n\n# acceptor\n\nacceptor 用于接受请求。跟 tomcat 一样，jetty 也有独立的 acceptor 线程组用于处理连接请求。在 connector 的实现类 serverconnector 中，有一个 _acceptors 的数组，在 connector 启动的时候, 会根据 _acceptors 数组的长度创建对应数量的 acceptor，而 acceptor 的个数可以配置。\n\nfor (int i = 0; i < _acceptors.length; i++)\n{\n  acceptor a = new acceptor(i);\n  getexecutor().execute(a);\n}\n\n\nacceptor 是 serverconnector 中的一个内部类，同时也是一个 runnable，acceptor 线程是通过 getexecutor() 得到的线程池来执行的，前面提到这是一个全局的线程池。\n\nacceptor 通过阻塞的方式来接受连接，这一点跟 tomcat 也是一样的。\n\npublic void accept(int acceptorid) throws ioexception\n{\n  serversocketchannel serverchannel = _acceptchannel;\n  if (serverchannel != null && serverchannel.isopen())\n  {\n    // 这里是阻塞的\n    socketchannel channel = serverchannel.accept();\n    // 执行到这里时说明有请求进来了\n    accepted(channel);\n  }\n}\n\n\n接受连接成功后会调用 accepted() 函数，accepted() 函数中会将 socketchannel 设置为非阻塞模式，然后交给 selector 去处理，因此这也就到了 selector 的地界了。\n\nprivate void accepted(socketchannel channel) throws ioexception\n{\n    channel.configureblocking(false);\n    socket socket = channel.socket();\n    configure(socket);\n    // _manager 是 selectormanager 实例，里面管理了所有的 selector 实例\n    _manager.accept(channel);\n}\n\n\nselectormanager\n\njetty 的 selector 由 selectormanager 类管理，而被管理的 selector 叫作 managedselector。selectormanager 内部有一个 managedselector 数组，真正干活的是 managedselector。咱们接着上面分析，看看在 selectormanager 在 accept 方法里做了什么。\n\npublic void accept(selectablechannel channel, object attachment)\n{\n  // 选择一个 managedselector 来处理 channel\n  final managedselector selector = chooseselector();\n  // 提交一个任务 accept 给 managedselector\n  selector.submit(selector.new accept(channel, attachment));\n}\n\n\nselectormanager 从本身的 selector 数组中选择一个 selector 来处理这个 channel，并创建一个任务 accept 交给 managedselector，managedselector 在处理这个任务主要做了两步：\n\n第一步，调用 selector 的 register 方法把 channel 注册到 selector 上，拿到一个 selectionkey。\n\n _key = _channel.register(selector, selectionkey.op_accept, this);\n\n\n第二步，创建一个 endpoint 和 connection，并跟这个 selectionkey（channel）绑在一起：\n\nprivate void createendpoint(selectablechannel channel, selectionkey selectionkey) throws ioexception\n{\n    //1. 创建 endpoint\n    endpoint endpoint = _selectormanager.newendpoint(channel, this, selectionkey);\n\n    //2. 创建 connection\n    connection connection = _selectormanager.newconnection(channel, endpoint, selectionkey.attachment());\n\n    //3. 把 endpoint、connection 和 selectionkey 绑在一起\n    endpoint.setconnection(connection);\n    selectionkey.attach(endpoint);\n\n}\n\n\n这里需要你特别注意的是，managedselector 并没有直接调用 endpoint 的方法去处理数据，而是通过调用 endpoint 的方法返回一个 runnable，然后把这个 runnable 扔给线程池执行，所以你能猜到，这个 runnable 才会去真正读数据和处理请求。\n\nconnection\n\n这个 runnable 是 endpoint 的一个内部类，它会调用 connection 的回调方法来处理请求。jetty 的 connection 组件类比就是 tomcat 的 processor，负责具体协议的解析，得到 request 对象，并调用 handler 容器进行处理。下面我简单介绍一下它的具体实现类 httpconnection 对请求和响应的处理过程。\n\n请求处理：httpconnection 并不会主动向 endpoint 读取数据，而是向在 endpoint 中注册一堆回调方法：\n\ngetendpoint().fillinterested(_readcallback);\n\n\n这段代码就是告诉 endpoint，数据到了你就调我这些回调方法 _readcallback 吧，有点异步 i/o 的感觉，也就是说 jetty 在应用层面模拟了异步 i/o 模型。\n\n而在回调方法 _readcallback 里，会调用 endpoint 的接口去读数据，读完后让 http 解析器去解析字节流，http 解析器会将解析后的数据，包括请求行、请求头相关信息存到 request 对象里。\n\n响应处理：connection 调用 handler 进行业务处理，handler 会通过 response 对象来操作响应流，向流里面写入数据，httpconnection 再通过 endpoint 把数据写到 channel，这样一次响应就完成了。\n\n到此你应该了解了 connector 的工作原理，下面我画张图再来回顾一下 connector 的工作流程。\n\n\n\n 1. acceptor 监听连接请求，当有连接请求到达时就接受连接，一个连接对应一个 channel，acceptor 将 channel 交给 managedselector 来处理。\n\n 2. managedselector 把 channel 注册到 selector 上，并创建一个 endpoint 和 connection 跟这个 channel 绑定，接着就不断地检测 i/o 事件。\n\n 3. i/o 事件到了就调用 endpoint 的方法拿到一个 runnable，并扔给线程池执行。\n\n 4. 线程池中调度某个线程执行 runnable。\n\n 5. runnable 执行时，调用回调函数，这个回调函数是 connection 注册到 endpoint 中的。\n\n 6. 回调函数内部实现，其实就是调用 endpoint 的接口方法来读数据。\n\n 7. connection 解析读到的数据，生成请求对象并交给 handler 组件去处理。\n\n\n# handler 组件\n\njetty 的 handler 设计是它的一大特色，jetty 本质就是一个 handler 管理器，jetty 本身就提供了一些默认 handler 来实现 servlet 容器的功能，你也可以定义自己的 handler 来添加到 jetty 中，这体现了“微内核 + 插件”的设计思想。\n\nhandler 就是一个接口，它有一堆实现类，jetty 的 connector 组件调用这些接口来处理 servlet 请求。\n\npublic interface handler extends lifecycle, destroyable\n{\n    // 处理请求的方法\n    public void handle(string target, request baserequest, httpservletrequest request, httpservletresponse response)\n        throws ioexception, servletexception;\n\n    // 每个 handler 都关联一个 server 组件，被 server 管理\n    public void setserver(server server);\n    public server getserver();\n\n    // 销毁方法相关的资源\n    public void destroy();\n}\n\n\n方法说明：\n\n * handler 的 handle 方法跟 tomcat 容器组件的 service 方法一样，它有 servletrequest 和 serveletresponse 两个参数。\n * 因为任何一个 handler 都需要关联一个 server 组件，handler 需要被 server 组件来管理。handler 通过 setserver 和 getserver 方法绑定 server。\n * handler 会加载一些资源到内存，因此通过设置 destroy 方法来销毁。\n\n# handler 继承关系\n\nhandler 只是一个接口，完成具体功能的还是它的子类。那么 handler 有哪些子类呢？它们的继承关系又是怎样的？这些子类是如何实现 servlet 容器功能的呢？\n\n\n\n在 abstracthandler 之下有 abstracthandlercontainer，为什么需要这个类呢？这其实是个过渡，为了实现链式调用，一个 handler 内部必然要有其他 handler 的引用，所以这个类的名字里才有 container，意思就是这样的 handler 里包含了其他 handler 的引用。\n\nhandlerwrapper 和 handlercollection 都是 handler，但是这些 handler 里还包括其他 handler 的引用。不同的是，handlerwrapper 只包含一个其他 handler 的引用，而 handlercollection 中有一个 handler 数组的引用。\n\nhandlerwrapper 有两个子类：server 和 scopedhandler。\n\n * server 比较好理解，它本身是 handler 模块的入口，必然要将请求传递给其他 handler 来处理，为了触发其他 handler 的调用，所以它是一个 handlerwrapper。\n * scopedhandler 也是一个比较重要的 handler，实现了“具有上下文信息”的责任链调用。为什么我要强调“具有上下文信息”呢？那是因为 servlet 规范规定 servlet 在执行过程中是有上下文的。那么这些 handler 在执行过程中如何访问这个上下文呢？这个上下文又存在什么地方呢？答案就是通过 scopedhandler 来实现的。\n\nhandlercollection 其实维护了一个 handler 数组。这是为了同时支持多个 web 应用，如果每个 web 应用有一个 handler 入口，那么多个 web 应用的 handler 就成了一个数组，比如 server 中就有一个 handlercollection，server 会根据用户请求的 url 从数组中选取相应的 handler 来处理，就是选择特定的 web 应用来处理请求。\n\nhandler 可以分成三种类型：\n\n * 第一种是协调 handler，这种 handler 负责将请求路由到一组 handler 中去，比如 handlercollection，它内部持有一个 handler 数组，当请求到来时，它负责将请求转发到数组中的某一个 handler。\n * 第二种是过滤器 handler，这种 handler 自己会处理请求，处理完了后再把请求转发到下一个 handler，比如图上的 handlerwrapper，它内部持有下一个 handler 的引用。需要注意的是，所有继承了 handlerwrapper 的 handler 都具有了过滤器 handler 的特征，比如 contexthandler、sessionhandler 和 webappcontext 等。\n * 第三种是内容 handler，说白了就是这些 handler 会真正调用 servlet 来处理请求，生成响应的内容，比如 servlethandler。如果浏览器请求的是一个静态资源，也有相应的 resourcehandler 来处理这个请求，返回静态页面。\n\n# 实现 servlet 规范\n\nservlethandler、contexthandler 以及 webappcontext 等，它们实现了 servlet 规范。\n\nservlet 规范中有 context、servlet、filter、listener 和 session 等，jetty 要支持 servlet 规范，就需要有相应的 handler 来分别实现这些功能。因此，jetty 设计了 3 个组件：contexthandler、servlethandler 和 sessionhandler 来实现 servle 规范中规定的功能，而webappcontext 本身就是一个 contexthandler，另外它还负责管理 servlethandler 和 sessionhandler。\n\ncontexthandler 会创建并初始化 servlet 规范里的 servletcontext 对象，同时 contexthandler 还包含了一组能够让你的 web 应用运行起来的 handler，可以这样理解，context 本身也是一种 handler，它里面包含了其他的 handler，这些 handler 能处理某个特定 url 下的请求。比如，contexthandler 包含了一个或者多个 servlethandler。\n\nservlethandler 实现了 servlet 规范中的 servlet、filter 和 listener 的功能。servlethandler 依赖 filterholder、servletholder、servletmapping、filtermapping 这四大组件。filterholder 和 servletholder 分别是 filter 和 servlet 的包装类，每一个 servlet 与路径的映射会被封装成 servletmapping，而 filter 与拦截 url 的映射会被封装成 filtermapping。\n\nsessionhandler 用来管理 session。除此之外 webappcontext 还有一些通用功能的 handler，比如 securityhandler 和 gziphandler，同样从名字可以知道这些 handler 的功能分别是安全控制和压缩 / 解压缩。\n\nwebappcontext 会将这些 handler 构建成一个执行链，通过这个链会最终调用到我们的业务 servlet。\n\n\n# jetty 的线程策略\n\n\n# 传统 selector 编程模型\n\n常规的 nio 编程思路是，将 i/o 事件的侦测和请求的处理分别用不同的线程处理。具体过程是：\n\n启动一个线程，在一个死循环里不断地调用 select 方法，检测 channel 的 i/o 状态，一旦 i/o 事件达到，比如数据就绪，就把该 i/o 事件以及一些数据包装成一个 runnable，将 runnable 放到新线程中去处理。\n\n在这个过程中按照职责划分，有两个线程在干活，一个是 i/o 事件检测线程，另一个是 i/o 事件处理线程。这样的好处是它们互不干扰和阻塞对方。\n\n\n# jetty 的 selector 编程模型\n\n将 i/o 事件检测和业务处理这两种工作分开的思路也有缺点：当 selector 检测读就绪事件时，数据已经被拷贝到内核中的缓存了，同时 cpu 的缓存中也有这些数据了，我们知道 cpu 本身的缓存比内存快多了，这时当应用程序去读取这些数据时，如果用另一个线程去读，很有可能这个读线程使用另一个 cpu 核，而不是之前那个检测数据就绪的 cpu 核，这样 cpu 缓存中的数据就用不上了，并且线程切换也需要开销。\n\n因此 jetty 的 connector 做了一个大胆尝试，那就是把 i/o 事件的生产和消费放到同一个线程来处理，如果这两个任务由同一个线程来执行，如果执行过程中线程不阻塞，操作系统会用同一个 cpu 核来执行这两个任务，这样就能利用 cpu 缓存了。\n\n# managedselector\n\nmanagedselector 的本质就是一个 selector，负责 i/o 事件的检测和分发。为了方便使用，jetty 在 java 原生的 selector 上做了一些扩展，就变成了 managedselector，我们先来看看它有哪些成员变量：\n\npublic class managedselector extends containerlifecycle implements dumpable\n{\n    // 原子变量，表明当前的 managedselector 是否已经启动\n    private final atomicboolean _started = new atomicboolean(false);\n\n    // 表明是否阻塞在 select 调用上\n    private boolean _selecting = false;\n\n    // 管理器的引用，selectormanager 管理若干 managedselector 的生命周期\n    private final selectormanager _selectormanager;\n\n    //managedselector 不止一个，为它们每人分配一个 id\n    private final int _id;\n\n    // 关键的执行策略，生产者和消费者是否在同一个线程处理由它决定\n    private final executionstrategy _strategy;\n\n    //java 原生的 selector\n    private selector _selector;\n\n    //"selector 更新任务 " 队列\n    private deque<selectorupdate> _updates = new arraydeque<>();\n    private deque<selectorupdate> _updateable = new arraydeque<>();\n\n    ...\n}\n\n\n这些成员变量中其他的都好理解，就是“selector 更新任务”队列_updates和执行策略_strategy可能不是很直观。\n\n# selectorupdate 接口\n\n为什么需要一个“selector 更新任务”队列呢，对于 selector 的用户来说，我们对 selector 的操作无非是将 channel 注册到 selector 或者告诉 selector 我对什么 i/o 事件感兴趣，那么这些操作其实就是对 selector 状态的更新，jetty 把这些操作抽象成 selectorupdate 接口。\n\n/**\n * a selector update to be done when the selector has been woken.\n */\npublic interface selectorupdate\n{\n    void update(selector selector);\n}\n\n\n这意味着如果你不能直接操作 manageselector 中的 selector，而是需要向 managedselector 提交一个任务类，这个类需要实现 selectorupdate 接口 update 方法，在 update 方法里定义你想要对 managedselector 做的操作。\n\n比如 connector 中 endpoint 组件对读就绪事件感兴趣，它就向 managedselector 提交了一个内部任务类 managedselector.selectorupdate：\n\n_selector.submit(_updatekeyaction);\n\n\n这个_updatekeyaction就是一个 selectorupdate 实例，它的 update 方法实现如下：\n\nprivate final managedselector.selectorupdate _updatekeyaction = new managedselector.selectorupdate()\n{\n    @override\n    public void update(selector selector)\n    {\n        // 这里的 updatekey 其实就是调用了 selectionkey.interestops(op_read);\n        updatekey();\n    }\n};\n\n\n我们看到在 update 方法里，调用了 selectionkey 类的 interestops 方法，传入的参数是op_read，意思是现在我对这个 channel 上的读就绪事件感兴趣了。\n\n那谁来负责执行这些 update 方法呢，答案是 managedselector 自己，它在一个死循环里拉取这些 selectorupdate 任务类逐个执行。\n\n# selectable 接口\n\n那 i/o 事件到达时，managedselector 怎么知道应该调哪个函数来处理呢？其实也是通过一个任务类接口，这个接口就是 selectable，它返回一个 runnable，这个 runnable 其实就是 i/o 事件就绪时相应的处理逻辑。\n\npublic interface selectable\n{\n    // 当某一个 channel 的 i/o 事件就绪后，managedselector 会调用的回调函数\n    runnable onselected();\n\n    // 当所有事件处理完了之后 managedselector 会调的回调函数，我们先忽略。\n    void updatekey();\n}\n\n\nmanagedselector 在检测到某个 channel 上的 i/o 事件就绪时，也就是说这个 channel 被选中了，managedselector 调用这个 channel 所绑定的附件类的 onselected 方法来拿到一个 runnable。\n\n这句话有点绕，其实就是 managedselector 的使用者，比如 endpoint 组件在向 managedselector 注册读就绪事件时，同时也要告诉 managedselector 在事件就绪时执行什么任务，具体来说就是传入一个附件类，这个附件类需要实现 selectable 接口。managedselector 通过调用这个 onselected 拿到一个 runnable，然后把 runnable 扔给线程池去执行。\n\n那 endpoint 的 onselected 是如何实现的呢？\n\n@override\npublic runnable onselected()\n{\n    int readyops = _key.readyops();\n\n    boolean fillable = (readyops & selectionkey.op_read) != 0;\n    boolean flushable = (readyops & selectionkey.op_write) != 0;\n\n    // return task to complete the job\n    runnable task= fillable\n            ? (flushable\n                    ? _runcompletewritefillable\n                    : _runfillable)\n            : (flushable\n                    ? _runcompletewrite\n                    : null);\n\n    return task;\n}\n\n\n上面的代码逻辑很简单，就是读事件到了就读，写事件到了就写。\n\n# executionstrategy\n\n铺垫了这么多，终于要上主菜了。前面我主要介绍了 managedselector 的使用者如何跟 managedselector 交互，也就是如何注册 channel 以及 i/o 事件，提供什么样的处理类来处理 i/o 事件，接下来我们来看看 managedselector 是如何统一管理和维护用户注册的 channel 集合。再回到今天开始的讨论，managedselector 将 i/o 事件的生产和消费看作是生产者消费者模式，为了充分利用 cpu 缓存，生产和消费尽量放到同一个线程处理，那这是如何实现的呢？jetty 定义了 executionstrategy 接口：\n\npublic interface executionstrategy\n{\n    // 只在 http2 中用到，简单起见，我们先忽略这个方法。\n    public void dispatch();\n\n    // 实现具体执行策略，任务生产出来后可能由当前线程执行，也可能由新线程来执行\n    public void produce();\n\n    // 任务的生产委托给 producer 内部接口，\n    public interface producer\n    {\n        // 生产一个 runnable(任务)\n        runnable produce();\n    }\n}\n\n\n我们看到 executionstrategy 接口比较简单，它将具体任务的生产委托内部接口 producer，而在自己的 produce 方法里来实现具体执行逻辑，也就是生产出来的任务要么由当前线程执行，要么放到新线程中执行。jetty 提供了一些具体策略实现类：produceconsume、produceexecuteconsume、executeproduceconsume 和 eatwhatyoukill。它们的区别是：\n\n * produceconsume：任务生产者自己依次生产和执行任务，对应到 nio 通信模型就是用一个线程来侦测和处理一个 managedselector 上所有的 i/o 事件，后面的 i/o 事件要等待前面的 i/o 事件处理完，效率明显不高。通过图来理解，图中绿色表示生产一个任务，蓝色表示执行这个任务。\n\n\n\n * produceexecuteconsume：任务生产者开启新线程来运行任务，这是典型的 i/o 事件侦测和处理用不同的线程来处理，缺点是不能利用 cpu 缓存，并且线程切换成本高。同样我们通过一张图来理解，图中的棕色表示线程切换。\n\n\n\n * executeproduceconsume：任务生产者自己运行任务，但是该策略可能会新建一个新线程以继续生产和执行任务。这种策略也被称为“吃掉你杀的猎物”，它来自狩猎伦理，认为一个人不应该杀死他不吃掉的东西，对应线程来说，不应该生成自己不打算运行的任务。它的优点是能利用 cpu 缓存，但是潜在的问题是如果处理 i/o 事件的业务代码执行时间过长，会导致线程大量阻塞和线程饥饿。\n\n\n\n * eatwhatyoukill：这是 jetty 对 executeproduceconsume 策略的改良，在线程池线程充足的情况下等同于 executeproduceconsume；当系统比较忙线程不够时，切换成 produceexecuteconsume 策略。为什么要这么做呢，原因是 executeproduceconsume 是在同一线程执行 i/o 事件的生产和消费，它使用的线程来自 jetty 全局的线程池，这些线程有可能被业务代码阻塞，如果阻塞得多了，全局线程池中的线程自然就不够用了，最坏的情况是连 i/o 事件的侦测都没有线程可用了，会导致 connector 拒绝浏览器请求。于是 jetty 做了一个优化，在低线程情况下，就执行 produceexecuteconsume 策略，i/o 侦测用专门的线程处理，i/o 事件的处理扔给线程池处理，其实就是放到线程池的队列里慢慢处理。\n\n分析了这几种线程策略，我们再来看看 jetty 是如何实现 executionstrategy 接口的。答案其实就是实现 produce 接口生产任务，一旦任务生产出来，executionstrategy 会负责执行这个任务。\n\nprivate class selectorproducer implements executionstrategy.producer\n{\n    private set<selectionkey> _keys = collections.emptyset();\n    private iterator<selectionkey> _cursor = collections.emptyiterator();\n\n    @override\n    public runnable produce()\n    {\n        while (true)\n        {\n            // 如何 channel 集合中有 i/o 事件就绪，调用前面提到的 selectable 接口获取 runnable, 直接返回给 executionstrategy 去处理\n            runnable task = processselected();\n            if (task != null)\n                return task;\n\n           // 如果没有 i/o 事件就绪，就干点杂活，看看有没有客户提交了更新 selector 的任务，就是上面提到的 selectorupdate 任务类。\n            processupdates();\n            updatekeys();\n\n           // 继续执行 select 方法，侦测 i/o 就绪事件\n            if (!select())\n                return null;\n        }\n    }\n }\n\n\nselectorproducer 是 managedselector 的内部类，selectorproducer 实现了 executionstrategy 中的 producer 接口中的 produce 方法，需要向 executionstrategy 返回一个 runnable。在这个方法里 selectorproducer 主要干了三件事情\n\n 1. 如果 channel 集合中有 i/o 事件就绪，调用前面提到的 selectable 接口获取 runnable，直接返回给 executionstrategy 去处理。\n 2. 如果没有 i/o 事件就绪，就干点杂活，看看有没有客户提交了更新 selector 上事件注册的任务，也就是上面提到的 selectorupdate 任务类。\n 3. 干完杂活继续执行 select 方法，侦测 i/o 就绪事件。\n\n\n# 参考资料\n\n * jetty 官方网址\n * jetty github\n * jetty wiki',charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"JavaEE",frontmatter:{title:"JavaEE",date:"2022-02-18T08:53:11.000Z",categories:["Java","JavaEE"],tags:["Java","JavaEE"],permalink:"/pages/80a822/",hidden:!0,index:!1},regularPath:"/01.Java/02.JavaEE/",relativePath:"01.Java/02.JavaEE/README.md",key:"v-2a45c84c",path:"/pages/80a822/",headers:[{level:2,title:"📖 内容",slug:"📖-内容",normalizedTitle:"📖 内容",charIndex:13},{level:3,title:"JavaWeb",slug:"javaweb",normalizedTitle:"javaweb",charIndex:23},{level:3,title:"Java 服务器",slug:"java-服务器",normalizedTitle:"java 服务器",charIndex:155},{level:2,title:"📚 资料",slug:"📚-资料",normalizedTitle:"📚 资料",charIndex:326},{level:2,title:"🚪 传送",slug:"🚪-传送",normalizedTitle:"🚪 传送",charIndex:619}],headersStr:"📖 内容 JavaWeb Java 服务器 📚 资料 🚪 传送",content:"# JavaEE\n\n\n# 📖 内容\n\n\n# JavaWeb\n\n * JavaWeb 面经\n * JavaWeb 之 Servlet 指南\n * JavaWeb 之 Jsp 指南\n * JavaWeb 之 Filter 和 Listener\n * JavaWeb 之 Cookie 和 Session\n\n\n# Java 服务器\n\n> Tomcat 和 Jetty 都是 Java 比较流行的轻量级服务器。\n> \n> Nginx 是目前最流行的反向代理服务器，也常用于负载均衡。\n\n * Tomcat 快速入门\n * Tomcat 连接器\n * Tomcat 容器\n * Tomcat 优化\n * Tomcat 和 Jetty\n * Jetty\n\n\n# 📚 资料\n\n * JavaWeb\n   * 书籍\n     * Java Web 整合开发王者归来\n     * Head First Servlets & JSP\n   * 教程\n     * 深入拆解 Tomcat & Jetty\n     * Servlet 教程\n     * 博客园孤傲苍狼 JavaWeb 学习总结\n     * JSP 教程\n * 服务器\n   * Tomcat 官网\n   * Jetty 官网\n   * Jetty Github\n   * Nginx 官网\n   * Nginx 的中文维基\n   * 深入拆解 Tomcat & Jetty\n\n\n# 🚪 传送\n\n◾ 💧 钝悟的 IT 知识图谱 ◾",normalizedContent:"# javaee\n\n\n# 📖 内容\n\n\n# javaweb\n\n * javaweb 面经\n * javaweb 之 servlet 指南\n * javaweb 之 jsp 指南\n * javaweb 之 filter 和 listener\n * javaweb 之 cookie 和 session\n\n\n# java 服务器\n\n> tomcat 和 jetty 都是 java 比较流行的轻量级服务器。\n> \n> nginx 是目前最流行的反向代理服务器，也常用于负载均衡。\n\n * tomcat 快速入门\n * tomcat 连接器\n * tomcat 容器\n * tomcat 优化\n * tomcat 和 jetty\n * jetty\n\n\n# 📚 资料\n\n * javaweb\n   * 书籍\n     * java web 整合开发王者归来\n     * head first servlets & jsp\n   * 教程\n     * 深入拆解 tomcat & jetty\n     * servlet 教程\n     * 博客园孤傲苍狼 javaweb 学习总结\n     * jsp 教程\n * 服务器\n   * tomcat 官网\n   * jetty 官网\n   * jetty github\n   * nginx 官网\n   * nginx 的中文维基\n   * 深入拆解 tomcat & jetty\n\n\n# 🚪 传送\n\n◾ 💧 钝悟的 it 知识图谱 ◾",charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Java 服务器",frontmatter:{title:"Java 服务器",date:"2022-02-17T22:34:30.000Z",categories:["Java","JavaEE","服务器"],tags:["Java","JavaWeb","服务器"],permalink:"/pages/e3f3f3/",hidden:!0,index:!1},regularPath:"/01.Java/02.JavaEE/02.%E6%9C%8D%E5%8A%A1%E5%99%A8/",relativePath:"01.Java/02.JavaEE/02.服务器/README.md",key:"v-60c4af86",path:"/pages/e3f3f3/",headers:[{level:2,title:"📖 内容",slug:"📖-内容",normalizedTitle:"📖 内容",charIndex:15},{level:2,title:"📚 资料",slug:"📚-资料",normalizedTitle:"📚 资料",charIndex:108},{level:2,title:"🚪 传送",slug:"🚪-传送",normalizedTitle:"🚪 传送",charIndex:210}],headersStr:"📖 内容 📚 资料 🚪 传送",content:"# Java 服务器\n\n\n# 📖 内容\n\n * Tomcat 快速入门\n * Tomcat 连接器\n * Tomcat 容器\n * Tomcat 优化\n * Tomcat 和 Jetty\n * Jetty\n\n\n# 📚 资料\n\n * Tomcat 官网\n * Jetty 官网\n * Jetty Github\n * Nginx 官网\n * Nginx 的中文维基\n * 深入拆解 Tomcat & Jetty\n\n\n# 🚪 传送\n\n◾ 💧 钝悟的 IT 知识图谱 ◾",normalizedContent:"# java 服务器\n\n\n# 📖 内容\n\n * tomcat 快速入门\n * tomcat 连接器\n * tomcat 容器\n * tomcat 优化\n * tomcat 和 jetty\n * jetty\n\n\n# 📚 资料\n\n * tomcat 官网\n * jetty 官网\n * jetty github\n * nginx 官网\n * nginx 的中文维基\n * 深入拆解 tomcat & jetty\n\n\n# 🚪 传送\n\n◾ 💧 钝悟的 it 知识图谱 ◾",charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Maven 教程之 pom.xml 详解",frontmatter:{title:"Maven 教程之 pom.xml 详解",date:"2019-05-14T14:57:33.000Z",order:2,categories:["Java","软件","构建","Maven"],tags:["Java","构建","Maven"],permalink:"/pages/d893c2/"},regularPath:"/01.Java/11.%E8%BD%AF%E4%BB%B6/01.%E6%9E%84%E5%BB%BA/01.Maven/02.Maven%E6%95%99%E7%A8%8B%E4%B9%8Bpom.xml%E8%AF%A6%E8%A7%A3.html",relativePath:"01.Java/11.软件/01.构建/01.Maven/02.Maven教程之pom.xml详解.md",key:"v-c8c7b0bc",path:"/pages/d893c2/",headers:[{level:2,title:"pom.xml 简介",slug:"pom-xml-简介",normalizedTitle:"pom.xml 简介",charIndex:27},{level:3,title:"什么是 pom",slug:"什么是-pom",normalizedTitle:"什么是 pom",charIndex:42},{level:3,title:"pom 配置一览",slug:"pom-配置一览",normalizedTitle:"pom 配置一览",charIndex:132},{level:2,title:"基本配置",slug:"基本配置",normalizedTitle:"基本配置",charIndex:1434},{level:3,title:"maven 坐标",slug:"maven-坐标",normalizedTitle:"maven 坐标",charIndex:2019},{level:2,title:"依赖配置",slug:"依赖配置",normalizedTitle:"依赖配置",charIndex:2864},{level:3,title:"dependencies",slug:"dependencies",normalizedTitle:"dependencies",charIndex:546},{level:3,title:"parent",slug:"parent",normalizedTitle:"parent",charIndex:581},{level:3,title:"dependencyManagement",slug:"dependencymanagement",normalizedTitle:"dependencymanagement",charIndex:604},{level:3,title:"modules",slug:"modules",normalizedTitle:"modules",charIndex:655},{level:3,title:"properties",slug:"properties",normalizedTitle:"properties",charIndex:680},{level:2,title:"构建配置",slug:"构建配置",normalizedTitle:"构建配置",charIndex:6541},{level:3,title:"build",slug:"build",normalizedTitle:"build",charIndex:738},{level:4,title:"resources",slug:"resources",normalizedTitle:"resources",charIndex:7639},{level:4,title:"plugins",slug:"plugins",normalizedTitle:"plugins",charIndex:5540},{level:4,title:"pluginManagement",slug:"pluginmanagement",normalizedTitle:"pluginmanagement",charIndex:5548},{level:4,title:"directories",slug:"directories",normalizedTitle:"directories",charIndex:11477},{level:4,title:"extensions",slug:"extensions",normalizedTitle:"extensions",charIndex:9500},{level:3,title:"reporting",slug:"reporting",normalizedTitle:"reporting",charIndex:759},{level:2,title:"项目信息",slug:"项目信息",normalizedTitle:"项目信息",charIndex:14128},{level:2,title:"环境配置",slug:"环境配置",normalizedTitle:"环境配置",charIndex:15966},{level:3,title:"issueManagement",slug:"issuemanagement",normalizedTitle:"issuemanagement",charIndex:1092},{level:3,title:"ciManagement",slug:"cimanagement",normalizedTitle:"cimanagement",charIndex:1133},{level:3,title:"mailingLists",slug:"mailinglists",normalizedTitle:"mailinglists",charIndex:1168},{level:3,title:"scm",slug:"scm",normalizedTitle:"scm",charIndex:1203},{level:3,title:"prerequisites",slug:"prerequisites",normalizedTitle:"prerequisites",charIndex:1220},{level:3,title:"repositories",slug:"repositories",normalizedTitle:"repositories",charIndex:1257},{level:3,title:"pluginRepositories",slug:"pluginrepositories",normalizedTitle:"pluginrepositories",charIndex:1292},{level:3,title:"distributionManagement",slug:"distributionmanagement",normalizedTitle:"distributionmanagement",charIndex:1339},{level:3,title:"profiles",slug:"profiles",normalizedTitle:"profiles",charIndex:1394},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:21784}],headersStr:"pom.xml 简介 什么是 pom pom 配置一览 基本配置 maven 坐标 依赖配置 dependencies parent dependencyManagement modules properties 构建配置 build resources plugins pluginManagement directories extensions reporting 项目信息 环境配置 issueManagement ciManagement mailingLists scm prerequisites repositories pluginRepositories distributionManagement profiles 参考资料",content:'# Maven 教程之 pom.xml 详解\n\n\n# pom.xml 简介\n\n\n# 什么是 pom\n\nPOM 是 Project Object Model 的缩写，即项目对象模型。\n\npom.xml 就是 maven 的配置文件，用以描述项目的各种信息。\n\n\n# pom 配置一览\n\n<project xmlns="http://maven.apache.org/POM/4.0.0"\n  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0\n                      http://maven.apache.org/xsd/maven-4.0.0.xsd">\n  <modelVersion>4.0.0</modelVersion>\n\n  \x3c!-- The Basics --\x3e\n  <groupId>...</groupId>\n  <artifactId>...</artifactId>\n  <version>...</version>\n  <packaging>...</packaging>\n  <dependencies>...</dependencies>\n  <parent>...</parent>\n  <dependencyManagement>...</dependencyManagement>\n  <modules>...</modules>\n  <properties>...</properties>\n\n  \x3c!-- Build Settings --\x3e\n  <build>...</build>\n  <reporting>...</reporting>\n\n  \x3c!-- More Project Information --\x3e\n  <name>...</name>\n  <description>...</description>\n  <url>...</url>\n  <inceptionYear>...</inceptionYear>\n  <licenses>...</licenses>\n  <organization>...</organization>\n  <developers>...</developers>\n  <contributors>...</contributors>\n\n  \x3c!-- Environment Settings --\x3e\n  <issueManagement>...</issueManagement>\n  <ciManagement>...</ciManagement>\n  <mailingLists>...</mailingLists>\n  <scm>...</scm>\n  <prerequisites>...</prerequisites>\n  <repositories>...</repositories>\n  <pluginRepositories>...</pluginRepositories>\n  <distributionManagement>...</distributionManagement>\n  <profiles>...</profiles>\n</project>\n\n\n\n# 基本配置\n\n * project - project 是 pom.xml 中描述符的根。\n * modelVersion - modelVersion 指定 pom.xml 符合哪个版本的描述符。maven 2 和 3 只能为 4.0.0。\n\n一般 jar 包被识别为： groupId:artifactId:version 的形式。\n\n<project xmlns="http://maven.apache.org/POM/4.0.0"\n  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0\n                      http://maven.apache.org/xsd/maven-4.0.0.xsd">\n  <modelVersion>4.0.0</modelVersion>\n\n  <groupId>org.codehaus.mojo</groupId>\n  <artifactId>my-project</artifactId>\n  <version>1.0</version>\n  <packaging>war</packaging>\n</project>\n\n\n\n# maven 坐标\n\n在 maven 中，根据 groupId、artifactId、version 组合成 groupId:artifactId:version 来唯一识别一个 jar 包。\n\n * groupId - 团体、组织的标识符。团体标识的约定是，它以创建这个项目的组织名称的逆向域名(reverse domain name)开头。一般对应着 java 的包结构。\n * artifactId - 单独项目的唯一标识符。比如我们的 tomcat、commons 等。不要在 artifactId 中包含点号(.)。\n * version - 一个项目的特定版本。\n   * maven 有自己的版本规范，一般是如下定义 major version、minor version、incremental version-qualifier ，比如 1.2.3-beta-01。要说明的是，maven 自己判断版本的算法是 major、minor、incremental 部分用数字比较，qualifier 部分用字符串比较，所以要小心 alpha-2 和 alpha-15 的比较关系，最好用 alpha-02 的格式。\n   * maven 在版本管理时候可以使用几个特殊的字符串 SNAPSHOT、LATEST、RELEASE。比如 1.0-SNAPSHOT。各个部分的含义和处理逻辑如下说明：\n     * SNAPSHOT - 这个版本一般用于开发过程中，表示不稳定的版本。\n     * LATEST - 指某个特定构件的最新发布，这个发布可能是一个发布版，也可能是一个 snapshot 版，具体看哪个时间最后。\n     * RELEASE ：指最后一个发布版。\n * packaging - 项目的类型，描述了项目打包后的输出，默认是 jar。常见的输出类型为：pom, jar, maven-plugin, ejb, war, ear, rar, par。\n\n\n# 依赖配置\n\n\n# dependencies\n\n<project xmlns="http://maven.apache.org/POM/4.0.0"\n  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0\n                      https://maven.apache.org/xsd/maven-4.0.0.xsd">\n  ...\n  <dependencies>\n    <dependency>\n     <groupId>org.apache.maven</groupId>\n      <artifactId>maven-embedder</artifactId>\n      <version>2.0</version>\n      <type>jar</type>\n      <scope>test</scope>\n      <optional>true</optional>\n      <exclusions>\n        <exclusion>\n          <groupId>org.apache.maven</groupId>\n          <artifactId>maven-core</artifactId>\n        </exclusion>\n      </exclusions>\n    </dependency>\n    ...\n  </dependencies>\n  ...\n</project>\n\n\n * groupId, artifactId, version - 和基本配置中的 groupId、artifactId、version 意义相同。\n * type - 对应 packaging 的类型，如果不使用 type 标签，maven 默认为 jar。\n * scope - 此元素指的是任务的类路径（编译和运行时，测试等）以及如何限制依赖关系的传递性。有 5 种可用的限定范围：\n   * compile - 如果没有指定 scope 标签，maven 默认为这个范围。编译依赖关系在所有 classpath 中都可用。此外，这些依赖关系被传播到依赖项目。\n   * provided - 与 compile 类似，但是表示您希望 jdk 或容器在运行时提供它。它只适用于编译和测试 classpath，不可传递。\n   * runtime - 此范围表示编译不需要依赖关系，而是用于执行。它是在运行时和测试 classpath，但不是编译 classpath。\n   * test - 此范围表示正常使用应用程序不需要依赖关系，仅适用于测试编译和执行阶段。它不是传递的。\n   * system - 此范围与 provided 类似，除了您必须提供明确包含它的 jar。该 artifact 始终可用，并且不是在仓库中查找。\n * systemPath - 仅当依赖范围是系统时才使用。否则，如果设置此元素，构建将失败。该路径必须是绝对路径，因此建议使用 propertie 来指定特定的路径，如$ {java.home} / lib。由于假定先前安装了系统范围依赖关系，maven 将不会检查项目的仓库，而是检查库文件是否存在。如果没有，maven 将会失败，并建议您手动下载安装。\n * optional - optional 让其他项目知道，当您使用此项目时，您不需要这种依赖性才能正常工作。\n * exclusions - 包含一个或多个排除元素，每个排除元素都包含一个表示要排除的依赖关系的 groupId 和 artifactId。与可选项不同，可能或可能不会安装和使用，排除主动从依赖关系树中删除自己。\n\n\n# parent\n\nmaven 支持继承功能。子 POM 可以使用 parent 指定父 POM ，然后继承其配置。\n\n<project xmlns="http://maven.apache.org/POM/4.0.0"\n  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0\n                      https://maven.apache.org/xsd/maven-4.0.0.xsd">\n  <modelVersion>4.0.0</modelVersion>\n\n  <parent>\n    <groupId>org.codehaus.mojo</groupId>\n    <artifactId>my-parent</artifactId>\n    <version>2.0</version>\n    <relativePath>../my-parent</relativePath>\n  </parent>\n\n  <artifactId>my-project</artifactId>\n</project>\n\n\n * relativePath - 注意 relativePath 元素。在搜索本地和远程存储库之前，它不是必需的，但可以用作 maven 的指示符，以首先搜索给定该项目父级的路径。\n\n\n# dependencyManagement\n\ndependencyManagement 是表示依赖 jar 包的声明。即你在项目中的 dependencyManagement 下声明了依赖，maven 不会加载该依赖，dependencyManagement 声明可以被子 POM 继承。\n\ndependencyManagement 的一个使用案例是当有父子项目的时候，父项目中可以利用 dependencyManagement 声明子项目中需要用到的依赖 jar 包，之后，当某个或者某几个子项目需要加载该依赖的时候，就可以在子项目中 dependencies 节点只配置 groupId 和 artifactId 就可以完成依赖的引用。\n\ndependencyManagement 主要是为了统一管理依赖包的版本，确保所有子项目使用的版本一致，类似的还有plugins和pluginManagement。\n\n\n# modules\n\n子模块列表。\n\n<project xmlns="http://maven.apache.org/POM/4.0.0"\n  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0\n                      https://maven.apache.org/xsd/maven-4.0.0.xsd">\n  <modelVersion>4.0.0</modelVersion>\n\n  <groupId>org.codehaus.mojo</groupId>\n  <artifactId>my-parent</artifactId>\n  <version>2.0</version>\n  <packaging>pom</packaging>\n\n  <modules>\n    <module>my-project</module>\n    <module>another-project</module>\n    <module>third-project/pom-example.xml</module>\n  </modules>\n</project>\n\n\n\n# properties\n\n属性列表。定义的属性可以在 pom.xml 文件中任意处使用。使用方式为 ${propertie} 。\n\n<project>\n  ...\n  <properties>\n    <maven.compiler.source>1.7<maven.compiler.source>\n    <maven.compiler.target>1.7<maven.compiler.target>\n    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n    <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n  </properties>\n  ...\n</project>\n\n\n\n# 构建配置\n\n\n# build\n\nbuild 可以分为 "project build" 和 "profile build"。\n\n<project xmlns="http://maven.apache.org/POM/4.0.0"\n  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0\n                      https://maven.apache.org/xsd/maven-4.0.0.xsd">\n  ...\n  \x3c!-- "Project Build" contains more elements than just the BaseBuild set --\x3e\n  <build>...</build>\n\n  <profiles>\n    <profile>\n      \x3c!-- "Profile Build" contains a subset of "Project Build"s elements --\x3e\n      <build>...</build>\n    </profile>\n  </profiles>\n</project>\n\n\n基本构建配置：\n\n<build>\n  <defaultGoal>install</defaultGoal>\n  <directory>${basedir}/target</directory>\n  <finalName>${artifactId}-${version}</finalName>\n  <filters>\n    <filter>filters/filter1.properties</filter>\n  </filters>\n  ...\n</build>\n\n\ndefaultGoal : 默认执行目标或阶段。如果给出了一个目标，它应该被定义为它在命令行中（如 jar：jar）。如果定义了一个阶段（如安装），也是如此。\n\ndirectory ：构建时的输出路径。默认为：${basedir}/target 。\n\nfinalName ：这是项目的最终构建名称（不包括文件扩展名，例如：my-project-1.0.jar）\n\nfilter ：定义 * .properties 文件，其中包含适用于接受其设置的资源的属性列表（如下所述）。换句话说，过滤器文件中定义的“name = value”对在代码中替换$ {name}字符串。\n\n# resources\n\n资源的配置。资源文件通常不是代码，不需要编译，而是在项目需要捆绑使用的内容。\n\n<project xmlns="http://maven.apache.org/POM/4.0.0"\n  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0\n                      https://maven.apache.org/xsd/maven-4.0.0.xsd">\n  <build>\n    ...\n    <resources>\n      <resource>\n        <targetPath>META-INF/plexus</targetPath>\n        <filtering>false</filtering>\n        <directory>${basedir}/src/main/plexus</directory>\n        <includes>\n          <include>configuration.xml</include>\n        </includes>\n        <excludes>\n          <exclude>**/*.properties</exclude>\n        </excludes>\n      </resource>\n    </resources>\n    <testResources>\n      ...\n    </testResources>\n    ...\n  </build>\n</project>\n\n\n * resources: 资源元素的列表，每个资源元素描述与此项目关联的文件和何处包含文件。\n * targetPath: 指定从构建中放置资源集的目录结构。目标路径默认为基本目录。将要包装在 jar 中的资源的通常指定的目标路径是 META-INF。\n * filtering: 值为 true 或 false。表示是否要为此资源启用过滤。请注意，该过滤器 * .properties 文件不必定义为进行过滤 - 资源还可以使用默认情况下在 POM 中定义的属性（例如$ {project.version}），并将其传递到命令行中“-D”标志（例如，“-Dname = value”）或由 properties 元素显式定义。过滤文件覆盖上面。\n * directory: 值定义了资源的路径。构建的默认目录是${basedir}/src/main/resources。\n * includes: 一组文件匹配模式，指定目录中要包括的文件，使用*作为通配符。\n * excludes: 与 includes 类似，指定目录中要排除的文件，使用*作为通配符。注意：如果 include 和 exclude 发生冲突，maven 会以 exclude 作为有效项。\n * testResources: testResources 与 resources 功能类似，区别仅在于：testResources 指定的资源仅用于 test 阶段，并且其默认资源目录为：${basedir}/src/test/resources 。\n\n# plugins\n\n<project xmlns="http://maven.apache.org/POM/4.0.0"\n  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0\n                      https://maven.apache.org/xsd/maven-4.0.0.xsd">\n  <build>\n    ...\n    <plugins>\n      <plugin>\n        <groupId>org.apache.maven.plugins</groupId>\n        <artifactId>maven-jar-plugin</artifactId>\n        <version>2.6</version>\n        <extensions>false</extensions>\n        <inherited>true</inherited>\n        <configuration>\n          <classifier>test</classifier>\n        </configuration>\n        <dependencies>...</dependencies>\n        <executions>...</executions>\n      </plugin>\n    </plugins>\n  </build>\n</project>\n\n\n * groupId, artifactId, version ：和基本配置中的 groupId、artifactId、version 意义相同。\n\n * extensions ：值为 true 或 false。是否加载此插件的扩展名。默认为 false。\n\n * inherited ：值为 true 或 false。这个插件配置是否应该适用于继承自这个插件的 POM。默认值为 true。\n\n * configuration - 这是针对个人插件的配置，这里不扩散讲解。\n\n * dependencies ：这里的 dependencies 是插件本身所需要的依赖。\n\n * executions ：需要记住的是，插件可能有多个目标。每个目标可能有一个单独的配置，甚至可能将插件的目标完全绑定到不同的阶段。执行配置插件的目标的执行。\n   \n   * id: 执行目标的标识。\n   * goals: 像所有多元化的 POM 元素一样，它包含单个元素的列表。在这种情况下，这个执行块指定的插件目标列表。\n   * phase: 这是执行目标列表的阶段。这是一个非常强大的选项，允许将任何目标绑定到构建生命周期中的任何阶段，从而改变 maven 的默认行为。\n   * inherited: 像上面的继承元素一样，设置这个 false 会阻止 maven 将这个执行传递给它的子代。此元素仅对父 POM 有意义。\n   * configuration: 与上述相同，但将配置限制在此特定目标列表中，而不是插件下的所有目标。\n\n<project xmlns="http://maven.apache.org/POM/4.0.0"\n  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0\n                      https://maven.apache.org/xsd/maven-4.0.0.xsd">\n  ...\n  <build>\n    <plugins>\n      <plugin>\n        <artifactId>maven-antrun-plugin</artifactId>\n        <version>1.1</version>\n        <executions>\n          <execution>\n            <id>echodir</id>\n            <goals>\n              <goal>run</goal>\n            </goals>\n            <phase>verify</phase>\n            <inherited>false</inherited>\n            <configuration>\n              <tasks>\n                <echo>Build Dir: ${project.build.directory}</echo>\n              </tasks>\n            </configuration>\n          </execution>\n        </executions>\n\n      </plugin>\n    </plugins>\n  </build>\n</project>\n\n\n# pluginManagement\n\n与 dependencyManagement 很相似，在当前 POM 中仅声明插件，而不是实际引入插件。子 POM 中只配置 groupId 和 artifactId 就可以完成插件的引用，且子 POM 有权重写 pluginManagement 定义。\n\n它的目的在于统一所有子 POM 的插件版本。\n\n# directories\n\n<project xmlns="http://maven.apache.org/POM/4.0.0"\n  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0\n                      https://maven.apache.org/xsd/maven-4.0.0.xsd">\n  ...\n  <build>\n    <sourceDirectory>${basedir}/src/main/java</sourceDirectory>\n    <scriptSourceDirectory>${basedir}/src/main/scripts</scriptSourceDirectory>\n    <testSourceDirectory>${basedir}/src/test/java</testSourceDirectory>\n    <outputDirectory>${basedir}/target/classes</outputDirectory>\n    <testOutputDirectory>${basedir}/target/test-classes</testOutputDirectory>\n    ...\n  </build>\n</project>\n\n\n目录元素集合存在于 build 元素中，它为整个 POM 设置了各种目录结构。由于它们在配置文件构建中不存在，所以这些不能由配置文件更改。\n\n如果上述目录元素的值设置为绝对路径（扩展属性时），则使用该目录。否则，它是相对于基础构建目录：${basedir}。\n\n# extensions\n\n扩展是在此构建中使用的 artifacts 的列表。它们将被包含在运行构建的 classpath 中。它们可以启用对构建过程的扩展（例如为 Wagon 传输机制添加一个 ftp 提供程序），并使活动的插件能够对构建生命周期进行更改。简而言之，扩展是在构建期间激活的 artifacts。扩展不需要实际执行任何操作，也不包含 Mojo。因此，扩展对于指定普通插件接口的多个实现中的一个是非常好的。\n\n<project xmlns="http://maven.apache.org/POM/4.0.0"\n  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0\n                      https://maven.apache.org/xsd/maven-4.0.0.xsd">\n  ...\n  <build>\n    ...\n    <extensions>\n      <extension>\n        <groupId>org.apache.maven.wagon</groupId>\n        <artifactId>wagon-ftp</artifactId>\n        <version>1.0-alpha-3</version>\n      </extension>\n    </extensions>\n    ...\n  </build>\n</project>\n\n\n\n# reporting\n\n报告包含特定针对 site 生成阶段的元素。某些 maven 插件可以生成 reporting 元素下配置的报告，例如：生成 javadoc 报告。reporting 与 build 元素配置插件的能力相似。明显的区别在于：在执行块中插件目标的控制不是细粒度的，报表通过配置 reportSet 元素来精细控制。而微妙的区别在于 reporting 元素下的 configuration 元素可以用作 build 下的 configuration ，尽管相反的情况并非如此（ build 下的 configuration 不影响 reporting 元素下的 configuration ）。\n\n另一个区别就是 plugin 下的 outputDirectory 元素。在报告的情况下，默认输出目录为 ${basedir}/target/site。\n\n<project xmlns="http://maven.apache.org/POM/4.0.0"\n  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0\n                      https://maven.apache.org/xsd/maven-4.0.0.xsd">\n  ...\n  <reporting>\n    <plugins>\n      <plugin>\n        ...\n        <reportSets>\n          <reportSet>\n            <id>sunlink</id>\n            <reports>\n              <report>javadoc</report>\n            </reports>\n            <inherited>true</inherited>\n            <configuration>\n              <links>\n                <link>http://java.sun.com/j2se/1.5.0/docs/api/</link>\n              </links>\n            </configuration>\n          </reportSet>\n        </reportSets>\n      </plugin>\n    </plugins>\n  </reporting>\n  ...\n</project>\n\n\n\n# 项目信息\n\n项目信息相关的这部分标签都不是必要的，也就是说完全可以不填写。\n\n它的作用仅限于描述项目的详细信息。\n\n下面的示例是项目信息相关标签的清单：\n\n<project xmlns="http://maven.apache.org/POM/4.0.0"\n  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0\n                      https://maven.apache.org/xsd/maven-4.0.0.xsd">\n  ...\n\n  \x3c!-- 项目信息 begin --\x3e\n\n  \x3c!--项目名--\x3e\n  <name>maven-notes</name>\n\n  \x3c!--项目描述--\x3e\n  <description>maven 学习笔记</description>\n\n  \x3c!--项目url--\x3e\n  <url>https://github.com/dunwu/maven-notes</url>\n\n  \x3c!--项目开发年份--\x3e\n  <inceptionYear>2017</inceptionYear>\n\n  \x3c!--开源协议--\x3e\n  <licenses>\n    <license>\n      <name>Apache License, Version 2.0</name>\n      <url>https://www.apache.org/licenses/LICENSE-2.0.txt</url>\n      <distribution>repo</distribution>\n      <comments>A business-friendly OSS license</comments>\n    </license>\n  </licenses>\n\n  \x3c!--组织信息(如公司、开源组织等)--\x3e\n  <organization>\n    <name>...</name>\n    <url>...</url>\n  </organization>\n\n  \x3c!--开发者列表--\x3e\n  <developers>\n    <developer>\n      <id>victor</id>\n      <name>Zhang Peng</name>\n      <email>forbreak at 163.com</email>\n      <url>https://github.com/dunwu</url>\n      <organization>...</organization>\n      <organizationUrl>...</organizationUrl>\n      <roles>\n        <role>architect</role>\n        <role>developer</role>\n      </roles>\n      <timezone>+8</timezone>\n      <properties>...</properties>\n    </developer>\n  </developers>\n\n  \x3c!--代码贡献者列表--\x3e\n   <contributors>\n    <contributor>\n      \x3c!--标签内容和<developer>相同--\x3e\n    </contributor>\n  </contributors>\n\n  \x3c!-- 项目信息 end --\x3e\n\n  ...\n</project>\n\n\n这部分标签都非常简单，基本都能做到顾名思义，且都属于可有可无的标签，所以这里仅简单介绍一下：\n\n * name - 项目完整名称\n\n * description - 项目描述\n\n * url - 一般为项目仓库的 host\n\n * inceptionYear - 开发年份\n\n * licenses - 开源协议\n\n * organization - 项目所属组织信息\n\n * developers - 项目开发者列表\n\n * contributors - 项目贡献者列表，<contributor> 的子标签和 <developer> 的完全相同。\n\n\n# 环境配置\n\n\n# issueManagement\n\n这定义了所使用的缺陷跟踪系统（Bugzilla，TestTrack，ClearQuest 等）。虽然没有什么可以阻止插件使用这些信息的东西，但它主要用于生成项目文档。\n\n<project xmlns="http://maven.apache.org/POM/4.0.0"\n  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0\n                      https://maven.apache.org/xsd/maven-4.0.0.xsd">\n  ...\n  <issueManagement>\n    <system>Bugzilla</system>\n    <url>http://127.0.0.1/bugzilla/</url>\n  </issueManagement>\n  ...\n</project>\n\n\n\n# ciManagement\n\nCI 构建系统配置，主要是指定通知机制以及被通知的邮箱。\n\n<project xmlns="http://maven.apache.org/POM/4.0.0"\n  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0\n                      https://maven.apache.org/xsd/maven-4.0.0.xsd">\n  ...\n  <ciManagement>\n    <system>continuum</system>\n    <url>http://127.0.0.1:8080/continuum</url>\n    <notifiers>\n      <notifier>\n        <type>mail</type>\n        <sendOnError>true</sendOnError>\n        <sendOnFailure>true</sendOnFailure>\n        <sendOnSuccess>false</sendOnSuccess>\n        <sendOnWarning>false</sendOnWarning>\n        <configuration><address>continuum@127.0.0.1</address></configuration>\n      </notifier>\n    </notifiers>\n  </ciManagement>\n  ...\n</project>\n\n\n\n# mailingLists\n\n邮件列表\n\n<project xmlns="http://maven.apache.org/POM/4.0.0"\n  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0\n                      https://maven.apache.org/xsd/maven-4.0.0.xsd">\n  ...\n  <mailingLists>\n    <mailingList>\n      <name>User List</name>\n      <subscribe>user-subscribe@127.0.0.1</subscribe>\n      <unsubscribe>user-unsubscribe@127.0.0.1</unsubscribe>\n      <post>user@127.0.0.1</post>\n      <archive>http://127.0.0.1/user/</archive>\n      <otherArchives>\n        <otherArchive>http://base.google.com/base/1/127.0.0.1</otherArchive>\n      </otherArchives>\n    </mailingList>\n  </mailingLists>\n  ...\n</project>\n\n\n\n# scm\n\nSCM（软件配置管理，也称为源代码/控制管理或简洁的版本控制）。常见的 scm 有 svn 和 git 。\n\n<project xmlns="http://maven.apache.org/POM/4.0.0"\n  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0\n                      https://maven.apache.org/xsd/maven-4.0.0.xsd">\n  ...\n  <scm>\n    <connection>scm:svn:http://127.0.0.1/svn/my-project</connection>\n    <developerConnection>scm:svn:https://127.0.0.1/svn/my-project</developerConnection>\n    <tag>HEAD</tag>\n    <url>http://127.0.0.1/websvn/my-project</url>\n  </scm>\n  ...\n</project>\n\n\n\n# prerequisites\n\nPOM 执行的预设条件。\n\n<project xmlns="http://maven.apache.org/POM/4.0.0"\n  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0\n                      https://maven.apache.org/xsd/maven-4.0.0.xsd">\n  ...\n  <prerequisites>\n    <maven>2.0.6</maven>\n  </prerequisites>\n  ...\n</project>\n\n\n\n# repositories\n\nrepositories 是遵循 Maven 存储库目录布局的 artifacts 集合。默认的 Maven 中央存储库位于https://repo.maven.apache.org/maven2/上。\n\n<project xmlns="http://maven.apache.org/POM/4.0.0"\n  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0\n                      https://maven.apache.org/xsd/maven-4.0.0.xsd">\n  ...\n  <repositories>\n    <repository>\n      <releases>\n        <enabled>false</enabled>\n        <updatePolicy>always</updatePolicy>\n        <checksumPolicy>warn</checksumPolicy>\n      </releases>\n      <snapshots>\n        <enabled>true</enabled>\n        <updatePolicy>never</updatePolicy>\n        <checksumPolicy>fail</checksumPolicy>\n      </snapshots>\n      <id>codehausSnapshots</id>\n      <name>Codehaus Snapshots</name>\n      <url>http://snapshots.maven.codehaus.org/maven2</url>\n      <layout>default</layout>\n    </repository>\n  </repositories>\n  <pluginRepositories>\n    ...\n  </pluginRepositories>\n  ...\n</project>\n\n\n\n# pluginRepositories\n\n与 repositories 差不多。\n\n<project xmlns="http://maven.apache.org/POM/4.0.0"\n  xmlns:xsi="http://www.w3.org/001/XMLSchema-instance"\n  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0\n                      https://maven.apache.org/xsd/maven-4.0.0.xsd">\n  ...\n  <distributionManagement>\n    ...\n    <downloadUrl>http://mojo.codehaus.org/my-project</downloadUrl>\n    <status>deployed</status>\n  </distributionManagement>\n  ...\n</project>\n\n\n\n# distributionManagement\n\n它管理在整个构建过程中生成的 artifact 和支持文件的分布。从最后的元素开始：\n\n<project xmlns="http://maven.apache.org/POM/4.0.0"\n  xmlns:xsi="http://www.w3.org/001/XMLSchema-instance"\n  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0\n                      https://maven.apache.org/xsd/maven-4.0.0.xsd">\n  ...\n  <distributionManagement>\n    ...\n    <downloadUrl>http://mojo.codehaus.org/my-project</downloadUrl>\n    <status>deployed</status>\n  </distributionManagement>\n  ...\n</project>\n\n\n * repository - 与 repositories 相似\n\n * site - 站点信息\n\n * relocation - 项目迁移位置\n\n\n# profiles\n\nactivation 是一个 profile 的关键。配置文件的功能来自于在某些情况下仅修改基本 POM 的功能。这些情况通过 activation 元素指定。\n\n<project xmlns="http://maven.apache.org/POM/4.0.0"\n  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0\n                      https://maven.apache.org/xsd/maven-4.0.0.xsd">\n  ...\n  <profiles>\n    <profile>\n      <id>test</id>\n      <activation>\n        <activeByDefault>false</activeByDefault>\n        <jdk>1.5</jdk>\n        <os>\n          <name>Windows XP</name>\n          <family>Windows</family>\n          <arch>x86</arch>\n          <version>5.1.2600</version>\n        </os>\n        <property>\n          <name>sparrow-type</name>\n          <value>African</value>\n        </property>\n        <file>\n          <exists>${basedir}/file2.properties</exists>\n          <missing>${basedir}/file1.properties</missing>\n        </file>\n      </activation>\n      ...\n    </profile>\n  </profiles>\n</project>\n\n\n\n# 参考资料\n\n * maven 官方文档之 pom',normalizedContent:'# maven 教程之 pom.xml 详解\n\n\n# pom.xml 简介\n\n\n# 什么是 pom\n\npom 是 project object model 的缩写，即项目对象模型。\n\npom.xml 就是 maven 的配置文件，用以描述项目的各种信息。\n\n\n# pom 配置一览\n\n<project xmlns="http://maven.apache.org/pom/4.0.0"\n  xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n  xsi:schemalocation="http://maven.apache.org/pom/4.0.0\n                      http://maven.apache.org/xsd/maven-4.0.0.xsd">\n  <modelversion>4.0.0</modelversion>\n\n  \x3c!-- the basics --\x3e\n  <groupid>...</groupid>\n  <artifactid>...</artifactid>\n  <version>...</version>\n  <packaging>...</packaging>\n  <dependencies>...</dependencies>\n  <parent>...</parent>\n  <dependencymanagement>...</dependencymanagement>\n  <modules>...</modules>\n  <properties>...</properties>\n\n  \x3c!-- build settings --\x3e\n  <build>...</build>\n  <reporting>...</reporting>\n\n  \x3c!-- more project information --\x3e\n  <name>...</name>\n  <description>...</description>\n  <url>...</url>\n  <inceptionyear>...</inceptionyear>\n  <licenses>...</licenses>\n  <organization>...</organization>\n  <developers>...</developers>\n  <contributors>...</contributors>\n\n  \x3c!-- environment settings --\x3e\n  <issuemanagement>...</issuemanagement>\n  <cimanagement>...</cimanagement>\n  <mailinglists>...</mailinglists>\n  <scm>...</scm>\n  <prerequisites>...</prerequisites>\n  <repositories>...</repositories>\n  <pluginrepositories>...</pluginrepositories>\n  <distributionmanagement>...</distributionmanagement>\n  <profiles>...</profiles>\n</project>\n\n\n\n# 基本配置\n\n * project - project 是 pom.xml 中描述符的根。\n * modelversion - modelversion 指定 pom.xml 符合哪个版本的描述符。maven 2 和 3 只能为 4.0.0。\n\n一般 jar 包被识别为： groupid:artifactid:version 的形式。\n\n<project xmlns="http://maven.apache.org/pom/4.0.0"\n  xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n  xsi:schemalocation="http://maven.apache.org/pom/4.0.0\n                      http://maven.apache.org/xsd/maven-4.0.0.xsd">\n  <modelversion>4.0.0</modelversion>\n\n  <groupid>org.codehaus.mojo</groupid>\n  <artifactid>my-project</artifactid>\n  <version>1.0</version>\n  <packaging>war</packaging>\n</project>\n\n\n\n# maven 坐标\n\n在 maven 中，根据 groupid、artifactid、version 组合成 groupid:artifactid:version 来唯一识别一个 jar 包。\n\n * groupid - 团体、组织的标识符。团体标识的约定是，它以创建这个项目的组织名称的逆向域名(reverse domain name)开头。一般对应着 java 的包结构。\n * artifactid - 单独项目的唯一标识符。比如我们的 tomcat、commons 等。不要在 artifactid 中包含点号(.)。\n * version - 一个项目的特定版本。\n   * maven 有自己的版本规范，一般是如下定义 major version、minor version、incremental version-qualifier ，比如 1.2.3-beta-01。要说明的是，maven 自己判断版本的算法是 major、minor、incremental 部分用数字比较，qualifier 部分用字符串比较，所以要小心 alpha-2 和 alpha-15 的比较关系，最好用 alpha-02 的格式。\n   * maven 在版本管理时候可以使用几个特殊的字符串 snapshot、latest、release。比如 1.0-snapshot。各个部分的含义和处理逻辑如下说明：\n     * snapshot - 这个版本一般用于开发过程中，表示不稳定的版本。\n     * latest - 指某个特定构件的最新发布，这个发布可能是一个发布版，也可能是一个 snapshot 版，具体看哪个时间最后。\n     * release ：指最后一个发布版。\n * packaging - 项目的类型，描述了项目打包后的输出，默认是 jar。常见的输出类型为：pom, jar, maven-plugin, ejb, war, ear, rar, par。\n\n\n# 依赖配置\n\n\n# dependencies\n\n<project xmlns="http://maven.apache.org/pom/4.0.0"\n  xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n  xsi:schemalocation="http://maven.apache.org/pom/4.0.0\n                      https://maven.apache.org/xsd/maven-4.0.0.xsd">\n  ...\n  <dependencies>\n    <dependency>\n     <groupid>org.apache.maven</groupid>\n      <artifactid>maven-embedder</artifactid>\n      <version>2.0</version>\n      <type>jar</type>\n      <scope>test</scope>\n      <optional>true</optional>\n      <exclusions>\n        <exclusion>\n          <groupid>org.apache.maven</groupid>\n          <artifactid>maven-core</artifactid>\n        </exclusion>\n      </exclusions>\n    </dependency>\n    ...\n  </dependencies>\n  ...\n</project>\n\n\n * groupid, artifactid, version - 和基本配置中的 groupid、artifactid、version 意义相同。\n * type - 对应 packaging 的类型，如果不使用 type 标签，maven 默认为 jar。\n * scope - 此元素指的是任务的类路径（编译和运行时，测试等）以及如何限制依赖关系的传递性。有 5 种可用的限定范围：\n   * compile - 如果没有指定 scope 标签，maven 默认为这个范围。编译依赖关系在所有 classpath 中都可用。此外，这些依赖关系被传播到依赖项目。\n   * provided - 与 compile 类似，但是表示您希望 jdk 或容器在运行时提供它。它只适用于编译和测试 classpath，不可传递。\n   * runtime - 此范围表示编译不需要依赖关系，而是用于执行。它是在运行时和测试 classpath，但不是编译 classpath。\n   * test - 此范围表示正常使用应用程序不需要依赖关系，仅适用于测试编译和执行阶段。它不是传递的。\n   * system - 此范围与 provided 类似，除了您必须提供明确包含它的 jar。该 artifact 始终可用，并且不是在仓库中查找。\n * systempath - 仅当依赖范围是系统时才使用。否则，如果设置此元素，构建将失败。该路径必须是绝对路径，因此建议使用 propertie 来指定特定的路径，如$ {java.home} / lib。由于假定先前安装了系统范围依赖关系，maven 将不会检查项目的仓库，而是检查库文件是否存在。如果没有，maven 将会失败，并建议您手动下载安装。\n * optional - optional 让其他项目知道，当您使用此项目时，您不需要这种依赖性才能正常工作。\n * exclusions - 包含一个或多个排除元素，每个排除元素都包含一个表示要排除的依赖关系的 groupid 和 artifactid。与可选项不同，可能或可能不会安装和使用，排除主动从依赖关系树中删除自己。\n\n\n# parent\n\nmaven 支持继承功能。子 pom 可以使用 parent 指定父 pom ，然后继承其配置。\n\n<project xmlns="http://maven.apache.org/pom/4.0.0"\n  xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n  xsi:schemalocation="http://maven.apache.org/pom/4.0.0\n                      https://maven.apache.org/xsd/maven-4.0.0.xsd">\n  <modelversion>4.0.0</modelversion>\n\n  <parent>\n    <groupid>org.codehaus.mojo</groupid>\n    <artifactid>my-parent</artifactid>\n    <version>2.0</version>\n    <relativepath>../my-parent</relativepath>\n  </parent>\n\n  <artifactid>my-project</artifactid>\n</project>\n\n\n * relativepath - 注意 relativepath 元素。在搜索本地和远程存储库之前，它不是必需的，但可以用作 maven 的指示符，以首先搜索给定该项目父级的路径。\n\n\n# dependencymanagement\n\ndependencymanagement 是表示依赖 jar 包的声明。即你在项目中的 dependencymanagement 下声明了依赖，maven 不会加载该依赖，dependencymanagement 声明可以被子 pom 继承。\n\ndependencymanagement 的一个使用案例是当有父子项目的时候，父项目中可以利用 dependencymanagement 声明子项目中需要用到的依赖 jar 包，之后，当某个或者某几个子项目需要加载该依赖的时候，就可以在子项目中 dependencies 节点只配置 groupid 和 artifactid 就可以完成依赖的引用。\n\ndependencymanagement 主要是为了统一管理依赖包的版本，确保所有子项目使用的版本一致，类似的还有plugins和pluginmanagement。\n\n\n# modules\n\n子模块列表。\n\n<project xmlns="http://maven.apache.org/pom/4.0.0"\n  xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n  xsi:schemalocation="http://maven.apache.org/pom/4.0.0\n                      https://maven.apache.org/xsd/maven-4.0.0.xsd">\n  <modelversion>4.0.0</modelversion>\n\n  <groupid>org.codehaus.mojo</groupid>\n  <artifactid>my-parent</artifactid>\n  <version>2.0</version>\n  <packaging>pom</packaging>\n\n  <modules>\n    <module>my-project</module>\n    <module>another-project</module>\n    <module>third-project/pom-example.xml</module>\n  </modules>\n</project>\n\n\n\n# properties\n\n属性列表。定义的属性可以在 pom.xml 文件中任意处使用。使用方式为 ${propertie} 。\n\n<project>\n  ...\n  <properties>\n    <maven.compiler.source>1.7<maven.compiler.source>\n    <maven.compiler.target>1.7<maven.compiler.target>\n    <project.build.sourceencoding>utf-8</project.build.sourceencoding>\n    <project.reporting.outputencoding>utf-8</project.reporting.outputencoding>\n  </properties>\n  ...\n</project>\n\n\n\n# 构建配置\n\n\n# build\n\nbuild 可以分为 "project build" 和 "profile build"。\n\n<project xmlns="http://maven.apache.org/pom/4.0.0"\n  xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n  xsi:schemalocation="http://maven.apache.org/pom/4.0.0\n                      https://maven.apache.org/xsd/maven-4.0.0.xsd">\n  ...\n  \x3c!-- "project build" contains more elements than just the basebuild set --\x3e\n  <build>...</build>\n\n  <profiles>\n    <profile>\n      \x3c!-- "profile build" contains a subset of "project build"s elements --\x3e\n      <build>...</build>\n    </profile>\n  </profiles>\n</project>\n\n\n基本构建配置：\n\n<build>\n  <defaultgoal>install</defaultgoal>\n  <directory>${basedir}/target</directory>\n  <finalname>${artifactid}-${version}</finalname>\n  <filters>\n    <filter>filters/filter1.properties</filter>\n  </filters>\n  ...\n</build>\n\n\ndefaultgoal : 默认执行目标或阶段。如果给出了一个目标，它应该被定义为它在命令行中（如 jar：jar）。如果定义了一个阶段（如安装），也是如此。\n\ndirectory ：构建时的输出路径。默认为：${basedir}/target 。\n\nfinalname ：这是项目的最终构建名称（不包括文件扩展名，例如：my-project-1.0.jar）\n\nfilter ：定义 * .properties 文件，其中包含适用于接受其设置的资源的属性列表（如下所述）。换句话说，过滤器文件中定义的“name = value”对在代码中替换$ {name}字符串。\n\n# resources\n\n资源的配置。资源文件通常不是代码，不需要编译，而是在项目需要捆绑使用的内容。\n\n<project xmlns="http://maven.apache.org/pom/4.0.0"\n  xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n  xsi:schemalocation="http://maven.apache.org/pom/4.0.0\n                      https://maven.apache.org/xsd/maven-4.0.0.xsd">\n  <build>\n    ...\n    <resources>\n      <resource>\n        <targetpath>meta-inf/plexus</targetpath>\n        <filtering>false</filtering>\n        <directory>${basedir}/src/main/plexus</directory>\n        <includes>\n          <include>configuration.xml</include>\n        </includes>\n        <excludes>\n          <exclude>**/*.properties</exclude>\n        </excludes>\n      </resource>\n    </resources>\n    <testresources>\n      ...\n    </testresources>\n    ...\n  </build>\n</project>\n\n\n * resources: 资源元素的列表，每个资源元素描述与此项目关联的文件和何处包含文件。\n * targetpath: 指定从构建中放置资源集的目录结构。目标路径默认为基本目录。将要包装在 jar 中的资源的通常指定的目标路径是 meta-inf。\n * filtering: 值为 true 或 false。表示是否要为此资源启用过滤。请注意，该过滤器 * .properties 文件不必定义为进行过滤 - 资源还可以使用默认情况下在 pom 中定义的属性（例如$ {project.version}），并将其传递到命令行中“-d”标志（例如，“-dname = value”）或由 properties 元素显式定义。过滤文件覆盖上面。\n * directory: 值定义了资源的路径。构建的默认目录是${basedir}/src/main/resources。\n * includes: 一组文件匹配模式，指定目录中要包括的文件，使用*作为通配符。\n * excludes: 与 includes 类似，指定目录中要排除的文件，使用*作为通配符。注意：如果 include 和 exclude 发生冲突，maven 会以 exclude 作为有效项。\n * testresources: testresources 与 resources 功能类似，区别仅在于：testresources 指定的资源仅用于 test 阶段，并且其默认资源目录为：${basedir}/src/test/resources 。\n\n# plugins\n\n<project xmlns="http://maven.apache.org/pom/4.0.0"\n  xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n  xsi:schemalocation="http://maven.apache.org/pom/4.0.0\n                      https://maven.apache.org/xsd/maven-4.0.0.xsd">\n  <build>\n    ...\n    <plugins>\n      <plugin>\n        <groupid>org.apache.maven.plugins</groupid>\n        <artifactid>maven-jar-plugin</artifactid>\n        <version>2.6</version>\n        <extensions>false</extensions>\n        <inherited>true</inherited>\n        <configuration>\n          <classifier>test</classifier>\n        </configuration>\n        <dependencies>...</dependencies>\n        <executions>...</executions>\n      </plugin>\n    </plugins>\n  </build>\n</project>\n\n\n * groupid, artifactid, version ：和基本配置中的 groupid、artifactid、version 意义相同。\n\n * extensions ：值为 true 或 false。是否加载此插件的扩展名。默认为 false。\n\n * inherited ：值为 true 或 false。这个插件配置是否应该适用于继承自这个插件的 pom。默认值为 true。\n\n * configuration - 这是针对个人插件的配置，这里不扩散讲解。\n\n * dependencies ：这里的 dependencies 是插件本身所需要的依赖。\n\n * executions ：需要记住的是，插件可能有多个目标。每个目标可能有一个单独的配置，甚至可能将插件的目标完全绑定到不同的阶段。执行配置插件的目标的执行。\n   \n   * id: 执行目标的标识。\n   * goals: 像所有多元化的 pom 元素一样，它包含单个元素的列表。在这种情况下，这个执行块指定的插件目标列表。\n   * phase: 这是执行目标列表的阶段。这是一个非常强大的选项，允许将任何目标绑定到构建生命周期中的任何阶段，从而改变 maven 的默认行为。\n   * inherited: 像上面的继承元素一样，设置这个 false 会阻止 maven 将这个执行传递给它的子代。此元素仅对父 pom 有意义。\n   * configuration: 与上述相同，但将配置限制在此特定目标列表中，而不是插件下的所有目标。\n\n<project xmlns="http://maven.apache.org/pom/4.0.0"\n  xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n  xsi:schemalocation="http://maven.apache.org/pom/4.0.0\n                      https://maven.apache.org/xsd/maven-4.0.0.xsd">\n  ...\n  <build>\n    <plugins>\n      <plugin>\n        <artifactid>maven-antrun-plugin</artifactid>\n        <version>1.1</version>\n        <executions>\n          <execution>\n            <id>echodir</id>\n            <goals>\n              <goal>run</goal>\n            </goals>\n            <phase>verify</phase>\n            <inherited>false</inherited>\n            <configuration>\n              <tasks>\n                <echo>build dir: ${project.build.directory}</echo>\n              </tasks>\n            </configuration>\n          </execution>\n        </executions>\n\n      </plugin>\n    </plugins>\n  </build>\n</project>\n\n\n# pluginmanagement\n\n与 dependencymanagement 很相似，在当前 pom 中仅声明插件，而不是实际引入插件。子 pom 中只配置 groupid 和 artifactid 就可以完成插件的引用，且子 pom 有权重写 pluginmanagement 定义。\n\n它的目的在于统一所有子 pom 的插件版本。\n\n# directories\n\n<project xmlns="http://maven.apache.org/pom/4.0.0"\n  xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n  xsi:schemalocation="http://maven.apache.org/pom/4.0.0\n                      https://maven.apache.org/xsd/maven-4.0.0.xsd">\n  ...\n  <build>\n    <sourcedirectory>${basedir}/src/main/java</sourcedirectory>\n    <scriptsourcedirectory>${basedir}/src/main/scripts</scriptsourcedirectory>\n    <testsourcedirectory>${basedir}/src/test/java</testsourcedirectory>\n    <outputdirectory>${basedir}/target/classes</outputdirectory>\n    <testoutputdirectory>${basedir}/target/test-classes</testoutputdirectory>\n    ...\n  </build>\n</project>\n\n\n目录元素集合存在于 build 元素中，它为整个 pom 设置了各种目录结构。由于它们在配置文件构建中不存在，所以这些不能由配置文件更改。\n\n如果上述目录元素的值设置为绝对路径（扩展属性时），则使用该目录。否则，它是相对于基础构建目录：${basedir}。\n\n# extensions\n\n扩展是在此构建中使用的 artifacts 的列表。它们将被包含在运行构建的 classpath 中。它们可以启用对构建过程的扩展（例如为 wagon 传输机制添加一个 ftp 提供程序），并使活动的插件能够对构建生命周期进行更改。简而言之，扩展是在构建期间激活的 artifacts。扩展不需要实际执行任何操作，也不包含 mojo。因此，扩展对于指定普通插件接口的多个实现中的一个是非常好的。\n\n<project xmlns="http://maven.apache.org/pom/4.0.0"\n  xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n  xsi:schemalocation="http://maven.apache.org/pom/4.0.0\n                      https://maven.apache.org/xsd/maven-4.0.0.xsd">\n  ...\n  <build>\n    ...\n    <extensions>\n      <extension>\n        <groupid>org.apache.maven.wagon</groupid>\n        <artifactid>wagon-ftp</artifactid>\n        <version>1.0-alpha-3</version>\n      </extension>\n    </extensions>\n    ...\n  </build>\n</project>\n\n\n\n# reporting\n\n报告包含特定针对 site 生成阶段的元素。某些 maven 插件可以生成 reporting 元素下配置的报告，例如：生成 javadoc 报告。reporting 与 build 元素配置插件的能力相似。明显的区别在于：在执行块中插件目标的控制不是细粒度的，报表通过配置 reportset 元素来精细控制。而微妙的区别在于 reporting 元素下的 configuration 元素可以用作 build 下的 configuration ，尽管相反的情况并非如此（ build 下的 configuration 不影响 reporting 元素下的 configuration ）。\n\n另一个区别就是 plugin 下的 outputdirectory 元素。在报告的情况下，默认输出目录为 ${basedir}/target/site。\n\n<project xmlns="http://maven.apache.org/pom/4.0.0"\n  xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n  xsi:schemalocation="http://maven.apache.org/pom/4.0.0\n                      https://maven.apache.org/xsd/maven-4.0.0.xsd">\n  ...\n  <reporting>\n    <plugins>\n      <plugin>\n        ...\n        <reportsets>\n          <reportset>\n            <id>sunlink</id>\n            <reports>\n              <report>javadoc</report>\n            </reports>\n            <inherited>true</inherited>\n            <configuration>\n              <links>\n                <link>http://java.sun.com/j2se/1.5.0/docs/api/</link>\n              </links>\n            </configuration>\n          </reportset>\n        </reportsets>\n      </plugin>\n    </plugins>\n  </reporting>\n  ...\n</project>\n\n\n\n# 项目信息\n\n项目信息相关的这部分标签都不是必要的，也就是说完全可以不填写。\n\n它的作用仅限于描述项目的详细信息。\n\n下面的示例是项目信息相关标签的清单：\n\n<project xmlns="http://maven.apache.org/pom/4.0.0"\n  xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n  xsi:schemalocation="http://maven.apache.org/pom/4.0.0\n                      https://maven.apache.org/xsd/maven-4.0.0.xsd">\n  ...\n\n  \x3c!-- 项目信息 begin --\x3e\n\n  \x3c!--项目名--\x3e\n  <name>maven-notes</name>\n\n  \x3c!--项目描述--\x3e\n  <description>maven 学习笔记</description>\n\n  \x3c!--项目url--\x3e\n  <url>https://github.com/dunwu/maven-notes</url>\n\n  \x3c!--项目开发年份--\x3e\n  <inceptionyear>2017</inceptionyear>\n\n  \x3c!--开源协议--\x3e\n  <licenses>\n    <license>\n      <name>apache license, version 2.0</name>\n      <url>https://www.apache.org/licenses/license-2.0.txt</url>\n      <distribution>repo</distribution>\n      <comments>a business-friendly oss license</comments>\n    </license>\n  </licenses>\n\n  \x3c!--组织信息(如公司、开源组织等)--\x3e\n  <organization>\n    <name>...</name>\n    <url>...</url>\n  </organization>\n\n  \x3c!--开发者列表--\x3e\n  <developers>\n    <developer>\n      <id>victor</id>\n      <name>zhang peng</name>\n      <email>forbreak at 163.com</email>\n      <url>https://github.com/dunwu</url>\n      <organization>...</organization>\n      <organizationurl>...</organizationurl>\n      <roles>\n        <role>architect</role>\n        <role>developer</role>\n      </roles>\n      <timezone>+8</timezone>\n      <properties>...</properties>\n    </developer>\n  </developers>\n\n  \x3c!--代码贡献者列表--\x3e\n   <contributors>\n    <contributor>\n      \x3c!--标签内容和<developer>相同--\x3e\n    </contributor>\n  </contributors>\n\n  \x3c!-- 项目信息 end --\x3e\n\n  ...\n</project>\n\n\n这部分标签都非常简单，基本都能做到顾名思义，且都属于可有可无的标签，所以这里仅简单介绍一下：\n\n * name - 项目完整名称\n\n * description - 项目描述\n\n * url - 一般为项目仓库的 host\n\n * inceptionyear - 开发年份\n\n * licenses - 开源协议\n\n * organization - 项目所属组织信息\n\n * developers - 项目开发者列表\n\n * contributors - 项目贡献者列表，<contributor> 的子标签和 <developer> 的完全相同。\n\n\n# 环境配置\n\n\n# issuemanagement\n\n这定义了所使用的缺陷跟踪系统（bugzilla，testtrack，clearquest 等）。虽然没有什么可以阻止插件使用这些信息的东西，但它主要用于生成项目文档。\n\n<project xmlns="http://maven.apache.org/pom/4.0.0"\n  xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n  xsi:schemalocation="http://maven.apache.org/pom/4.0.0\n                      https://maven.apache.org/xsd/maven-4.0.0.xsd">\n  ...\n  <issuemanagement>\n    <system>bugzilla</system>\n    <url>http://127.0.0.1/bugzilla/</url>\n  </issuemanagement>\n  ...\n</project>\n\n\n\n# cimanagement\n\nci 构建系统配置，主要是指定通知机制以及被通知的邮箱。\n\n<project xmlns="http://maven.apache.org/pom/4.0.0"\n  xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n  xsi:schemalocation="http://maven.apache.org/pom/4.0.0\n                      https://maven.apache.org/xsd/maven-4.0.0.xsd">\n  ...\n  <cimanagement>\n    <system>continuum</system>\n    <url>http://127.0.0.1:8080/continuum</url>\n    <notifiers>\n      <notifier>\n        <type>mail</type>\n        <sendonerror>true</sendonerror>\n        <sendonfailure>true</sendonfailure>\n        <sendonsuccess>false</sendonsuccess>\n        <sendonwarning>false</sendonwarning>\n        <configuration><address>continuum@127.0.0.1</address></configuration>\n      </notifier>\n    </notifiers>\n  </cimanagement>\n  ...\n</project>\n\n\n\n# mailinglists\n\n邮件列表\n\n<project xmlns="http://maven.apache.org/pom/4.0.0"\n  xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n  xsi:schemalocation="http://maven.apache.org/pom/4.0.0\n                      https://maven.apache.org/xsd/maven-4.0.0.xsd">\n  ...\n  <mailinglists>\n    <mailinglist>\n      <name>user list</name>\n      <subscribe>user-subscribe@127.0.0.1</subscribe>\n      <unsubscribe>user-unsubscribe@127.0.0.1</unsubscribe>\n      <post>user@127.0.0.1</post>\n      <archive>http://127.0.0.1/user/</archive>\n      <otherarchives>\n        <otherarchive>http://base.google.com/base/1/127.0.0.1</otherarchive>\n      </otherarchives>\n    </mailinglist>\n  </mailinglists>\n  ...\n</project>\n\n\n\n# scm\n\nscm（软件配置管理，也称为源代码/控制管理或简洁的版本控制）。常见的 scm 有 svn 和 git 。\n\n<project xmlns="http://maven.apache.org/pom/4.0.0"\n  xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n  xsi:schemalocation="http://maven.apache.org/pom/4.0.0\n                      https://maven.apache.org/xsd/maven-4.0.0.xsd">\n  ...\n  <scm>\n    <connection>scm:svn:http://127.0.0.1/svn/my-project</connection>\n    <developerconnection>scm:svn:https://127.0.0.1/svn/my-project</developerconnection>\n    <tag>head</tag>\n    <url>http://127.0.0.1/websvn/my-project</url>\n  </scm>\n  ...\n</project>\n\n\n\n# prerequisites\n\npom 执行的预设条件。\n\n<project xmlns="http://maven.apache.org/pom/4.0.0"\n  xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n  xsi:schemalocation="http://maven.apache.org/pom/4.0.0\n                      https://maven.apache.org/xsd/maven-4.0.0.xsd">\n  ...\n  <prerequisites>\n    <maven>2.0.6</maven>\n  </prerequisites>\n  ...\n</project>\n\n\n\n# repositories\n\nrepositories 是遵循 maven 存储库目录布局的 artifacts 集合。默认的 maven 中央存储库位于https://repo.maven.apache.org/maven2/上。\n\n<project xmlns="http://maven.apache.org/pom/4.0.0"\n  xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n  xsi:schemalocation="http://maven.apache.org/pom/4.0.0\n                      https://maven.apache.org/xsd/maven-4.0.0.xsd">\n  ...\n  <repositories>\n    <repository>\n      <releases>\n        <enabled>false</enabled>\n        <updatepolicy>always</updatepolicy>\n        <checksumpolicy>warn</checksumpolicy>\n      </releases>\n      <snapshots>\n        <enabled>true</enabled>\n        <updatepolicy>never</updatepolicy>\n        <checksumpolicy>fail</checksumpolicy>\n      </snapshots>\n      <id>codehaussnapshots</id>\n      <name>codehaus snapshots</name>\n      <url>http://snapshots.maven.codehaus.org/maven2</url>\n      <layout>default</layout>\n    </repository>\n  </repositories>\n  <pluginrepositories>\n    ...\n  </pluginrepositories>\n  ...\n</project>\n\n\n\n# pluginrepositories\n\n与 repositories 差不多。\n\n<project xmlns="http://maven.apache.org/pom/4.0.0"\n  xmlns:xsi="http://www.w3.org/001/xmlschema-instance"\n  xsi:schemalocation="http://maven.apache.org/pom/4.0.0\n                      https://maven.apache.org/xsd/maven-4.0.0.xsd">\n  ...\n  <distributionmanagement>\n    ...\n    <downloadurl>http://mojo.codehaus.org/my-project</downloadurl>\n    <status>deployed</status>\n  </distributionmanagement>\n  ...\n</project>\n\n\n\n# distributionmanagement\n\n它管理在整个构建过程中生成的 artifact 和支持文件的分布。从最后的元素开始：\n\n<project xmlns="http://maven.apache.org/pom/4.0.0"\n  xmlns:xsi="http://www.w3.org/001/xmlschema-instance"\n  xsi:schemalocation="http://maven.apache.org/pom/4.0.0\n                      https://maven.apache.org/xsd/maven-4.0.0.xsd">\n  ...\n  <distributionmanagement>\n    ...\n    <downloadurl>http://mojo.codehaus.org/my-project</downloadurl>\n    <status>deployed</status>\n  </distributionmanagement>\n  ...\n</project>\n\n\n * repository - 与 repositories 相似\n\n * site - 站点信息\n\n * relocation - 项目迁移位置\n\n\n# profiles\n\nactivation 是一个 profile 的关键。配置文件的功能来自于在某些情况下仅修改基本 pom 的功能。这些情况通过 activation 元素指定。\n\n<project xmlns="http://maven.apache.org/pom/4.0.0"\n  xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n  xsi:schemalocation="http://maven.apache.org/pom/4.0.0\n                      https://maven.apache.org/xsd/maven-4.0.0.xsd">\n  ...\n  <profiles>\n    <profile>\n      <id>test</id>\n      <activation>\n        <activebydefault>false</activebydefault>\n        <jdk>1.5</jdk>\n        <os>\n          <name>windows xp</name>\n          <family>windows</family>\n          <arch>x86</arch>\n          <version>5.1.2600</version>\n        </os>\n        <property>\n          <name>sparrow-type</name>\n          <value>african</value>\n        </property>\n        <file>\n          <exists>${basedir}/file2.properties</exists>\n          <missing>${basedir}/file1.properties</missing>\n        </file>\n      </activation>\n      ...\n    </profile>\n  </profiles>\n</project>\n\n\n\n# 参考资料\n\n * maven 官方文档之 pom',charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Maven 快速入门",frontmatter:{title:"Maven 快速入门",date:"2020-02-07T23:04:47.000Z",order:1,categories:["Java","软件","构建","Maven"],tags:["Java","构建","Maven"],permalink:"/pages/e5b79f/"},regularPath:"/01.Java/11.%E8%BD%AF%E4%BB%B6/01.%E6%9E%84%E5%BB%BA/01.Maven/01.Maven%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8.html",relativePath:"01.Java/11.软件/01.构建/01.Maven/01.Maven快速入门.md",key:"v-7a43a3c8",path:"/pages/e5b79f/",headers:[{level:2,title:"Maven 简介",slug:"maven-简介",normalizedTitle:"maven 简介",charIndex:17},{level:3,title:"Maven 是什么",slug:"maven-是什么",normalizedTitle:"maven 是什么",charIndex:30},{level:3,title:"Maven 的生命周期",slug:"maven-的生命周期",normalizedTitle:"maven 的生命周期",charIndex:448},{level:3,title:"Maven 的标准工程结构",slug:"maven-的标准工程结构",normalizedTitle:"maven 的标准工程结构",charIndex:704},{level:3,title:'Maven 的"约定优于配置"',slug:"maven-的-约定优于配置",normalizedTitle:"maven 的&quot;约定优于配置&quot;",charIndex:null},{level:3,title:"Maven 的版本规范",slug:"maven-的版本规范",normalizedTitle:"maven 的版本规范",charIndex:1212},{level:2,title:"Maven 安装",slug:"maven-安装",normalizedTitle:"maven 安装",charIndex:2183},{level:3,title:"环境准备",slug:"环境准备",normalizedTitle:"环境准备",charIndex:2304},{level:3,title:"下载解压",slug:"下载解压",normalizedTitle:"下载解压",charIndex:2542},{level:3,title:"环境变量",slug:"环境变量",normalizedTitle:"环境变量",charIndex:2686},{level:4,title:"配置 Unix 系统环境变量",slug:"配置-unix-系统环境变量",normalizedTitle:"配置 unix 系统环境变量",charIndex:2729},{level:4,title:"配置 Windows 系统环境变量",slug:"配置-windows-系统环境变量",normalizedTitle:"配置 windows 系统环境变量",charIndex:2906},{level:3,title:"检测安装成功",slug:"检测安装成功",normalizedTitle:"检测安装成功",charIndex:2994},{level:3,title:"Maven 配置文件",slug:"maven-配置文件",normalizedTitle:"maven 配置文件",charIndex:3419},{level:2,title:"快速入门",slug:"快速入门",normalizedTitle:"快速入门",charIndex:8},{level:3,title:"创建 Maven 工程",slug:"创建-maven-工程",normalizedTitle:"创建 maven 工程",charIndex:3925},{level:4,title:"初始化工程",slug:"初始化工程",normalizedTitle:"初始化工程",charIndex:3940},{level:4,title:"POM 配置",slug:"pom-配置",normalizedTitle:"pom 配置",charIndex:4580},{level:4,title:"构建项目",slug:"构建项目",normalizedTitle:"构建项目",charIndex:5361},{level:3,title:"在 Intellij 中创建 Maven 工程",slug:"在-intellij-中创建-maven-工程",normalizedTitle:"在 intellij 中创建 maven 工程",charIndex:5940},{level:3,title:"在 Eclipse 中创建 Maven 工程",slug:"在-eclipse-中创建-maven-工程",normalizedTitle:"在 eclipse 中创建 maven 工程",charIndex:6117},{level:2,title:"使用说明",slug:"使用说明",normalizedTitle:"使用说明",charIndex:6884},{level:3,title:"如何添加依赖",slug:"如何添加依赖",normalizedTitle:"如何添加依赖",charIndex:6893},{level:3,title:"如何寻找 jar 包",slug:"如何寻找-jar-包",normalizedTitle:"如何寻找 jar 包",charIndex:8222},{level:3,title:"如何使用 Maven 插件(Plugin)",slug:"如何使用-maven-插件-plugin",normalizedTitle:"如何使用 maven 插件(plugin)",charIndex:8350},{level:3,title:"如何一次编译多个工程",slug:"如何一次编译多个工程",normalizedTitle:"如何一次编译多个工程",charIndex:8761},{level:3,title:"常用 Maven 插件",slug:"常用-maven-插件",normalizedTitle:"常用 maven 插件",charIndex:9542},{level:4,title:"maven-antrun-plugin",slug:"maven-antrun-plugin",normalizedTitle:"maven-antrun-plugin",charIndex:9602},{level:4,title:"maven-archetype-plugin",slug:"maven-archetype-plugin",normalizedTitle:"maven-archetype-plugin",charIndex:9854},{level:4,title:"maven-assembly-plugin",slug:"maven-assembly-plugin",normalizedTitle:"maven-assembly-plugin",charIndex:10211},{level:4,title:"maven-dependency-plugin",slug:"maven-dependency-plugin",normalizedTitle:"maven-dependency-plugin",charIndex:10531},{level:4,title:"maven-enforcer-plugin",slug:"maven-enforcer-plugin",normalizedTitle:"maven-enforcer-plugin",charIndex:10822},{level:4,title:"maven-help-plugin",slug:"maven-help-plugin",normalizedTitle:"maven-help-plugin",charIndex:11211},{level:4,title:"maven-release-plugin",slug:"maven-release-plugin",normalizedTitle:"maven-release-plugin",charIndex:11643},{level:4,title:"maven-resources-plugin",slug:"maven-resources-plugin",normalizedTitle:"maven-resources-plugin",charIndex:12020},{level:4,title:"maven-surefire-plugin",slug:"maven-surefire-plugin",normalizedTitle:"maven-surefire-plugin",charIndex:12391},{level:4,title:"build-helper-maven-plugin",slug:"build-helper-maven-plugin",normalizedTitle:"build-helper-maven-plugin",charIndex:12747},{level:4,title:"exec-maven-plugin",slug:"exec-maven-plugin",normalizedTitle:"exec-maven-plugin",charIndex:13167},{level:4,title:"jetty-maven-plugin",slug:"jetty-maven-plugin",normalizedTitle:"jetty-maven-plugin",charIndex:13532},{level:4,title:"versions-maven-plugin",slug:"versions-maven-plugin",normalizedTitle:"versions-maven-plugin",charIndex:14047},{level:3,title:"Maven 命令",slug:"maven-命令",normalizedTitle:"maven 命令",charIndex:6810},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:16004}],headersStr:'Maven 简介 Maven 是什么 Maven 的生命周期 Maven 的标准工程结构 Maven 的"约定优于配置" Maven 的版本规范 Maven 安装 环境准备 下载解压 环境变量 配置 Unix 系统环境变量 配置 Windows 系统环境变量 检测安装成功 Maven 配置文件 快速入门 创建 Maven 工程 初始化工程 POM 配置 构建项目 在 Intellij 中创建 Maven 工程 在 Eclipse 中创建 Maven 工程 使用说明 如何添加依赖 如何寻找 jar 包 如何使用 Maven 插件(Plugin) 如何一次编译多个工程 常用 Maven 插件 maven-antrun-plugin maven-archetype-plugin maven-assembly-plugin maven-dependency-plugin maven-enforcer-plugin maven-help-plugin maven-release-plugin maven-resources-plugin maven-surefire-plugin build-helper-maven-plugin exec-maven-plugin jetty-maven-plugin versions-maven-plugin Maven 命令 参考资料',content:'# Maven 快速入门\n\n\n# Maven 简介\n\n\n# Maven 是什么\n\nMaven 是一个项目管理工具。它负责管理项目开发过程中的几乎所有的东西。\n\n * 版本 - maven 有自己的版本定义和规则。\n * 构建 - maven 支持许多种的应用程序类型，对于每一种支持的应用程序类型都定义好了一组构建规则和工具集。\n * 输出物管理 - maven 可以管理项目构建的产物，并将其加入到用户库中。这个功能可以用于项目组和其他部门之间的交付行为。\n * 依赖关系 - maven 对依赖关系的特性进行细致的分析和划分，避免开发过程中的依赖混乱和相互污染行为\n * 文档和构建结果 - maven 的 site 命令支持各种文档信息的发布，包括构建过程的各种输出，javadoc，产品文档等。\n * 项目关系 - 一个大型的项目通常有几个小项目或者模块组成，用 maven 可以很方便地管理。\n * 移植性管理 - maven 可以针对不同的开发场景，输出不同种类的输出结果。\n\n\n# Maven 的生命周期\n\nmaven 把项目的构建划分为不同的生命周期(lifecycle)。粗略一点的话，它这个过程(phase)包括：编译、测试、打包、集成测试、验证、部署。maven 中所有的执行动作(goal)都需要指明自己在这个过程中的执行位置，然后 maven 执行的时候，就依照过程的发展依次调用这些 goal 进行各种处理。\n\n这个也是 maven 的一个基本调度机制。一般来说，位置稍后的过程都会依赖于之前的过程。当然，maven 同样提供了配置文件，可以依照用户要求，跳过某些阶段。\n\n\n# Maven 的标准工程结构\n\nMaven 的标准工程结构如下：\n\n|-- pom.xml(maven的核心配置文件)\n|-- src\n|-- main\n  |-- java(java源代码目录)\n  |-- resources(资源文件目录)\n|-- test\n    |-- java(单元测试代码目录)\n|-- target(输出目录，所有的输出物都存放在这个目录下)\n    |-- classes(编译后的class文件存放处)\n\n\n\n# Maven 的"约定优于配置"\n\n所谓的"约定优于配置"，在 maven 中并不是完全不可以修改的，他们只是一些配置的默认值而已。但是除非必要，并不需要去修改那些约定内容。maven 默认的文件存放结构如下：\n\n每一个阶段的任务都知道怎么正确完成自己的工作，比如 compile 任务就知道从 src/main/java 下编译所有的 java 文件，并把它的输出 class 文件存放到 target/classes 中。\n\n对 maven 来说，采用"约定优于配置"的策略可以减少修改配置的工作量，也可以降低学习成本，更重要的是，给项目引入了统一的规范。\n\n\n# Maven 的版本规范\n\nmaven 使用如下几个要素来唯一定位某一个输出物：\n\n * groupId - 团体、组织的标识符。团体标识的约定是，它以创建这个项目的组织名称的逆向域名(reverse domain name)开头。一般对应着 JAVA 的包的结构。例如 org.apache\n * artifactId - 单独项目的唯一标识符。比如我们的 tomcat, commons 等。不要在 artifactId 中包含点号(.)。\n * version - 一个项目的特定版本。\n * packaging - 项目的类型，默认是 jar，描述了项目打包后的输出。类型为 jar 的项目产生一个 JAR 文件，类型为 war 的项目产生一个 web 应用。\n\n例如：想在 maven 工程中引入 4.12 版本的 junit 包，添加如下依赖即可。\n\n<dependency>\n  <groupId>junit</groupId>\n  <artifactId>junit</artifactId>\n  <version>4.12</version>\n  <scope>compile</scope>\n</dependency>\n\n\nmaven 有自己的版本规范，一般是如下定义 <major version>、<minor version>、<incremental version>-<qualifier> ，比如 1.2.3-beta-01。要说明的是，maven 自己判断版本的算法是 major,minor,incremental 部分用数字比 较，qualifier 部分用字符串比较，所以要小心 alpha-2 和 alpha-15 的比较关系，最好用 alpha-02 的格式。\n\nmaven 在版本管理时候可以使用几个特殊的字符串 SNAPSHOT，LATEST，RELEASE。比如"1.0-SNAPSHOT"。各个部分的含义和处理逻辑如下说明：\n\n * SNAPSHOT - 这个版本一般用于开发过程中，表示不稳定的版本。\n * LATEST - 指某个特定构件的最新发布，这个发布可能是一个发布版，也可能是一个 snapshot 版，具体看哪个时间最后。\n * RELEASE - 指最后一个发布版。\n\n\n# Maven 安装\n\n> Linux 环境安装可以使用我写一键安装脚本：https://github.com/dunwu/linux-tutorial/tree/master/codes/linux/ops/service/maven\n\n\n# 环境准备\n\nMaven 依赖于 Java，所以本地必须安装 JDK。\n\n打开控制台，执行 java -version 确认本地已安装 JDK。\n\n$ java -version\njava version "1.8.0_191"\nJava(TM) SE Runtime Environment (build 1.8.0_191-b12)\nJava HotSpot(TM) 64-Bit Server VM (build 25.191-b12, mixed mode)\n\n\n\n# 下载解压\n\n进入 官网下载地址，选择合适版本，下载并解压到本地。解压命令如下：\n\n# 以下解压命令分别针对 zip 包和 tar 包\nunzip apache-maven-3.6.3-bin.zip\ntar xzvf apache-maven-3.6.3-bin.tar.gz\n\n\n\n# 环境变量\n\n添加环境变量 MAVEN_HOME，值为 Maven 的安装路径。\n\n# 配置 Unix 系统环境变量\n\n输入 vi /etc/profile ，添加环境变量如下：\n\n# MAVEN 的根路径\nexport MAVEN_HOME=/opt/maven/apache-maven-3.5.2\nexport PATH=$MAVEN_HOME/bin:$PATH\n\n\n执行 source /etc/profile ，立即生效。\n\n# 配置 Windows 系统环境变量\n\n右键 "计算机"，选择 "属性"，之后点击 "高级系统设置"，点击"环境变量"，来设置环境变量，有以下系统变量需要配置：\n\n\n\n\n\n\n# 检测安装成功\n\n检验是否安装成功，执行 mvn -v 命令，如果输出类似下面的 maven 版本信息，说明配置成功。\n\n$ mvn -v\nApache Maven 3.5.4 (1edded0938998edf8bf061f1ceb3cfdeccf443fe; 2018-06-18T02:33:14+08:00)\nMaven home: /opt/maven/apache-maven-3.5.4\nJava version: 1.8.0_191, vendor: Oracle Corporation, runtime: /mnt/disk1/jdk1.8.0_191/jre\nDefault locale: zh_CN, platform encoding: UTF-8\nOS name: "linux", version: "3.10.0-327.el7.x86_64", arch: "amd64", family: "unix"\n\n\n\n# Maven 配置文件\n\nsetting.xml 文件是 Maven 的默认配置文件，其默认路径为：<Maven 安装目录>/conf/settings.xml。\n\n如果需要修改 Maven 配置，直接修改 setting.xml 并保持即可。\n\n例如：想要修改本地仓库位置可以按如下配置，这样，所有通过 Maven 下载打包的 jar 包都会存储在 D:\\maven\\repo 路径下。\n\n<settings xmlns="http://maven.apache.org/SETTINGS/1.1.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n  xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.1.0 http://maven.apache.org/xsd/settings-1.1.0.xsd">\n  <localRepository>D:\\maven\\repo<localRepository/>\n  \x3c!-- 略 --\x3e\n</settings>\n\n\n\n# 快速入门\n\n\n# 创建 Maven 工程\n\n# 初始化工程\n\n执行指令：\n\nmvn archetype:generate -DgroupId=com.mycompany.app -DartifactId=my-app -DarchetypeArtifactId=maven-archetype-quickstart -DarchetypeVersion=1.4 -DinteractiveMode=false\n\n\n会在当前路径新建一个名为 my-app 的 Maven 工程，其目录结构如下：\n\nmy-app\n|-- pom.xml\n`-- src\n    |-- main\n    |   `-- java\n    |       `-- com\n    |           `-- mycompany\n    |               `-- app\n    |                   `-- App.java\n    `-- test\n        `-- java\n            `-- com\n                `-- mycompany\n                    `-- app\n                        `-- AppTest.java\n\n\n其中， src/main/java 目录包含 java 源码， src/test/java 目录包含 java 测试源码，而 pom.xml 文件是 maven 工程的配置文件。\n\n# POM 配置\n\npom.xml 是 maven 工程的配置文件，它描述了 maven 工程的构建方式，其配置信息是很复杂的，这里给一个最简单的配置示例：\n\nproject xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\n  <modelVersion>4.0.0</modelVersion>\n\n  <groupId>com.mycompany.app</groupId>\n  <artifactId>my-app</artifactId>\n  <version>1.0-SNAPSHOT</version>\n\n  <properties>\n    <maven.compiler.source>1.7</maven.compiler.source>\n    <maven.compiler.target>1.7</maven.compiler.target>\n  </properties>\n\n  <dependencies>\n    <dependency>\n      <groupId>junit</groupId>\n      <artifactId>junit</artifactId>\n      <version>4.12</version>\n      <scope>test</scope>\n    </dependency>\n  </dependencies>\n</project>\n\n\n# 构建项目\n\n执行以下命令，即可构建项目：\n\nmvn clean package -Dmaven.test.skip=true -B -U\n\n\n构建成功后，会输出类似下面的信息：\n\n...\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time:  2.953 s\n[INFO] Finished at: 2019-11-24T13:05:10+01:00\n[INFO] ------------------------------------------------------------------------\n\n\n这时，在当前路径下会产生一个 target 目录，其中包含了构建的输出物，如：jar 包、class 文件等。\n\n这时，我们可以执行以下命令启动 jar 包：\n\njava -cp target/my-app-1.0-SNAPSHOT.jar com.mycompany.app.App\n\n\n\n# 在 Intellij 中创建 Maven 工程\n\n（1）创建 Maven 工程\n\n依次点击 File -> New -> Project 打开创建工程对话框，选择 Maven 工程。\n\n\n\n（2）输入项目信息\n\n\n\n（3）点击 Intellij 侧边栏中的 Maven 工具界面，有几个可以直接使用的 maven 命令，可以帮助你进行构建。\n\n\n\n\n# 在 Eclipse 中创建 Maven 工程\n\n（1）Maven 插件\n\n在 Eclipse 中创建 Maven 工程，需要安装 Maven 插件。\n\n一般较新版本的 Eclipse 都会带有 Maven 插件，如果你的 Eclipse 中已经有 Maven 插件，可以跳过这一步骤。\n\n点击 Help -> Eclipse Marketplace，搜索 maven 关键字，选择安装红框对应的 Maven 插件。\n\n\n\n（2）Maven 环境配置\n\n点击 Window -> Preferences\n\n如下图所示，配置 settings.xml 文件的位置\n\n\n\n（3）创建 Maven 工程\n\nFile -> New -> Maven Project -> Next，在接下来的窗口中会看到一大堆的项目模板，选择合适的模板。\n\n接下来设置项目的参数，如下：\n\n\n\ngroupId是项目组织唯一的标识符，实际对应 JAVA 的包的结构，是 main 目录里 java 的目录结构。\n\nartifactId就是项目的唯一的标识符，实际对应项目的名称，就是项目根目录的名称。\n\n点击 Finish，Eclipse 会创建一个 Maven 工程。\n\n（4）使用 Maven 进行构建\n\nEclipse 中构建方式：\n\n在 Elipse 项目上右击 -> Run As 就能看到很多 Maven 操作。这些操作和 maven 命令是等效的。例如 Maven clean，等同于 mvn clean 命令。\n\n\n\n你也可以点击 Maven build，输入组合命令，并保存下来。如下图：\n\n\n\nMaven 命令构建方式：\n\n当然，你也可以直接使用 maven 命令进行构建。\n\n进入工程所在目录，输入 maven 命令就可以了。\n\n\n\n\n# 使用说明\n\n\n# 如何添加依赖\n\n在 Maven 工程中添加依赖 jar 包，很简单，只要在 POM 文件中引入对应的<dependency>标签即可。\n\n参考下例：\n\n<project xmlns="http://maven.apache.org/POM/4.0.0"xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\n\n  <modelVersion>4.0.0</modelVersion>\n  <groupId>com.zp.maven</groupId>\n  <artifactId>MavenDemo</artifactId>\n  <version>0.0.1-SNAPSHOT</version>\n  <packaging>jar</packaging>\n  <name>MavenDemo</name>\n  <url>http://maven.apache.org</url>\n\n  <properties>\n    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n    <junit.version>3.8.1</junit.version>\n  </properties>\n\n  <dependencies>\n    <dependency>\n      <groupId>junit</groupId>\n      <artifactId>junit</artifactId>\n      <version>${junit.version}</version>\n      <scope>test</scope>\n    </dependency>\n\n    <dependency>\n      <groupId>log4j</groupId>\n      <artifactId>log4j</artifactId>\n      <version>1.2.12</version>\n      <scope>compile</scope>\n    </dependency>\n  </dependencies>\n</project>\n\n\n<dependency> 标签最常用的四个属性标签：\n\n * <groupId> - 项目组织唯一的标识符，实际对应 JAVA 的包的结构。\n * <artifactId> - 项目唯一的标识符，实际对应项目的名称，就是项目根目录的名称。\n * <version> - jar 包的版本号。可以直接填版本数字，也可以在 properties 标签中设置属性值。\n * <scope> - jar 包的作用范围。可以填写 compile、runtime、test、system 和 provided。用来在编译、测试等场景下选择对应的 classpath。\n\n\n# 如何寻找 jar 包\n\n可以在 http://mvnrepository.com/ 站点搜寻你想要的 jar 包版本\n\n例如，想要使用 log4j，可以找到需要的版本号，然后拷贝对应的 maven 标签信息，将其添加到 pom .xml 文件中。\n\n\n# 如何使用 Maven 插件(Plugin)\n\n要添加 Maven 插件，可以在 pom.xml 文件中添加 <plugin> 标签。\n\n<build>\n  <plugins>\n    <plugin>\n      <groupId>org.apache.maven.plugins</groupId>\n      <artifactId>maven-compiler-plugin</artifactId>\n      <version>3.3</version>\n      <configuration>\n        <source>1.7</source>\n        <target>1.7</target>\n      </configuration>\n    </plugin>\n  </plugins>\n</build>\n\n\n<configuration> 标签用来配置插件的一些使用参数。\n\n\n# 如何一次编译多个工程\n\n假设要创建一个父 maven 工程，它有两个子工程：my-app 和 my-webapp：\n\n+- pom.xml\n+- my-app\n| +- pom.xml\n| +- src\n|   +- main\n|     +- java\n+- my-webapp\n| +- pom.xml\n| +- src\n|   +- main\n|     +- webapp\n\n\napp 工程的 pom.xml 如下，重点在于在 modules 中引入两个子 module：\n\n<project xmlns="http://maven.apache.org/POM/4.0.0"\n  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0\n                      http://maven.apache.org/xsd/maven-4.0.0.xsd">\n  <modelVersion>4.0.0</modelVersion>\n\n  <groupId>com.mycompany.app</groupId>\n  <artifactId>app</artifactId>\n  <version>1.0-SNAPSHOT</version>\n  <packaging>pom</packaging>\n\n  <modules>\n    <module>my-app</module>\n    <module>my-webapp</module>\n  </modules>\n</project>\n\n\n选择编译 XXX 时，会依次对它的所有 Module 执行相同操作。\n\n\n# 常用 Maven 插件\n\n> 更多详情请参考：https://maven.apache.org/plugins/\n\n# maven-antrun-plugin\n\nmaven-antrun-plugin 能让用户在 Maven 项目中运行 Ant 任务。用户可以直接在该插件的配置以 Ant 的方式编写 Target， 然后交给该插件的 run 目标去执行。在一些由 Ant 往 Maven 迁移的项目中，该插件尤其有用。此外当你发现需要编写一些自定义程度很高的任务，同时又觉 得 Maven 不够灵活时，也可以以 Ant 的方式实现之。maven-antrun-plugin 的 run 目标通常与生命周期绑定运行。\n\n# maven-archetype-plugin\n\nArchtype 指项目的骨架，Maven 初学者最开始执行的 Maven 命令可能就是mvn archetype:generate，这实际上就是让 maven-archetype-plugin 生成一个很简单的项目骨架，帮助开发者快速上手。可能也有人看到一些文档写了mvn archetype:create， 但实际上 create 目标已经被弃用了，取而代之的是 generate 目标，该目标使用交互式的方式提示用户输入必要的信息以创建项目，体验更好。 maven-archetype-plugin 还有一些其他目标帮助用户自己定义项目原型，例如你由一个产品需要交付给很多客户进行二次开发，你就可以为 他们提供一个 Archtype，帮助他们快速上手。\n\n# maven-assembly-plugin\n\nmaven-assembly-plugin 的用途是将项目打包，该包可能包含了项目的可执行文件、源代码、readme、平台脚本等等。 maven-assembly-plugin 支持各种主流的格式如 zip、tar.gz、jar 和 war 等，具体打包哪些文件是高度可控的，例如用户可以 按文件级别的粒度、文件集级别的粒度、模块级别的粒度、以及依赖级别的粒度控制打包，此外，包含和排除配置也是支持的。maven-assembly- plugin 要求用户使用一个名为assembly.xml的元数据文件来表述打包，它的 single 目标可以直接在命令行调用，也可以被绑定至生命周期。\n\n# maven-dependency-plugin\n\nmaven-dependency-plugin 最大的用途是帮助分析项目依赖，dependency:list能够列出项目最终解析到的依赖列表，dependency:tree能进一步的描绘项目依赖树，dependency:analyze可以告诉你项目依赖潜在的问题，如果你有直接使用到的却未声明的依赖，该目标就会发出警告。maven-dependency-plugin 还有很多目标帮助你操作依赖文件，例如dependency:copy-dependencies能将项目依赖从本地 Maven 仓库复制到某个特定的文件夹下面。\n\n# maven-enforcer-plugin\n\n在一个稍大一点的组织或团队中，你无法保证所有成员都熟悉 Maven，那他们做一些比较愚蠢的事情就会变得很正常，例如给项目引入了外部的 SNAPSHOT 依赖而导致构建不稳定，使用了一个与大家不一致的 Maven 版本而经常抱怨构建出现诡异问题。maven-enforcer- plugin 能够帮助你避免之类问题，它允许你创建一系列规则强制大家遵守，包括设定 Java 版本、设定 Maven 版本、禁止某些依赖、禁止 SNAPSHOT 依赖。只要在一个父 POM 配置规则，然后让大家继承，当规则遭到破坏的时候，Maven 就会报错。除了标准的规则之外，你还可以扩展该插 件，编写自己的规则。maven-enforcer-plugin 的 enforce 目标负责检查规则，它默认绑定到生命周期的 validate 阶段。\n\n# maven-help-plugin\n\nmaven-help-plugin 是一个小巧的辅助工具，最简单的help:system可以打印所有可用的环境变量和 Java 系统属性。help:effective-pom和help:effective-settings最 为有用，它们分别打印项目的有效 POM 和有效 settings，有效 POM 是指合并了所有父 POM（包括 Super POM）后的 XML，当你不确定 POM 的某些信息从何而来时，就可以查看有效 POM。有效 settings 同理，特别是当你发现自己配置的 settings.xml 没有生效时，就可以用help:effective-settings来验证。此外，maven-help-plugin 的 describe 目标可以帮助你描述任何一个 Maven 插件的信息，还有 all-profiles 目标和 active-profiles 目标帮助查看项目的 Profile。\n\n# maven-release-plugin\n\nmaven-release-plugin 的用途是帮助自动化项目版本发布，它依赖于 POM 中的 SCM 信息。release:prepare用来准备版本发布，具体的工作包括检查是否有未提交代码、检查是否有 SNAPSHOT 依赖、升级项目的 SNAPSHOT 版本至 RELEASE 版本、为项目打标签等等。release:perform则 是签出标签中的 RELEASE 源码，构建并发布。版本发布是非常琐碎的工作，它涉及了各种检查，而且由于该工作仅仅是偶尔需要，因此手动操作很容易遗漏一 些细节，maven-release-plugin 让该工作变得非常快速简便，不易出错。maven-release-plugin 的各种目标通常直接在 命令行调用，因为版本发布显然不是日常构建生命周期的一部分。\n\n# maven-resources-plugin\n\n为了使项目结构更为清晰，Maven 区别对待 Java 代码文件和资源文件，maven-compiler-plugin 用来编译 Java 代码，maven-resources-plugin 则用来处理资源文件。默认的主资源文件目录是src/main/resources，很多用户会需要添加额外的资源文件目录，这个时候就可以通过配置 maven-resources-plugin 来实现。此外，资源文件过滤也是 Maven 的一大特性，你可以在资源文件中使用*${propertyName}*形式的 Maven 属性，然后配置 maven-resources-plugin 开启对资源文件的过滤，之后就可以针对不同环境通过命令行或者 Profile 传入属性的值，以实现更为灵活的构建。\n\n# maven-surefire-plugin\n\n可能是由于历史的原因，Maven 2.3 中用于执行测试的插件不是 maven-test-plugin，而是 maven-surefire-plugin。其实大部分时间内，只要你的测试 类遵循通用的命令约定（以 Test 结尾、以 TestCase 结尾、或者以 Test 开头），就几乎不用知晓该插件的存在。然而在当你想要跳过测试、排除某些 测试类、或者使用一些 TestNG 特性的时候，了解 maven-surefire-plugin 的一些配置选项就很有用了。例如 mvn test -Dtest=FooTest 这样一条命令的效果是仅运行 FooTest 测试类，这是通过控制 maven-surefire-plugin 的 test 参数实现的。\n\n# build-helper-maven-plugin\n\nMaven 默认只允许指定一个主 Java 代码目录和一个测试 Java 代码目录，虽然这其实是个应当尽量遵守的约定，但偶尔你还是会希望能够指定多个 源码目录（例如为了应对遗留项目），build-helper-maven-plugin 的 add-source 目标就是服务于这个目的，通常它被绑定到 默认生命周期的 generate-sources 阶段以添加额外的源码目录。需要强调的是，这种做法还是不推荐的，因为它破坏了 Maven 的约定，而且可能会遇到其他严格遵守约定的插件工具无法正确识别额外的源码目录。\n\nbuild-helper-maven-plugin 的另一个非常有用的目标是 attach-artifact，使用该目标你可以以 classifier 的形式选取部分项目文件生成附属构件，并同时 install 到本地仓库，也可以 deploy 到远程仓库。\n\n# exec-maven-plugin\n\nexec-maven-plugin 很好理解，顾名思义，它能让你运行任何本地的系统程序，在某些特定情况下，运行一个 Maven 外部的程序可能就是最简单的问题解决方案，这就是exec:exec的 用途，当然，该插件还允许你配置相关的程序运行参数。除了 exec 目标之外，exec-maven-plugin 还提供了一个 java 目标，该目标要求你 提供一个 mainClass 参数，然后它能够利用当前项目的依赖作为 classpath，在同一个 JVM 中运行该 mainClass。有时候，为了简单的 演示一个命令行 Java 程序，你可以在 POM 中配置好 exec-maven-plugin 的相关运行参数，然后直接在命令运行mvn exec:java 以查看运行效果。\n\n# jetty-maven-plugin\n\n在进行 Web 开发的时候，打开浏览器对应用进行手动的测试几乎是无法避免的，这种测试方法通常就是将项目打包成 war 文件，然后部署到 Web 容器 中，再启动容器进行验证，这显然十分耗时。为了帮助开发者节省时间，jetty-maven-plugin 应运而生，它完全兼容 Maven 项目的目录结构，能够周期性地检查源文件，一旦发现变更后自动更新到内置的 Jetty Web 容器中。做一些基本配置后（例如 Web 应用的 contextPath 和自动扫描变更的时间间隔），你只要执行 mvn jetty:run ，然后在 IDE 中修改代码，代码经 IDE 自动编译后产生变更，再由 jetty-maven-plugin 侦测到后更新至 Jetty 容器，这时你就可以直接 测试 Web 页面了。需要注意的是，jetty-maven-plugin 并不是宿主于 Apache 或 Codehaus 的官方插件，因此使用的时候需要额外 的配置settings.xml的 pluginGroups 元素，将 org.mortbay.jetty 这个 pluginGroup 加入。\n\n# versions-maven-plugin\n\n很多 Maven 用户遇到过这样一个问题，当项目包含大量模块的时候，为他们集体更新版本就变成一件烦人的事情，到底有没有自动化工具能帮助完成这件 事情呢？（当然你可以使用 sed 之类的文本操作工具，不过不在本文讨论范围）答案是肯定的，versions-maven- plugin 提供了很多目标帮助你管理 Maven 项目的各种版本信息。例如最常用的，命令 mvn versions:set -DnewVersion=1.1-SNAPSHOT 就能帮助你把所有模块的版本更新到 1.1-SNAPSHOT。该插件还提供了其他一些很有用的目标，display-dependency- updates 能告诉你项目依赖有哪些可用的更新；类似的 display-plugin-updates 能告诉你可用的插件更新；然后 use- latest-versions 能自动帮你将所有依赖升级到最新版本。最后，如果你对所做的更改满意，则可以使用 mvn versions:commit 提交，不满意的话也可以使用 mvn versions:revert 进行撤销。\n\n\n# Maven 命令\n\n常用 maven 命令清单：\n\n生命周期                          阶段描述\nmvn validate                  验证项目是否正确，以及所有为了完整构建必要的信息是否可用\nmvn generate-sources          生成所有需要包含在编译过程中的源代码\nmvn process-sources           处理源代码，比如过滤一些值\nmvn generate-resources        生成所有需要包含在打包过程中的资源文件\nmvn process-resources         复制并处理资源文件至目标目录，准备打包\nmvn compile                   编译项目的源代码\nmvn process-classes           后处理编译生成的文件，例如对 Java 类进行字节码增强（bytecode enhancement）\nmvn generate-test-sources     生成所有包含在测试编译过程中的测试源码\nmvn process-test-sources      处理测试源码，比如过滤一些值\nmvn generate-test-resources   生成测试需要的资源文件\nmvn process-test-resources    复制并处理测试资源文件至测试目标目录\nmvn test-compile              编译测试源码至测试目标目录\nmvn test                      使用合适的单元测试框架运行测试。这些测试应该不需要代码被打包或发布\nmvn prepare-package           在真正的打包之前，执行一些准备打包必要的操作。这通常会产生一个包的展开的处理过的版本（将会在 Maven\n                              2.1+中实现）\nmvn package                   将编译好的代码打包成可分发的格式，如 JAR，WAR，或者 EAR\nmvn pre-integration-test      执行一些在集成测试运行之前需要的动作。如建立集成测试需要的环境\nmvn integration-test          如果有必要的话，处理包并发布至集成测试可以运行的环境\nmvn post-integration-test     执行一些在集成测试运行之后需要的动作。如清理集成测试环境。\nmvn verify                    执行所有检查，验证包是有效的，符合质量规范\nmvn install                   安装包至本地仓库，以备本地的其它项目作为依赖使用\nmvn deploy                    复制最终的包至远程仓库，共享给其它开发人员和项目（通常和一次正式的发布相关）\n\n示例：最常用的 maven 构建命令\n\nmvn clean install -Dmaven.test.skip=true -B -U\n\n\n清理本地输出物，并构建 maven 项目，最后将输出物归档在本地仓库。\n\n> 💡 想了解更多 maven 命令行细节可以参考官方文档：\n> \n>  * Maven 构建生命周期说明\n>  * Maven 命令行参数说明\n\n\n# 参考资料\n\n * Maven Github\n * Maven 官方文档\n * Maven in 5 Minutes\n * Maven Getting Started Guide\n * maven 常见问题问答\n * 常用 Maven 插件介绍',normalizedContent:'# maven 快速入门\n\n\n# maven 简介\n\n\n# maven 是什么\n\nmaven 是一个项目管理工具。它负责管理项目开发过程中的几乎所有的东西。\n\n * 版本 - maven 有自己的版本定义和规则。\n * 构建 - maven 支持许多种的应用程序类型，对于每一种支持的应用程序类型都定义好了一组构建规则和工具集。\n * 输出物管理 - maven 可以管理项目构建的产物，并将其加入到用户库中。这个功能可以用于项目组和其他部门之间的交付行为。\n * 依赖关系 - maven 对依赖关系的特性进行细致的分析和划分，避免开发过程中的依赖混乱和相互污染行为\n * 文档和构建结果 - maven 的 site 命令支持各种文档信息的发布，包括构建过程的各种输出，javadoc，产品文档等。\n * 项目关系 - 一个大型的项目通常有几个小项目或者模块组成，用 maven 可以很方便地管理。\n * 移植性管理 - maven 可以针对不同的开发场景，输出不同种类的输出结果。\n\n\n# maven 的生命周期\n\nmaven 把项目的构建划分为不同的生命周期(lifecycle)。粗略一点的话，它这个过程(phase)包括：编译、测试、打包、集成测试、验证、部署。maven 中所有的执行动作(goal)都需要指明自己在这个过程中的执行位置，然后 maven 执行的时候，就依照过程的发展依次调用这些 goal 进行各种处理。\n\n这个也是 maven 的一个基本调度机制。一般来说，位置稍后的过程都会依赖于之前的过程。当然，maven 同样提供了配置文件，可以依照用户要求，跳过某些阶段。\n\n\n# maven 的标准工程结构\n\nmaven 的标准工程结构如下：\n\n|-- pom.xml(maven的核心配置文件)\n|-- src\n|-- main\n  |-- java(java源代码目录)\n  |-- resources(资源文件目录)\n|-- test\n    |-- java(单元测试代码目录)\n|-- target(输出目录，所有的输出物都存放在这个目录下)\n    |-- classes(编译后的class文件存放处)\n\n\n\n# maven 的"约定优于配置"\n\n所谓的"约定优于配置"，在 maven 中并不是完全不可以修改的，他们只是一些配置的默认值而已。但是除非必要，并不需要去修改那些约定内容。maven 默认的文件存放结构如下：\n\n每一个阶段的任务都知道怎么正确完成自己的工作，比如 compile 任务就知道从 src/main/java 下编译所有的 java 文件，并把它的输出 class 文件存放到 target/classes 中。\n\n对 maven 来说，采用"约定优于配置"的策略可以减少修改配置的工作量，也可以降低学习成本，更重要的是，给项目引入了统一的规范。\n\n\n# maven 的版本规范\n\nmaven 使用如下几个要素来唯一定位某一个输出物：\n\n * groupid - 团体、组织的标识符。团体标识的约定是，它以创建这个项目的组织名称的逆向域名(reverse domain name)开头。一般对应着 java 的包的结构。例如 org.apache\n * artifactid - 单独项目的唯一标识符。比如我们的 tomcat, commons 等。不要在 artifactid 中包含点号(.)。\n * version - 一个项目的特定版本。\n * packaging - 项目的类型，默认是 jar，描述了项目打包后的输出。类型为 jar 的项目产生一个 jar 文件，类型为 war 的项目产生一个 web 应用。\n\n例如：想在 maven 工程中引入 4.12 版本的 junit 包，添加如下依赖即可。\n\n<dependency>\n  <groupid>junit</groupid>\n  <artifactid>junit</artifactid>\n  <version>4.12</version>\n  <scope>compile</scope>\n</dependency>\n\n\nmaven 有自己的版本规范，一般是如下定义 <major version>、<minor version>、<incremental version>-<qualifier> ，比如 1.2.3-beta-01。要说明的是，maven 自己判断版本的算法是 major,minor,incremental 部分用数字比 较，qualifier 部分用字符串比较，所以要小心 alpha-2 和 alpha-15 的比较关系，最好用 alpha-02 的格式。\n\nmaven 在版本管理时候可以使用几个特殊的字符串 snapshot，latest，release。比如"1.0-snapshot"。各个部分的含义和处理逻辑如下说明：\n\n * snapshot - 这个版本一般用于开发过程中，表示不稳定的版本。\n * latest - 指某个特定构件的最新发布，这个发布可能是一个发布版，也可能是一个 snapshot 版，具体看哪个时间最后。\n * release - 指最后一个发布版。\n\n\n# maven 安装\n\n> linux 环境安装可以使用我写一键安装脚本：https://github.com/dunwu/linux-tutorial/tree/master/codes/linux/ops/service/maven\n\n\n# 环境准备\n\nmaven 依赖于 java，所以本地必须安装 jdk。\n\n打开控制台，执行 java -version 确认本地已安装 jdk。\n\n$ java -version\njava version "1.8.0_191"\njava(tm) se runtime environment (build 1.8.0_191-b12)\njava hotspot(tm) 64-bit server vm (build 25.191-b12, mixed mode)\n\n\n\n# 下载解压\n\n进入 官网下载地址，选择合适版本，下载并解压到本地。解压命令如下：\n\n# 以下解压命令分别针对 zip 包和 tar 包\nunzip apache-maven-3.6.3-bin.zip\ntar xzvf apache-maven-3.6.3-bin.tar.gz\n\n\n\n# 环境变量\n\n添加环境变量 maven_home，值为 maven 的安装路径。\n\n# 配置 unix 系统环境变量\n\n输入 vi /etc/profile ，添加环境变量如下：\n\n# maven 的根路径\nexport maven_home=/opt/maven/apache-maven-3.5.2\nexport path=$maven_home/bin:$path\n\n\n执行 source /etc/profile ，立即生效。\n\n# 配置 windows 系统环境变量\n\n右键 "计算机"，选择 "属性"，之后点击 "高级系统设置"，点击"环境变量"，来设置环境变量，有以下系统变量需要配置：\n\n\n\n\n\n\n# 检测安装成功\n\n检验是否安装成功，执行 mvn -v 命令，如果输出类似下面的 maven 版本信息，说明配置成功。\n\n$ mvn -v\napache maven 3.5.4 (1edded0938998edf8bf061f1ceb3cfdeccf443fe; 2018-06-18t02:33:14+08:00)\nmaven home: /opt/maven/apache-maven-3.5.4\njava version: 1.8.0_191, vendor: oracle corporation, runtime: /mnt/disk1/jdk1.8.0_191/jre\ndefault locale: zh_cn, platform encoding: utf-8\nos name: "linux", version: "3.10.0-327.el7.x86_64", arch: "amd64", family: "unix"\n\n\n\n# maven 配置文件\n\nsetting.xml 文件是 maven 的默认配置文件，其默认路径为：<maven 安装目录>/conf/settings.xml。\n\n如果需要修改 maven 配置，直接修改 setting.xml 并保持即可。\n\n例如：想要修改本地仓库位置可以按如下配置，这样，所有通过 maven 下载打包的 jar 包都会存储在 d:\\maven\\repo 路径下。\n\n<settings xmlns="http://maven.apache.org/settings/1.1.0" xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n  xsi:schemalocation="http://maven.apache.org/settings/1.1.0 http://maven.apache.org/xsd/settings-1.1.0.xsd">\n  <localrepository>d:\\maven\\repo<localrepository/>\n  \x3c!-- 略 --\x3e\n</settings>\n\n\n\n# 快速入门\n\n\n# 创建 maven 工程\n\n# 初始化工程\n\n执行指令：\n\nmvn archetype:generate -dgroupid=com.mycompany.app -dartifactid=my-app -darchetypeartifactid=maven-archetype-quickstart -darchetypeversion=1.4 -dinteractivemode=false\n\n\n会在当前路径新建一个名为 my-app 的 maven 工程，其目录结构如下：\n\nmy-app\n|-- pom.xml\n`-- src\n    |-- main\n    |   `-- java\n    |       `-- com\n    |           `-- mycompany\n    |               `-- app\n    |                   `-- app.java\n    `-- test\n        `-- java\n            `-- com\n                `-- mycompany\n                    `-- app\n                        `-- apptest.java\n\n\n其中， src/main/java 目录包含 java 源码， src/test/java 目录包含 java 测试源码，而 pom.xml 文件是 maven 工程的配置文件。\n\n# pom 配置\n\npom.xml 是 maven 工程的配置文件，它描述了 maven 工程的构建方式，其配置信息是很复杂的，这里给一个最简单的配置示例：\n\nproject xmlns="http://maven.apache.org/pom/4.0.0" xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n  xsi:schemalocation="http://maven.apache.org/pom/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\n  <modelversion>4.0.0</modelversion>\n\n  <groupid>com.mycompany.app</groupid>\n  <artifactid>my-app</artifactid>\n  <version>1.0-snapshot</version>\n\n  <properties>\n    <maven.compiler.source>1.7</maven.compiler.source>\n    <maven.compiler.target>1.7</maven.compiler.target>\n  </properties>\n\n  <dependencies>\n    <dependency>\n      <groupid>junit</groupid>\n      <artifactid>junit</artifactid>\n      <version>4.12</version>\n      <scope>test</scope>\n    </dependency>\n  </dependencies>\n</project>\n\n\n# 构建项目\n\n执行以下命令，即可构建项目：\n\nmvn clean package -dmaven.test.skip=true -b -u\n\n\n构建成功后，会输出类似下面的信息：\n\n...\n[info] ------------------------------------------------------------------------\n[info] build success\n[info] ------------------------------------------------------------------------\n[info] total time:  2.953 s\n[info] finished at: 2019-11-24t13:05:10+01:00\n[info] ------------------------------------------------------------------------\n\n\n这时，在当前路径下会产生一个 target 目录，其中包含了构建的输出物，如：jar 包、class 文件等。\n\n这时，我们可以执行以下命令启动 jar 包：\n\njava -cp target/my-app-1.0-snapshot.jar com.mycompany.app.app\n\n\n\n# 在 intellij 中创建 maven 工程\n\n（1）创建 maven 工程\n\n依次点击 file -> new -> project 打开创建工程对话框，选择 maven 工程。\n\n\n\n（2）输入项目信息\n\n\n\n（3）点击 intellij 侧边栏中的 maven 工具界面，有几个可以直接使用的 maven 命令，可以帮助你进行构建。\n\n\n\n\n# 在 eclipse 中创建 maven 工程\n\n（1）maven 插件\n\n在 eclipse 中创建 maven 工程，需要安装 maven 插件。\n\n一般较新版本的 eclipse 都会带有 maven 插件，如果你的 eclipse 中已经有 maven 插件，可以跳过这一步骤。\n\n点击 help -> eclipse marketplace，搜索 maven 关键字，选择安装红框对应的 maven 插件。\n\n\n\n（2）maven 环境配置\n\n点击 window -> preferences\n\n如下图所示，配置 settings.xml 文件的位置\n\n\n\n（3）创建 maven 工程\n\nfile -> new -> maven project -> next，在接下来的窗口中会看到一大堆的项目模板，选择合适的模板。\n\n接下来设置项目的参数，如下：\n\n\n\ngroupid是项目组织唯一的标识符，实际对应 java 的包的结构，是 main 目录里 java 的目录结构。\n\nartifactid就是项目的唯一的标识符，实际对应项目的名称，就是项目根目录的名称。\n\n点击 finish，eclipse 会创建一个 maven 工程。\n\n（4）使用 maven 进行构建\n\neclipse 中构建方式：\n\n在 elipse 项目上右击 -> run as 就能看到很多 maven 操作。这些操作和 maven 命令是等效的。例如 maven clean，等同于 mvn clean 命令。\n\n\n\n你也可以点击 maven build，输入组合命令，并保存下来。如下图：\n\n\n\nmaven 命令构建方式：\n\n当然，你也可以直接使用 maven 命令进行构建。\n\n进入工程所在目录，输入 maven 命令就可以了。\n\n\n\n\n# 使用说明\n\n\n# 如何添加依赖\n\n在 maven 工程中添加依赖 jar 包，很简单，只要在 pom 文件中引入对应的<dependency>标签即可。\n\n参考下例：\n\n<project xmlns="http://maven.apache.org/pom/4.0.0"xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n  xsi:schemalocation="http://maven.apache.org/pom/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\n\n  <modelversion>4.0.0</modelversion>\n  <groupid>com.zp.maven</groupid>\n  <artifactid>mavendemo</artifactid>\n  <version>0.0.1-snapshot</version>\n  <packaging>jar</packaging>\n  <name>mavendemo</name>\n  <url>http://maven.apache.org</url>\n\n  <properties>\n    <project.build.sourceencoding>utf-8</project.build.sourceencoding>\n    <junit.version>3.8.1</junit.version>\n  </properties>\n\n  <dependencies>\n    <dependency>\n      <groupid>junit</groupid>\n      <artifactid>junit</artifactid>\n      <version>${junit.version}</version>\n      <scope>test</scope>\n    </dependency>\n\n    <dependency>\n      <groupid>log4j</groupid>\n      <artifactid>log4j</artifactid>\n      <version>1.2.12</version>\n      <scope>compile</scope>\n    </dependency>\n  </dependencies>\n</project>\n\n\n<dependency> 标签最常用的四个属性标签：\n\n * <groupid> - 项目组织唯一的标识符，实际对应 java 的包的结构。\n * <artifactid> - 项目唯一的标识符，实际对应项目的名称，就是项目根目录的名称。\n * <version> - jar 包的版本号。可以直接填版本数字，也可以在 properties 标签中设置属性值。\n * <scope> - jar 包的作用范围。可以填写 compile、runtime、test、system 和 provided。用来在编译、测试等场景下选择对应的 classpath。\n\n\n# 如何寻找 jar 包\n\n可以在 http://mvnrepository.com/ 站点搜寻你想要的 jar 包版本\n\n例如，想要使用 log4j，可以找到需要的版本号，然后拷贝对应的 maven 标签信息，将其添加到 pom .xml 文件中。\n\n\n# 如何使用 maven 插件(plugin)\n\n要添加 maven 插件，可以在 pom.xml 文件中添加 <plugin> 标签。\n\n<build>\n  <plugins>\n    <plugin>\n      <groupid>org.apache.maven.plugins</groupid>\n      <artifactid>maven-compiler-plugin</artifactid>\n      <version>3.3</version>\n      <configuration>\n        <source>1.7</source>\n        <target>1.7</target>\n      </configuration>\n    </plugin>\n  </plugins>\n</build>\n\n\n<configuration> 标签用来配置插件的一些使用参数。\n\n\n# 如何一次编译多个工程\n\n假设要创建一个父 maven 工程，它有两个子工程：my-app 和 my-webapp：\n\n+- pom.xml\n+- my-app\n| +- pom.xml\n| +- src\n|   +- main\n|     +- java\n+- my-webapp\n| +- pom.xml\n| +- src\n|   +- main\n|     +- webapp\n\n\napp 工程的 pom.xml 如下，重点在于在 modules 中引入两个子 module：\n\n<project xmlns="http://maven.apache.org/pom/4.0.0"\n  xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n  xsi:schemalocation="http://maven.apache.org/pom/4.0.0\n                      http://maven.apache.org/xsd/maven-4.0.0.xsd">\n  <modelversion>4.0.0</modelversion>\n\n  <groupid>com.mycompany.app</groupid>\n  <artifactid>app</artifactid>\n  <version>1.0-snapshot</version>\n  <packaging>pom</packaging>\n\n  <modules>\n    <module>my-app</module>\n    <module>my-webapp</module>\n  </modules>\n</project>\n\n\n选择编译 xxx 时，会依次对它的所有 module 执行相同操作。\n\n\n# 常用 maven 插件\n\n> 更多详情请参考：https://maven.apache.org/plugins/\n\n# maven-antrun-plugin\n\nmaven-antrun-plugin 能让用户在 maven 项目中运行 ant 任务。用户可以直接在该插件的配置以 ant 的方式编写 target， 然后交给该插件的 run 目标去执行。在一些由 ant 往 maven 迁移的项目中，该插件尤其有用。此外当你发现需要编写一些自定义程度很高的任务，同时又觉 得 maven 不够灵活时，也可以以 ant 的方式实现之。maven-antrun-plugin 的 run 目标通常与生命周期绑定运行。\n\n# maven-archetype-plugin\n\narchtype 指项目的骨架，maven 初学者最开始执行的 maven 命令可能就是mvn archetype:generate，这实际上就是让 maven-archetype-plugin 生成一个很简单的项目骨架，帮助开发者快速上手。可能也有人看到一些文档写了mvn archetype:create， 但实际上 create 目标已经被弃用了，取而代之的是 generate 目标，该目标使用交互式的方式提示用户输入必要的信息以创建项目，体验更好。 maven-archetype-plugin 还有一些其他目标帮助用户自己定义项目原型，例如你由一个产品需要交付给很多客户进行二次开发，你就可以为 他们提供一个 archtype，帮助他们快速上手。\n\n# maven-assembly-plugin\n\nmaven-assembly-plugin 的用途是将项目打包，该包可能包含了项目的可执行文件、源代码、readme、平台脚本等等。 maven-assembly-plugin 支持各种主流的格式如 zip、tar.gz、jar 和 war 等，具体打包哪些文件是高度可控的，例如用户可以 按文件级别的粒度、文件集级别的粒度、模块级别的粒度、以及依赖级别的粒度控制打包，此外，包含和排除配置也是支持的。maven-assembly- plugin 要求用户使用一个名为assembly.xml的元数据文件来表述打包，它的 single 目标可以直接在命令行调用，也可以被绑定至生命周期。\n\n# maven-dependency-plugin\n\nmaven-dependency-plugin 最大的用途是帮助分析项目依赖，dependency:list能够列出项目最终解析到的依赖列表，dependency:tree能进一步的描绘项目依赖树，dependency:analyze可以告诉你项目依赖潜在的问题，如果你有直接使用到的却未声明的依赖，该目标就会发出警告。maven-dependency-plugin 还有很多目标帮助你操作依赖文件，例如dependency:copy-dependencies能将项目依赖从本地 maven 仓库复制到某个特定的文件夹下面。\n\n# maven-enforcer-plugin\n\n在一个稍大一点的组织或团队中，你无法保证所有成员都熟悉 maven，那他们做一些比较愚蠢的事情就会变得很正常，例如给项目引入了外部的 snapshot 依赖而导致构建不稳定，使用了一个与大家不一致的 maven 版本而经常抱怨构建出现诡异问题。maven-enforcer- plugin 能够帮助你避免之类问题，它允许你创建一系列规则强制大家遵守，包括设定 java 版本、设定 maven 版本、禁止某些依赖、禁止 snapshot 依赖。只要在一个父 pom 配置规则，然后让大家继承，当规则遭到破坏的时候，maven 就会报错。除了标准的规则之外，你还可以扩展该插 件，编写自己的规则。maven-enforcer-plugin 的 enforce 目标负责检查规则，它默认绑定到生命周期的 validate 阶段。\n\n# maven-help-plugin\n\nmaven-help-plugin 是一个小巧的辅助工具，最简单的help:system可以打印所有可用的环境变量和 java 系统属性。help:effective-pom和help:effective-settings最 为有用，它们分别打印项目的有效 pom 和有效 settings，有效 pom 是指合并了所有父 pom（包括 super pom）后的 xml，当你不确定 pom 的某些信息从何而来时，就可以查看有效 pom。有效 settings 同理，特别是当你发现自己配置的 settings.xml 没有生效时，就可以用help:effective-settings来验证。此外，maven-help-plugin 的 describe 目标可以帮助你描述任何一个 maven 插件的信息，还有 all-profiles 目标和 active-profiles 目标帮助查看项目的 profile。\n\n# maven-release-plugin\n\nmaven-release-plugin 的用途是帮助自动化项目版本发布，它依赖于 pom 中的 scm 信息。release:prepare用来准备版本发布，具体的工作包括检查是否有未提交代码、检查是否有 snapshot 依赖、升级项目的 snapshot 版本至 release 版本、为项目打标签等等。release:perform则 是签出标签中的 release 源码，构建并发布。版本发布是非常琐碎的工作，它涉及了各种检查，而且由于该工作仅仅是偶尔需要，因此手动操作很容易遗漏一 些细节，maven-release-plugin 让该工作变得非常快速简便，不易出错。maven-release-plugin 的各种目标通常直接在 命令行调用，因为版本发布显然不是日常构建生命周期的一部分。\n\n# maven-resources-plugin\n\n为了使项目结构更为清晰，maven 区别对待 java 代码文件和资源文件，maven-compiler-plugin 用来编译 java 代码，maven-resources-plugin 则用来处理资源文件。默认的主资源文件目录是src/main/resources，很多用户会需要添加额外的资源文件目录，这个时候就可以通过配置 maven-resources-plugin 来实现。此外，资源文件过滤也是 maven 的一大特性，你可以在资源文件中使用*${propertyname}*形式的 maven 属性，然后配置 maven-resources-plugin 开启对资源文件的过滤，之后就可以针对不同环境通过命令行或者 profile 传入属性的值，以实现更为灵活的构建。\n\n# maven-surefire-plugin\n\n可能是由于历史的原因，maven 2.3 中用于执行测试的插件不是 maven-test-plugin，而是 maven-surefire-plugin。其实大部分时间内，只要你的测试 类遵循通用的命令约定（以 test 结尾、以 testcase 结尾、或者以 test 开头），就几乎不用知晓该插件的存在。然而在当你想要跳过测试、排除某些 测试类、或者使用一些 testng 特性的时候，了解 maven-surefire-plugin 的一些配置选项就很有用了。例如 mvn test -dtest=footest 这样一条命令的效果是仅运行 footest 测试类，这是通过控制 maven-surefire-plugin 的 test 参数实现的。\n\n# build-helper-maven-plugin\n\nmaven 默认只允许指定一个主 java 代码目录和一个测试 java 代码目录，虽然这其实是个应当尽量遵守的约定，但偶尔你还是会希望能够指定多个 源码目录（例如为了应对遗留项目），build-helper-maven-plugin 的 add-source 目标就是服务于这个目的，通常它被绑定到 默认生命周期的 generate-sources 阶段以添加额外的源码目录。需要强调的是，这种做法还是不推荐的，因为它破坏了 maven 的约定，而且可能会遇到其他严格遵守约定的插件工具无法正确识别额外的源码目录。\n\nbuild-helper-maven-plugin 的另一个非常有用的目标是 attach-artifact，使用该目标你可以以 classifier 的形式选取部分项目文件生成附属构件，并同时 install 到本地仓库，也可以 deploy 到远程仓库。\n\n# exec-maven-plugin\n\nexec-maven-plugin 很好理解，顾名思义，它能让你运行任何本地的系统程序，在某些特定情况下，运行一个 maven 外部的程序可能就是最简单的问题解决方案，这就是exec:exec的 用途，当然，该插件还允许你配置相关的程序运行参数。除了 exec 目标之外，exec-maven-plugin 还提供了一个 java 目标，该目标要求你 提供一个 mainclass 参数，然后它能够利用当前项目的依赖作为 classpath，在同一个 jvm 中运行该 mainclass。有时候，为了简单的 演示一个命令行 java 程序，你可以在 pom 中配置好 exec-maven-plugin 的相关运行参数，然后直接在命令运行mvn exec:java 以查看运行效果。\n\n# jetty-maven-plugin\n\n在进行 web 开发的时候，打开浏览器对应用进行手动的测试几乎是无法避免的，这种测试方法通常就是将项目打包成 war 文件，然后部署到 web 容器 中，再启动容器进行验证，这显然十分耗时。为了帮助开发者节省时间，jetty-maven-plugin 应运而生，它完全兼容 maven 项目的目录结构，能够周期性地检查源文件，一旦发现变更后自动更新到内置的 jetty web 容器中。做一些基本配置后（例如 web 应用的 contextpath 和自动扫描变更的时间间隔），你只要执行 mvn jetty:run ，然后在 ide 中修改代码，代码经 ide 自动编译后产生变更，再由 jetty-maven-plugin 侦测到后更新至 jetty 容器，这时你就可以直接 测试 web 页面了。需要注意的是，jetty-maven-plugin 并不是宿主于 apache 或 codehaus 的官方插件，因此使用的时候需要额外 的配置settings.xml的 plugingroups 元素，将 org.mortbay.jetty 这个 plugingroup 加入。\n\n# versions-maven-plugin\n\n很多 maven 用户遇到过这样一个问题，当项目包含大量模块的时候，为他们集体更新版本就变成一件烦人的事情，到底有没有自动化工具能帮助完成这件 事情呢？（当然你可以使用 sed 之类的文本操作工具，不过不在本文讨论范围）答案是肯定的，versions-maven- plugin 提供了很多目标帮助你管理 maven 项目的各种版本信息。例如最常用的，命令 mvn versions:set -dnewversion=1.1-snapshot 就能帮助你把所有模块的版本更新到 1.1-snapshot。该插件还提供了其他一些很有用的目标，display-dependency- updates 能告诉你项目依赖有哪些可用的更新；类似的 display-plugin-updates 能告诉你可用的插件更新；然后 use- latest-versions 能自动帮你将所有依赖升级到最新版本。最后，如果你对所做的更改满意，则可以使用 mvn versions:commit 提交，不满意的话也可以使用 mvn versions:revert 进行撤销。\n\n\n# maven 命令\n\n常用 maven 命令清单：\n\n生命周期                          阶段描述\nmvn validate                  验证项目是否正确，以及所有为了完整构建必要的信息是否可用\nmvn generate-sources          生成所有需要包含在编译过程中的源代码\nmvn process-sources           处理源代码，比如过滤一些值\nmvn generate-resources        生成所有需要包含在打包过程中的资源文件\nmvn process-resources         复制并处理资源文件至目标目录，准备打包\nmvn compile                   编译项目的源代码\nmvn process-classes           后处理编译生成的文件，例如对 java 类进行字节码增强（bytecode enhancement）\nmvn generate-test-sources     生成所有包含在测试编译过程中的测试源码\nmvn process-test-sources      处理测试源码，比如过滤一些值\nmvn generate-test-resources   生成测试需要的资源文件\nmvn process-test-resources    复制并处理测试资源文件至测试目标目录\nmvn test-compile              编译测试源码至测试目标目录\nmvn test                      使用合适的单元测试框架运行测试。这些测试应该不需要代码被打包或发布\nmvn prepare-package           在真正的打包之前，执行一些准备打包必要的操作。这通常会产生一个包的展开的处理过的版本（将会在 maven\n                              2.1+中实现）\nmvn package                   将编译好的代码打包成可分发的格式，如 jar，war，或者 ear\nmvn pre-integration-test      执行一些在集成测试运行之前需要的动作。如建立集成测试需要的环境\nmvn integration-test          如果有必要的话，处理包并发布至集成测试可以运行的环境\nmvn post-integration-test     执行一些在集成测试运行之后需要的动作。如清理集成测试环境。\nmvn verify                    执行所有检查，验证包是有效的，符合质量规范\nmvn install                   安装包至本地仓库，以备本地的其它项目作为依赖使用\nmvn deploy                    复制最终的包至远程仓库，共享给其它开发人员和项目（通常和一次正式的发布相关）\n\n示例：最常用的 maven 构建命令\n\nmvn clean install -dmaven.test.skip=true -b -u\n\n\n清理本地输出物，并构建 maven 项目，最后将输出物归档在本地仓库。\n\n> 💡 想了解更多 maven 命令行细节可以参考官方文档：\n> \n>  * maven 构建生命周期说明\n>  * maven 命令行参数说明\n\n\n# 参考资料\n\n * maven github\n * maven 官方文档\n * maven in 5 minutes\n * maven getting started guide\n * maven 常见问题问答\n * 常用 maven 插件介绍',charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Maven 教程之 settings.xml 详解",frontmatter:{title:"Maven 教程之 settings.xml 详解",date:"2019-05-14T14:57:33.000Z",order:3,categories:["Java","软件","构建","Maven"],tags:["Java","构建","Maven"],permalink:"/pages/1d58f1/"},regularPath:"/01.Java/11.%E8%BD%AF%E4%BB%B6/01.%E6%9E%84%E5%BB%BA/01.Maven/03.Maven%E6%95%99%E7%A8%8B%E4%B9%8Bsettings.xml%E8%AF%A6%E8%A7%A3.html",relativePath:"01.Java/11.软件/01.构建/01.Maven/03.Maven教程之settings.xml详解.md",key:"v-9dacab80",path:"/pages/1d58f1/",headers:[{level:2,title:"settings.xml 简介",slug:"settings-xml-简介",normalizedTitle:"settings.xml 简介",charIndex:32},{level:3,title:"settings.xml 有什么用",slug:"settings-xml-有什么用",normalizedTitle:"settings.xml 有什么用",charIndex:52},{level:3,title:"settings.xml 文件位置",slug:"settings-xml-文件位置",normalizedTitle:"settings.xml 文件位置",charIndex:223},{level:3,title:"配置优先级",slug:"配置优先级",normalizedTitle:"配置优先级",charIndex:442},{level:2,title:"settings.xml 元素详解",slug:"settings-xml-元素详解",normalizedTitle:"settings.xml 元素详解",charIndex:578},{level:3,title:"顶级元素概览",slug:"顶级元素概览",normalizedTitle:"顶级元素概览",charIndex:600},{level:3,title:"LocalRepository",slug:"localrepository",normalizedTitle:"localrepository",charIndex:1077},{level:3,title:"InteractiveMode",slug:"interactivemode",normalizedTitle:"interactivemode",charIndex:1207},{level:3,title:"UsePluginRegistry",slug:"usepluginregistry",normalizedTitle:"usepluginregistry",charIndex:1353},{level:3,title:"Offline",slug:"offline",normalizedTitle:"offline",charIndex:1541},{level:3,title:"PluginGroups",slug:"plugingroups",normalizedTitle:"plugingroups",charIndex:1688},{level:3,title:"Servers",slug:"servers",normalizedTitle:"servers",charIndex:2311},{level:3,title:"Mirrors",slug:"mirrors",normalizedTitle:"mirrors",charIndex:3754},{level:3,title:"Proxies",slug:"proxies",normalizedTitle:"proxies",charIndex:4554},{level:3,title:"Profiles",slug:"profiles",normalizedTitle:"profiles",charIndex:1049},{level:4,title:"Activation",slug:"activation",normalizedTitle:"activation",charIndex:6504},{level:4,title:"properties",slug:"properties",normalizedTitle:"properties",charIndex:5766},{level:4,title:"Repositories",slug:"repositories",normalizedTitle:"repositories",charIndex:5751},{level:4,title:"pluginRepositories",slug:"pluginrepositories",normalizedTitle:"pluginrepositories",charIndex:5745},{level:3,title:"ActiveProfiles",slug:"activeprofiles",normalizedTitle:"activeprofiles",charIndex:10568},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:11334}],headersStr:"settings.xml 简介 settings.xml 有什么用 settings.xml 文件位置 配置优先级 settings.xml 元素详解 顶级元素概览 LocalRepository InteractiveMode UsePluginRegistry Offline PluginGroups Servers Mirrors Proxies Profiles Activation properties Repositories pluginRepositories ActiveProfiles 参考资料",content:'# Maven 教程之 settings.xml 详解\n\n\n# settings.xml 简介\n\n\n# settings.xml 有什么用\n\n从 settings.xml 的文件名就可以看出，它是用来设置 maven 参数的配置文件。settings.xml 中包含类似本地仓储位置、修改远程仓储服务器、认证信息等配置。\n\n * settings.xml 是 maven 的全局配置文件。\n * pom.xml 文件是本地项目配置文件。\n\n\n# settings.xml 文件位置\n\nsettings.xml 文件一般存在于两个位置：\n\n * 全局配置 - ${maven.home}/conf/settings.xml\n * 用户配置 - ${user.home}/.m2/settings.xml\n\n> 🔔 注意：用户配置优先于全局配置。${user.home} 和和所有其他系统属性只能在 3.0+版本上使用。请注意 windows 和 Linux 使用变量的区别。\n\n\n# 配置优先级\n\n> 重要：局部配置优先于全局配置。\n\n配置优先级从高到低：pom.xml > user settings > global settings\n\n如果这些文件同时存在，在应用配置时，会合并它们的内容，如果有重复的配置，优先级高的配置会覆盖优先级低的。\n\n\n# settings.xml 元素详解\n\n\n# 顶级元素概览\n\n下面列举了settings.xml中的顶级元素\n\n<settings xmlns="http://maven.apache.org/SETTINGS/1.0.0"\n      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n      xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0\n                          https://maven.apache.org/xsd/settings-1.0.0.xsd">\n  <localRepository/>\n  <interactiveMode/>\n  <usePluginRegistry/>\n  <offline/>\n  <pluginGroups/>\n  <servers/>\n  <mirrors/>\n  <proxies/>\n  <profiles/>\n  <activeProfiles/>\n</settings>\n\n\n\n# LocalRepository\n\n作用：该值表示构建系统本地仓库的路径。\n\n其默认值：~/.m2/repository。\n\n<localRepository>${user.home}/.m2/repository</localRepository>\n\n\n\n# InteractiveMode\n\n作用：表示 maven 是否需要和用户交互以获得输入。\n\n如果 maven 需要和用户交互以获得输入，则设置成 true，反之则应为 false。默认为 true。\n\n<interactiveMode>true</interactiveMode>\n\n\n\n# UsePluginRegistry\n\n作用：maven 是否需要使用 plugin-registry.xml 文件来管理插件版本。\n\n如果需要让 maven 使用文件~/.m2/plugin-registry.xml 来管理插件版本，则设为 true。默认为 false。\n\n<usePluginRegistry>false</usePluginRegistry>\n\n\n\n# Offline\n\n作用：表示 maven 是否需要在离线模式下运行。\n\n如果构建系统需要在离线模式下运行，则为 true，默认为 false。\n\n当由于网络设置原因或者安全因素，构建服务器不能连接远程仓库的时候，该配置就十分有用。\n\n<offline>false</offline>\n\n\n\n# PluginGroups\n\n作用：当插件的组织 id（groupId）没有显式提供时，供搜寻插件组织 Id（groupId）的列表。\n\n该元素包含一个 pluginGroup 元素列表，每个子元素包含了一个组织 Id（groupId）。\n\n当我们使用某个插件，并且没有在命令行为其提供组织 Id（groupId）的时候，Maven 就会使用该列表。默认情况下该列表包含了 org.apache.maven.plugins 和 org.codehaus.mojo。\n\n<settings xmlns="http://maven.apache.org/SETTINGS/1.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n  xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0\n                      https://maven.apache.org/xsd/settings-1.0.0.xsd">\n  ...\n  <pluginGroups>\n    \x3c!--plugin的组织Id（groupId） --\x3e\n    <pluginGroup>org.codehaus.mojo</pluginGroup>\n  </pluginGroups>\n  ...\n</settings>\n\n\n\n# Servers\n\n作用：一般，仓库的下载和部署是在 pom.xml 文件中的 repositories 和 distributionManagement 元素中定义的。然而，一般类似用户名、密码（有些仓库访问是需要安全认证的）等信息不应该在 pom.xml 文件中配置，这些信息可以配置在 settings.xml 中。\n\n<settings xmlns="http://maven.apache.org/SETTINGS/1.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n  xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0\n                      https://maven.apache.org/xsd/settings-1.0.0.xsd">\n  ...\n  \x3c!--配置服务端的一些设置。一些设置如安全证书不应该和pom.xml一起分发。这种类型的信息应该存在于构建服务器上的settings.xml文件中。 --\x3e\n  <servers>\n    \x3c!--服务器元素包含配置服务器时需要的信息 --\x3e\n    <server>\n      \x3c!--这是server的id（注意不是用户登陆的id），该id与distributionManagement中repository元素的id相匹配。 --\x3e\n      <id>server001</id>\n      \x3c!--鉴权用户名。鉴权用户名和鉴权密码表示服务器认证所需要的登录名和密码。 --\x3e\n      <username>my_login</username>\n      \x3c!--鉴权密码 。鉴权用户名和鉴权密码表示服务器认证所需要的登录名和密码。密码加密功能已被添加到2.1.0 +。详情请访问密码加密页面 --\x3e\n      <password>my_password</password>\n      \x3c!--鉴权时使用的私钥位置。和前两个元素类似，私钥位置和私钥密码指定了一个私钥的路径（默认是${user.home}/.ssh/id_dsa）以及如果需要的话，一个密语。将来passphrase和password元素可能会被提取到外部，但目前它们必须在settings.xml文件以纯文本的形式声明。 --\x3e\n      <privateKey>${usr.home}/.ssh/id_dsa</privateKey>\n      \x3c!--鉴权时使用的私钥密码。 --\x3e\n      <passphrase>some_passphrase</passphrase>\n      \x3c!--文件被创建时的权限。如果在部署的时候会创建一个仓库文件或者目录，这时候就可以使用权限（permission）。这两个元素合法的值是一个三位数字，其对应了unix文件系统的权限，如664，或者775。 --\x3e\n      <filePermissions>664</filePermissions>\n      \x3c!--目录被创建时的权限。 --\x3e\n      <directoryPermissions>775</directoryPermissions>\n    </server>\n  </servers>\n  ...\n</settings>\n\n\n\n# Mirrors\n\n作用：为仓库列表配置的下载镜像列表。\n\n<settings xmlns="http://maven.apache.org/SETTINGS/1.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n  xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0\n                      https://maven.apache.org/xsd/settings-1.0.0.xsd">\n  ...\n  <mirrors>\n    \x3c!-- 给定仓库的下载镜像。 --\x3e\n    <mirror>\n      \x3c!-- 该镜像的唯一标识符。id用来区分不同的mirror元素。 --\x3e\n      <id>planetmirror.com</id>\n      \x3c!-- 镜像名称 --\x3e\n      <name>PlanetMirror Australia</name>\n      \x3c!-- 该镜像的URL。构建系统会优先考虑使用该URL，而非使用默认的服务器URL。 --\x3e\n      <url>http://downloads.planetmirror.com/pub/maven2</url>\n      \x3c!-- 被镜像的服务器的id。例如，如果我们要设置了一个Maven中央仓库（http://repo.maven.apache.org/maven2/）的镜像，就需要将该元素设置成central。这必须和中央仓库的id central完全一致。 --\x3e\n      <mirrorOf>central</mirrorOf>\n    </mirror>\n  </mirrors>\n  ...\n</settings>\n\n\n\n# Proxies\n\n作用：用来配置不同的代理。\n\n<settings xmlns="http://maven.apache.org/SETTINGS/1.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n  xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0\n                      https://maven.apache.org/xsd/settings-1.0.0.xsd">\n  ...\n  <proxies>\n    \x3c!--代理元素包含配置代理时需要的信息 --\x3e\n    <proxy>\n      \x3c!--代理的唯一定义符，用来区分不同的代理元素。 --\x3e\n      <id>myproxy</id>\n      \x3c!--该代理是否是激活的那个。true则激活代理。当我们声明了一组代理，而某个时候只需要激活一个代理的时候，该元素就可以派上用处。 --\x3e\n      <active>true</active>\n      \x3c!--代理的协议。 协议://主机名:端口，分隔成离散的元素以方便配置。 --\x3e\n      <protocol>http</protocol>\n      \x3c!--代理的主机名。协议://主机名:端口，分隔成离散的元素以方便配置。 --\x3e\n      <host>proxy.somewhere.com</host>\n      \x3c!--代理的端口。协议://主机名:端口，分隔成离散的元素以方便配置。 --\x3e\n      <port>8080</port>\n      \x3c!--代理的用户名，用户名和密码表示代理服务器认证的登录名和密码。 --\x3e\n      <username>proxyuser</username>\n      \x3c!--代理的密码，用户名和密码表示代理服务器认证的登录名和密码。 --\x3e\n      <password>somepassword</password>\n      \x3c!--不该被代理的主机名列表。该列表的分隔符由代理服务器指定；例子中使用了竖线分隔符，使用逗号分隔也很常见。 --\x3e\n      <nonProxyHosts>*.google.com|ibiblio.org</nonProxyHosts>\n    </proxy>\n  </proxies>\n  ...\n</settings>\n\n\n\n# Profiles\n\n作用：根据环境参数来调整构建配置的列表。\n\nsettings.xml 中的 profile 元素是 pom.xml 中 profile 元素的裁剪版本。\n\n它包含了id、activation、repositories、pluginRepositories 和 properties 元素。这里的 profile 元素只包含这五个子元素是因为这里只关心构建系统这个整体（这正是 settings.xml 文件的角色定位），而非单独的项目对象模型设置。如果一个 settings.xml 中的 profile 被激活，它的值会覆盖任何其它定义在 pom.xml 中带有相同 id 的 profile。\n\n<settings xmlns="http://maven.apache.org/SETTINGS/1.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n  xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0\n                      https://maven.apache.org/xsd/settings-1.0.0.xsd">\n  ...\n  <profiles>\n    <profile>\n      \x3c!-- profile的唯一标识 --\x3e\n      <id>test</id>\n      \x3c!-- 自动触发profile的条件逻辑 --\x3e\n      <activation />\n      \x3c!-- 扩展属性列表 --\x3e\n      <properties />\n      \x3c!-- 远程仓库列表 --\x3e\n      <repositories />\n      \x3c!-- 插件仓库列表 --\x3e\n      <pluginRepositories />\n    </profile>\n  </profiles>\n  ...\n</settings>\n\n\n# Activation\n\n作用：自动触发 profile 的条件逻辑。\n\n如 pom.xml 中的 profile 一样，profile 的作用在于它能够在某些特定的环境中自动使用某些特定的值；这些环境通过 activation 元素指定。 activation 元素并不是激活 profile 的唯一方式。settings.xml 文件中的 activeProfile 元素可以包含 profile 的 id。profile 也可以通过在命令行，使用 -P 标记和逗号分隔的列表来显式的激活（如，-P test）。\n\n<activation>\n  \x3c!--profile默认是否激活的标识 --\x3e\n  <activeByDefault>false</activeByDefault>\n  \x3c!--当匹配的jdk被检测到，profile被激活。例如，1.4激活JDK1.4，1.4.0_2，而!1.4激活所有版本不是以1.4开头的JDK。 --\x3e\n  <jdk>1.5</jdk>\n  \x3c!--当匹配的操作系统属性被检测到，profile被激活。os元素可以定义一些操作系统相关的属性。 --\x3e\n  <os>\n    \x3c!--激活profile的操作系统的名字 --\x3e\n    <name>Windows XP</name>\n    \x3c!--激活profile的操作系统所属家族(如 \'windows\') --\x3e\n    <family>Windows</family>\n    \x3c!--激活profile的操作系统体系结构 --\x3e\n    <arch>x86</arch>\n    \x3c!--激活profile的操作系统版本 --\x3e\n    <version>5.1.2600</version>\n  </os>\n  \x3c!--如果Maven检测到某一个属性（其值可以在POM中通过${name}引用），其拥有对应的name = 值，Profile就会被激活。如果值字段是空的，那么存在属性名称字段就会激活profile，否则按区分大小写方式匹配属性值字段 --\x3e\n  <property>\n    \x3c!--激活profile的属性的名称 --\x3e\n    <name>mavenVersion</name>\n    \x3c!--激活profile的属性的值 --\x3e\n    <value>2.0.3</value>\n  </property>\n  \x3c!--提供一个文件名，通过检测该文件的存在或不存在来激活profile。missing检查文件是否存在，如果不存在则激活profile。另一方面，exists则会检查文件是否存在，如果存在则激活profile。 --\x3e\n  <file>\n    \x3c!--如果指定的文件存在，则激活profile。 --\x3e\n    <exists>${basedir}/file2.properties</exists>\n    \x3c!--如果指定的文件不存在，则激活profile。 --\x3e\n    <missing>${basedir}/file1.properties</missing>\n  </file>\n</activation>\n\n\n> 注：在 maven 工程的 pom.xml 所在目录下执行 mvn help:active-profiles 命令可以查看中央仓储的 profile 是否在工程中生效。\n\n# properties\n\n作用：对应profile的扩展属性列表。\n\nmaven 属性和 ant 中的属性一样，可以用来存放一些值。这些值可以在 pom.xml 中的任何地方使用标记${X}来使用，这里 X 是指属性的名称。属性有五种不同的形式，并且都能在 settings.xml 文件中访问。\n\n\x3c!--\n  1. env.X: 在一个变量前加上"env."的前缀，会返回一个shell环境变量。例如,"env.PATH"指代了$path环境变量（在Windows上是%PATH%）。\n  2. project.x：指代了POM中对应的元素值。例如: <project><version>1.0</version></project>通过${project.version}获得version的值。\n  3. settings.x: 指代了settings.xml中对应元素的值。例如：<settings><offline>false</offline></settings>通过 ${settings.offline}获得offline的值。\n  4. Java System Properties: 所有可通过java.lang.System.getProperties()访问的属性都能在POM中使用该形式访问，例如 ${java.home}。\n  5. x: 在<properties/>元素中，或者外部文件中设置，以${someVar}的形式使用。\n --\x3e\n<properties>\n  <user.install>${user.home}/our-project</user.install>\n</properties>\n\n\n> 注：如果该 profile 被激活，则可以在pom.xml中使用${user.install}。\n\n# Repositories\n\n作用：远程仓库列表，它是 maven 用来填充构建系统本地仓库所使用的一组远程仓库。\n\n<repositories>\n  \x3c!--包含需要连接到远程仓库的信息 --\x3e\n  <repository>\n    \x3c!--远程仓库唯一标识 --\x3e\n    <id>codehausSnapshots</id>\n    \x3c!--远程仓库名称 --\x3e\n    <name>Codehaus Snapshots</name>\n    \x3c!--如何处理远程仓库里发布版本的下载 --\x3e\n    <releases>\n      \x3c!--true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。 --\x3e\n      <enabled>false</enabled>\n      \x3c!--该元素指定更新发生的频率。Maven会比较本地POM和远程POM的时间戳。这里的选项是：always（一直），daily（默认，每日），interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。 --\x3e\n      <updatePolicy>always</updatePolicy>\n      \x3c!--当Maven验证构件校验文件失败时该怎么做-ignore（忽略），fail（失败），或者warn（警告）。 --\x3e\n      <checksumPolicy>warn</checksumPolicy>\n    </releases>\n    \x3c!--如何处理远程仓库里快照版本的下载。有了releases和snapshots这两组配置，POM就可以在每个单独的仓库中，为每种类型的构件采取不同的策略。例如，可能有人会决定只为开发目的开启对快照版本下载的支持。参见repositories/repository/releases元素 --\x3e\n    <snapshots>\n      <enabled />\n      <updatePolicy />\n      <checksumPolicy />\n    </snapshots>\n    \x3c!--远程仓库URL，按protocol://hostname/path形式 --\x3e\n    <url>http://snapshots.maven.codehaus.org/maven2</url>\n    \x3c!--用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。Maven 2为其仓库提供了一个默认的布局；然而，Maven 1.x有一种不同的布局。我们可以使用该元素指定布局是default（默认）还是legacy（遗留）。 --\x3e\n    <layout>default</layout>\n  </repository>\n</repositories>\n\n\n# pluginRepositories\n\n作用：发现插件的远程仓库列表。\n\n和 repository 类似，只是 repository 是管理 jar 包依赖的仓库，pluginRepositories 则是管理插件的仓库。 maven 插件是一种特殊类型的构件。由于这个原因，插件仓库独立于其它仓库。pluginRepositories 元素的结构和 repositories 元素的结构类似。每个 pluginRepository 元素指定一个 Maven 可以用来寻找新插件的远程地址。\n\n<pluginRepositories>\n  \x3c!-- 包含需要连接到远程插件仓库的信息.参见profiles/profile/repositories/repository元素的说明 --\x3e\n  <pluginRepository>\n    <releases>\n      <enabled />\n      <updatePolicy />\n      <checksumPolicy />\n    </releases>\n    <snapshots>\n      <enabled />\n      <updatePolicy />\n      <checksumPolicy />\n    </snapshots>\n    <id />\n    <name />\n    <url />\n    <layout />\n  </pluginRepository>\n</pluginRepositories>\n\n\n\n# ActiveProfiles\n\n作用：手动激活 profiles 的列表，按照profile被应用的顺序定义activeProfile。\n\n该元素包含了一组 activeProfile 元素，每个 activeProfile 都含有一个 profile id。任何在 activeProfile 中定义的 profile id，不论环境设置如何，其对应的 profile 都会被激活。如果没有匹配的 profile，则什么都不会发生。\n\n例如，env-test 是一个 activeProfile，则在 pom.xml（或者 profile.xml）中对应 id 的 profile 会被激活。如果运行过程中找不到这样一个 profile，Maven 则会像往常一样运行。\n\n<settings xmlns="http://maven.apache.org/SETTINGS/1.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n  xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0\n                      https://maven.apache.org/xsd/settings-1.0.0.xsd">\n  ...\n  <activeProfiles>\n    \x3c!-- 要激活的profile id --\x3e\n    <activeProfile>env-test</activeProfile>\n  </activeProfiles>\n  ...\n</settings>\n\n\n至此，maven settings.xml 中的标签都讲解完毕，希望对大家有所帮助。\n\n\n# 参考资料\n\n * maven 官方文档之 settings',normalizedContent:'# maven 教程之 settings.xml 详解\n\n\n# settings.xml 简介\n\n\n# settings.xml 有什么用\n\n从 settings.xml 的文件名就可以看出，它是用来设置 maven 参数的配置文件。settings.xml 中包含类似本地仓储位置、修改远程仓储服务器、认证信息等配置。\n\n * settings.xml 是 maven 的全局配置文件。\n * pom.xml 文件是本地项目配置文件。\n\n\n# settings.xml 文件位置\n\nsettings.xml 文件一般存在于两个位置：\n\n * 全局配置 - ${maven.home}/conf/settings.xml\n * 用户配置 - ${user.home}/.m2/settings.xml\n\n> 🔔 注意：用户配置优先于全局配置。${user.home} 和和所有其他系统属性只能在 3.0+版本上使用。请注意 windows 和 linux 使用变量的区别。\n\n\n# 配置优先级\n\n> 重要：局部配置优先于全局配置。\n\n配置优先级从高到低：pom.xml > user settings > global settings\n\n如果这些文件同时存在，在应用配置时，会合并它们的内容，如果有重复的配置，优先级高的配置会覆盖优先级低的。\n\n\n# settings.xml 元素详解\n\n\n# 顶级元素概览\n\n下面列举了settings.xml中的顶级元素\n\n<settings xmlns="http://maven.apache.org/settings/1.0.0"\n      xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n      xsi:schemalocation="http://maven.apache.org/settings/1.0.0\n                          https://maven.apache.org/xsd/settings-1.0.0.xsd">\n  <localrepository/>\n  <interactivemode/>\n  <usepluginregistry/>\n  <offline/>\n  <plugingroups/>\n  <servers/>\n  <mirrors/>\n  <proxies/>\n  <profiles/>\n  <activeprofiles/>\n</settings>\n\n\n\n# localrepository\n\n作用：该值表示构建系统本地仓库的路径。\n\n其默认值：~/.m2/repository。\n\n<localrepository>${user.home}/.m2/repository</localrepository>\n\n\n\n# interactivemode\n\n作用：表示 maven 是否需要和用户交互以获得输入。\n\n如果 maven 需要和用户交互以获得输入，则设置成 true，反之则应为 false。默认为 true。\n\n<interactivemode>true</interactivemode>\n\n\n\n# usepluginregistry\n\n作用：maven 是否需要使用 plugin-registry.xml 文件来管理插件版本。\n\n如果需要让 maven 使用文件~/.m2/plugin-registry.xml 来管理插件版本，则设为 true。默认为 false。\n\n<usepluginregistry>false</usepluginregistry>\n\n\n\n# offline\n\n作用：表示 maven 是否需要在离线模式下运行。\n\n如果构建系统需要在离线模式下运行，则为 true，默认为 false。\n\n当由于网络设置原因或者安全因素，构建服务器不能连接远程仓库的时候，该配置就十分有用。\n\n<offline>false</offline>\n\n\n\n# plugingroups\n\n作用：当插件的组织 id（groupid）没有显式提供时，供搜寻插件组织 id（groupid）的列表。\n\n该元素包含一个 plugingroup 元素列表，每个子元素包含了一个组织 id（groupid）。\n\n当我们使用某个插件，并且没有在命令行为其提供组织 id（groupid）的时候，maven 就会使用该列表。默认情况下该列表包含了 org.apache.maven.plugins 和 org.codehaus.mojo。\n\n<settings xmlns="http://maven.apache.org/settings/1.0.0" xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n  xsi:schemalocation="http://maven.apache.org/settings/1.0.0\n                      https://maven.apache.org/xsd/settings-1.0.0.xsd">\n  ...\n  <plugingroups>\n    \x3c!--plugin的组织id（groupid） --\x3e\n    <plugingroup>org.codehaus.mojo</plugingroup>\n  </plugingroups>\n  ...\n</settings>\n\n\n\n# servers\n\n作用：一般，仓库的下载和部署是在 pom.xml 文件中的 repositories 和 distributionmanagement 元素中定义的。然而，一般类似用户名、密码（有些仓库访问是需要安全认证的）等信息不应该在 pom.xml 文件中配置，这些信息可以配置在 settings.xml 中。\n\n<settings xmlns="http://maven.apache.org/settings/1.0.0" xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n  xsi:schemalocation="http://maven.apache.org/settings/1.0.0\n                      https://maven.apache.org/xsd/settings-1.0.0.xsd">\n  ...\n  \x3c!--配置服务端的一些设置。一些设置如安全证书不应该和pom.xml一起分发。这种类型的信息应该存在于构建服务器上的settings.xml文件中。 --\x3e\n  <servers>\n    \x3c!--服务器元素包含配置服务器时需要的信息 --\x3e\n    <server>\n      \x3c!--这是server的id（注意不是用户登陆的id），该id与distributionmanagement中repository元素的id相匹配。 --\x3e\n      <id>server001</id>\n      \x3c!--鉴权用户名。鉴权用户名和鉴权密码表示服务器认证所需要的登录名和密码。 --\x3e\n      <username>my_login</username>\n      \x3c!--鉴权密码 。鉴权用户名和鉴权密码表示服务器认证所需要的登录名和密码。密码加密功能已被添加到2.1.0 +。详情请访问密码加密页面 --\x3e\n      <password>my_password</password>\n      \x3c!--鉴权时使用的私钥位置。和前两个元素类似，私钥位置和私钥密码指定了一个私钥的路径（默认是${user.home}/.ssh/id_dsa）以及如果需要的话，一个密语。将来passphrase和password元素可能会被提取到外部，但目前它们必须在settings.xml文件以纯文本的形式声明。 --\x3e\n      <privatekey>${usr.home}/.ssh/id_dsa</privatekey>\n      \x3c!--鉴权时使用的私钥密码。 --\x3e\n      <passphrase>some_passphrase</passphrase>\n      \x3c!--文件被创建时的权限。如果在部署的时候会创建一个仓库文件或者目录，这时候就可以使用权限（permission）。这两个元素合法的值是一个三位数字，其对应了unix文件系统的权限，如664，或者775。 --\x3e\n      <filepermissions>664</filepermissions>\n      \x3c!--目录被创建时的权限。 --\x3e\n      <directorypermissions>775</directorypermissions>\n    </server>\n  </servers>\n  ...\n</settings>\n\n\n\n# mirrors\n\n作用：为仓库列表配置的下载镜像列表。\n\n<settings xmlns="http://maven.apache.org/settings/1.0.0" xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n  xsi:schemalocation="http://maven.apache.org/settings/1.0.0\n                      https://maven.apache.org/xsd/settings-1.0.0.xsd">\n  ...\n  <mirrors>\n    \x3c!-- 给定仓库的下载镜像。 --\x3e\n    <mirror>\n      \x3c!-- 该镜像的唯一标识符。id用来区分不同的mirror元素。 --\x3e\n      <id>planetmirror.com</id>\n      \x3c!-- 镜像名称 --\x3e\n      <name>planetmirror australia</name>\n      \x3c!-- 该镜像的url。构建系统会优先考虑使用该url，而非使用默认的服务器url。 --\x3e\n      <url>http://downloads.planetmirror.com/pub/maven2</url>\n      \x3c!-- 被镜像的服务器的id。例如，如果我们要设置了一个maven中央仓库（http://repo.maven.apache.org/maven2/）的镜像，就需要将该元素设置成central。这必须和中央仓库的id central完全一致。 --\x3e\n      <mirrorof>central</mirrorof>\n    </mirror>\n  </mirrors>\n  ...\n</settings>\n\n\n\n# proxies\n\n作用：用来配置不同的代理。\n\n<settings xmlns="http://maven.apache.org/settings/1.0.0" xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n  xsi:schemalocation="http://maven.apache.org/settings/1.0.0\n                      https://maven.apache.org/xsd/settings-1.0.0.xsd">\n  ...\n  <proxies>\n    \x3c!--代理元素包含配置代理时需要的信息 --\x3e\n    <proxy>\n      \x3c!--代理的唯一定义符，用来区分不同的代理元素。 --\x3e\n      <id>myproxy</id>\n      \x3c!--该代理是否是激活的那个。true则激活代理。当我们声明了一组代理，而某个时候只需要激活一个代理的时候，该元素就可以派上用处。 --\x3e\n      <active>true</active>\n      \x3c!--代理的协议。 协议://主机名:端口，分隔成离散的元素以方便配置。 --\x3e\n      <protocol>http</protocol>\n      \x3c!--代理的主机名。协议://主机名:端口，分隔成离散的元素以方便配置。 --\x3e\n      <host>proxy.somewhere.com</host>\n      \x3c!--代理的端口。协议://主机名:端口，分隔成离散的元素以方便配置。 --\x3e\n      <port>8080</port>\n      \x3c!--代理的用户名，用户名和密码表示代理服务器认证的登录名和密码。 --\x3e\n      <username>proxyuser</username>\n      \x3c!--代理的密码，用户名和密码表示代理服务器认证的登录名和密码。 --\x3e\n      <password>somepassword</password>\n      \x3c!--不该被代理的主机名列表。该列表的分隔符由代理服务器指定；例子中使用了竖线分隔符，使用逗号分隔也很常见。 --\x3e\n      <nonproxyhosts>*.google.com|ibiblio.org</nonproxyhosts>\n    </proxy>\n  </proxies>\n  ...\n</settings>\n\n\n\n# profiles\n\n作用：根据环境参数来调整构建配置的列表。\n\nsettings.xml 中的 profile 元素是 pom.xml 中 profile 元素的裁剪版本。\n\n它包含了id、activation、repositories、pluginrepositories 和 properties 元素。这里的 profile 元素只包含这五个子元素是因为这里只关心构建系统这个整体（这正是 settings.xml 文件的角色定位），而非单独的项目对象模型设置。如果一个 settings.xml 中的 profile 被激活，它的值会覆盖任何其它定义在 pom.xml 中带有相同 id 的 profile。\n\n<settings xmlns="http://maven.apache.org/settings/1.0.0" xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n  xsi:schemalocation="http://maven.apache.org/settings/1.0.0\n                      https://maven.apache.org/xsd/settings-1.0.0.xsd">\n  ...\n  <profiles>\n    <profile>\n      \x3c!-- profile的唯一标识 --\x3e\n      <id>test</id>\n      \x3c!-- 自动触发profile的条件逻辑 --\x3e\n      <activation />\n      \x3c!-- 扩展属性列表 --\x3e\n      <properties />\n      \x3c!-- 远程仓库列表 --\x3e\n      <repositories />\n      \x3c!-- 插件仓库列表 --\x3e\n      <pluginrepositories />\n    </profile>\n  </profiles>\n  ...\n</settings>\n\n\n# activation\n\n作用：自动触发 profile 的条件逻辑。\n\n如 pom.xml 中的 profile 一样，profile 的作用在于它能够在某些特定的环境中自动使用某些特定的值；这些环境通过 activation 元素指定。 activation 元素并不是激活 profile 的唯一方式。settings.xml 文件中的 activeprofile 元素可以包含 profile 的 id。profile 也可以通过在命令行，使用 -p 标记和逗号分隔的列表来显式的激活（如，-p test）。\n\n<activation>\n  \x3c!--profile默认是否激活的标识 --\x3e\n  <activebydefault>false</activebydefault>\n  \x3c!--当匹配的jdk被检测到，profile被激活。例如，1.4激活jdk1.4，1.4.0_2，而!1.4激活所有版本不是以1.4开头的jdk。 --\x3e\n  <jdk>1.5</jdk>\n  \x3c!--当匹配的操作系统属性被检测到，profile被激活。os元素可以定义一些操作系统相关的属性。 --\x3e\n  <os>\n    \x3c!--激活profile的操作系统的名字 --\x3e\n    <name>windows xp</name>\n    \x3c!--激活profile的操作系统所属家族(如 \'windows\') --\x3e\n    <family>windows</family>\n    \x3c!--激活profile的操作系统体系结构 --\x3e\n    <arch>x86</arch>\n    \x3c!--激活profile的操作系统版本 --\x3e\n    <version>5.1.2600</version>\n  </os>\n  \x3c!--如果maven检测到某一个属性（其值可以在pom中通过${name}引用），其拥有对应的name = 值，profile就会被激活。如果值字段是空的，那么存在属性名称字段就会激活profile，否则按区分大小写方式匹配属性值字段 --\x3e\n  <property>\n    \x3c!--激活profile的属性的名称 --\x3e\n    <name>mavenversion</name>\n    \x3c!--激活profile的属性的值 --\x3e\n    <value>2.0.3</value>\n  </property>\n  \x3c!--提供一个文件名，通过检测该文件的存在或不存在来激活profile。missing检查文件是否存在，如果不存在则激活profile。另一方面，exists则会检查文件是否存在，如果存在则激活profile。 --\x3e\n  <file>\n    \x3c!--如果指定的文件存在，则激活profile。 --\x3e\n    <exists>${basedir}/file2.properties</exists>\n    \x3c!--如果指定的文件不存在，则激活profile。 --\x3e\n    <missing>${basedir}/file1.properties</missing>\n  </file>\n</activation>\n\n\n> 注：在 maven 工程的 pom.xml 所在目录下执行 mvn help:active-profiles 命令可以查看中央仓储的 profile 是否在工程中生效。\n\n# properties\n\n作用：对应profile的扩展属性列表。\n\nmaven 属性和 ant 中的属性一样，可以用来存放一些值。这些值可以在 pom.xml 中的任何地方使用标记${x}来使用，这里 x 是指属性的名称。属性有五种不同的形式，并且都能在 settings.xml 文件中访问。\n\n\x3c!--\n  1. env.x: 在一个变量前加上"env."的前缀，会返回一个shell环境变量。例如,"env.path"指代了$path环境变量（在windows上是%path%）。\n  2. project.x：指代了pom中对应的元素值。例如: <project><version>1.0</version></project>通过${project.version}获得version的值。\n  3. settings.x: 指代了settings.xml中对应元素的值。例如：<settings><offline>false</offline></settings>通过 ${settings.offline}获得offline的值。\n  4. java system properties: 所有可通过java.lang.system.getproperties()访问的属性都能在pom中使用该形式访问，例如 ${java.home}。\n  5. x: 在<properties/>元素中，或者外部文件中设置，以${somevar}的形式使用。\n --\x3e\n<properties>\n  <user.install>${user.home}/our-project</user.install>\n</properties>\n\n\n> 注：如果该 profile 被激活，则可以在pom.xml中使用${user.install}。\n\n# repositories\n\n作用：远程仓库列表，它是 maven 用来填充构建系统本地仓库所使用的一组远程仓库。\n\n<repositories>\n  \x3c!--包含需要连接到远程仓库的信息 --\x3e\n  <repository>\n    \x3c!--远程仓库唯一标识 --\x3e\n    <id>codehaussnapshots</id>\n    \x3c!--远程仓库名称 --\x3e\n    <name>codehaus snapshots</name>\n    \x3c!--如何处理远程仓库里发布版本的下载 --\x3e\n    <releases>\n      \x3c!--true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。 --\x3e\n      <enabled>false</enabled>\n      \x3c!--该元素指定更新发生的频率。maven会比较本地pom和远程pom的时间戳。这里的选项是：always（一直），daily（默认，每日），interval：x（这里x是以分钟为单位的时间间隔），或者never（从不）。 --\x3e\n      <updatepolicy>always</updatepolicy>\n      \x3c!--当maven验证构件校验文件失败时该怎么做-ignore（忽略），fail（失败），或者warn（警告）。 --\x3e\n      <checksumpolicy>warn</checksumpolicy>\n    </releases>\n    \x3c!--如何处理远程仓库里快照版本的下载。有了releases和snapshots这两组配置，pom就可以在每个单独的仓库中，为每种类型的构件采取不同的策略。例如，可能有人会决定只为开发目的开启对快照版本下载的支持。参见repositories/repository/releases元素 --\x3e\n    <snapshots>\n      <enabled />\n      <updatepolicy />\n      <checksumpolicy />\n    </snapshots>\n    \x3c!--远程仓库url，按protocol://hostname/path形式 --\x3e\n    <url>http://snapshots.maven.codehaus.org/maven2</url>\n    \x3c!--用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。maven 2为其仓库提供了一个默认的布局；然而，maven 1.x有一种不同的布局。我们可以使用该元素指定布局是default（默认）还是legacy（遗留）。 --\x3e\n    <layout>default</layout>\n  </repository>\n</repositories>\n\n\n# pluginrepositories\n\n作用：发现插件的远程仓库列表。\n\n和 repository 类似，只是 repository 是管理 jar 包依赖的仓库，pluginrepositories 则是管理插件的仓库。 maven 插件是一种特殊类型的构件。由于这个原因，插件仓库独立于其它仓库。pluginrepositories 元素的结构和 repositories 元素的结构类似。每个 pluginrepository 元素指定一个 maven 可以用来寻找新插件的远程地址。\n\n<pluginrepositories>\n  \x3c!-- 包含需要连接到远程插件仓库的信息.参见profiles/profile/repositories/repository元素的说明 --\x3e\n  <pluginrepository>\n    <releases>\n      <enabled />\n      <updatepolicy />\n      <checksumpolicy />\n    </releases>\n    <snapshots>\n      <enabled />\n      <updatepolicy />\n      <checksumpolicy />\n    </snapshots>\n    <id />\n    <name />\n    <url />\n    <layout />\n  </pluginrepository>\n</pluginrepositories>\n\n\n\n# activeprofiles\n\n作用：手动激活 profiles 的列表，按照profile被应用的顺序定义activeprofile。\n\n该元素包含了一组 activeprofile 元素，每个 activeprofile 都含有一个 profile id。任何在 activeprofile 中定义的 profile id，不论环境设置如何，其对应的 profile 都会被激活。如果没有匹配的 profile，则什么都不会发生。\n\n例如，env-test 是一个 activeprofile，则在 pom.xml（或者 profile.xml）中对应 id 的 profile 会被激活。如果运行过程中找不到这样一个 profile，maven 则会像往常一样运行。\n\n<settings xmlns="http://maven.apache.org/settings/1.0.0" xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n  xsi:schemalocation="http://maven.apache.org/settings/1.0.0\n                      https://maven.apache.org/xsd/settings-1.0.0.xsd">\n  ...\n  <activeprofiles>\n    \x3c!-- 要激活的profile id --\x3e\n    <activeprofile>env-test</activeprofile>\n  </activeprofiles>\n  ...\n</settings>\n\n\n至此，maven settings.xml 中的标签都讲解完毕，希望对大家有所帮助。\n\n\n# 参考资料\n\n * maven 官方文档之 settings',charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Maven 实战问题和最佳实践",frontmatter:{title:"Maven 实战问题和最佳实践",date:"2018-11-28T09:29:22.000Z",order:4,categories:["Java","软件","构建","Maven"],tags:["Java","构建","Maven"],permalink:"/pages/198618/"},regularPath:"/01.Java/11.%E8%BD%AF%E4%BB%B6/01.%E6%9E%84%E5%BB%BA/01.Maven/04.Maven%E5%AE%9E%E6%88%98%E9%97%AE%E9%A2%98%E5%92%8C%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5.html",relativePath:"01.Java/11.软件/01.构建/01.Maven/04.Maven实战问题和最佳实践.md",key:"v-35a64902",path:"/pages/198618/",headers:[{level:2,title:"Maven 常见问题",slug:"maven-常见问题",normalizedTitle:"maven 常见问题",charIndex:22},{level:3,title:"dependencies 和 dependencyManagement，plugins 和 pluginManagement 有什么区别",slug:"dependencies-和-dependencymanagement-plugins-和-pluginmanagement-有什么区别",normalizedTitle:"dependencies 和 dependencymanagement，plugins 和 pluginmanagement 有什么区别",charIndex:37},{level:3,title:"IDEA 修改 JDK 版本后编译报错",slug:"idea-修改-jdk-版本后编译报错",normalizedTitle:"idea 修改 jdk 版本后编译报错",charIndex:490},{level:3,title:"重复引入依赖",slug:"重复引入依赖",normalizedTitle:"重复引入依赖",charIndex:975},{level:3,title:"如何打包一个可以直接运行的 Spring Boot jar 包",slug:"如何打包一个可以直接运行的-spring-boot-jar-包",normalizedTitle:"如何打包一个可以直接运行的 spring boot jar 包",charIndex:1067},{level:3,title:"去哪儿找 maven dependency",slug:"去哪儿找-maven-dependency",normalizedTitle:"去哪儿找 maven dependency",charIndex:2213},{level:3,title:"如何指定编码",slug:"如何指定编码",normalizedTitle:"如何指定编码",charIndex:2401},{level:3,title:"如何指定 JDK 版本",slug:"如何指定-jdk-版本",normalizedTitle:"如何指定 jdk 版本",charIndex:2619},{level:3,title:"如何避免将 dependency 打包到构件中",slug:"如何避免将-dependency-打包到构件中",normalizedTitle:"如何避免将 dependency 打包到构件中",charIndex:3234},{level:3,title:"如何跳过单元测试",slug:"如何跳过单元测试",normalizedTitle:"如何跳过单元测试",charIndex:3381},{level:3,title:"如何引入本地 jar",slug:"如何引入本地-jar",normalizedTitle:"如何引入本地 jar",charIndex:3534},{level:3,title:"如何排除依赖",slug:"如何排除依赖",normalizedTitle:"如何排除依赖",charIndex:3991},{level:2,title:"Maven 最佳实践",slug:"maven-最佳实践",normalizedTitle:"maven 最佳实践",charIndex:4462},{level:3,title:"通过 bom 统一管理版本",slug:"通过-bom-统一管理版本",normalizedTitle:"通过 bom 统一管理版本",charIndex:4477}],headersStr:"Maven 常见问题 dependencies 和 dependencyManagement，plugins 和 pluginManagement 有什么区别 IDEA 修改 JDK 版本后编译报错 重复引入依赖 如何打包一个可以直接运行的 Spring Boot jar 包 去哪儿找 maven dependency 如何指定编码 如何指定 JDK 版本 如何避免将 dependency 打包到构件中 如何跳过单元测试 如何引入本地 jar 如何排除依赖 Maven 最佳实践 通过 bom 统一管理版本",content:'# Maven 实战问题和最佳实践\n\n\n# Maven 常见问题\n\n\n# dependencies 和 dependencyManagement，plugins 和 pluginManagement 有什么区别\n\ndependencyManagement 是表示依赖 jar 包的声明，即你在项目中的 dependencyManagement 下声明了依赖，maven 不会加载该依赖，dependencyManagement 声明可以被继承。\n\ndependencyManagement 的一个使用案例是当有父子项目的时候，父项目中可以利用 dependencyManagement 声明子项目中需要用到的依赖 jar 包，之后，当某个或者某几个子项目需要加载该插件的时候，就可以在子项目中 dependencies 节点只配置 groupId 和 artifactId 就可以完成插件的引用。\n\ndependencyManagement 主要是为了统一管理插件，确保所有子项目使用的插件版本保持一致，类似的还有 plugins 和 pluginManagement。\n\n\n# IDEA 修改 JDK 版本后编译报错\n\n错误现象：\n\n修改 JDK 版本，指定 maven-compiler-plugin 的 source 和 target 为 1.8 。\n\n然后，在 Intellij IDEA 中执行 maven 指令，报错：\n\n[ERROR] Failed to execute goal org.apache.maven.plugins:maven-compiler-plugin:3.0:compile (default-compile) on project apollo-common: Fatal error compiling: 无效的目标版本： 1.8 -> [Help 1]\n\n\n错误原因：\n\nmaven 的 JDK 源与指定的 JDK 编译版本不符。\n\n排错手段：\n\n * 查看 Project Settings\n\nProject SDK 是否正确\n\n\n\nSDK 路径是否正确\n\n\n\n * 查看 Settings > Maven 的配置\n\nJDK for importer 是否正确\n\n\n\nRunner 是否正确\n\n\n\n\n# 重复引入依赖\n\n在 Idea 中，选中 Module，使用 Ctrl+Alt+Shift+U，打开依赖图，检索是否存在重复引用的情况。如果存在重复引用，可以将多余的引用删除。\n\n\n# 如何打包一个可以直接运行的 Spring Boot jar 包\n\n可以使用 spring-boot-maven-plugin 插件\n\n<build>\n  <plugins>\n    <plugin>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-maven-plugin</artifactId>\n      <executions>\n        <execution>\n          <goals>\n            <goal>repackage</goal>\n          </goals>\n        </execution>\n      </executions>\n    </plugin>\n  </plugins>\n</build>\n\n\n如果引入了第三方 jar 包，如何打包？\n\n首先，要添加依赖\n\n<dependency>\n  <groupId>io.github.dunwu</groupId>\n  <artifactId>dunwu-common</artifactId>\n  <version>1.0.0</version>\n  <scope>system</scope>\n  <systemPath>${project.basedir}/src/main/resources/lib/dunwu-common-1.0.0.jar</systemPath>\n</dependency>\n\n\n接着，需要配置 spring-boot-maven-plugin 插件：\n\n<build>\n  <plugins>\n    <plugin>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-maven-plugin</artifactId>\n      <executions>\n        <execution>\n          <goals>\n            <goal>repackage</goal>\n          </goals>\n        </execution>\n      </executions>\n      <configuration>\n        <includeSystemScope>true</includeSystemScope>\n      </configuration>\n    </plugin>\n  </plugins>\n</build>\n\n\n\n# 去哪儿找 maven dependency\n\n问：刚接触 maven 的新手，往往会有这样的疑问，我该去哪儿找 jar？\n\n答：官方推荐的搜索 maven dependency 网址：\n\n * https://search.maven.org\n * https://repository.apache.org\n * https://mvnrepository.com\n\n\n# 如何指定编码\n\n问：众所周知，不同编码格式常常会产生意想不到的诡异问题，那么 maven 构建时如何指定 maven 构建时的编码？\n\n答：在 properties 中指定 project.build.sourceEncoding\n\n<properties>\n  <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n</properties>\n\n\n\n# 如何指定 JDK 版本\n\n问：如何指定 maven 构建时的 JDK 版本\n\n答：有两种方法：\n\n（1）properties 方式\n\n<project>\n  ...\n  <properties>\n    <maven.compiler.source>1.7</maven.compiler.source>\n    <maven.compiler.target>1.7</maven.compiler.target>\n  </properties>\n  ...\n</project>\n\n\n（2）使用 maven-compiler-plugin 插件，并指定 source 和 target 版本\n\n<build>\n...\n  <plugins>\n    <plugin>\n      <groupId>org.apache.maven.plugins</groupId>\n      <artifactId>maven-compiler-plugin</artifactId>\n      <version>3.3</version>\n      <configuration>\n        <source>1.7</source>\n        <target>1.7</target>\n      </configuration>\n    </plugin>\n  </plugins>\n...\n</build>\n\n\n\n# 如何避免将 dependency 打包到构件中\n\n答：指定 maven dependency 的 scope 为 provided，这意味着：依赖关系将在运行时由其容器或 JDK 提供。 具有此范围的依赖关系不会传递，也不会捆绑在诸如 WAR 之类的包中，也不会包含在运行时类路径中。\n\n\n# 如何跳过单元测试\n\n问：执行 mvn package 或 mvn install 时，会自动编译所有单元测试(src/test/java 目录下的代码)，如何跳过这一步？\n\n答：在执行命令的后面，添加命令行参数 -Dmaven.test.skip=true 或者 -DskipTests=true\n\n\n# 如何引入本地 jar\n\n问：有时候，需要引入在中央仓库找不到的 jar，但又想通过 maven 进行管理，那么应该如何做到呢？ 答：可以通过设置 dependency 的 scope 为 system 来引入本地 jar。 例：\n\n * 将私有 jar 放置在 resouces/lib 下，然后以如下方式添加依赖：\n * groupId 和 artifactId 可以按照 jar 包中的 package 设置，只要和其他 jar 不冲突即可。\n\n<dependency>\n    <groupId>xxx</groupId>\n    <artifactId>xxx</artifactId>\n    <version>1.0.0</version>\n    <scope>system</scope>\n    <systemPath>${project.basedir}/src/main/resources/lib/xxx-6.0.0.jar</systemPath>\n</dependency>\n\n\n\n# 如何排除依赖\n\n问：如何排除依赖一个依赖关系？比方项目中使用的 libA 依赖某个库的 1.0 版。libB 以来某个库的 2.0 版，如今想统一使用 2.0 版，怎样去掉 1.0 版的依赖？\n\n答：通过 exclusion 排除指定依赖即可。\n\n例：\n\n<dependency>\n    <groupId>org.apache.zookeeper</groupId>\n    <artifactId>zookeeper</artifactId>\n    <version>3.4.12</version>\n    <optional>true</optional>\n    <exclusions>\n        <exclusion>\n            <groupId>org.slf4j</groupId>\n            <artifactId>slf4j-log4j12</artifactId>\n        </exclusion>\n    </exclusions>\n</dependency>\n\n\n\n# Maven 最佳实践\n\n\n# 通过 bom 统一管理版本\n\n采用类似 spring-boot-dependencies 的方式统一管理依赖版本。\n\nspring-boot-dependencies 的 pom.xml 形式：\n\n<?xml version="1.0" encoding="UTF-8"?>\n<project xmlns="http://maven.apache.org/POM/4.0.0" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">\n<modelVersion>4.0.0</modelVersion>\n<groupId>org.springframework.boot</groupId>\n<artifactId>spring-boot-dependencies</artifactId>\n<version>2.1.9.RELEASE</version>\n<packaging>pom</packaging>\n\n\x3c!-- 省略 --\x3e\n\n\x3c!-- 依赖包版本管理 --\x3e\n<dependencyManagement>\n    <dependencies>\n    \x3c!-- 省略 --\x3e\n    </dependencies>\n</dependencyManagement>\n\n<build>\n\x3c!-- 插件版本管理 --\x3e\n<pluginManagement>\n    <plugins>\n    \x3c!-- 省略 --\x3e\n    </plugins>\n</pluginManagement>\n</build>\n</project>\n\n\n其他项目引入 spring-boot-dependencies 来管理依赖版本的方式：\n\n <dependencyManagement>\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-dependencies</artifactId>\n            <version>${spring-boot.version}</version>\n            <type>pom</type>\n            <scope>import</scope>\n        </dependency>\n    </dependencies>\n</dependencyManagement>\n',normalizedContent:'# maven 实战问题和最佳实践\n\n\n# maven 常见问题\n\n\n# dependencies 和 dependencymanagement，plugins 和 pluginmanagement 有什么区别\n\ndependencymanagement 是表示依赖 jar 包的声明，即你在项目中的 dependencymanagement 下声明了依赖，maven 不会加载该依赖，dependencymanagement 声明可以被继承。\n\ndependencymanagement 的一个使用案例是当有父子项目的时候，父项目中可以利用 dependencymanagement 声明子项目中需要用到的依赖 jar 包，之后，当某个或者某几个子项目需要加载该插件的时候，就可以在子项目中 dependencies 节点只配置 groupid 和 artifactid 就可以完成插件的引用。\n\ndependencymanagement 主要是为了统一管理插件，确保所有子项目使用的插件版本保持一致，类似的还有 plugins 和 pluginmanagement。\n\n\n# idea 修改 jdk 版本后编译报错\n\n错误现象：\n\n修改 jdk 版本，指定 maven-compiler-plugin 的 source 和 target 为 1.8 。\n\n然后，在 intellij idea 中执行 maven 指令，报错：\n\n[error] failed to execute goal org.apache.maven.plugins:maven-compiler-plugin:3.0:compile (default-compile) on project apollo-common: fatal error compiling: 无效的目标版本： 1.8 -> [help 1]\n\n\n错误原因：\n\nmaven 的 jdk 源与指定的 jdk 编译版本不符。\n\n排错手段：\n\n * 查看 project settings\n\nproject sdk 是否正确\n\n\n\nsdk 路径是否正确\n\n\n\n * 查看 settings > maven 的配置\n\njdk for importer 是否正确\n\n\n\nrunner 是否正确\n\n\n\n\n# 重复引入依赖\n\n在 idea 中，选中 module，使用 ctrl+alt+shift+u，打开依赖图，检索是否存在重复引用的情况。如果存在重复引用，可以将多余的引用删除。\n\n\n# 如何打包一个可以直接运行的 spring boot jar 包\n\n可以使用 spring-boot-maven-plugin 插件\n\n<build>\n  <plugins>\n    <plugin>\n      <groupid>org.springframework.boot</groupid>\n      <artifactid>spring-boot-maven-plugin</artifactid>\n      <executions>\n        <execution>\n          <goals>\n            <goal>repackage</goal>\n          </goals>\n        </execution>\n      </executions>\n    </plugin>\n  </plugins>\n</build>\n\n\n如果引入了第三方 jar 包，如何打包？\n\n首先，要添加依赖\n\n<dependency>\n  <groupid>io.github.dunwu</groupid>\n  <artifactid>dunwu-common</artifactid>\n  <version>1.0.0</version>\n  <scope>system</scope>\n  <systempath>${project.basedir}/src/main/resources/lib/dunwu-common-1.0.0.jar</systempath>\n</dependency>\n\n\n接着，需要配置 spring-boot-maven-plugin 插件：\n\n<build>\n  <plugins>\n    <plugin>\n      <groupid>org.springframework.boot</groupid>\n      <artifactid>spring-boot-maven-plugin</artifactid>\n      <executions>\n        <execution>\n          <goals>\n            <goal>repackage</goal>\n          </goals>\n        </execution>\n      </executions>\n      <configuration>\n        <includesystemscope>true</includesystemscope>\n      </configuration>\n    </plugin>\n  </plugins>\n</build>\n\n\n\n# 去哪儿找 maven dependency\n\n问：刚接触 maven 的新手，往往会有这样的疑问，我该去哪儿找 jar？\n\n答：官方推荐的搜索 maven dependency 网址：\n\n * https://search.maven.org\n * https://repository.apache.org\n * https://mvnrepository.com\n\n\n# 如何指定编码\n\n问：众所周知，不同编码格式常常会产生意想不到的诡异问题，那么 maven 构建时如何指定 maven 构建时的编码？\n\n答：在 properties 中指定 project.build.sourceencoding\n\n<properties>\n  <project.build.sourceencoding>utf-8</project.build.sourceencoding>\n</properties>\n\n\n\n# 如何指定 jdk 版本\n\n问：如何指定 maven 构建时的 jdk 版本\n\n答：有两种方法：\n\n（1）properties 方式\n\n<project>\n  ...\n  <properties>\n    <maven.compiler.source>1.7</maven.compiler.source>\n    <maven.compiler.target>1.7</maven.compiler.target>\n  </properties>\n  ...\n</project>\n\n\n（2）使用 maven-compiler-plugin 插件，并指定 source 和 target 版本\n\n<build>\n...\n  <plugins>\n    <plugin>\n      <groupid>org.apache.maven.plugins</groupid>\n      <artifactid>maven-compiler-plugin</artifactid>\n      <version>3.3</version>\n      <configuration>\n        <source>1.7</source>\n        <target>1.7</target>\n      </configuration>\n    </plugin>\n  </plugins>\n...\n</build>\n\n\n\n# 如何避免将 dependency 打包到构件中\n\n答：指定 maven dependency 的 scope 为 provided，这意味着：依赖关系将在运行时由其容器或 jdk 提供。 具有此范围的依赖关系不会传递，也不会捆绑在诸如 war 之类的包中，也不会包含在运行时类路径中。\n\n\n# 如何跳过单元测试\n\n问：执行 mvn package 或 mvn install 时，会自动编译所有单元测试(src/test/java 目录下的代码)，如何跳过这一步？\n\n答：在执行命令的后面，添加命令行参数 -dmaven.test.skip=true 或者 -dskiptests=true\n\n\n# 如何引入本地 jar\n\n问：有时候，需要引入在中央仓库找不到的 jar，但又想通过 maven 进行管理，那么应该如何做到呢？ 答：可以通过设置 dependency 的 scope 为 system 来引入本地 jar。 例：\n\n * 将私有 jar 放置在 resouces/lib 下，然后以如下方式添加依赖：\n * groupid 和 artifactid 可以按照 jar 包中的 package 设置，只要和其他 jar 不冲突即可。\n\n<dependency>\n    <groupid>xxx</groupid>\n    <artifactid>xxx</artifactid>\n    <version>1.0.0</version>\n    <scope>system</scope>\n    <systempath>${project.basedir}/src/main/resources/lib/xxx-6.0.0.jar</systempath>\n</dependency>\n\n\n\n# 如何排除依赖\n\n问：如何排除依赖一个依赖关系？比方项目中使用的 liba 依赖某个库的 1.0 版。libb 以来某个库的 2.0 版，如今想统一使用 2.0 版，怎样去掉 1.0 版的依赖？\n\n答：通过 exclusion 排除指定依赖即可。\n\n例：\n\n<dependency>\n    <groupid>org.apache.zookeeper</groupid>\n    <artifactid>zookeeper</artifactid>\n    <version>3.4.12</version>\n    <optional>true</optional>\n    <exclusions>\n        <exclusion>\n            <groupid>org.slf4j</groupid>\n            <artifactid>slf4j-log4j12</artifactid>\n        </exclusion>\n    </exclusions>\n</dependency>\n\n\n\n# maven 最佳实践\n\n\n# 通过 bom 统一管理版本\n\n采用类似 spring-boot-dependencies 的方式统一管理依赖版本。\n\nspring-boot-dependencies 的 pom.xml 形式：\n\n<?xml version="1.0" encoding="utf-8"?>\n<project xmlns="http://maven.apache.org/pom/4.0.0" xsi:schemalocation="http://maven.apache.org/pom/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd" xmlns:xsi="http://www.w3.org/2001/xmlschema-instance">\n<modelversion>4.0.0</modelversion>\n<groupid>org.springframework.boot</groupid>\n<artifactid>spring-boot-dependencies</artifactid>\n<version>2.1.9.release</version>\n<packaging>pom</packaging>\n\n\x3c!-- 省略 --\x3e\n\n\x3c!-- 依赖包版本管理 --\x3e\n<dependencymanagement>\n    <dependencies>\n    \x3c!-- 省略 --\x3e\n    </dependencies>\n</dependencymanagement>\n\n<build>\n\x3c!-- 插件版本管理 --\x3e\n<pluginmanagement>\n    <plugins>\n    \x3c!-- 省略 --\x3e\n    </plugins>\n</pluginmanagement>\n</build>\n</project>\n\n\n其他项目引入 spring-boot-dependencies 来管理依赖版本的方式：\n\n <dependencymanagement>\n    <dependencies>\n        <dependency>\n            <groupid>org.springframework.boot</groupid>\n            <artifactid>spring-boot-dependencies</artifactid>\n            <version>${spring-boot.version}</version>\n            <type>pom</type>\n            <scope>import</scope>\n        </dependency>\n    </dependencies>\n</dependencymanagement>\n',charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Maven 教程之发布 jar 到私服或中央仓库",frontmatter:{title:"Maven 教程之发布 jar 到私服或中央仓库",date:"2019-05-14T14:57:33.000Z",order:5,categories:["Java","软件","构建","Maven"],tags:["Java","构建","Maven"],permalink:"/pages/7bdaf9/"},regularPath:"/01.Java/11.%E8%BD%AF%E4%BB%B6/01.%E6%9E%84%E5%BB%BA/01.Maven/05.Maven%E6%95%99%E7%A8%8B%E4%B9%8B%E5%8F%91%E5%B8%83jar%E5%88%B0%E7%A7%81%E6%9C%8D%E6%88%96%E4%B8%AD%E5%A4%AE%E4%BB%93%E5%BA%93.html",relativePath:"01.Java/11.软件/01.构建/01.Maven/05.Maven教程之发布jar到私服或中央仓库.md",key:"v-030a633c",path:"/pages/7bdaf9/",headers:[{level:2,title:"发布 jar 包到中央仓库",slug:"发布-jar-包到中央仓库",normalizedTitle:"发布 jar 包到中央仓库",charIndex:31},{level:3,title:"在 Sonatype 创建 Issue",slug:"在-sonatype-创建-issue",normalizedTitle:"在 sonatype 创建 issue",charIndex:140},{level:3,title:"使用 GPG 生成公私钥对",slug:"使用-gpg-生成公私钥对",normalizedTitle:"使用 gpg 生成公私钥对",charIndex:605},{level:3,title:"Maven 配置",slug:"maven-配置",normalizedTitle:"maven 配置",charIndex:3332},{level:4,title:"settings.xml 配置",slug:"settings-xml-配置",normalizedTitle:"settings.xml 配置",charIndex:3401},{level:4,title:"pom.xml 配置",slug:"pom-xml-配置",normalizedTitle:"pom.xml 配置",charIndex:4723},{level:3,title:"部署和发布",slug:"部署和发布",normalizedTitle:"部署和发布",charIndex:7380},{level:2,title:"部署 maven 私服",slug:"部署-maven-私服",normalizedTitle:"部署 maven 私服",charIndex:7542},{level:3,title:"下载安装 Nexus",slug:"下载安装-nexus",normalizedTitle:"下载安装 nexus",charIndex:7672},{level:3,title:"启动停止 Nexus",slug:"启动停止-nexus",normalizedTitle:"启动停止 nexus",charIndex:8084},{level:3,title:"使用 Nexus",slug:"使用-nexus",normalizedTitle:"使用 nexus",charIndex:8738},{level:4,title:"配置 settings.xml",slug:"配置-settings-xml",normalizedTitle:"配置 settings.xml",charIndex:8713},{level:4,title:"配置 pom.xml",slug:"配置-pom-xml",normalizedTitle:"配置 pom.xml",charIndex:10530},{level:4,title:"执行 maven 构建",slug:"执行-maven-构建",normalizedTitle:"执行 maven 构建",charIndex:11092},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:11310}],headersStr:"发布 jar 包到中央仓库 在 Sonatype 创建 Issue 使用 GPG 生成公私钥对 Maven 配置 settings.xml 配置 pom.xml 配置 部署和发布 部署 maven 私服 下载安装 Nexus 启动停止 Nexus 使用 Nexus 配置 settings.xml 配置 pom.xml 执行 maven 构建 参考资料",content:'# Maven 教程之发布 jar 到私服或中央仓库\n\n\n# 发布 jar 包到中央仓库\n\n> 为了避免重复造轮子，相信每个 Java 程序员都想打造自己的脚手架或工具包（自己定制的往往才是最适合自己的）。那么如何将自己的脚手架发布到中央仓库呢？下面我们将一步步来实现。\n\n\n# 在 Sonatype 创建 Issue\n\n（1）注册 Sonatype 账号\n\n发布 Java 包到 Maven 中央仓库，首先需要在 Sonatype 网站创建一个工单(Issues)。\n\n第一次使用这个网站的时候需要注册自己的帐号（这个帐号和密码需要记住，后面会用到）。\n\n（2）创建 Issue\n\n注册账号成功后，根据你 Java 包的功能分别写上Summary、Description、Group Id、SCM url以及Project URL等必要信息，可以参见我之前创建的 Issue：OSSRH-36187。\n\n\n\n创建完之后需要等待 Sonatype 的工作人员审核处理，审核时间还是很快的，我的审核差不多等待了两小时。当 Issue 的 Status 变为RESOLVED后，就可以进行下一步操作了。\n\n> 说明：如果你的 Group Id 填写的是自己的网站（我的就是这种情况），Sonatype 的工作人员会询问你那个 Group Id 是不是你的域名，你只需要在上面回答是就行，然后就会通过审核。\n\n\n# 使用 GPG 生成公私钥对\n\n（1）安装 Gpg4win\n\nWindows 系统，可以下载 Gpg4win 软件来生成密钥对。\n\nGpg4win 下载地址\n\n安装后，执行命令 gpg --version 检查是否安装成功。\n\nC:\\Program Files (x86)\\GnuPG\\bin>gpg --version\ngpg (GnuPG) 2.2.10\nlibgcrypt 1.8.3\nCopyright (C) 2018 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later <https://gnu.org/licenses/gpl.html>\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the exdunwu permitted by law.\n\nHome: C:/Users/Administrator/AppData/Roaming/gnupg\nSupported algorithms:\nPubkey: RSA, ELG, DSA, ECDH, ECDSA, EDDSA\nCipher: IDEA, 3DES, CAST5, BLOWFISH, AES, AES192, AES256, TWOFISH,\n        CAMELLIA128, CAMELLIA192, CAMELLIA256\nHash: SHA1, RIPEMD160, SHA256, SHA384, SHA512, SHA224\nCompression: Uncompressed, ZIP, ZLIB, BZIP2\n\n\n（2）生成密钥对\n\n执行命令 gpg --gen-key\n\nC:\\Program Files (x86)\\GnuPG\\bin>gpg --gen-key\ngpg (GnuPG) 2.2.10; Copyright (C) 2018 Free Software Foundation, Inc.\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the exdunwu permitted by law.\n\nNote: Use "gpg --full-generate-key" for a full featured key generation dialog.\n\nGnuPG needs to construct a user ID to identify your key.\n\nReal name: Zhang Peng\nEmail address: forbreak@163.com\nYou selected this USER-ID:\n    "Zhang Peng <forbreak@163.com>"\n\nChange (N)ame, (E)mail, or (O)kay/(Q)uit? O\n\n\n说明：按照提示，依次输入用户名、邮箱。\n\n（3）查看公钥\n\nC:\\Program Files (x86)\\GnuPG\\bin>gpg --list-keys\n\ngpg: checking the trustdb\ngpg: marginals needed: 3  completes needed: 1  trust model: pgp\ngpg: depth: 0  valid:   2  signed:   0  trust: 0-, 0q, 0n, 0m, 0f, 2u\ngpg: next trustdb check due at 2020-11-05\nC:/Users/Administrator/AppData/Roaming/gnupg/pubring.kbx\n--------------------------------------------------------\npub   rsa2048 2018-11-06 [SC] [expires: 2020-11-06]\n      E4CE537A3803D49C35332221A306519BAFF57F60\nuid           [ultimate] forbreak <forbreak@163.com>\nsub   rsa2048 2018-11-06 [E] [expires: 2020-11-06]\n\n\n> 说明：其中，E4CE537A3803D49C35332221A306519BAFF57F60 就是公钥\n\n（4）将公钥发布到 PGP 密钥服务器\n\n执行 gpg --keyserver hkp://pool.sks-keyservers.net --send-keys 发布公钥：\n\nC:\\Program Files (x86)\\GnuPG\\bin>gpg --keyserver hkp://pool.sks-keyservers.net --send-keys E4CE537A3803D49C35332221A306519BAFF57F60\ngpg: sending key A306519BAFF57F60 to hkp://pool.sks-keyservers.net\n\n\n> 🔔 注意：有可能出现 gpg: keyserver receive failed: No dat 错误，等大约 30 分钟后再执行就不会报错了。\n\n（5）查看公钥是否发布成功\n\n执行 gpg --keyserver hkp://pool.sks-keyservers.net --recv-keys 查看公钥是否发布成功。\n\nC:\\Program Files (x86)\\GnuPG\\bin>gpg --keyserver hkp://pool.sks-keyservers.net --recv-keys E4CE537A3803D49C35332221A306519BAFF57F60\ngpg: key A306519BAFF57F60: "forbreak <forbreak@163.com>" not changed\ngpg: Total number processed: 1\ngpg:              unchanged: 1\n\n\n\n# Maven 配置\n\n完成了前两个章节的准备工作，就可以将 jar 包上传到中央仓库了。当然了，我们还要对 maven 做一些配置。\n\n# settings.xml 配置\n\n一份完整的 settings.xml 配置示例如下：\n\n<?xml version="1.0" encoding="UTF-8"?>\n\n<settings xmlns="http://maven.apache.org/SETTINGS/1.0.0"\n  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd">\n\n  <pluginGroups>\n    <pluginGroup>org.sonatype.plugins</pluginGroup>\n  </pluginGroups>\n\n  \x3c!-- 用户名、密码就是 Sonatype 账号、密码 --\x3e\n  <servers>\n    <server>\n      <id>sonatype-snapshots</id>\n      <username>xxxxxx</username>\n      <password>xxxxxx</password>\n    </server>\n    <server>\n      <id>sonatype-staging</id>\n      <username>xxxxxx</username>\n      <password>xxxxxx</password>\n    </server>\n  </servers>\n\n  \x3c!-- 使用 aliyun maven 仓库加速下载 --\x3e\n  <mirrors>\n    <mirror>\n      <id>nexus-aliyun</id>\n      <mirrorOf>*</mirrorOf>\n      <name>Aliyun</name>\n      <url>http://maven.aliyun.com/nexus/groups/public</url>\n    </mirror>\n  </mirrors>\n\n  \x3c!-- gpg 的密码，注意，这里不是指公钥 --\x3e\n  <profiles>\n    <profile>\n      <id>sonatype</id>\n      <properties>\n        <gpg.executable>C:/Program Files (x86)/GnuPG/bin/gpg.exe</gpg.executable>\n        <gpg.passphrase>xxxxxx</gpg.passphrase>\n      </properties>\n    </profile>\n  </profiles>\n\n  <activeProfiles>\n    <activeProfile>sonatype</activeProfile>\n  </activeProfiles>\n</settings>\n\n\n# pom.xml 配置\n\n（1）添加 licenses、scm、developers 配置：\n\n<licenses>\n  <license>\n    <name>The Apache Software License, Version 2.0</name>\n    <url>http://www.apache.org/licenses/LICENSE-2.0.txt</url>\n    <distribution>repo</distribution>\n  </license>\n</licenses>\n\n<developers>\n  <developer>\n    <name>xxxxxx</name>\n    <email>forbreak@163.com</email>\n    <url>https://github.com/dunwu</url>\n  </developer>\n</developers>\n\n<scm>\n  <url>https://github.com/dunwu/dunwu</url>\n  <connection>git@github.com:dunwu/dunwu.git</connection>\n  <developerConnection>https://github.com/dunwu</developerConnection>\n</scm>\n\n\n（2）添加 distributionManagement 配置\n\n<distributionManagement>\n  <snapshotRepository>\n    <id>sonatype-snapshots</id>\n    <url>https://oss.sonatype.org/content/repositories/snapshots</url>\n  </snapshotRepository>\n  <repository>\n    <id>sonatype-staging</id>\n    <url>https://oss.sonatype.org/service/local/staging/deploy/maven2</url>\n  </repository>\n</distributionManagement>\n\n\n> 说明：<snapshotRepository> 指定的是 snapshot 仓库地址；<repository> 指定的是 staging （正式版）仓库地址。需要留意的是，这里的 id 需要和 settings.xml 中的 <server> 的 id 保持一致。\n\n（3）添加 profiles 配置\n\n <profiles>\n  <profile>\n    <id>sonatype</id>\n    <build>\n      <plugins>\n        <plugin>\n          <groupId>org.sonatype.plugins</groupId>\n          <artifactId>nexus-staging-maven-plugin</artifactId>\n          <version>1.6.7</version>\n          <extensions>true</extensions>\n          <configuration>\n            <serverId>sonatype-snapshots</serverId>\n            <nexusUrl>https://oss.sonatype.org/</nexusUrl>\n            <autoReleaseAfterClose>true</autoReleaseAfterClose>\n          </configuration>\n        </plugin>\n        <plugin>\n          <groupId>org.apache.maven.plugins</groupId>\n          <artifactId>maven-javadoc-plugin</artifactId>\n          <version>3.0.1</version>\n          <configuration>\n            <failOnError>false</failOnError>\n            <quiet>true</quiet>\n          </configuration>\n          <executions>\n            <execution>\n              <id>attach-javadocs</id>\n              <goals>\n                <goal>jar</goal>\n              </goals>\n            </execution>\n          </executions>\n        </plugin>\n\n        <plugin>\n          <groupId>org.apache.maven.plugins</groupId>\n          <artifactId>maven-gpg-plugin</artifactId>\n          <version>1.6</version>\n          <executions>\n            <execution>\n              <id>sign-artifacts</id>\n              <phase>verify</phase>\n              <goals>\n                <goal>sign</goal>\n              </goals>\n            </execution>\n          </executions>\n        </plugin>\n      </plugins>\n    </build>\n  </profile>\n</profiles>\n\n\n\n# 部署和发布\n\n按照上面的步骤配置完后，一切都已经 OK。\n\n此时，使用 mvn clean deploy -P sonatype 命令就可以发布 jar 包到中央仓库了：\n\n> 说明：-P 参数后面的 sonatype 需要和 pom.xml 中 <profile> 的 id 保持一致，才能激活 profile。\n\n\n# 部署 maven 私服\n\n> 工作中，Java 程序员开发的商用 Java 项目，一般不想发布到中央仓库，使得人人尽知。这时，我们就需要搭建私服，将 maven 服务器部署在公司内部网络，从而避免 jar 包流传出去。怎么做呢，让我们来一步步学习吧。\n\n\n# 下载安装 Nexus\n\n进入官方下载地址，选择合适版本下载。\n\n\n\n本人希望将 Nexus 部署在 Linux 机器，所以选用的是 Unix 版本。\n\n这里，如果想通过命令方式直接下载（比如用脚本安装），可以在官方历史发布版本页面中找到合适版本，然后执行以下命令：\n\nwget -O /opt/maven/nexus-unix.tar.gz http://download.sonatype.com/nexus/3/nexus-3.13.0-01-unix.tar.gz\ntar -zxf nexus-unix.tar.gz\n\n\n解压后，有两个目录：\n\n * nexus-3.13.0-01 - 包含了 Nexus 运行所需要的文件。是 Nexus 运行必须的。\n * sonatype-work - 包含了 Nexus 生成的配置文件、日志文件、仓库文件等。当我们需要备份 Nexus 的时候默认备份此目录即可。\n\n\n# 启动停止 Nexus\n\n进入 nexus-3.13.0-01/bin 目录，有一个可执行脚本 nexus。\n\n执行 ./nexus，可以查看允许执行的参数，如下所示，含义可谓一目了然：\n\n$ ./nexus\nUsage: ./nexus {start|stop|run|run-redirect|status|restart|force-reload}\n\n\n * 启动 nexus - ./nexus start\n * 停止 nexus -\n\n启动成功后，在浏览器中访问 http://<ip>:8081，欢迎页面如下图所示：\n\n\n\n点击右上角 Sign in 登录，默认用户名/密码为：admin/admin123。\n\n有必要提一下的是，在 Nexus 的 Repositories 管理页面，展示了可用的 maven 仓库，如下图所示：\n\n\n\n> 说明：\n> \n>  * maven-central - maven 中央库（如果没有配置 mirror，默认就从这里下载 jar 包），从 https://repo1.maven.org/maven2/ 获取资源\n>  * maven-releases - 存储私有仓库的发行版 jar 包\n>  * maven-snapshots - 存储私有仓库的快照版（调试版本） jar 包\n>  * maven-public - 私有仓库的公共空间，把上面三个仓库组合在一起对外提供服务，在本地 maven 基础配置 settings.xml 中使用。\n\n\n# 使用 Nexus\n\n如果要使用 Nexus，还必须在 settings.xml 和 pom.xml 中配置认证信息。\n\n# 配置 settings.xml\n\n一份完整的 settings.xml：\n\n<?xml version="1.0" encoding="UTF-8"?>\n\n<settings xmlns="http://maven.apache.org/SETTINGS/1.0.0"\n  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd">\n  <pluginGroups>\n    <pluginGroup>org.sonatype.plugins</pluginGroup>\n  </pluginGroups>\n\n  \x3c!-- Maven 私服账号信息 --\x3e\n  <servers>\n    <server>\n      <id>releases</id>\n      <username>admin</username>\n      <password>admin123</password>\n    </server>\n    <server>\n      <id>snapshots</id>\n      <username>admin</username>\n      <password>admin123</password>\n    </server>\n  </servers>\n\n  \x3c!-- jar 包下载地址 --\x3e\n  <mirrors>\n    <mirror>\n      <id>public</id>\n      <mirrorOf>*</mirrorOf>\n      <url>http://10.255.255.224:8081/repository/maven-public/</url>\n    </mirror>\n  </mirrors>\n\n  <profiles>\n    <profile>\n      <id>zp</id>\n      <repositories>\n        <repository>\n          <id>central</id>\n          <url>http://central</url>\n          <releases>\n            <enabled>true</enabled>\n          </releases>\n          <snapshots>\n            <enabled>true</enabled>\n          </snapshots>\n        </repository>\n      </repositories>\n      <pluginRepositories>\n        <pluginRepository>\n          <id>central</id>\n          <url>http://central</url>\n          <releases>\n            <enabled>true</enabled>\n          </releases>\n          <snapshots>\n            <enabled>true</enabled>\n            <updatePolicy>always</updatePolicy>\n          </snapshots>\n        </pluginRepository>\n      </pluginRepositories>\n    </profile>\n  </profiles>\n\n  <activeProfiles>\n    <activeProfile>zp</activeProfile>\n  </activeProfiles>\n</settings>\n\n\n# 配置 pom.xml\n\n在 pom.xml 中添加如下配置：\n\n  <distributionManagement>\n    <repository>\n      <id>releases</id>\n      <name>Releases</name>\n      <url>http://10.255.255.224:8081/repository/maven-releases</url>\n    </repository>\n    <snapshotRepository>\n      <id>snapshots</id>\n      <name>Snapshot</name>\n      <url>http://10.255.255.224:8081/repository/maven-snapshots</url>\n    </snapshotRepository>\n  </distributionManagement>\n\n\n> 🔔 注意：\n> \n>  * <repository> 和 <snapshotRepository> 的 id 必须和 settings.xml 配置文件中的 <server> 标签中的 id 匹配。\n>  * <url> 标签的地址需要和 maven 私服的地址匹配。\n\n# 执行 maven 构建\n\n如果要使用 settings.xml 中的私服配置，必须通过指定 -P zp 来激活 profile。\n\n示例：\n\n## 编译并打包 maven 项目\n$ mvn clean package -Dmaven.skip.test=true -P zp\n\n## 编译并上传 maven 交付件（jar 包）\n$ mvn clean deploy -Dmaven.skip.test=true -P zp\n\n\n\n# 参考资料\n\n * https://www.jianshu.com/p/8c3d7fb09bce\n * http://www.ruanyifeng.com/blog/2013/07/gpg.html\n * https://www.cnblogs.com/hoobey/p/6102382.html\n * https://blog.csdn.net/wzygis/article/details/49276779\n * https://blog.csdn.net/clj198606061111/article/details/52200928',normalizedContent:'# maven 教程之发布 jar 到私服或中央仓库\n\n\n# 发布 jar 包到中央仓库\n\n> 为了避免重复造轮子，相信每个 java 程序员都想打造自己的脚手架或工具包（自己定制的往往才是最适合自己的）。那么如何将自己的脚手架发布到中央仓库呢？下面我们将一步步来实现。\n\n\n# 在 sonatype 创建 issue\n\n（1）注册 sonatype 账号\n\n发布 java 包到 maven 中央仓库，首先需要在 sonatype 网站创建一个工单(issues)。\n\n第一次使用这个网站的时候需要注册自己的帐号（这个帐号和密码需要记住，后面会用到）。\n\n（2）创建 issue\n\n注册账号成功后，根据你 java 包的功能分别写上summary、description、group id、scm url以及project url等必要信息，可以参见我之前创建的 issue：ossrh-36187。\n\n\n\n创建完之后需要等待 sonatype 的工作人员审核处理，审核时间还是很快的，我的审核差不多等待了两小时。当 issue 的 status 变为resolved后，就可以进行下一步操作了。\n\n> 说明：如果你的 group id 填写的是自己的网站（我的就是这种情况），sonatype 的工作人员会询问你那个 group id 是不是你的域名，你只需要在上面回答是就行，然后就会通过审核。\n\n\n# 使用 gpg 生成公私钥对\n\n（1）安装 gpg4win\n\nwindows 系统，可以下载 gpg4win 软件来生成密钥对。\n\ngpg4win 下载地址\n\n安装后，执行命令 gpg --version 检查是否安装成功。\n\nc:\\program files (x86)\\gnupg\\bin>gpg --version\ngpg (gnupg) 2.2.10\nlibgcrypt 1.8.3\ncopyright (c) 2018 free software foundation, inc.\nlicense gplv3+: gnu gpl version 3 or later <https://gnu.org/licenses/gpl.html>\nthis is free software: you are free to change and redistribute it.\nthere is no warranty, to the exdunwu permitted by law.\n\nhome: c:/users/administrator/appdata/roaming/gnupg\nsupported algorithms:\npubkey: rsa, elg, dsa, ecdh, ecdsa, eddsa\ncipher: idea, 3des, cast5, blowfish, aes, aes192, aes256, twofish,\n        camellia128, camellia192, camellia256\nhash: sha1, ripemd160, sha256, sha384, sha512, sha224\ncompression: uncompressed, zip, zlib, bzip2\n\n\n（2）生成密钥对\n\n执行命令 gpg --gen-key\n\nc:\\program files (x86)\\gnupg\\bin>gpg --gen-key\ngpg (gnupg) 2.2.10; copyright (c) 2018 free software foundation, inc.\nthis is free software: you are free to change and redistribute it.\nthere is no warranty, to the exdunwu permitted by law.\n\nnote: use "gpg --full-generate-key" for a full featured key generation dialog.\n\ngnupg needs to construct a user id to identify your key.\n\nreal name: zhang peng\nemail address: forbreak@163.com\nyou selected this user-id:\n    "zhang peng <forbreak@163.com>"\n\nchange (n)ame, (e)mail, or (o)kay/(q)uit? o\n\n\n说明：按照提示，依次输入用户名、邮箱。\n\n（3）查看公钥\n\nc:\\program files (x86)\\gnupg\\bin>gpg --list-keys\n\ngpg: checking the trustdb\ngpg: marginals needed: 3  completes needed: 1  trust model: pgp\ngpg: depth: 0  valid:   2  signed:   0  trust: 0-, 0q, 0n, 0m, 0f, 2u\ngpg: next trustdb check due at 2020-11-05\nc:/users/administrator/appdata/roaming/gnupg/pubring.kbx\n--------------------------------------------------------\npub   rsa2048 2018-11-06 [sc] [expires: 2020-11-06]\n      e4ce537a3803d49c35332221a306519baff57f60\nuid           [ultimate] forbreak <forbreak@163.com>\nsub   rsa2048 2018-11-06 [e] [expires: 2020-11-06]\n\n\n> 说明：其中，e4ce537a3803d49c35332221a306519baff57f60 就是公钥\n\n（4）将公钥发布到 pgp 密钥服务器\n\n执行 gpg --keyserver hkp://pool.sks-keyservers.net --send-keys 发布公钥：\n\nc:\\program files (x86)\\gnupg\\bin>gpg --keyserver hkp://pool.sks-keyservers.net --send-keys e4ce537a3803d49c35332221a306519baff57f60\ngpg: sending key a306519baff57f60 to hkp://pool.sks-keyservers.net\n\n\n> 🔔 注意：有可能出现 gpg: keyserver receive failed: no dat 错误，等大约 30 分钟后再执行就不会报错了。\n\n（5）查看公钥是否发布成功\n\n执行 gpg --keyserver hkp://pool.sks-keyservers.net --recv-keys 查看公钥是否发布成功。\n\nc:\\program files (x86)\\gnupg\\bin>gpg --keyserver hkp://pool.sks-keyservers.net --recv-keys e4ce537a3803d49c35332221a306519baff57f60\ngpg: key a306519baff57f60: "forbreak <forbreak@163.com>" not changed\ngpg: total number processed: 1\ngpg:              unchanged: 1\n\n\n\n# maven 配置\n\n完成了前两个章节的准备工作，就可以将 jar 包上传到中央仓库了。当然了，我们还要对 maven 做一些配置。\n\n# settings.xml 配置\n\n一份完整的 settings.xml 配置示例如下：\n\n<?xml version="1.0" encoding="utf-8"?>\n\n<settings xmlns="http://maven.apache.org/settings/1.0.0"\n  xmlns:xsi="http://www.w3.org/2001/xmlschema-instance" xsi:schemalocation="http://maven.apache.org/settings/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd">\n\n  <plugingroups>\n    <plugingroup>org.sonatype.plugins</plugingroup>\n  </plugingroups>\n\n  \x3c!-- 用户名、密码就是 sonatype 账号、密码 --\x3e\n  <servers>\n    <server>\n      <id>sonatype-snapshots</id>\n      <username>xxxxxx</username>\n      <password>xxxxxx</password>\n    </server>\n    <server>\n      <id>sonatype-staging</id>\n      <username>xxxxxx</username>\n      <password>xxxxxx</password>\n    </server>\n  </servers>\n\n  \x3c!-- 使用 aliyun maven 仓库加速下载 --\x3e\n  <mirrors>\n    <mirror>\n      <id>nexus-aliyun</id>\n      <mirrorof>*</mirrorof>\n      <name>aliyun</name>\n      <url>http://maven.aliyun.com/nexus/groups/public</url>\n    </mirror>\n  </mirrors>\n\n  \x3c!-- gpg 的密码，注意，这里不是指公钥 --\x3e\n  <profiles>\n    <profile>\n      <id>sonatype</id>\n      <properties>\n        <gpg.executable>c:/program files (x86)/gnupg/bin/gpg.exe</gpg.executable>\n        <gpg.passphrase>xxxxxx</gpg.passphrase>\n      </properties>\n    </profile>\n  </profiles>\n\n  <activeprofiles>\n    <activeprofile>sonatype</activeprofile>\n  </activeprofiles>\n</settings>\n\n\n# pom.xml 配置\n\n（1）添加 licenses、scm、developers 配置：\n\n<licenses>\n  <license>\n    <name>the apache software license, version 2.0</name>\n    <url>http://www.apache.org/licenses/license-2.0.txt</url>\n    <distribution>repo</distribution>\n  </license>\n</licenses>\n\n<developers>\n  <developer>\n    <name>xxxxxx</name>\n    <email>forbreak@163.com</email>\n    <url>https://github.com/dunwu</url>\n  </developer>\n</developers>\n\n<scm>\n  <url>https://github.com/dunwu/dunwu</url>\n  <connection>git@github.com:dunwu/dunwu.git</connection>\n  <developerconnection>https://github.com/dunwu</developerconnection>\n</scm>\n\n\n（2）添加 distributionmanagement 配置\n\n<distributionmanagement>\n  <snapshotrepository>\n    <id>sonatype-snapshots</id>\n    <url>https://oss.sonatype.org/content/repositories/snapshots</url>\n  </snapshotrepository>\n  <repository>\n    <id>sonatype-staging</id>\n    <url>https://oss.sonatype.org/service/local/staging/deploy/maven2</url>\n  </repository>\n</distributionmanagement>\n\n\n> 说明：<snapshotrepository> 指定的是 snapshot 仓库地址；<repository> 指定的是 staging （正式版）仓库地址。需要留意的是，这里的 id 需要和 settings.xml 中的 <server> 的 id 保持一致。\n\n（3）添加 profiles 配置\n\n <profiles>\n  <profile>\n    <id>sonatype</id>\n    <build>\n      <plugins>\n        <plugin>\n          <groupid>org.sonatype.plugins</groupid>\n          <artifactid>nexus-staging-maven-plugin</artifactid>\n          <version>1.6.7</version>\n          <extensions>true</extensions>\n          <configuration>\n            <serverid>sonatype-snapshots</serverid>\n            <nexusurl>https://oss.sonatype.org/</nexusurl>\n            <autoreleaseafterclose>true</autoreleaseafterclose>\n          </configuration>\n        </plugin>\n        <plugin>\n          <groupid>org.apache.maven.plugins</groupid>\n          <artifactid>maven-javadoc-plugin</artifactid>\n          <version>3.0.1</version>\n          <configuration>\n            <failonerror>false</failonerror>\n            <quiet>true</quiet>\n          </configuration>\n          <executions>\n            <execution>\n              <id>attach-javadocs</id>\n              <goals>\n                <goal>jar</goal>\n              </goals>\n            </execution>\n          </executions>\n        </plugin>\n\n        <plugin>\n          <groupid>org.apache.maven.plugins</groupid>\n          <artifactid>maven-gpg-plugin</artifactid>\n          <version>1.6</version>\n          <executions>\n            <execution>\n              <id>sign-artifacts</id>\n              <phase>verify</phase>\n              <goals>\n                <goal>sign</goal>\n              </goals>\n            </execution>\n          </executions>\n        </plugin>\n      </plugins>\n    </build>\n  </profile>\n</profiles>\n\n\n\n# 部署和发布\n\n按照上面的步骤配置完后，一切都已经 ok。\n\n此时，使用 mvn clean deploy -p sonatype 命令就可以发布 jar 包到中央仓库了：\n\n> 说明：-p 参数后面的 sonatype 需要和 pom.xml 中 <profile> 的 id 保持一致，才能激活 profile。\n\n\n# 部署 maven 私服\n\n> 工作中，java 程序员开发的商用 java 项目，一般不想发布到中央仓库，使得人人尽知。这时，我们就需要搭建私服，将 maven 服务器部署在公司内部网络，从而避免 jar 包流传出去。怎么做呢，让我们来一步步学习吧。\n\n\n# 下载安装 nexus\n\n进入官方下载地址，选择合适版本下载。\n\n\n\n本人希望将 nexus 部署在 linux 机器，所以选用的是 unix 版本。\n\n这里，如果想通过命令方式直接下载（比如用脚本安装），可以在官方历史发布版本页面中找到合适版本，然后执行以下命令：\n\nwget -o /opt/maven/nexus-unix.tar.gz http://download.sonatype.com/nexus/3/nexus-3.13.0-01-unix.tar.gz\ntar -zxf nexus-unix.tar.gz\n\n\n解压后，有两个目录：\n\n * nexus-3.13.0-01 - 包含了 nexus 运行所需要的文件。是 nexus 运行必须的。\n * sonatype-work - 包含了 nexus 生成的配置文件、日志文件、仓库文件等。当我们需要备份 nexus 的时候默认备份此目录即可。\n\n\n# 启动停止 nexus\n\n进入 nexus-3.13.0-01/bin 目录，有一个可执行脚本 nexus。\n\n执行 ./nexus，可以查看允许执行的参数，如下所示，含义可谓一目了然：\n\n$ ./nexus\nusage: ./nexus {start|stop|run|run-redirect|status|restart|force-reload}\n\n\n * 启动 nexus - ./nexus start\n * 停止 nexus -\n\n启动成功后，在浏览器中访问 http://<ip>:8081，欢迎页面如下图所示：\n\n\n\n点击右上角 sign in 登录，默认用户名/密码为：admin/admin123。\n\n有必要提一下的是，在 nexus 的 repositories 管理页面，展示了可用的 maven 仓库，如下图所示：\n\n\n\n> 说明：\n> \n>  * maven-central - maven 中央库（如果没有配置 mirror，默认就从这里下载 jar 包），从 https://repo1.maven.org/maven2/ 获取资源\n>  * maven-releases - 存储私有仓库的发行版 jar 包\n>  * maven-snapshots - 存储私有仓库的快照版（调试版本） jar 包\n>  * maven-public - 私有仓库的公共空间，把上面三个仓库组合在一起对外提供服务，在本地 maven 基础配置 settings.xml 中使用。\n\n\n# 使用 nexus\n\n如果要使用 nexus，还必须在 settings.xml 和 pom.xml 中配置认证信息。\n\n# 配置 settings.xml\n\n一份完整的 settings.xml：\n\n<?xml version="1.0" encoding="utf-8"?>\n\n<settings xmlns="http://maven.apache.org/settings/1.0.0"\n  xmlns:xsi="http://www.w3.org/2001/xmlschema-instance" xsi:schemalocation="http://maven.apache.org/settings/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd">\n  <plugingroups>\n    <plugingroup>org.sonatype.plugins</plugingroup>\n  </plugingroups>\n\n  \x3c!-- maven 私服账号信息 --\x3e\n  <servers>\n    <server>\n      <id>releases</id>\n      <username>admin</username>\n      <password>admin123</password>\n    </server>\n    <server>\n      <id>snapshots</id>\n      <username>admin</username>\n      <password>admin123</password>\n    </server>\n  </servers>\n\n  \x3c!-- jar 包下载地址 --\x3e\n  <mirrors>\n    <mirror>\n      <id>public</id>\n      <mirrorof>*</mirrorof>\n      <url>http://10.255.255.224:8081/repository/maven-public/</url>\n    </mirror>\n  </mirrors>\n\n  <profiles>\n    <profile>\n      <id>zp</id>\n      <repositories>\n        <repository>\n          <id>central</id>\n          <url>http://central</url>\n          <releases>\n            <enabled>true</enabled>\n          </releases>\n          <snapshots>\n            <enabled>true</enabled>\n          </snapshots>\n        </repository>\n      </repositories>\n      <pluginrepositories>\n        <pluginrepository>\n          <id>central</id>\n          <url>http://central</url>\n          <releases>\n            <enabled>true</enabled>\n          </releases>\n          <snapshots>\n            <enabled>true</enabled>\n            <updatepolicy>always</updatepolicy>\n          </snapshots>\n        </pluginrepository>\n      </pluginrepositories>\n    </profile>\n  </profiles>\n\n  <activeprofiles>\n    <activeprofile>zp</activeprofile>\n  </activeprofiles>\n</settings>\n\n\n# 配置 pom.xml\n\n在 pom.xml 中添加如下配置：\n\n  <distributionmanagement>\n    <repository>\n      <id>releases</id>\n      <name>releases</name>\n      <url>http://10.255.255.224:8081/repository/maven-releases</url>\n    </repository>\n    <snapshotrepository>\n      <id>snapshots</id>\n      <name>snapshot</name>\n      <url>http://10.255.255.224:8081/repository/maven-snapshots</url>\n    </snapshotrepository>\n  </distributionmanagement>\n\n\n> 🔔 注意：\n> \n>  * <repository> 和 <snapshotrepository> 的 id 必须和 settings.xml 配置文件中的 <server> 标签中的 id 匹配。\n>  * <url> 标签的地址需要和 maven 私服的地址匹配。\n\n# 执行 maven 构建\n\n如果要使用 settings.xml 中的私服配置，必须通过指定 -p zp 来激活 profile。\n\n示例：\n\n## 编译并打包 maven 项目\n$ mvn clean package -dmaven.skip.test=true -p zp\n\n## 编译并上传 maven 交付件（jar 包）\n$ mvn clean deploy -dmaven.skip.test=true -p zp\n\n\n\n# 参考资料\n\n * https://www.jianshu.com/p/8c3d7fb09bce\n * http://www.ruanyifeng.com/blog/2013/07/gpg.html\n * https://www.cnblogs.com/hoobey/p/6102382.html\n * https://blog.csdn.net/wzygis/article/details/49276779\n * https://blog.csdn.net/clj198606061111/article/details/52200928',charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Maven 插件之代码检查",frontmatter:{title:"Maven 插件之代码检查",date:"2019-12-16T17:09:26.000Z",order:6,categories:["Java","软件","构建","Maven"],tags:["Java","构建","Maven"],permalink:"/pages/370f1d/"},regularPath:"/01.Java/11.%E8%BD%AF%E4%BB%B6/01.%E6%9E%84%E5%BB%BA/01.Maven/06.Maven%E6%8F%92%E4%BB%B6%E4%B9%8B%E4%BB%A3%E7%A0%81%E6%A3%80%E6%9F%A5.html",relativePath:"01.Java/11.软件/01.构建/01.Maven/06.Maven插件之代码检查.md",key:"v-ecc5245e",path:"/pages/370f1d/",headers:[{level:2,title:"maven-checkstyle-plugin",slug:"maven-checkstyle-plugin",normalizedTitle:"maven-checkstyle-plugin",charIndex:20},{level:3,title:"定义 checkstyle.xml",slug:"定义-checkstyle-xml",normalizedTitle:"定义 checkstyle.xml",charIndex:92},{level:2,title:"maven-pmd-plugin",slug:"maven-pmd-plugin",normalizedTitle:"maven-pmd-plugin",charIndex:13708},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:15423}],headersStr:"maven-checkstyle-plugin 定义 checkstyle.xml maven-pmd-plugin 参考资料",content:'# Maven 插件之代码检查\n\n\n# maven-checkstyle-plugin\n\n> maven-checkstyle-plugin，用于检测代码中不符合规范的地方。\n\n\n# 定义 checkstyle.xml\n\n<!DOCTYPE module PUBLIC\n  "-//Checkstyle//DTD Checkstyle Configuration 1.3//EN"\n  "https://checkstyle.org/dtds/configuration_1_3.dtd">\n\n\x3c!-- Generated by RHY @will_awoke --\x3e\n\n<module name="Checker">\n\n  <property name="charset" value="UTF-8"/>\n  <property name="severity" value="warning"/>\n\n  \x3c!-- Checks for Size Violations.  --\x3e\n  \x3c!-- 检查文件的长度（行） default max=2000 --\x3e\n  <module name="FileLength">\n    <property name="max" value="2500"/>\n  </module>\n\n  \x3c!-- Checks that property files contain the same keys. --\x3e\n  \x3c!-- 检查**.properties配置文件 是否有相同的key\n  <module name="Translation">\n  </module>\n  --\x3e\n\n  <module name="TreeWalker">\n\n    \x3c!-- Checks for imports    --\x3e\n    \x3c!-- 必须导入类的完整路径，即不能使用*导入所需的类 --\x3e\n    <module name="AvoidStarImport"/>\n\n    \x3c!-- 检查是否从非法的包中导入了类 illegalPkgs: 定义非法的包名称--\x3e\n    <module name="IllegalImport"/> \x3c!-- defaults to sun.* packages --\x3e\n\n    \x3c!-- 检查是否导入了不必显示导入的类--\x3e\n    <module name="RedundantImport"/>\n\n    \x3c!-- 检查是否导入的包没有使用--\x3e\n    <module name="UnusedImports"/>\n\n    \x3c!-- Checks for whitespace\n    <module name="EmptyForIteratorPad"/>\n    <module name="MethodParamPad"/>\n    <module name="NoWhitespaceAfter"/>\n    <module name="NoWhitespaceBefore"/>\n    <module name="OperatorWrap"/>\n    <module name="ParenPad"/>\n    <module name="TypecastParenPad"/>\n    <module name="WhitespaceAfter"/>\n    <module name="WhitespaceAround"/>\n    --\x3e\n\n    \x3c!-- 检查类和接口的javadoc 默认不检查author 和version tags\n      authorFormat: 检查author标签的格式\n            versionFormat: 检查version标签的格式\n            scope: 可以检查的类的范围，例如：public只能检查public修饰的类，private可以检查所有的类\n            excludeScope: 不能检查的类的范围，例如：public，public的类将不被检查，但访问权限小于public的类仍然会检查，其他的权限以此类推\n            tokens: 该属性适用的类型，例如：CLASS_DEF,INTERFACE_DEF --\x3e\n    <module name="JavadocType">\n      <property name="authorFormat" value="\\S"/>\n      <property name="scope" value="protected"/>\n      <property name="tokens" value="CLASS_DEF,INTERFACE_DEF"/>\n    </module>\n\n    \x3c!-- 检查方法的javadoc的注释\n            scope: 可以检查的方法的范围，例如：public只能检查public修饰的方法，private可以检查所有的方法\n            allowMissingParamTags: 是否忽略对参数注释的检查\n            allowMissingThrowsTags: 是否忽略对throws注释的检查\n            allowMissingReturntags: 是否忽略对return注释的检查 --\x3e\n    <module name="JavadocMethod">\n      <property name="scope" value="private"/>\n      <property name="allowMissingParamTags" value="false"/>\n      <property name="allowMissingThrowsTags" value="false"/>\n      <property name="allowMissingReturnTag" value="false"/>\n      <property name="tokens" value="METHOD_DEF"/>\n      <property name="allowUndeclaredRTE" value="true"/>\n      <property name="allowThrowsTagsForSubclasses" value="true"/>\n      \x3c!--允许get set 方法没有注释--\x3e\n      <property name="allowMissingPropertyJavadoc" value="true"/>\n    </module>\n\n    \x3c!-- 检查类变量的注释\n            scope: 检查变量的范围，例如：public只能检查public修饰的变量，private可以检查所有的变量 --\x3e\n    <module name="JavadocVariable">\n      <property name="scope" value="private"/>\n    </module>\n\n    \x3c!--option: 定义左大括号\'{\'显示位置，eol在同一行显示，nl在下一行显示\n      maxLineLength: 大括号\'{\'所在行行最多容纳的字符数\n      tokens: 该属性适用的类型，例：CLASS_DEF,INTERFACE_DEF,METHOD_DEF,CTOR_DEF --\x3e\n    <module name="LeftCurly">\n      <property name="option" value="nl"/>\n    </module>\n\n    \x3c!-- NeedBraces 检查是否应该使用括号的地方没有加括号\n      tokens: 定义检查的类型 --\x3e\n    <module name="NeedBraces"/>\n\n    \x3c!-- Checks the placement of right curly braces (\'}\') for  else, try, and catch tokens. The policy to verify is specified using property  option.\n      option: 右大括号是否单独一行显示\n      tokens: 定义检查的类型  --\x3e\n    <module name="RightCurly">\n      <property name="option" value="alone"/>\n    </module>\n\n    \x3c!-- 检查在重写了equals方法后是否重写了hashCode方法 --\x3e\n    <module name="EqualsHashCode"/>\n\n    \x3c!--  Checks for illegal instantiations where a factory method is preferred.\n      Rationale: Depending on the project, for some classes it might be preferable to create instances through factory methods rather than calling the constructor.\n      A simple example is the java.lang.Boolean class. In order to save memory and CPU cycles, it is preferable to use the predefined constants TRUE and FALSE. Constructor invocations should be replaced by calls to Boolean.valueOf().\n      Some extremely performance sensitive projects may require the use of factory methods for other classes as well, to enforce the usage of number caches or object pools. --\x3e\n    <module name="IllegalInstantiation">\n      <property name="classes" value="java.lang.Boolean"/>\n    </module>\n\n    \x3c!-- Checks for Naming Conventions.   命名规范   --\x3e\n    \x3c!-- local, final variables, including catch parameters --\x3e\n    <module name="LocalFinalVariableName"/>\n\n    \x3c!-- local, non-final variables, including catch parameters--\x3e\n    <module name="LocalVariableName"/>\n\n    \x3c!-- static, non-final fields --\x3e\n    <module name="StaticVariableName">\n      <property name="format" value="(^[A-Z0-9_]{0,19}$)"/>\n    </module>\n\n    \x3c!-- packages --\x3e\n    <module name="PackageName">\n      <property name="format" value="^[a-z]+(\\.[a-z][a-z0-9]*)*$"/>\n    </module>\n\n    \x3c!-- classes and interfaces --\x3e\n    <module name="TypeName">\n      <property name="format" value="(^[A-Z][a-zA-Z0-9]{0,19}$)"/>\n    </module>\n\n    \x3c!-- methods --\x3e\n    <module name="MethodName">\n      <property name="format" value="(^[a-z][a-zA-Z0-9]{0,19}$)"/>\n    </module>\n\n    \x3c!-- non-static fields --\x3e\n    <module name="MemberName">\n      <property name="format" value="(^[a-z][a-z0-9][a-zA-Z0-9]{0,19}$)"/>\n    </module>\n\n    \x3c!-- parameters --\x3e\n    <module name="ParameterName">\n      <property name="format" value="(^[a-z][a-zA-Z0-9_]{0,19}$)"/>\n    </module>\n\n    \x3c!-- constants (static,  final fields) --\x3e\n    <module name="ConstantName">\n      <property name="format" value="(^[A-Z0-9_]{0,19}$)"/>\n    </module>\n\n    \x3c!-- 代码缩进   --\x3e\n    <module name="Indentation">\n    </module>\n\n    \x3c!-- Checks for redundant exceptions declared in throws clause such as duplicates, unchecked exceptions or subclasses of another declared exception.\n      检查是否抛出了多余的异常\n    <module name="RedundantThrows">\n        <property name="logLoadErrors" value="true"/>\n        <property name="suppressLoadErrors" value="true"/>\n    </module>\n    --\x3e\n\n    \x3c!--  Checks for overly complicated boolean expressions. Currently finds code like  if (b == true), b || true, !false, etc.\n      检查boolean值是否冗余的地方\n      Rationale: Complex boolean logic makes code hard to understand and maintain. --\x3e\n    <module name="SimplifyBooleanExpression"/>\n\n    \x3c!--  Checks for overly complicated boolean return statements. For example the following code\n       检查是否存在过度复杂的boolean返回值\n       if (valid())\n          return false;\n       else\n          return true;\n       could be written as\n          return !valid();\n       The Idea for this Check has been shamelessly stolen from the equivalent PMD rule. --\x3e\n    <module name="SimplifyBooleanReturn"/>\n\n    \x3c!-- Checks that a class which has only private constructors is declared as final.只有私有构造器的类必须声明为final--\x3e\n    <module name="FinalClass"/>\n\n    \x3c!--  Make sure that utility classes (classes that contain only static methods or fields in their API) do not have a public constructor.\n      确保Utils类（只提供static方法和属性的类）没有public构造器。\n      Rationale: Instantiating utility classes does not make sense. Hence the constructors should either be private or (if you want to allow subclassing) protected. A common mistake is forgetting to hide the default constructor.\n      If you make the constructor protected you may want to consider the following constructor implementation technique to disallow instantiating subclasses:\n      public class StringUtils // not final to allow subclassing\n      {\n          protected StringUtils() {\n              throw new UnsupportedOperationException(); // prevents calls from subclass\n          }\n          public static int count(char c, String s) {\n              // ...\n          }\n      }\n   <module name="HideUtilityClassConstructor"/>\n   --\x3e\n\n    \x3c!--  Checks visibility of class members. Only static final members may be public; other class members must be private unless property protectedAllowed or packageAllowed is set.\n      检查class成员属性可见性。只有static final 修饰的成员是可以public的。其他的成员属性必需是private的，除非属性protectedAllowed或者packageAllowed设置了true.\n       Public members are not flagged if the name matches the public member regular expression (contains "^serialVersionUID$" by default). Note: Checkstyle 2 used to include "^f[A-Z][a-zA-Z0-9]*$" in the default pattern to allow CMP for EJB 1.1 with the default settings. With EJB 2.0 it is not longer necessary to have public access for persistent fields, hence the default has been changed.\n       Rationale: Enforce encapsulation. 强制封装 --\x3e\n    <module name="VisibilityModifier"/>\n\n    \x3c!-- 每一行只能定义一个变量 --\x3e\n    <module name="MultipleVariableDeclarations">\n    </module>\n\n    \x3c!-- Checks the style of array type definitions. Some like Java-style: public static void main(String[] args) and some like C-style: public static void main(String args[])\n      检查再定义数组时，采用java风格还是c风格，例如：int[] num是java风格，int num[]是c风格。默认是java风格--\x3e\n    <module name="ArrayTypeStyle">\n    </module>\n\n    \x3c!-- Checks that there are no "magic numbers", where a magic number is a numeric literal that is not defined as a constant. By default, -1, 0, 1, and 2 are not considered to be magic numbers.\n    <module name="MagicNumber">\n    </module>\n    --\x3e\n\n    \x3c!-- A check for TODO: comments. Actually it is a generic regular expression matcher on Java comments. To check for other patterns in Java comments, set property format.\n       检查是否存在TODO（待处理） TODO是javaIDE自动生成的。一般代码写完后要去掉。\n     --\x3e\n    <module name="TodoComment"/>\n\n    \x3c!--  Checks that long constants are defined with an upper ell. That is \' L\' and not \'l\'. This is in accordance to the Java Language Specification,  Section 3.10.1.\n      检查是否在long类型是否定义了大写的L.字母小写l和数字1（一）很相似。\n      looks a lot like 1. --\x3e\n    <module name="UpperEll"/>\n\n    \x3c!--  Checks that switch statement has "default" clause. 检查switch语句是否有‘default’从句\n       Rationale: It\'s usually a good idea to introduce a default case in every switch statement.\n       Even if the developer is sure that all currently possible cases are covered, this should be expressed in the default branch,\n        e.g. by using an assertion. This way the code is protected aginst later changes, e.g. introduction of new types in an enumeration type. --\x3e\n    <module name="MissingSwitchDefault"/>\n\n    \x3c!--检查switch中case后是否加入了跳出语句，例如：return、break、throw、continue --\x3e\n    <module name="FallThrough"/>\n\n    \x3c!-- Checks the number of parameters of a method or constructor. max default 7个. --\x3e\n    <module name="ParameterNumber">\n      <property name="max" value="5"/>\n    </module>\n\n    \x3c!-- 每行字符数 --\x3e\n    <module name="LineLength">\n      <property name="max" value="200"/>\n    </module>\n\n    \x3c!-- Checks for long methods and constructors. max default 150行. max=300 设置长度300 --\x3e\n    <module name="MethodLength">\n      <property name="max" value="300"/>\n    </module>\n\n    \x3c!-- ModifierOrder 检查修饰符的顺序，默认是 public,protected,private,abstract,static,final,transient,volatile,synchronized,native --\x3e\n    <module name="ModifierOrder">\n    </module>\n\n    \x3c!-- 检查是否有多余的修饰符，例如：接口中的方法不必使用public、abstract修饰  --\x3e\n    <module name="RedundantModifier">\n    </module>\n\n    \x3c!--- 字符串比较必须使用 equals() --\x3e\n    <module name="StringLiteralEquality">\n    </module>\n\n    \x3c!-- if-else嵌套语句个数 最多4层 --\x3e\n    <module name="NestedIfDepth">\n      <property name="max" value="3"/>\n    </module>\n\n    \x3c!-- try-catch 嵌套语句个数 最多2层 --\x3e\n    <module name="NestedTryDepth">\n      <property name="max" value="2"/>\n    </module>\n\n    \x3c!-- 返回个数 --\x3e\n    <module name="ReturnCount">\n      <property name="max" value="5"/>\n      <property name="format" value="^$"/>\n    </module>\n\n  </module>\n</module>\n\n\n配置 pom.xml：\n\n\n<project>\n    ...\n    <properties>\n        <checkstyle.config.location>config/maven_checks.xml</checkstyle.config.location>\n    </properties>\n    ...\n    <reporting>\n        <plugins>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-checkstyle-plugin</artifactId>\n                <version>3.0</version>\n                <executions>\n                    <execution>\n                        \x3c!-- 绑定pmd:pmd到validate生命周期，在validate时会自动进行代码规范检查 --\x3e\n                        <id>validate</id>\n                        <phase>validate</phase>\n                        <configuration>\n                            \x3c!-- 配置文件的路径，在style文件夹下 --\x3e\n                            <configLocation>style/checkstyle.xml</configLocation>\n                            <encoding>UTF-8</encoding>\n                            <consoleOutput>true</consoleOutput>\n                            <failsOnError>true</failsOnError>\n                            <includeTestSourceDirectory>false</includeTestSourceDirectory>\n                        </configuration>\n                        <goals>\n                            <goal>check</goal>\n                        </goals>\n                    </execution>\n                </executions>\n            </plugin>\n\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-jxr-plugin</artifactId>\n                <version>2.3</version>\n            </plugin>\n        </plugins>\n    </reporting>\n    ...\n</project>\n\n\n其中可以修改使用的检查规则文件路径，插件默认提供了四个规则文件可以直接使用，无需手动下载：\n\n * config/sun_checks.xml - Sun Microsystems Definition (default).\n * config/maven_checks.xml - Maven Development Definitions.\n * config/turbine_checks.xml - Turbine Development Definitions.\n * config/avalon_checks.xml - Avalon Development Definitions.\n\n配置好后，可以执行 mvn clean checkstyle:check 检查代码。\n\n\n# maven-pmd-plugin\n\n> maven-pmd-plugin 是阿里编程规范检查插件。\n\n配置 pom.xml：\n\n参考 https://github.com/alibaba/p3c/blob/master/p3c-pmd/pom.xml 配置\n\n      <plugin>\n        <groupId>org.apache.maven.plugins</groupId>\n        <artifactId>maven-pmd-plugin</artifactId>\n        <version>3.11.0</version>\n        <configuration>\n          <sourceEncoding>${project.build.sourceEncoding}</sourceEncoding>\n          <targetJdk>${maven.compiler.target}</targetJdk>\n          <printFailingErrors>true</printFailingErrors>\n          <rulesets>\n            <ruleset>rulesets/java/ali-comment.xml</ruleset>\n            <ruleset>rulesets/java/ali-concurrent.xml</ruleset>\n            <ruleset>rulesets/java/ali-constant.xml</ruleset>\n            <ruleset>rulesets/java/ali-exception.xml</ruleset>\n            <ruleset>rulesets/java/ali-flowcontrol.xml</ruleset>\n            <ruleset>rulesets/java/ali-naming.xml</ruleset>\n            <ruleset>rulesets/java/ali-oop.xml</ruleset>\n            <ruleset>rulesets/java/ali-orm.xml</ruleset>\n            <ruleset>rulesets/java/ali-other.xml</ruleset>\n            <ruleset>rulesets/java/ali-set.xml</ruleset>\n          </rulesets>\n          <printFailingErrors>true</printFailingErrors>\n        </configuration>\n        <executions>\n          <execution>\n            <phase>verify</phase>\n            <goals>\n              <goal>check</goal>\n            </goals>\n          </execution>\n        </executions>\n        <dependencies>\n          <dependency>\n            <groupId>com.alibaba.p3c</groupId>\n            <artifactId>p3c-pmd</artifactId>\n            <version>2.0.0</version>\n          </dependency>\n        </dependencies>\n      </plugin>\n    </plugins>\n\n\n配置好后，可以执行 mvn clean pmd:check 检查代码。\n\n\n# 参考资料\n\n * https://maven.apache.org/plugins/maven-checkstyle-plugin/\n * https://maven.apache.org/jxr/maven-jxr-plugin/\n * https://www.jianshu.com/p/557b975ae40d\n * 阿里巴巴编程规范\n   * https://github.com/alibaba/p3c\n   * https://github.com/alibaba/p3c/blob/master/p3c-pmd/pom.xml',normalizedContent:'# maven 插件之代码检查\n\n\n# maven-checkstyle-plugin\n\n> maven-checkstyle-plugin，用于检测代码中不符合规范的地方。\n\n\n# 定义 checkstyle.xml\n\n<!doctype module public\n  "-//checkstyle//dtd checkstyle configuration 1.3//en"\n  "https://checkstyle.org/dtds/configuration_1_3.dtd">\n\n\x3c!-- generated by rhy @will_awoke --\x3e\n\n<module name="checker">\n\n  <property name="charset" value="utf-8"/>\n  <property name="severity" value="warning"/>\n\n  \x3c!-- checks for size violations.  --\x3e\n  \x3c!-- 检查文件的长度（行） default max=2000 --\x3e\n  <module name="filelength">\n    <property name="max" value="2500"/>\n  </module>\n\n  \x3c!-- checks that property files contain the same keys. --\x3e\n  \x3c!-- 检查**.properties配置文件 是否有相同的key\n  <module name="translation">\n  </module>\n  --\x3e\n\n  <module name="treewalker">\n\n    \x3c!-- checks for imports    --\x3e\n    \x3c!-- 必须导入类的完整路径，即不能使用*导入所需的类 --\x3e\n    <module name="avoidstarimport"/>\n\n    \x3c!-- 检查是否从非法的包中导入了类 illegalpkgs: 定义非法的包名称--\x3e\n    <module name="illegalimport"/> \x3c!-- defaults to sun.* packages --\x3e\n\n    \x3c!-- 检查是否导入了不必显示导入的类--\x3e\n    <module name="redundantimport"/>\n\n    \x3c!-- 检查是否导入的包没有使用--\x3e\n    <module name="unusedimports"/>\n\n    \x3c!-- checks for whitespace\n    <module name="emptyforiteratorpad"/>\n    <module name="methodparampad"/>\n    <module name="nowhitespaceafter"/>\n    <module name="nowhitespacebefore"/>\n    <module name="operatorwrap"/>\n    <module name="parenpad"/>\n    <module name="typecastparenpad"/>\n    <module name="whitespaceafter"/>\n    <module name="whitespacearound"/>\n    --\x3e\n\n    \x3c!-- 检查类和接口的javadoc 默认不检查author 和version tags\n      authorformat: 检查author标签的格式\n            versionformat: 检查version标签的格式\n            scope: 可以检查的类的范围，例如：public只能检查public修饰的类，private可以检查所有的类\n            excludescope: 不能检查的类的范围，例如：public，public的类将不被检查，但访问权限小于public的类仍然会检查，其他的权限以此类推\n            tokens: 该属性适用的类型，例如：class_def,interface_def --\x3e\n    <module name="javadoctype">\n      <property name="authorformat" value="\\s"/>\n      <property name="scope" value="protected"/>\n      <property name="tokens" value="class_def,interface_def"/>\n    </module>\n\n    \x3c!-- 检查方法的javadoc的注释\n            scope: 可以检查的方法的范围，例如：public只能检查public修饰的方法，private可以检查所有的方法\n            allowmissingparamtags: 是否忽略对参数注释的检查\n            allowmissingthrowstags: 是否忽略对throws注释的检查\n            allowmissingreturntags: 是否忽略对return注释的检查 --\x3e\n    <module name="javadocmethod">\n      <property name="scope" value="private"/>\n      <property name="allowmissingparamtags" value="false"/>\n      <property name="allowmissingthrowstags" value="false"/>\n      <property name="allowmissingreturntag" value="false"/>\n      <property name="tokens" value="method_def"/>\n      <property name="allowundeclaredrte" value="true"/>\n      <property name="allowthrowstagsforsubclasses" value="true"/>\n      \x3c!--允许get set 方法没有注释--\x3e\n      <property name="allowmissingpropertyjavadoc" value="true"/>\n    </module>\n\n    \x3c!-- 检查类变量的注释\n            scope: 检查变量的范围，例如：public只能检查public修饰的变量，private可以检查所有的变量 --\x3e\n    <module name="javadocvariable">\n      <property name="scope" value="private"/>\n    </module>\n\n    \x3c!--option: 定义左大括号\'{\'显示位置，eol在同一行显示，nl在下一行显示\n      maxlinelength: 大括号\'{\'所在行行最多容纳的字符数\n      tokens: 该属性适用的类型，例：class_def,interface_def,method_def,ctor_def --\x3e\n    <module name="leftcurly">\n      <property name="option" value="nl"/>\n    </module>\n\n    \x3c!-- needbraces 检查是否应该使用括号的地方没有加括号\n      tokens: 定义检查的类型 --\x3e\n    <module name="needbraces"/>\n\n    \x3c!-- checks the placement of right curly braces (\'}\') for  else, try, and catch tokens. the policy to verify is specified using property  option.\n      option: 右大括号是否单独一行显示\n      tokens: 定义检查的类型  --\x3e\n    <module name="rightcurly">\n      <property name="option" value="alone"/>\n    </module>\n\n    \x3c!-- 检查在重写了equals方法后是否重写了hashcode方法 --\x3e\n    <module name="equalshashcode"/>\n\n    \x3c!--  checks for illegal instantiations where a factory method is preferred.\n      rationale: depending on the project, for some classes it might be preferable to create instances through factory methods rather than calling the constructor.\n      a simple example is the java.lang.boolean class. in order to save memory and cpu cycles, it is preferable to use the predefined constants true and false. constructor invocations should be replaced by calls to boolean.valueof().\n      some extremely performance sensitive projects may require the use of factory methods for other classes as well, to enforce the usage of number caches or object pools. --\x3e\n    <module name="illegalinstantiation">\n      <property name="classes" value="java.lang.boolean"/>\n    </module>\n\n    \x3c!-- checks for naming conventions.   命名规范   --\x3e\n    \x3c!-- local, final variables, including catch parameters --\x3e\n    <module name="localfinalvariablename"/>\n\n    \x3c!-- local, non-final variables, including catch parameters--\x3e\n    <module name="localvariablename"/>\n\n    \x3c!-- static, non-final fields --\x3e\n    <module name="staticvariablename">\n      <property name="format" value="(^[a-z0-9_]{0,19}$)"/>\n    </module>\n\n    \x3c!-- packages --\x3e\n    <module name="packagename">\n      <property name="format" value="^[a-z]+(\\.[a-z][a-z0-9]*)*$"/>\n    </module>\n\n    \x3c!-- classes and interfaces --\x3e\n    <module name="typename">\n      <property name="format" value="(^[a-z][a-za-z0-9]{0,19}$)"/>\n    </module>\n\n    \x3c!-- methods --\x3e\n    <module name="methodname">\n      <property name="format" value="(^[a-z][a-za-z0-9]{0,19}$)"/>\n    </module>\n\n    \x3c!-- non-static fields --\x3e\n    <module name="membername">\n      <property name="format" value="(^[a-z][a-z0-9][a-za-z0-9]{0,19}$)"/>\n    </module>\n\n    \x3c!-- parameters --\x3e\n    <module name="parametername">\n      <property name="format" value="(^[a-z][a-za-z0-9_]{0,19}$)"/>\n    </module>\n\n    \x3c!-- constants (static,  final fields) --\x3e\n    <module name="constantname">\n      <property name="format" value="(^[a-z0-9_]{0,19}$)"/>\n    </module>\n\n    \x3c!-- 代码缩进   --\x3e\n    <module name="indentation">\n    </module>\n\n    \x3c!-- checks for redundant exceptions declared in throws clause such as duplicates, unchecked exceptions or subclasses of another declared exception.\n      检查是否抛出了多余的异常\n    <module name="redundantthrows">\n        <property name="logloaderrors" value="true"/>\n        <property name="suppressloaderrors" value="true"/>\n    </module>\n    --\x3e\n\n    \x3c!--  checks for overly complicated boolean expressions. currently finds code like  if (b == true), b || true, !false, etc.\n      检查boolean值是否冗余的地方\n      rationale: complex boolean logic makes code hard to understand and maintain. --\x3e\n    <module name="simplifybooleanexpression"/>\n\n    \x3c!--  checks for overly complicated boolean return statements. for example the following code\n       检查是否存在过度复杂的boolean返回值\n       if (valid())\n          return false;\n       else\n          return true;\n       could be written as\n          return !valid();\n       the idea for this check has been shamelessly stolen from the equivalent pmd rule. --\x3e\n    <module name="simplifybooleanreturn"/>\n\n    \x3c!-- checks that a class which has only private constructors is declared as final.只有私有构造器的类必须声明为final--\x3e\n    <module name="finalclass"/>\n\n    \x3c!--  make sure that utility classes (classes that contain only static methods or fields in their api) do not have a public constructor.\n      确保utils类（只提供static方法和属性的类）没有public构造器。\n      rationale: instantiating utility classes does not make sense. hence the constructors should either be private or (if you want to allow subclassing) protected. a common mistake is forgetting to hide the default constructor.\n      if you make the constructor protected you may want to consider the following constructor implementation technique to disallow instantiating subclasses:\n      public class stringutils // not final to allow subclassing\n      {\n          protected stringutils() {\n              throw new unsupportedoperationexception(); // prevents calls from subclass\n          }\n          public static int count(char c, string s) {\n              // ...\n          }\n      }\n   <module name="hideutilityclassconstructor"/>\n   --\x3e\n\n    \x3c!--  checks visibility of class members. only static final members may be public; other class members must be private unless property protectedallowed or packageallowed is set.\n      检查class成员属性可见性。只有static final 修饰的成员是可以public的。其他的成员属性必需是private的，除非属性protectedallowed或者packageallowed设置了true.\n       public members are not flagged if the name matches the public member regular expression (contains "^serialversionuid$" by default). note: checkstyle 2 used to include "^f[a-z][a-za-z0-9]*$" in the default pattern to allow cmp for ejb 1.1 with the default settings. with ejb 2.0 it is not longer necessary to have public access for persistent fields, hence the default has been changed.\n       rationale: enforce encapsulation. 强制封装 --\x3e\n    <module name="visibilitymodifier"/>\n\n    \x3c!-- 每一行只能定义一个变量 --\x3e\n    <module name="multiplevariabledeclarations">\n    </module>\n\n    \x3c!-- checks the style of array type definitions. some like java-style: public static void main(string[] args) and some like c-style: public static void main(string args[])\n      检查再定义数组时，采用java风格还是c风格，例如：int[] num是java风格，int num[]是c风格。默认是java风格--\x3e\n    <module name="arraytypestyle">\n    </module>\n\n    \x3c!-- checks that there are no "magic numbers", where a magic number is a numeric literal that is not defined as a constant. by default, -1, 0, 1, and 2 are not considered to be magic numbers.\n    <module name="magicnumber">\n    </module>\n    --\x3e\n\n    \x3c!-- a check for todo: comments. actually it is a generic regular expression matcher on java comments. to check for other patterns in java comments, set property format.\n       检查是否存在todo（待处理） todo是javaide自动生成的。一般代码写完后要去掉。\n     --\x3e\n    <module name="todocomment"/>\n\n    \x3c!--  checks that long constants are defined with an upper ell. that is \' l\' and not \'l\'. this is in accordance to the java language specification,  section 3.10.1.\n      检查是否在long类型是否定义了大写的l.字母小写l和数字1（一）很相似。\n      looks a lot like 1. --\x3e\n    <module name="upperell"/>\n\n    \x3c!--  checks that switch statement has "default" clause. 检查switch语句是否有‘default’从句\n       rationale: it\'s usually a good idea to introduce a default case in every switch statement.\n       even if the developer is sure that all currently possible cases are covered, this should be expressed in the default branch,\n        e.g. by using an assertion. this way the code is protected aginst later changes, e.g. introduction of new types in an enumeration type. --\x3e\n    <module name="missingswitchdefault"/>\n\n    \x3c!--检查switch中case后是否加入了跳出语句，例如：return、break、throw、continue --\x3e\n    <module name="fallthrough"/>\n\n    \x3c!-- checks the number of parameters of a method or constructor. max default 7个. --\x3e\n    <module name="parameternumber">\n      <property name="max" value="5"/>\n    </module>\n\n    \x3c!-- 每行字符数 --\x3e\n    <module name="linelength">\n      <property name="max" value="200"/>\n    </module>\n\n    \x3c!-- checks for long methods and constructors. max default 150行. max=300 设置长度300 --\x3e\n    <module name="methodlength">\n      <property name="max" value="300"/>\n    </module>\n\n    \x3c!-- modifierorder 检查修饰符的顺序，默认是 public,protected,private,abstract,static,final,transient,volatile,synchronized,native --\x3e\n    <module name="modifierorder">\n    </module>\n\n    \x3c!-- 检查是否有多余的修饰符，例如：接口中的方法不必使用public、abstract修饰  --\x3e\n    <module name="redundantmodifier">\n    </module>\n\n    \x3c!--- 字符串比较必须使用 equals() --\x3e\n    <module name="stringliteralequality">\n    </module>\n\n    \x3c!-- if-else嵌套语句个数 最多4层 --\x3e\n    <module name="nestedifdepth">\n      <property name="max" value="3"/>\n    </module>\n\n    \x3c!-- try-catch 嵌套语句个数 最多2层 --\x3e\n    <module name="nestedtrydepth">\n      <property name="max" value="2"/>\n    </module>\n\n    \x3c!-- 返回个数 --\x3e\n    <module name="returncount">\n      <property name="max" value="5"/>\n      <property name="format" value="^$"/>\n    </module>\n\n  </module>\n</module>\n\n\n配置 pom.xml：\n\n\n<project>\n    ...\n    <properties>\n        <checkstyle.config.location>config/maven_checks.xml</checkstyle.config.location>\n    </properties>\n    ...\n    <reporting>\n        <plugins>\n            <plugin>\n                <groupid>org.apache.maven.plugins</groupid>\n                <artifactid>maven-checkstyle-plugin</artifactid>\n                <version>3.0</version>\n                <executions>\n                    <execution>\n                        \x3c!-- 绑定pmd:pmd到validate生命周期，在validate时会自动进行代码规范检查 --\x3e\n                        <id>validate</id>\n                        <phase>validate</phase>\n                        <configuration>\n                            \x3c!-- 配置文件的路径，在style文件夹下 --\x3e\n                            <configlocation>style/checkstyle.xml</configlocation>\n                            <encoding>utf-8</encoding>\n                            <consoleoutput>true</consoleoutput>\n                            <failsonerror>true</failsonerror>\n                            <includetestsourcedirectory>false</includetestsourcedirectory>\n                        </configuration>\n                        <goals>\n                            <goal>check</goal>\n                        </goals>\n                    </execution>\n                </executions>\n            </plugin>\n\n            <plugin>\n                <groupid>org.apache.maven.plugins</groupid>\n                <artifactid>maven-jxr-plugin</artifactid>\n                <version>2.3</version>\n            </plugin>\n        </plugins>\n    </reporting>\n    ...\n</project>\n\n\n其中可以修改使用的检查规则文件路径，插件默认提供了四个规则文件可以直接使用，无需手动下载：\n\n * config/sun_checks.xml - sun microsystems definition (default).\n * config/maven_checks.xml - maven development definitions.\n * config/turbine_checks.xml - turbine development definitions.\n * config/avalon_checks.xml - avalon development definitions.\n\n配置好后，可以执行 mvn clean checkstyle:check 检查代码。\n\n\n# maven-pmd-plugin\n\n> maven-pmd-plugin 是阿里编程规范检查插件。\n\n配置 pom.xml：\n\n参考 https://github.com/alibaba/p3c/blob/master/p3c-pmd/pom.xml 配置\n\n      <plugin>\n        <groupid>org.apache.maven.plugins</groupid>\n        <artifactid>maven-pmd-plugin</artifactid>\n        <version>3.11.0</version>\n        <configuration>\n          <sourceencoding>${project.build.sourceencoding}</sourceencoding>\n          <targetjdk>${maven.compiler.target}</targetjdk>\n          <printfailingerrors>true</printfailingerrors>\n          <rulesets>\n            <ruleset>rulesets/java/ali-comment.xml</ruleset>\n            <ruleset>rulesets/java/ali-concurrent.xml</ruleset>\n            <ruleset>rulesets/java/ali-constant.xml</ruleset>\n            <ruleset>rulesets/java/ali-exception.xml</ruleset>\n            <ruleset>rulesets/java/ali-flowcontrol.xml</ruleset>\n            <ruleset>rulesets/java/ali-naming.xml</ruleset>\n            <ruleset>rulesets/java/ali-oop.xml</ruleset>\n            <ruleset>rulesets/java/ali-orm.xml</ruleset>\n            <ruleset>rulesets/java/ali-other.xml</ruleset>\n            <ruleset>rulesets/java/ali-set.xml</ruleset>\n          </rulesets>\n          <printfailingerrors>true</printfailingerrors>\n        </configuration>\n        <executions>\n          <execution>\n            <phase>verify</phase>\n            <goals>\n              <goal>check</goal>\n            </goals>\n          </execution>\n        </executions>\n        <dependencies>\n          <dependency>\n            <groupid>com.alibaba.p3c</groupid>\n            <artifactid>p3c-pmd</artifactid>\n            <version>2.0.0</version>\n          </dependency>\n        </dependencies>\n      </plugin>\n    </plugins>\n\n\n配置好后，可以执行 mvn clean pmd:check 检查代码。\n\n\n# 参考资料\n\n * https://maven.apache.org/plugins/maven-checkstyle-plugin/\n * https://maven.apache.org/jxr/maven-jxr-plugin/\n * https://www.jianshu.com/p/557b975ae40d\n * 阿里巴巴编程规范\n   * https://github.com/alibaba/p3c\n   * https://github.com/alibaba/p3c/blob/master/p3c-pmd/pom.xml',charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Maven 教程",frontmatter:{title:"Maven 教程",date:"2020-08-04T15:20:54.000Z",categories:["Java","软件","构建","Maven"],tags:["Java","构建","Maven"],permalink:"/pages/85f27a/",hidden:!0,index:!1},regularPath:"/01.Java/11.%E8%BD%AF%E4%BB%B6/01.%E6%9E%84%E5%BB%BA/01.Maven/",relativePath:"01.Java/11.软件/01.构建/01.Maven/README.md",key:"v-160dee90",path:"/pages/85f27a/",headers:[{level:2,title:"📖 内容",slug:"📖-内容",normalizedTitle:"📖 内容",charIndex:437},{level:2,title:"📚 资料",slug:"📚-资料",normalizedTitle:"📚 资料",charIndex:579},{level:2,title:"🚪 传送",slug:"🚪-传送",normalizedTitle:"🚪 传送",charIndex:652}],headersStr:"📖 内容 📚 资料 🚪 传送",content:"# Maven 教程\n\n> Maven 是一个项目管理工具。它负责管理项目开发过程中的几乎所有的东西。\n> \n>  * 版本 - maven 有自己的版本定义和规则。\n>  * 构建 - maven 支持许多种的应用程序类型，对于每一种支持的应用程序类型都定义好了一组构建规则和工具集。\n>  * 输出物管理 - maven 可以管理项目构建的产物，并将其加入到用户库中。这个功能可以用于项目组和其他部门之间的交付行为。\n>  * 依赖关系 - maven 对依赖关系的特性进行细致的分析和划分，避免开发过程中的依赖混乱和相互污染行为\n>  * 文档和构建结果 - maven 的 site 命令支持各种文档信息的发布，包括构建过程的各种输出，javadoc，产品文档等。\n>  * 项目关系 - 一个大型的项目通常有几个小项目或者模块组成，用 maven 可以很方便地管理。\n>  * 移植性管理 - maven 可以针对不同的开发场景，输出不同种类的输出结果。\n\n\n# 📖 内容\n\n * Maven 快速入门\n * Maven 教程之 pom.xml 详解\n * Maven 教程之 settings.xml 详解\n * Maven 实战问题和最佳实践\n * Maven 教程之发布 jar 到私服或中央仓库\n * Maven 插件之代码检查\n\n\n# 📚 资料\n\n * 官网\n   * Maven Github\n   * Maven 官方文档\n * 书籍\n   * 《Maven 实战》\n\n\n# 🚪 传送\n\n◾ 💧 钝悟的 IT 知识图谱 ◾",normalizedContent:"# maven 教程\n\n> maven 是一个项目管理工具。它负责管理项目开发过程中的几乎所有的东西。\n> \n>  * 版本 - maven 有自己的版本定义和规则。\n>  * 构建 - maven 支持许多种的应用程序类型，对于每一种支持的应用程序类型都定义好了一组构建规则和工具集。\n>  * 输出物管理 - maven 可以管理项目构建的产物，并将其加入到用户库中。这个功能可以用于项目组和其他部门之间的交付行为。\n>  * 依赖关系 - maven 对依赖关系的特性进行细致的分析和划分，避免开发过程中的依赖混乱和相互污染行为\n>  * 文档和构建结果 - maven 的 site 命令支持各种文档信息的发布，包括构建过程的各种输出，javadoc，产品文档等。\n>  * 项目关系 - 一个大型的项目通常有几个小项目或者模块组成，用 maven 可以很方便地管理。\n>  * 移植性管理 - maven 可以针对不同的开发场景，输出不同种类的输出结果。\n\n\n# 📖 内容\n\n * maven 快速入门\n * maven 教程之 pom.xml 详解\n * maven 教程之 settings.xml 详解\n * maven 实战问题和最佳实践\n * maven 教程之发布 jar 到私服或中央仓库\n * maven 插件之代码检查\n\n\n# 📚 资料\n\n * 官网\n   * maven github\n   * maven 官方文档\n * 书籍\n   * 《maven 实战》\n\n\n# 🚪 传送\n\n◾ 💧 钝悟的 it 知识图谱 ◾",charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Java 构建",frontmatter:{title:"Java 构建",date:"2020-08-04T15:20:54.000Z",categories:["Java","软件","构建"],tags:["Java","构建"],permalink:"/pages/d1859b/",hidden:!0,index:!1},regularPath:"/01.Java/11.%E8%BD%AF%E4%BB%B6/01.%E6%9E%84%E5%BB%BA/",relativePath:"01.Java/11.软件/01.构建/README.md",key:"v-92d5b0d0",path:"/pages/d1859b/",headers:[{level:2,title:"📖 内容",slug:"📖-内容",normalizedTitle:"📖 内容",charIndex:245},{level:3,title:"Maven",slug:"maven",normalizedTitle:"maven",charIndex:85},{level:3,title:"Ant",slug:"ant",normalizedTitle:"ant",charIndex:177},{level:2,title:"📚 资料",slug:"📚-资料",normalizedTitle:"📚 资料",charIndex:418},{level:2,title:"🚪 传送",slug:"🚪-传送",normalizedTitle:"🚪 传送",charIndex:505}],headersStr:"📖 内容 Maven Ant 📚 资料 🚪 传送",content:"# Java 构建\n\n> Java 项目需要通过 构建工具 来管理项目依赖，完成编译、打包、发布、生成 JavaDoc 等任务。\n> \n>  * 目前最主流的构建工具是 Maven，它的功能非常强大。\n>  * Gradle 号称是要替代 Maven 等构件工具，它的版本管理确实简洁，但是需要学习 Groovy，学习成本比 Maven 高。\n>  * Ant 功能比 Maven 和 Gradle 要弱，现代 Java 项目基本不用了，但也有一些传统的 Java 项目还在使用。\n\n\n# 📖 内容\n\n\n# Maven\n\n * Maven 快速入门\n * Maven 教程之 pom.xml 详解\n * Maven 教程之 settings.xml 详解\n * Maven 实战问题和最佳实践\n * Maven 教程之发布 jar 到私服或中央仓库\n * Maven 插件之代码检查\n\n\n# Ant\n\n * Ant 简易教程\n\n\n# 📚 资料\n\n * 官网\n   * Maven Github\n   * Maven 官方文档\n   * Ant 官方手册\n * 书籍\n   * 《Maven 实战》\n\n\n# 🚪 传送\n\n◾ 💧 钝悟的 IT 知识图谱 ◾",normalizedContent:"# java 构建\n\n> java 项目需要通过 构建工具 来管理项目依赖，完成编译、打包、发布、生成 javadoc 等任务。\n> \n>  * 目前最主流的构建工具是 maven，它的功能非常强大。\n>  * gradle 号称是要替代 maven 等构件工具，它的版本管理确实简洁，但是需要学习 groovy，学习成本比 maven 高。\n>  * ant 功能比 maven 和 gradle 要弱，现代 java 项目基本不用了，但也有一些传统的 java 项目还在使用。\n\n\n# 📖 内容\n\n\n# maven\n\n * maven 快速入门\n * maven 教程之 pom.xml 详解\n * maven 教程之 settings.xml 详解\n * maven 实战问题和最佳实践\n * maven 教程之发布 jar 到私服或中央仓库\n * maven 插件之代码检查\n\n\n# ant\n\n * ant 简易教程\n\n\n# 📚 资料\n\n * 官网\n   * maven github\n   * maven 官方文档\n   * ant 官方手册\n * 书籍\n   * 《maven 实战》\n\n\n# 🚪 传送\n\n◾ 💧 钝悟的 it 知识图谱 ◾",charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Ant 简易教程",frontmatter:{title:"Ant 简易教程",date:"2017-12-06T09:46:28.000Z",order:2,categories:["Java","软件","构建"],tags:["Java","构建","Ant"],permalink:"/pages/0bafae/"},regularPath:"/01.Java/11.%E8%BD%AF%E4%BB%B6/01.%E6%9E%84%E5%BB%BA/02.Ant.html",relativePath:"01.Java/11.软件/01.构建/02.Ant.md",key:"v-7212740e",path:"/pages/0bafae/",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:15},{level:2,title:"下载和安装",slug:"下载和安装",normalizedTitle:"下载和安装",charIndex:139},{level:3,title:"下载",slug:"下载",normalizedTitle:"下载",charIndex:139},{level:3,title:"配置环境变量",slug:"配置环境变量",normalizedTitle:"配置环境变量",charIndex:261},{level:3,title:"验证",slug:"验证",normalizedTitle:"验证",charIndex:429},{level:2,title:"例子",slug:"例子",normalizedTitle:"例子",charIndex:758},{level:2,title:"关键元素",slug:"关键元素",normalizedTitle:"关键元素",charIndex:2625},{level:3,title:"Project 元素",slug:"project-元素",normalizedTitle:"project 元素",charIndex:2716},{level:3,title:"Target 元素",slug:"target-元素",normalizedTitle:"target 元素",charIndex:3109},{level:3,title:"Task 元素",slug:"task-元素",normalizedTitle:"task 元素",charIndex:4413},{level:3,title:"Property 元素",slug:"property-元素",normalizedTitle:"property 元素",charIndex:6322},{level:3,title:"extension-point 元素",slug:"extension-point-元素",normalizedTitle:"extension-point 元素",charIndex:3776},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:6875}],headersStr:"简介 下载和安装 下载 配置环境变量 验证 例子 关键元素 Project 元素 Target 元素 Task 元素 Property 元素 extension-point 元素 参考资料",content:'# Ant 简易教程\n\n\n# 简介\n\nApache Ant 是一个将软件编译、测试、部署等步骤联系在一起加以自动化的一个工具，大多用于 Java 环境中的软件开发。由 Apache 软件基金会所提供。\n\nAnt 是纯 Java 语言编写的，所以具有很好的跨平台性。\n\n\n\n\n# 下载和安装\n\n\n# 下载\n\nant 的官方下载地址：http://ant.apache.org/bindownload.cgi\n\n进入页面后，在下图的红色方框中可以下载最新版本。笔者下载的版本是 apache-ant-1.9.4。\n\n\n\n\n# 配置环境变量\n\n配置环境变量（我的电脑 -> 属性 -> 高级 -> 环境变量）。\n\n设置 ant 环境变量：\n\nANT_HOME C:/ apache-ant-1.9.4\n\n\n\n**path ** C:/ apache-ant-1.9.4/bin\n\n\n\nclasspath C:/apache-ant-1.9.4/lib\n\n\n\n\n# 验证\n\n点击 开始 -> 运行 -> 输入 cmd\n\n执行构建文件\n\n输入如下命令：ant\n\n如果出现如下内容，说明安装成功：\n\n> Buildfile: build.xml does not exist! Build failed\n\n注意：因为 ant 默认运行 build.xml 文件，这个文件需要我们创建。\n\n如果不想命名为 build.xml，运行时可以使用 ant -buildfile test.xml 命令指明要运行的构建文件。\n\n查看版本信息\n\n输入 ant -version，可以查看版本信息。\n\n\n\n但如果出现 \'ant\' 不是内部或外部命令，也不是可运行的程序或批处理文件，说明安装失败：（可以重复前述步骤，直至安装成功。）\n\n\n# 例子\n\n在安装和配置成功后，我们就可以使用 ant 了。\n\n为了让读者对 ant 有一个直观的认识，首先以 Ant 官方手册上的一个简单例子做一个说明。\n\n以下是一个 build.xml 文件的内容：\n\n<project name="MyProject" default="dist" basedir=".">\n    <description>\n        simple example build file\n    </description>\n  \x3c!-- set global properties for this build --\x3e\n  <property name="src" location="src"/>\n  <property name="build" location="build"/>\n  <property name="dist"  location="dist"/>\n\n  <target name="init">\n    \x3c!-- Create the time stamp --\x3e\n    <tstamp/>\n    \x3c!-- Create the build directory structure used by compile --\x3e\n    <mkdir dir="${build}"/>\n  </target>\n\n  <target name="compile" depends="init"\n        description="compile the source " >\n    \x3c!-- Compile the java code from ${src} into ${build} --\x3e\n    <javac srcdir="${src}" destdir="${build}"/>\n  </target>\n\n  <target name="dist" depends="compile"\n        description="generate the distribution" >\n    \x3c!-- Create the distribution directory --\x3e\n    <mkdir dir="${dist}/lib"/>\n\n    \x3c!-- Put everything in ${build} into the MyProject-${DSTAMP}.jar file --\x3e\n    <jar jarfile="${dist}/lib/MyProject-${DSTAMP}.jar" basedir="${build}"/>\n  </target>\n\n  <target name="clean"\n        description="clean up" >\n    \x3c!-- Delete the ${build} and ${dist} directory trees --\x3e\n    <delete dir="${build}"/>\n    <delete dir="${dist}"/>\n  </target>\n</project>\n\n\n在这个 xml 文件中，有几个 target 标签，每个 target 对应一个执行目标。\n\n我们将这个 build.xml 放在 D:\\Temp\\ant_test 路径下，然后在 dos 界面下进行测试。\n\nant init\n\n\n\n在 D:\\Temp\\ant_test 路径下创建了一个 build 目录，执行成功。\n\nant compile\n\n\n\n提示错误，原来是在 build.xml 的所在目录下找不到 src 目录。好的，我们直接创建一个 src 目录，然后再次尝试。这次，执行成功。\n\n\n\n**ant dist **\n\n\n\n在 D:\\Temp\\ant_test 路径下创建了一个 dist 目录，执行成功。\n\nant clean\n\n\n\n清除创建的 build 和 dist 目录，执行成功。\n\n一个细节\n\n细心的读者，想必已经发现一个问题——在执行 ant compile 和 ant dist 命令的时候把前面的命令也执行了。这是为什么呢？\n\n请留意一下 build.xml 中的内容。有部分 target 标签中含有 depends 关键字。\n\n\n\n这表明，当前的 target 在执行时需要依赖其他的 target，必须先执行依赖的 target，然后再执行。\n\n\n# 关键元素\n\nAnt 的构件文件都是 XML 格式的。每个构件文件包含一个 project 元素和至少一个 target。\n\ntarget 元素可以包含多个 task 元素。\n\n\n# Project 元素\n\nproject 元素是构建文件的根元素。\n\n一个 project 元素可以有多个 target 元素，一个 target 元素可以有多个 task。\n\n在上节的例子中，project 标签里有三个属性。\n\n<project name="MyProject" default="dist" basedir=".">\n\n\nname 属性，指示 project 元素的名字。例子中的名字就是 MyProject。\n\ndefault 属性，指示这个 project 默认执行的 target。在本文的例子中，默认执行的 target 为 dist。\n\n如果我们输入命令 ant 时，不指定 target 参数，默认会执行 dist 这个 target。\n\nbasedir 属性，指定根路径的位置。该属性没有指定时，使用 Ant 的构件文件的所在目录作为根目录。\n\n\n# Target 元素\n\ntarget 元素是 task 的容器，也就是 Ant 的一个基本执行单元。\n\n以上节例子中的 compile 来举例。\n\n<target name="compile" depends="init" description="compile the source " >\n    \x3c!-- Compile the java code from ${src} into ${build} --\x3e\n    <javac srcdir="${src}" destdir="${build}"/>\n</target>\n\n\n这个 target 中出现了几个属性。\n\nname 属性，指示 target 元素的名称。\n\n这个属性在一个 project 元素中必须是唯一的。这很好理解，如果出现重复，Ant 就不知道具体该执行哪个 target 了。\n\ndepends 属性，指示依赖的 target，当前的 target 必须在依赖的 target 之后执行。\n\ndescription 属性，是关于 target 的简短说明。\n\n此外，还有其他几个未出现在构建文件中的属性。\n\nif 属性，验证指定的属性是否存在，若不存在，所在 target 将不会被执行。\n\nunless 属性，正好和 if 属性相反，验证指定的属性是否存在，若存在，所在 target 将不会被执行。****\n\nextensionOf 属性，添加当前 target 到 extension-point 依赖列表。——Ant1.8.0 新特性。\n\n> extension-point 元素和 target 元素十分类似，都可以指定依赖的 target。但是不同的是，extension-point 中不能包含任何 task。\n\n请看以下实例：\n\n<target name="create-directory-layout">\n   ...\n</target>\n<extension-point name="ready-to-compile" depends="create-directory-layout"/>\n<target name="compile" depends="ready-to-compile">\n   ...\n</target>\n\n\n调用 target 顺序: create-directory-layout --\x3e \'empty slot\' --\x3e compile\n\n<target name="generate-sources" extensionOf="ready-to-compile">\n   ...\n</target>\n\n\n调用 target 顺序: create-directory-layout --\x3e generate-sources --\x3e compile\n\nonMissingExtensionPoint 属性：当无法找到一个 extension-point 时，target 尝试去做的动作("fail", "warn", "ignore")。——Ant1.8.2 新特性\n\n\n# Task 元素\n\ntask 是一段可以被执行的代码。\n\n一个 task 可以有多个属性， 一个属性可以包含对一个 property 的引用。\n\ntask 的通常结构为\n\n<name attribute1="value1" attribute2="value2" ... />\n\n\n其中，name 是 task 的名字， attributeN 是属性名， valueN 是这个属性的值。\n\n还是以 compile 做为例子：\n\n<target name="compile" depends="init" description="compile the source " >\n    \x3c!-- Compile the java code from srcintosrcinto{build} --\x3e\n    <javac srcdir="${src}" destdir="${build}"/>\n</target>\n\n\n在 compile 这个 target 标签中包含了一个任务。\n\n这个任务的动作是：执行 JAVA 编译，编译 src 下的代码，并把编译生成的文件放在 build 目录中。\n\n**常用 task **\n\njavac：用于编译一个或者多个 Java 源文件，通常需要 srcdir 和 destdir 两个属性，用于指定 Java 源文件的位置和编译后 class 文件的保存位置。\n\n<javac srcdir="${src}" destdir="${build}" classpath="abc.jar" debug="on" source="1.7" />\n\n\njava：用于运行某个 Java 类，通常需要 classname 属性，用于指定需要运行哪个类。\n\n<java classname="test.Main">\n    <arg value="-h" />\n    <classpath>\n        <pathelement location="dist/test.jar" />\n    </classpath>\n</java>\n\n\njar：用于生成 JAR 包，通常需要指定 destfile 属性，用于指定所创建 JAR 包的文件名。除此之外，通常还应指定一个文件集，表明需要将哪些文件打包到 JAR 包里。\n\n<jar jarfile="dist/lib/MyProject−dist/lib/MyProject−{DSTAMP}.jar" basedir="${build}"/>\n\n\necho：输出某个字符串。\n\n<echo message="Building to ${builddir}"/>\n<echo>You are using version ${java.version} of Java! This message spans two lines.</echo>\n\n\ncopy：用于复制文件或路径。\n\n<copy todir="${builddir}/srccopy">\n    <fileset dir="${srcdir}">\n        <include name="**/*.java"/>\n    </fileset>\n    <filterset>\n        <filter token="VERSION" value="${app.version}"/>\n    </filterset>\n</copy>\n\n\ndelete：用于删除文件或路径。\n\n<copy todir="${builddir}/srccopy">\n    <fileset dir="${srcdir}">\n        <include name="**/*.java"/>\n    </fileset>\n    <filterset>\n        <filter token="VERSION" value="${app.version}"/>\n    </filterset>\n</copy>\n\n\nmkdir：用于创建文件夹。\n\n<mkdir dir="${dist}/lib" />\n\n\nmove：用户移动文件和路径。\n\n<move todir="some/new/dir">\n    <fileset dir="my/src/dir">\n        <include name="**/*.jar" />\n        <exclude name="**/ant.jar" />\n    </fileset>\n</move>\n\n\n\n# Property 元素\n\nProperty 是对参数的定义。\n\nproject 的属性可以通过 property 元素来设定，也可在 Ant 之外设定。若要在外部引入某文件，例如 build.properties 文件，可以通过如下内容将其引入：<property file=” build.properties”/>。\n\nproperty 元素可用作 task 的属性值。在 task 中是通过将属性名放在“${”和“}”之间，并放在 task 属性值的位置来实现的。\n\n例如 complile 例子中，使用了前面定义的 src 作为源目录。\n\n<javac srcdir="${src}" destdir="${build}"/>\n\n\nAnt 提供了一些内置的属性，它能得到的系统属性的列表与 Java 文档中 System.getPropertis()方法得到的属性一致，这些系统属性可参考 sun 网站的说明。\n\n\n# extension-point 元素\n\n和 target 元素十分类似，都可以指定依赖的 target。但是不同的是，extension-point 中不能包含任何 task。\n\n——Ant1.8.0 新增特性。\n\n在 target 元素中的例子里已提到过，不再赘述。\n\n\n# 参考资料\n\n * ant 官方手册\n * http://www.blogjava.net/amigoxie/archive/2007/11/09/159413.html',normalizedContent:'# ant 简易教程\n\n\n# 简介\n\napache ant 是一个将软件编译、测试、部署等步骤联系在一起加以自动化的一个工具，大多用于 java 环境中的软件开发。由 apache 软件基金会所提供。\n\nant 是纯 java 语言编写的，所以具有很好的跨平台性。\n\n\n\n\n# 下载和安装\n\n\n# 下载\n\nant 的官方下载地址：http://ant.apache.org/bindownload.cgi\n\n进入页面后，在下图的红色方框中可以下载最新版本。笔者下载的版本是 apache-ant-1.9.4。\n\n\n\n\n# 配置环境变量\n\n配置环境变量（我的电脑 -> 属性 -> 高级 -> 环境变量）。\n\n设置 ant 环境变量：\n\nant_home c:/ apache-ant-1.9.4\n\n\n\n**path ** c:/ apache-ant-1.9.4/bin\n\n\n\nclasspath c:/apache-ant-1.9.4/lib\n\n\n\n\n# 验证\n\n点击 开始 -> 运行 -> 输入 cmd\n\n执行构建文件\n\n输入如下命令：ant\n\n如果出现如下内容，说明安装成功：\n\n> buildfile: build.xml does not exist! build failed\n\n注意：因为 ant 默认运行 build.xml 文件，这个文件需要我们创建。\n\n如果不想命名为 build.xml，运行时可以使用 ant -buildfile test.xml 命令指明要运行的构建文件。\n\n查看版本信息\n\n输入 ant -version，可以查看版本信息。\n\n\n\n但如果出现 \'ant\' 不是内部或外部命令，也不是可运行的程序或批处理文件，说明安装失败：（可以重复前述步骤，直至安装成功。）\n\n\n# 例子\n\n在安装和配置成功后，我们就可以使用 ant 了。\n\n为了让读者对 ant 有一个直观的认识，首先以 ant 官方手册上的一个简单例子做一个说明。\n\n以下是一个 build.xml 文件的内容：\n\n<project name="myproject" default="dist" basedir=".">\n    <description>\n        simple example build file\n    </description>\n  \x3c!-- set global properties for this build --\x3e\n  <property name="src" location="src"/>\n  <property name="build" location="build"/>\n  <property name="dist"  location="dist"/>\n\n  <target name="init">\n    \x3c!-- create the time stamp --\x3e\n    <tstamp/>\n    \x3c!-- create the build directory structure used by compile --\x3e\n    <mkdir dir="${build}"/>\n  </target>\n\n  <target name="compile" depends="init"\n        description="compile the source " >\n    \x3c!-- compile the java code from ${src} into ${build} --\x3e\n    <javac srcdir="${src}" destdir="${build}"/>\n  </target>\n\n  <target name="dist" depends="compile"\n        description="generate the distribution" >\n    \x3c!-- create the distribution directory --\x3e\n    <mkdir dir="${dist}/lib"/>\n\n    \x3c!-- put everything in ${build} into the myproject-${dstamp}.jar file --\x3e\n    <jar jarfile="${dist}/lib/myproject-${dstamp}.jar" basedir="${build}"/>\n  </target>\n\n  <target name="clean"\n        description="clean up" >\n    \x3c!-- delete the ${build} and ${dist} directory trees --\x3e\n    <delete dir="${build}"/>\n    <delete dir="${dist}"/>\n  </target>\n</project>\n\n\n在这个 xml 文件中，有几个 target 标签，每个 target 对应一个执行目标。\n\n我们将这个 build.xml 放在 d:\\temp\\ant_test 路径下，然后在 dos 界面下进行测试。\n\nant init\n\n\n\n在 d:\\temp\\ant_test 路径下创建了一个 build 目录，执行成功。\n\nant compile\n\n\n\n提示错误，原来是在 build.xml 的所在目录下找不到 src 目录。好的，我们直接创建一个 src 目录，然后再次尝试。这次，执行成功。\n\n\n\n**ant dist **\n\n\n\n在 d:\\temp\\ant_test 路径下创建了一个 dist 目录，执行成功。\n\nant clean\n\n\n\n清除创建的 build 和 dist 目录，执行成功。\n\n一个细节\n\n细心的读者，想必已经发现一个问题——在执行 ant compile 和 ant dist 命令的时候把前面的命令也执行了。这是为什么呢？\n\n请留意一下 build.xml 中的内容。有部分 target 标签中含有 depends 关键字。\n\n\n\n这表明，当前的 target 在执行时需要依赖其他的 target，必须先执行依赖的 target，然后再执行。\n\n\n# 关键元素\n\nant 的构件文件都是 xml 格式的。每个构件文件包含一个 project 元素和至少一个 target。\n\ntarget 元素可以包含多个 task 元素。\n\n\n# project 元素\n\nproject 元素是构建文件的根元素。\n\n一个 project 元素可以有多个 target 元素，一个 target 元素可以有多个 task。\n\n在上节的例子中，project 标签里有三个属性。\n\n<project name="myproject" default="dist" basedir=".">\n\n\nname 属性，指示 project 元素的名字。例子中的名字就是 myproject。\n\ndefault 属性，指示这个 project 默认执行的 target。在本文的例子中，默认执行的 target 为 dist。\n\n如果我们输入命令 ant 时，不指定 target 参数，默认会执行 dist 这个 target。\n\nbasedir 属性，指定根路径的位置。该属性没有指定时，使用 ant 的构件文件的所在目录作为根目录。\n\n\n# target 元素\n\ntarget 元素是 task 的容器，也就是 ant 的一个基本执行单元。\n\n以上节例子中的 compile 来举例。\n\n<target name="compile" depends="init" description="compile the source " >\n    \x3c!-- compile the java code from ${src} into ${build} --\x3e\n    <javac srcdir="${src}" destdir="${build}"/>\n</target>\n\n\n这个 target 中出现了几个属性。\n\nname 属性，指示 target 元素的名称。\n\n这个属性在一个 project 元素中必须是唯一的。这很好理解，如果出现重复，ant 就不知道具体该执行哪个 target 了。\n\ndepends 属性，指示依赖的 target，当前的 target 必须在依赖的 target 之后执行。\n\ndescription 属性，是关于 target 的简短说明。\n\n此外，还有其他几个未出现在构建文件中的属性。\n\nif 属性，验证指定的属性是否存在，若不存在，所在 target 将不会被执行。\n\nunless 属性，正好和 if 属性相反，验证指定的属性是否存在，若存在，所在 target 将不会被执行。****\n\nextensionof 属性，添加当前 target 到 extension-point 依赖列表。——ant1.8.0 新特性。\n\n> extension-point 元素和 target 元素十分类似，都可以指定依赖的 target。但是不同的是，extension-point 中不能包含任何 task。\n\n请看以下实例：\n\n<target name="create-directory-layout">\n   ...\n</target>\n<extension-point name="ready-to-compile" depends="create-directory-layout"/>\n<target name="compile" depends="ready-to-compile">\n   ...\n</target>\n\n\n调用 target 顺序: create-directory-layout --\x3e \'empty slot\' --\x3e compile\n\n<target name="generate-sources" extensionof="ready-to-compile">\n   ...\n</target>\n\n\n调用 target 顺序: create-directory-layout --\x3e generate-sources --\x3e compile\n\nonmissingextensionpoint 属性：当无法找到一个 extension-point 时，target 尝试去做的动作("fail", "warn", "ignore")。——ant1.8.2 新特性\n\n\n# task 元素\n\ntask 是一段可以被执行的代码。\n\n一个 task 可以有多个属性， 一个属性可以包含对一个 property 的引用。\n\ntask 的通常结构为\n\n<name attribute1="value1" attribute2="value2" ... />\n\n\n其中，name 是 task 的名字， attributen 是属性名， valuen 是这个属性的值。\n\n还是以 compile 做为例子：\n\n<target name="compile" depends="init" description="compile the source " >\n    \x3c!-- compile the java code from srcintosrcinto{build} --\x3e\n    <javac srcdir="${src}" destdir="${build}"/>\n</target>\n\n\n在 compile 这个 target 标签中包含了一个任务。\n\n这个任务的动作是：执行 java 编译，编译 src 下的代码，并把编译生成的文件放在 build 目录中。\n\n**常用 task **\n\njavac：用于编译一个或者多个 java 源文件，通常需要 srcdir 和 destdir 两个属性，用于指定 java 源文件的位置和编译后 class 文件的保存位置。\n\n<javac srcdir="${src}" destdir="${build}" classpath="abc.jar" debug="on" source="1.7" />\n\n\njava：用于运行某个 java 类，通常需要 classname 属性，用于指定需要运行哪个类。\n\n<java classname="test.main">\n    <arg value="-h" />\n    <classpath>\n        <pathelement location="dist/test.jar" />\n    </classpath>\n</java>\n\n\njar：用于生成 jar 包，通常需要指定 destfile 属性，用于指定所创建 jar 包的文件名。除此之外，通常还应指定一个文件集，表明需要将哪些文件打包到 jar 包里。\n\n<jar jarfile="dist/lib/myproject−dist/lib/myproject−{dstamp}.jar" basedir="${build}"/>\n\n\necho：输出某个字符串。\n\n<echo message="building to ${builddir}"/>\n<echo>you are using version ${java.version} of java! this message spans two lines.</echo>\n\n\ncopy：用于复制文件或路径。\n\n<copy todir="${builddir}/srccopy">\n    <fileset dir="${srcdir}">\n        <include name="**/*.java"/>\n    </fileset>\n    <filterset>\n        <filter token="version" value="${app.version}"/>\n    </filterset>\n</copy>\n\n\ndelete：用于删除文件或路径。\n\n<copy todir="${builddir}/srccopy">\n    <fileset dir="${srcdir}">\n        <include name="**/*.java"/>\n    </fileset>\n    <filterset>\n        <filter token="version" value="${app.version}"/>\n    </filterset>\n</copy>\n\n\nmkdir：用于创建文件夹。\n\n<mkdir dir="${dist}/lib" />\n\n\nmove：用户移动文件和路径。\n\n<move todir="some/new/dir">\n    <fileset dir="my/src/dir">\n        <include name="**/*.jar" />\n        <exclude name="**/ant.jar" />\n    </fileset>\n</move>\n\n\n\n# property 元素\n\nproperty 是对参数的定义。\n\nproject 的属性可以通过 property 元素来设定，也可在 ant 之外设定。若要在外部引入某文件，例如 build.properties 文件，可以通过如下内容将其引入：<property file=” build.properties”/>。\n\nproperty 元素可用作 task 的属性值。在 task 中是通过将属性名放在“${”和“}”之间，并放在 task 属性值的位置来实现的。\n\n例如 complile 例子中，使用了前面定义的 src 作为源目录。\n\n<javac srcdir="${src}" destdir="${build}"/>\n\n\nant 提供了一些内置的属性，它能得到的系统属性的列表与 java 文档中 system.getpropertis()方法得到的属性一致，这些系统属性可参考 sun 网站的说明。\n\n\n# extension-point 元素\n\n和 target 元素十分类似，都可以指定依赖的 target。但是不同的是，extension-point 中不能包含任何 task。\n\n——ant1.8.0 新增特性。\n\n在 target 元素中的例子里已提到过，不再赘述。\n\n\n# 参考资料\n\n * ant 官方手册\n * http://www.blogjava.net/amigoxie/archive/2007/11/09/159413.html',charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Intellij IDEA 快速入门",frontmatter:{title:"Intellij IDEA 快速入门",date:"2019-11-29T18:10:14.000Z",order:1,categories:["Java","软件","IDE"],tags:["Java","IDE","Intellij"],permalink:"/pages/ac5c6a/"},regularPath:"/01.Java/11.%E8%BD%AF%E4%BB%B6/02.IDE/01.Intellij.html",relativePath:"01.Java/11.软件/02.IDE/01.Intellij.md",key:"v-5a249b69",path:"/pages/ac5c6a/",headers:[{level:2,title:"快捷键",slug:"快捷键",normalizedTitle:"快捷键",charIndex:25},{level:3,title:"核心快捷键",slug:"核心快捷键",normalizedTitle:"核心快捷键",charIndex:33},{level:3,title:"快捷键分类",slug:"快捷键分类",normalizedTitle:"快捷键分类",charIndex:1634},{level:4,title:"Tradition",slug:"tradition",normalizedTitle:"tradition",charIndex:1643},{level:4,title:"Editing",slug:"editing",normalizedTitle:"editing",charIndex:1902},{level:4,title:"Search/Replace",slug:"search-replace",normalizedTitle:"search/replace",charIndex:3944},{level:4,title:"Usage Search",slug:"usage-search",normalizedTitle:"usage search",charIndex:4269},{level:4,title:"Compile and Run",slug:"compile-and-run",normalizedTitle:"compile and run",charIndex:4452},{level:4,title:"Debugging",slug:"debugging",normalizedTitle:"debugging",charIndex:4691},{level:4,title:"Navigation",slug:"navigation",normalizedTitle:"navigation",charIndex:5272},{level:4,title:"Refactoring",slug:"refactoring",normalizedTitle:"refactoring",charIndex:6830},{level:4,title:"VCS/Local History",slug:"vcs-local-history",normalizedTitle:"vcs/local history",charIndex:6951},{level:4,title:"Live Templates",slug:"live-templates",normalizedTitle:"live templates",charIndex:7187},{level:4,title:"General",slug:"general",normalizedTitle:"general",charIndex:7299},{level:3,title:"Intellij IDEA 官方快捷键表",slug:"intellij-idea-官方快捷键表",normalizedTitle:"intellij idea 官方快捷键表",charIndex:7675},{level:2,title:"插件",slug:"插件",normalizedTitle:"插件",charIndex:7702},{level:2,title:"个性化",slug:"个性化",normalizedTitle:"个性化",charIndex:8137},{level:3,title:"颜色主题",slug:"颜色主题",normalizedTitle:"颜色主题",charIndex:8145},{level:2,title:"FAQ",slug:"faq",normalizedTitle:"faq",charIndex:8202},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:8488}],headersStr:"快捷键 核心快捷键 快捷键分类 Tradition Editing Search/Replace Usage Search Compile and Run Debugging Navigation Refactoring VCS/Local History Live Templates General Intellij IDEA 官方快捷键表 插件 个性化 颜色主题 FAQ 参考资料",content:'# Intellij IDEA 快速入门\n\n\n# 快捷键\n\n\n# 核心快捷键\n\nIntelliJ IDEA 作为一个以快捷键为中心的 IDE，为大多数操作建议了键盘快捷键。在这个主题中，您可以找到最不可缺少的列表，使 IntelliJ IDEA 轻松实现第一步。\n\n核心快捷键表：\n\n操作                                                    快捷键\n根据名称查找操作                                              Ctrl+Shift+A\n显示可用 意图操作 列表                                          Alt+Enter\n切换视图 (Project,Structure, etc.).                       Alt+F1\n切换工具窗口和在编辑器中打开的文件                                     Ctrl+Tab\n显示 导航栏.                                               Alt+Home\n插入代码模板.                                               Ctrl+J\n在周围插入代码模板.                                            Ctrl+Alt+J\nEdit an item from the Project or another tree view.   F4\n注释                                                    Ctrl+/ Ctrl+Shift+/\n根据名称查找类或文件.                                           Ctrl+N Ctrl+Shift+N\n拷贝当前行或指定的行.                                           Ctrl+D\n增加或减少选中的表达式.                                          Ctrl+W and Ctrl+Shift+W\n在当前文件查找或替换.                                           Ctrl+F Ctrl+R\n在项目中或指定的目录中查找或替换                                      Ctrl+Shift+F Ctrl+Shift+R\n全局搜索                                                  双击 Shift\n快速查看选中对象的引用.                                          Ctrl+Shift+F7\n展开或折叠编辑器中的代码块.                                        Ctrl+NumPad Plus Ctrl+NumPad -\n调用代码完成.                                               Ctrl+Space\n智能声明完成.                                               Ctrl+Shift+Enter\n智能补全代码                                                Ctrl+Shift+Space\n显示可用的重构方法列表                                           Ctrl+Shift+Alt+T\n\n\n# 快捷键分类\n\n# Tradition\n\n快捷键                介绍\nCtrl + Z           撤销\nCtrl + Shift + Z   取消撤销\nCtrl + X           剪切\nCtrl + C           复制\nCtrl + S           保存\nTab                缩进\nShift + Tab        取消缩进\nShift + Home/End   选中光标到当前行头位置/行尾位置\nCtrl + Home/End    跳到文件头/文件尾\n\n# Editing\n\n快捷键                      介绍\nCtrl + Space             基础代码补全，默认在 Windows 系统上被输入法占用，需要进行修改，建议修改为 Ctrl + 逗号（必备）\nCtrl + Alt + Space       类名自动完成\nCtrl + Shift + Enter     自动结束代码，行末自动添加分号（必备）\nCtrl + P                 方法参数提示显示\nCtrl + Q                 光标所在的变量/类名/方法名等上面（也可以在提示补充的时候按），显示文档内容\nShift + F1               如果有外部文档可以连接外部文档\nCtrl + F1                在光标所在的错误代码处显示错误信息（必备）\nAlt + Insert             代码自动生成，如生成对象的 set/get 方法，构造函数，toString() 等（必备）\nCtrl + O                 选择可重写的方法\nCtrl + I                 选择可继承的方法\nCtrl + Alt + T           对选中的代码弹出环绕选项弹出层（必备）\nCtrl + /                 注释光标所在行代码，会根据当前不同文件类型使用不同的注释符号（必备）\nCtrl + Shift + /         代码块注释（必备）\nCtrl + W                 递进式选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展选中范围（必备）\nCtrl + Shift + W         递进式取消选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展取消选中范围（必备）\nAlt + Q                  弹出一个提示，显示当前类的声明/上下文信息\nAlt + Enter              IntelliJ IDEA 根据光标所在问题，提供快速修复选择，光标放在的位置不同提示的结果也不同（必备）\nCtrl + Alt + L           格式化代码，可以对当前文件和整个包目录使用（必备）\nCtrl + Alt + O           优化导入的类，可以对当前文件和整个包目录使用（必备）\nCtrl + Alt + I           光标所在行 或 选中部分进行自动代码缩进，有点类似格式化\nCtrl + Shift + C         复制当前文件磁盘路径到剪贴板（必备）\nCtrl + Shift + V         弹出缓存的最近拷贝的内容管理器弹出层\nCtrl + Alt + Shift + C   复制参考信息\nCtrl + Alt + Shift + V   无格式黏贴（必备）\nCtrl + D                 复制光标所在行 或 复制选择内容，并把复制内容插入光标位置下面（必备）\nCtrl + Y                 删除光标所在行 或 删除选中的行（必备）\nCtrl + Shift + J         自动将下一行合并到当前行末尾（必备）\nShift + Enter            开始新一行。光标所在行下空出一行，光标定位到新行位置（必备）\nCtrl + Shift + U         对选中的代码进行大/小写轮流转换（必备）\nCtrl + Shift + ]/[       选中从光标所在位置到它的底部/顶部的中括号位置（必备）\nCtrl + Delete            删除光标后面的单词或是中文句（必备）\nCtrl + BackSpace         删除光标前面的单词或是中文句（必备）\nCtrl + +/-               展开/折叠代码块\nCtrl + Shift + +/-       展开/折叠所有代码（必备）\nCtrl + F4                关闭当前编辑文件\nCtrl + Shift + Up/Down   光标放在方法名上，将方法移动到上一个/下一个方法前面，调整方法排序（必备）\nAlt + Shift + Up/Down    移动光标所在行向上移动/向下移动（必备）\nCtrl + Shift + 左键单击      把光标放在某个类变量上，按此快捷键可以直接定位到该类中（必备）\nAlt + Shift + 左键双击       选择被双击的单词/中文句，按住不放，可以同时选择其他单词/中文句（必备）\nCtrl + Shift + T         对当前类生成单元测试类，如果已经存在的单元测试类则可以进行选择（必备）\n\n# Search/Replace\n\n快捷键                介绍\nDouble Shift       弹出 Search Everywhere 弹出层\nF3                 在查找模式下，定位到下一个匹配处\nShift + F3         在查找模式下，查找匹配上一个\nCtrl + F           在当前文件进行文本查找（必备）\nCtrl + R           在当前文件进行文本替换（必备）\nCtrl + Shift + F   根据输入内容查找整个项目 或 指定目录内文件（必备）\nCtrl + Shift + R   根据输入内容替换对应内容，范围为整个项目 或 指定目录内文件（必备）\n\n# Usage Search\n\n快捷键                 介绍\nAlt + F7            查找光标所在的方法/变量/类被调用的地方\nCtrl + Alt + F7     显示使用的地方。寻找被该类或是变量被调用的地方，用弹出框的方式找出来\nCtrl + Shift + F7   高亮显示所有该选中文本，按 Esc 高亮消失（必备）\n\n# Compile and Run\n\n快捷键                 介绍\nCtrl + F9           执行 Make Project 操作\nCtrl + Shift + F9   编译选中的文件/包/Module\nShift + F9          Debug\nShift + F10         Run\nAlt + Shift + F9    弹出 Debug 的可选择菜单\nAlt + Shift + F10   弹出 Run 的可选择菜单\n\n# Debugging\n\n快捷键                 介绍\nF7                  在 Debug\n                    模式下，进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该方法体还有方法，则不会进入该内嵌的方法中\nF8                  在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则不进入当前方法体内\nShift + F7          在 Debug 模式下，智能步入。断点所在行上有多个方法调用，会弹出进入哪个方法\nShift + F8          在 Debug 模式下，跳出，表现出来的效果跟 F9 一样\nAlt + F8            在 Debug 模式下，选中对象，弹出可输入计算表达式调试框，查看该输入内容的调试结果\nAlt + F9            在 Debug 模式下，执行到光标处\nF9                  在 Debug 模式下，恢复程序运行，但是如果该断点下面代码还有断点则停在下一个断点上\nCtrl + F8           在 Debug 模式下，设置光标当前行为断点，如果当前已经是断点则去掉断点\nCtrl + Shift + F8   在 Debug 模式下，指定断点进入条件\n\n# Navigation\n\n快捷键                        介绍\nCtrl + N                   跳转到类（必备）\nCtrl + Shift + N           跳转到文件（必备）\nCtrl + Alt + Shift + N     跳转到符号（必备）\nAlt + Left/Right           切换当前已打开的窗口中的子视图，比如 Debug 窗口中有 Output、Debugger\n                           等子视图，用此快捷键就可以在子视图中切换（必备）\nF12                        回到前一个工具窗口（必备）\nESC                        从工具窗口进入代码文件窗口（必备）\nShift + ESC                隐藏当前 或 最后一个激活的工具窗口\nCtrl + G                   跳转到当前文件的指定行处\nCtrl + E                   显示最近打开的文件记录列表（必备）\nCtrl + Shift + E           显示最近编辑的文件记录列表（必备）\nCtrl + Alt + Left/Right    跳转到上一个/下一个操作的地方（必备）\nCtrl + Shift + Backspace   退回到上次修改的地方（必备）\nAlt + F1                   显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择（必备）\nCtrl + B/Ctrl + 左键单击       跳转到声明处\nCtrl + Alt + B             在某个调用的方法名上使用会跳到具体的实现处，可以跳过接口\nCtrl + Shift + B           跳转到类型声明处（必备）\nCtrl + Shift + I           快速查看光标所在的方法 或 类的定义\nCtrl + U                   前往当前光标所在的方法的父类的方法/接口定义（必备）\nAlt + Up/Down              跳转到当前文件的前一个/后一个方法（必备）\nCtrl + ]/[                 跳转到当前所在代码的花括号结束位置/开始位置\nCtrl + F12                 弹出当前文件结构层，可以在弹出的层上直接输入，进行筛选\nCtrl + H                   显示当前类的层次结构\nCtrl + Shift + H           显示方法层次结构\nCtrl + Alt + H             调用层次\nF2/Shift + F2              跳转到下一个/上一个高亮错误 或 警告位置（必备）\nF4                         编辑源（必备）\nAlt + Home                 定位/显示到当前文件的 Navigation Bar\nF11                        添加书签（必备）\nCtrl + F11                 选中文件/文件夹，使用助记符设定/取消书签（必备）\nShift + F11                弹出书签显示层（必备）\nAlt + 1,2,3...9            显示对应数值的选项卡，其中 1 是 Project 用得最多（必备）\nCtrl + 1,2,3...9           定位到对应数值的书签位置（必备）\n\n# Refactoring\n\n快捷键                      介绍\nShift + F6               对文件/文件夹 重命名（必备）\nCtrl + Alt + Shift + T   打开重构菜单（必备）\n\n# VCS/Local History\n\n快捷键               介绍\nCtrl + K          版本控制提交项目，需要此项目有加入到版本控制才可用\nCtrl + T          版本控制更新项目，需要此项目有加入到版本控制才可用\nAlt + |           显示版本控制常用操作菜单弹出层（必备）\nAlt + Shift + C   查看最近操作项目的变化情况列表\nAlt + Shift + N   选择/添加 task（必备）\n\n# Live Templates\n\n快捷键              介绍\nCtrl + J         插入自定义动态代码模板（必备）\nCtrl + Alt + J   弹出模板选择窗口，将选定的代码加入动态模板中\n\n# General\n\n快捷键                      介绍\nCtrl + Tab               编辑窗口切换，如果在切换的过程又加按上 delete，则是关闭对应选中的窗口\nCtrl + Alt + Y           同步、刷新\nCtrl + Alt + S           打开 IntelliJ IDEA 系统设置（必备）\nCtrl + Alt + Shift + S   打开当前项目设置（必备）\nCtrl + Shift + A         查找动作/设置（必备）\nCtrl + Shift + F12       编辑器最大化（必备）\nAlt + Shift + F          显示添加到收藏夹弹出层/添加到收藏夹\nAlt + Shift + I          查看项目当前文件\n\n\n# Intellij IDEA 官方快捷键表\n\n\n\n\n# 插件\n\n推荐几个比较好用的插件\n\n * Key promoter 快捷键提示\n * CamelCase 驼峰式命名和下划线命名交替变化\n * CheckStyle-IDEA 代码规范检查\n * FindBugs-IDEA潜在 Bug 检查\n * MetricsReloaded 代码复杂度检查\n * Statistic 代码统计\n * JRebel Plugin 热部署\n * GsonFormat 把 JSON 字符串直接实例化成类\n * Eclipse Code Formatter 如果你以前用的是 IDE，并有自己的一套代码风格配置，可以通过此插件导入到 IDEA\n * Alibaba Java Coding Guidelines 阿里 Java 开发规范的静态检查工具\n * IDE Features Trainer 官方的新手训练插件\n * Markdown Navigator Markdown 插件，适用于喜欢用 markdown 写文档的人\n\n\n# 个性化\n\n\n# 颜色主题\n\nintellij-colors-solarized 个人觉得这种色彩搭配十分优雅\n\n下载地址\n\n\n# FAQ\n\n（1）运行时报错\n\n> Error running XXX. Command line is too long. Shorten the command line via JAR manifest or via a classpath file and rerun\n\n解决方案：\n\n找到 .idea/libraies/workspace.xml 中的 <component name="PropertiesComponent">\n\n添加一行配置：\n\n<property name="dynamic.classpath" value="true" />\n\n\n\n# 参考资料\n\n * IntelliJ-IDEA-Tutorial\n * 极客学院 - Intellij IDEA 使用教程',normalizedContent:'# intellij idea 快速入门\n\n\n# 快捷键\n\n\n# 核心快捷键\n\nintellij idea 作为一个以快捷键为中心的 ide，为大多数操作建议了键盘快捷键。在这个主题中，您可以找到最不可缺少的列表，使 intellij idea 轻松实现第一步。\n\n核心快捷键表：\n\n操作                                                    快捷键\n根据名称查找操作                                              ctrl+shift+a\n显示可用 意图操作 列表                                          alt+enter\n切换视图 (project,structure, etc.).                       alt+f1\n切换工具窗口和在编辑器中打开的文件                                     ctrl+tab\n显示 导航栏.                                               alt+home\n插入代码模板.                                               ctrl+j\n在周围插入代码模板.                                            ctrl+alt+j\nedit an item from the project or another tree view.   f4\n注释                                                    ctrl+/ ctrl+shift+/\n根据名称查找类或文件.                                           ctrl+n ctrl+shift+n\n拷贝当前行或指定的行.                                           ctrl+d\n增加或减少选中的表达式.                                          ctrl+w and ctrl+shift+w\n在当前文件查找或替换.                                           ctrl+f ctrl+r\n在项目中或指定的目录中查找或替换                                      ctrl+shift+f ctrl+shift+r\n全局搜索                                                  双击 shift\n快速查看选中对象的引用.                                          ctrl+shift+f7\n展开或折叠编辑器中的代码块.                                        ctrl+numpad plus ctrl+numpad -\n调用代码完成.                                               ctrl+space\n智能声明完成.                                               ctrl+shift+enter\n智能补全代码                                                ctrl+shift+space\n显示可用的重构方法列表                                           ctrl+shift+alt+t\n\n\n# 快捷键分类\n\n# tradition\n\n快捷键                介绍\nctrl + z           撤销\nctrl + shift + z   取消撤销\nctrl + x           剪切\nctrl + c           复制\nctrl + s           保存\ntab                缩进\nshift + tab        取消缩进\nshift + home/end   选中光标到当前行头位置/行尾位置\nctrl + home/end    跳到文件头/文件尾\n\n# editing\n\n快捷键                      介绍\nctrl + space             基础代码补全，默认在 windows 系统上被输入法占用，需要进行修改，建议修改为 ctrl + 逗号（必备）\nctrl + alt + space       类名自动完成\nctrl + shift + enter     自动结束代码，行末自动添加分号（必备）\nctrl + p                 方法参数提示显示\nctrl + q                 光标所在的变量/类名/方法名等上面（也可以在提示补充的时候按），显示文档内容\nshift + f1               如果有外部文档可以连接外部文档\nctrl + f1                在光标所在的错误代码处显示错误信息（必备）\nalt + insert             代码自动生成，如生成对象的 set/get 方法，构造函数，tostring() 等（必备）\nctrl + o                 选择可重写的方法\nctrl + i                 选择可继承的方法\nctrl + alt + t           对选中的代码弹出环绕选项弹出层（必备）\nctrl + /                 注释光标所在行代码，会根据当前不同文件类型使用不同的注释符号（必备）\nctrl + shift + /         代码块注释（必备）\nctrl + w                 递进式选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展选中范围（必备）\nctrl + shift + w         递进式取消选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展取消选中范围（必备）\nalt + q                  弹出一个提示，显示当前类的声明/上下文信息\nalt + enter              intellij idea 根据光标所在问题，提供快速修复选择，光标放在的位置不同提示的结果也不同（必备）\nctrl + alt + l           格式化代码，可以对当前文件和整个包目录使用（必备）\nctrl + alt + o           优化导入的类，可以对当前文件和整个包目录使用（必备）\nctrl + alt + i           光标所在行 或 选中部分进行自动代码缩进，有点类似格式化\nctrl + shift + c         复制当前文件磁盘路径到剪贴板（必备）\nctrl + shift + v         弹出缓存的最近拷贝的内容管理器弹出层\nctrl + alt + shift + c   复制参考信息\nctrl + alt + shift + v   无格式黏贴（必备）\nctrl + d                 复制光标所在行 或 复制选择内容，并把复制内容插入光标位置下面（必备）\nctrl + y                 删除光标所在行 或 删除选中的行（必备）\nctrl + shift + j         自动将下一行合并到当前行末尾（必备）\nshift + enter            开始新一行。光标所在行下空出一行，光标定位到新行位置（必备）\nctrl + shift + u         对选中的代码进行大/小写轮流转换（必备）\nctrl + shift + ]/[       选中从光标所在位置到它的底部/顶部的中括号位置（必备）\nctrl + delete            删除光标后面的单词或是中文句（必备）\nctrl + backspace         删除光标前面的单词或是中文句（必备）\nctrl + +/-               展开/折叠代码块\nctrl + shift + +/-       展开/折叠所有代码（必备）\nctrl + f4                关闭当前编辑文件\nctrl + shift + up/down   光标放在方法名上，将方法移动到上一个/下一个方法前面，调整方法排序（必备）\nalt + shift + up/down    移动光标所在行向上移动/向下移动（必备）\nctrl + shift + 左键单击      把光标放在某个类变量上，按此快捷键可以直接定位到该类中（必备）\nalt + shift + 左键双击       选择被双击的单词/中文句，按住不放，可以同时选择其他单词/中文句（必备）\nctrl + shift + t         对当前类生成单元测试类，如果已经存在的单元测试类则可以进行选择（必备）\n\n# search/replace\n\n快捷键                介绍\ndouble shift       弹出 search everywhere 弹出层\nf3                 在查找模式下，定位到下一个匹配处\nshift + f3         在查找模式下，查找匹配上一个\nctrl + f           在当前文件进行文本查找（必备）\nctrl + r           在当前文件进行文本替换（必备）\nctrl + shift + f   根据输入内容查找整个项目 或 指定目录内文件（必备）\nctrl + shift + r   根据输入内容替换对应内容，范围为整个项目 或 指定目录内文件（必备）\n\n# usage search\n\n快捷键                 介绍\nalt + f7            查找光标所在的方法/变量/类被调用的地方\nctrl + alt + f7     显示使用的地方。寻找被该类或是变量被调用的地方，用弹出框的方式找出来\nctrl + shift + f7   高亮显示所有该选中文本，按 esc 高亮消失（必备）\n\n# compile and run\n\n快捷键                 介绍\nctrl + f9           执行 make project 操作\nctrl + shift + f9   编译选中的文件/包/module\nshift + f9          debug\nshift + f10         run\nalt + shift + f9    弹出 debug 的可选择菜单\nalt + shift + f10   弹出 run 的可选择菜单\n\n# debugging\n\n快捷键                 介绍\nf7                  在 debug\n                    模式下，进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该方法体还有方法，则不会进入该内嵌的方法中\nf8                  在 debug 模式下，进入下一步，如果当前行断点是一个方法，则不进入当前方法体内\nshift + f7          在 debug 模式下，智能步入。断点所在行上有多个方法调用，会弹出进入哪个方法\nshift + f8          在 debug 模式下，跳出，表现出来的效果跟 f9 一样\nalt + f8            在 debug 模式下，选中对象，弹出可输入计算表达式调试框，查看该输入内容的调试结果\nalt + f9            在 debug 模式下，执行到光标处\nf9                  在 debug 模式下，恢复程序运行，但是如果该断点下面代码还有断点则停在下一个断点上\nctrl + f8           在 debug 模式下，设置光标当前行为断点，如果当前已经是断点则去掉断点\nctrl + shift + f8   在 debug 模式下，指定断点进入条件\n\n# navigation\n\n快捷键                        介绍\nctrl + n                   跳转到类（必备）\nctrl + shift + n           跳转到文件（必备）\nctrl + alt + shift + n     跳转到符号（必备）\nalt + left/right           切换当前已打开的窗口中的子视图，比如 debug 窗口中有 output、debugger\n                           等子视图，用此快捷键就可以在子视图中切换（必备）\nf12                        回到前一个工具窗口（必备）\nesc                        从工具窗口进入代码文件窗口（必备）\nshift + esc                隐藏当前 或 最后一个激活的工具窗口\nctrl + g                   跳转到当前文件的指定行处\nctrl + e                   显示最近打开的文件记录列表（必备）\nctrl + shift + e           显示最近编辑的文件记录列表（必备）\nctrl + alt + left/right    跳转到上一个/下一个操作的地方（必备）\nctrl + shift + backspace   退回到上次修改的地方（必备）\nalt + f1                   显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择（必备）\nctrl + b/ctrl + 左键单击       跳转到声明处\nctrl + alt + b             在某个调用的方法名上使用会跳到具体的实现处，可以跳过接口\nctrl + shift + b           跳转到类型声明处（必备）\nctrl + shift + i           快速查看光标所在的方法 或 类的定义\nctrl + u                   前往当前光标所在的方法的父类的方法/接口定义（必备）\nalt + up/down              跳转到当前文件的前一个/后一个方法（必备）\nctrl + ]/[                 跳转到当前所在代码的花括号结束位置/开始位置\nctrl + f12                 弹出当前文件结构层，可以在弹出的层上直接输入，进行筛选\nctrl + h                   显示当前类的层次结构\nctrl + shift + h           显示方法层次结构\nctrl + alt + h             调用层次\nf2/shift + f2              跳转到下一个/上一个高亮错误 或 警告位置（必备）\nf4                         编辑源（必备）\nalt + home                 定位/显示到当前文件的 navigation bar\nf11                        添加书签（必备）\nctrl + f11                 选中文件/文件夹，使用助记符设定/取消书签（必备）\nshift + f11                弹出书签显示层（必备）\nalt + 1,2,3...9            显示对应数值的选项卡，其中 1 是 project 用得最多（必备）\nctrl + 1,2,3...9           定位到对应数值的书签位置（必备）\n\n# refactoring\n\n快捷键                      介绍\nshift + f6               对文件/文件夹 重命名（必备）\nctrl + alt + shift + t   打开重构菜单（必备）\n\n# vcs/local history\n\n快捷键               介绍\nctrl + k          版本控制提交项目，需要此项目有加入到版本控制才可用\nctrl + t          版本控制更新项目，需要此项目有加入到版本控制才可用\nalt + |           显示版本控制常用操作菜单弹出层（必备）\nalt + shift + c   查看最近操作项目的变化情况列表\nalt + shift + n   选择/添加 task（必备）\n\n# live templates\n\n快捷键              介绍\nctrl + j         插入自定义动态代码模板（必备）\nctrl + alt + j   弹出模板选择窗口，将选定的代码加入动态模板中\n\n# general\n\n快捷键                      介绍\nctrl + tab               编辑窗口切换，如果在切换的过程又加按上 delete，则是关闭对应选中的窗口\nctrl + alt + y           同步、刷新\nctrl + alt + s           打开 intellij idea 系统设置（必备）\nctrl + alt + shift + s   打开当前项目设置（必备）\nctrl + shift + a         查找动作/设置（必备）\nctrl + shift + f12       编辑器最大化（必备）\nalt + shift + f          显示添加到收藏夹弹出层/添加到收藏夹\nalt + shift + i          查看项目当前文件\n\n\n# intellij idea 官方快捷键表\n\n\n\n\n# 插件\n\n推荐几个比较好用的插件\n\n * key promoter 快捷键提示\n * camelcase 驼峰式命名和下划线命名交替变化\n * checkstyle-idea 代码规范检查\n * findbugs-idea潜在 bug 检查\n * metricsreloaded 代码复杂度检查\n * statistic 代码统计\n * jrebel plugin 热部署\n * gsonformat 把 json 字符串直接实例化成类\n * eclipse code formatter 如果你以前用的是 ide，并有自己的一套代码风格配置，可以通过此插件导入到 idea\n * alibaba java coding guidelines 阿里 java 开发规范的静态检查工具\n * ide features trainer 官方的新手训练插件\n * markdown navigator markdown 插件，适用于喜欢用 markdown 写文档的人\n\n\n# 个性化\n\n\n# 颜色主题\n\nintellij-colors-solarized 个人觉得这种色彩搭配十分优雅\n\n下载地址\n\n\n# faq\n\n（1）运行时报错\n\n> error running xxx. command line is too long. shorten the command line via jar manifest or via a classpath file and rerun\n\n解决方案：\n\n找到 .idea/libraies/workspace.xml 中的 <component name="propertiescomponent">\n\n添加一行配置：\n\n<property name="dynamic.classpath" value="true" />\n\n\n\n# 参考资料\n\n * intellij-idea-tutorial\n * 极客学院 - intellij idea 使用教程',charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Eclipse 快速入门",frontmatter:{title:"Eclipse 快速入门",date:"2018-07-01T11:27:47.000Z",order:2,categories:["Java","软件","IDE"],tags:["Java","IDE"],permalink:"/pages/2257c7/"},regularPath:"/01.Java/11.%E8%BD%AF%E4%BB%B6/02.IDE/02.Eclipse.html",relativePath:"01.Java/11.软件/02.IDE/02.Eclipse.md",key:"v-a4ec7cea",path:"/pages/2257c7/",headers:[{level:2,title:"代码智能提示",slug:"代码智能提示",normalizedTitle:"代码智能提示",charIndex:19},{level:3,title:"Java 智能提示",slug:"java-智能提示",normalizedTitle:"java 智能提示",charIndex:30},{level:3,title:"JavaScript 智能提示",slug:"javascript-智能提示",normalizedTitle:"javascript 智能提示",charIndex:369},{level:3,title:"HTML 智能提示",slug:"html-智能提示",normalizedTitle:"html 智能提示",charIndex:474},{level:2,title:"插件安装",slug:"插件安装",normalizedTitle:"插件安装",charIndex:606},{level:2,title:"基本设置",slug:"基本设置",normalizedTitle:"基本设置",charIndex:1445},{level:2,title:"设置文本文件及 JSP 文件编码",slug:"设置文本文件及-jsp-文件编码",normalizedTitle:"设置文本文件及 jsp 文件编码",charIndex:1713},{level:2,title:"设置 JDK 本地 JavaDOC API 路径及源码路径",slug:"设置-jdk-本地-javadoc-api-路径及源码路径",normalizedTitle:"设置 jdk 本地 javadoc api 路径及源码路径",charIndex:1817},{level:2,title:"设置 Servlet 源码或其它 Jar 包源码",slug:"设置-servlet-源码或其它-jar-包源码",normalizedTitle:"设置 servlet 源码或其它 jar 包源码",charIndex:2162},{level:2,title:"反编译插件 JD-Eclipse",slug:"反编译插件-jd-eclipse",normalizedTitle:"反编译插件 jd-eclipse",charIndex:2632},{level:2,title:"Validate 优化",slug:"validate-优化",normalizedTitle:"validate 优化",charIndex:3006},{level:2,title:"常用快捷键",slug:"常用快捷键",normalizedTitle:"常用快捷键",charIndex:3336}],headersStr:"代码智能提示 Java 智能提示 JavaScript 智能提示 HTML 智能提示 插件安装 基本设置 设置文本文件及 JSP 文件编码 设置 JDK 本地 JavaDOC API 路径及源码路径 设置 Servlet 源码或其它 Jar 包源码 反编译插件 JD-Eclipse Validate 优化 常用快捷键",content:'# Eclipse 快速入门\n\n\n# 代码智能提示\n\n\n# Java 智能提示\n\nWindow -> Preferences -> Java -> Editor -> Content Assist -> Auto Activation\n\n\n\ndelay 是自动弹出提示框的延时时间，我们可以修改成 100 毫秒；triggers 这里默认是"."，只要加上"abcdefghijklmnopqrstuvwxyz"或者"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"，嘿嘿！这下就能做到和 VS 一样的输入每个字母都能提示啦：\n\n\n\n其它类型的文件比如 HTML、JavaScript、JSP 如果也能提供提示那不是更爽了？有了第二点设置的基础，其实这些设置都是一样的。\n\n\n# JavaScript 智能提示\n\nWindow -> Preferences -> JavaScript-> Editor -> Content Assist -> Auto-Activation\n\n\n\n\n# HTML 智能提示\n\nWindow -> Preferences -> Web -> HTML Files -> Editor -> Content Assist -> Auto-Activation\n\n\n\n保存后，我们再来输入看看，感觉真是不错呀：\n\n\n\n\n# 插件安装\n\n很多教科书上说到 Eclipse 的插件安装都是通过 Help -> Install New SoftWare 这种自动检索的方式，操作起来固然是方便，不过当我们不需要某种插件时不太容易找到要删除哪些内容，而且以后 Eclipse 版本升级的时候，通过这种方式安装过的插件都得再重新装一次。另外一种通过 Link 链接方式，就可以解决这些问题。\n\n我们以 Eclipse 的中文汉化包插件为例，先到官方提供的汉化包地址下载一个：http://www.eclipse.org/babel/downloads.php，注意选好自己的 Eclipse 版本：\n\n\n\n我的版本是 Kepler，然后进入下载页面，单击红框框中的链接，即可下载汉化包了：\n\n\n\n下载完解压缩后，会有个包含 features 和 plugin 目录的 eclipse 文件夹，把这个 eclipse 放在我们的 Eclipse 安装根目录，也就是和 eclipse.exe 同一级目录下。然后仍然在这一级目录下，新建一个 links 文件夹，并在该文件夹内，建一个 language.link 的文本文件。该文本文件的名字是可以任取的，后缀名是.link，而不是.txt 哟。好了，最后一步，编辑该文件，在里面写入刚才放入的语言包的地址，并用“\\”表示路径，一定要有 path= 这个前缀。\n\n\n\n保存文件后，重新打开 Eclipse，熟悉的中文界面终于看到了。虽然汉化不完全，不过也够用了不是么。如果仍然出现的是英文，说明汉化失败，重新检查下 language.link 文件中配置的信息是否和汉化包的目录一致。　　其它的插件安装方法也是如此，当不需要某个插件时，只需删除存放插件的目录和 links 目录下相应的 link 文件，或者改变下 link 文件里面的路径变成无效路径即可；对 Eclipse 做高版本升级时，也只需把老版存放插件的目录和 links 目录复制过去就行了。\n\n\n# 基本设置\n\n在 Preference 的搜索项中搜索 Text Editors。 可以参考我的设置： Show line numbers Show print margin Insert spaces for tabs\n\n设置代码的字体类型和大小：\n\nWindow -> Preferences -> General -> Appearance -> Content Assist -> Colors and Fornts，只需修改 Basic 里面的 Text Font 就可以了。\n\n推荐 Courier New。\n\n\n\n\n\n\n# 设置文本文件及 JSP 文件编码\n\nWindow -> Preferences -> General -> Workspace -> Text file encoding -> Other：\n\n\n\n\n\n\n# 设置 JDK 本地 JavaDOC API 路径及源码路径\n\n\n\n\n\n还都生成的是无意义的变量名，这样可能会对含有相同类型的变量参数的调用顺序造成干扰；\n\n这种问题，我们把 JDK 或者相应 Jar 包的源码导入进去就能避免了：\n\nWindow -> Preferences -> Java -> Installed JREs -> Edit：\n\n\n\n选中设置好的 JRE 目录，编辑，然后全选 JRE system libraries 下的所有 Jar 包，点击右边的 Source Attachment；\n\n\n\nExternal location 下，选中 JDK 安装目录下的 src.zip 文件，一路 OK 下来。\n\n\n\n设置完，我们再来看看，幸福来的好突然有木有！\n\n\n\n\n# 设置 Servlet 源码或其它 Jar 包源码\n\n\n\n上一步已经设置过了 JDK 的源码或 JavaDoc 路径，为啥现在又出来了呢？其实这个不难理解，因为我们使用到的类的源码并不在 JDK 的源码包中。\n\n仔细看，我们会发现这些 Jar 包其实都在 Tomcat 根目录下的 lib 文件夹中，但是翻遍了 Tomcat 目录也没有相应的 jar 或 zip 文件呀。既然本地没有，那就去官网上找找：\n\nhttp://tomcat.apache.org/download-70.cgi这里有Tomcat的安装包和源码包；\n\n\n\n可以自定义一个专门用于存放 JavaSource 和 JavaDoc 的文件夹，把下载文件放到该目录下，\n\n然后再切换到 Eclipse 下，选中没有代码提示的类或者函数， 按下 F3，点击 Change Attached Source：\n\n\n\n选择我们刚才下载好的 tomcat 源码文件，一路 OK。\n\n\n\n然后再回过头看看我们的代码提示，友好多了：\n\n\n\n其它 Jar 包源码的设置方式也一样。\n\n\n# 反编译插件 JD-Eclipse\n\n无论是开发还是调试，反编译必不可少，每次都用 jd-gui 打开去看，多麻烦，干脆配置下 JD 插件，自动关联.class：\n\n先从 http://jd.benow.ca/ 上下载离线安装包 jdeclipse_update_site.zip，解压缩后把 features、plugins 这 2 个文件夹复制到 新建文件夹 jdeclipse，然后把 jdeclipse 文件夹整个复制到 Eclipse 根目录的 dropins 文件夹下，重启 Eclipse 即可。这种方式是不是比建 link 文件更方便了？\n\n\n\n打开 Eclipse，Window -> Preferences -> General - > Editors ，把 .class 文件设置关联成 jd 插件的 editor\n\n\n\n\n# Validate 优化\n\n我们在 eclipse 里经常看到这个进程，validating... 逐个的检查每一个文件。那么如何关闭一些 validate 操作呢？\n\n\n\n打开 eclipse，点击【window】菜单，选择【preferences】选项。\n\n\n\n在左侧点击【validation】选项，在右侧可以看到 eclipse 进行的自动检查都有哪些内容。\n\n\n\n将 Manual（手动）保持不动，将 build 里面只留下 classpath dependency Validator，其他的全部去掉。\n\n\n\n最后点击【OK】按钮，保存设置。\n\n\n\n以后如果需要对文件进行校验检查的时候，在文件上点击右键，点击【Validate】进行检查。\n\n\n# 常用快捷键\n\n快捷键                    描述\nCtrl+1                 快速修复（最经典的快捷键,就不用多说了，可以解决很多问题，比如 import 类、try catch 包围等）\nCtrl+Shift+F           格式化当前代码\nCtrl+Shift+M           添加类的 import 导入\nCtrl+Shift+O           组织类的 import 导入（既有 Ctrl+Shift+M 的作用，又可以帮你去除没用的导入，很有用）\nCtrl+Y                 重做（与撤销 Ctrl+Z 相反）\nAlt+/                  内容辅助（帮你省了多少次键盘敲打，太常用了）\nCtrl+D                 删除当前行或者多行\nAlt+↓                  当前行和下面一行交互位置（特别实用,可以省去先剪切,再粘贴了）\nAlt+↑                  当前行和上面一行交互位置（同上）\nCtrl+Alt+↓             复制当前行到下一行（复制增加）\nCtrl+Alt+↑             复制当前行到上一行（复制增加）\nShift+Enter            在当前行的下一行插入空行（这时鼠标可以在当前行的任一位置,不一定是最后）\nCtrl+/                 注释当前行,再按则取消注释\nAlt+Shift+↑            选择封装元素\nAlt+Shift+←            选择上一个元素\nAlt+Shift+→            选择下一个元素\nShift+←                从光标处开始往左选择字符\nShift+→                从光标处开始往右选择字符\nCtrl+Shift+←           选中光标左边的单词\nCtrl+Shift+→           选中光标又边的单词\nCtrl+←                 光标移到左边单词的开头，相当于 vim 的 b\nCtrl+→                 光标移到右边单词的末尾，相当于 vim 的 e\nCtrl+K                 参照选中的 Word 快速定位到下一个（如果没有选中 word，则搜索上一次使用搜索的 word）\nCtrl+Shift+K           参照选中的 Word 快速定位到上一个\nCtrl+J                 正向增量查找（按下 Ctrl+J\n                       后,你所输入的每个字母编辑器都提供快速匹配定位到某个单词,如果没有,则在状态栏中显示没有找到了,查一个单词时,特别实用,要退出这个模式，按\n                       escape 建）\nCtrl+Shift+J           反向增量查找（和上条相同,只不过是从后往前查）\nCtrl+Shift+U           列出所有包含字符串的行\nCtrl+H                 打开搜索对话框\nCtrl+G                 工作区中的声明\nCtrl+Shift+G           工作区中的引用\nCtrl+Shift+T           搜索类（包括工程和关联的第三 jar 包）\nCtrl+Shift+R           搜索工程中的文件\nCtrl+E                 快速显示当前 Editer 的下拉列表（如果当前页面没有显示的用黑体表示）\nF4                     打开类型层次结构\nF3                     跳转到声明处\nAlt+←                  前一个编辑的页面\nAlt+→                  下一个编辑的页面（当然是针对上面那条来说了）\nCtrl+PageUp/PageDown   在编辑器中，切换已经打开的文件\nF5                     单步跳入\nF6                     单步跳过\nF7                     单步返回\nF8                     继续\nCtrl+Shift+D           显示变量的值\nCtrl+Shift+B           在当前行设置或者去掉断点\nCtrl+R                 运行至行(超好用，可以节省好多的断点)\nAlt+Shift+R            重命名方法名、属性或者变量名 （是我自己最爱用的一个了,尤其是变量和类的 Rename,比手工方法能节省很多劳动力）\nAlt+Shift+M            把一段函数内的代码抽取成方法 （这是重构里面最常用的方法之一了,尤其是对一大堆泥团代码有用）\nAlt+Shift+C            修改函数结构（比较实用,有 N 个函数调用了这个方法,修改一次搞定）\nAlt+Shift+L            抽取本地变量（ 可以直接把一些魔法数字和字符串抽取成一个变量,尤其是多处调用的时候）\nAlt+Shift+F            把 Class 中的 local 变量变为 field 变量 （比较实用的功能）\nAlt+Shift+I            合并变量（可能这样说有点不妥 Inline）\nAlt+Shift+V            移动函数和变量（不怎么常用）\nAlt+Shift+Z            重构的后悔药（Undo）\nAlt+Enter              显示当前选择资源的属性，windows 下的查看文件的属性就是这个快捷键，通常用来查看文件在 windows\n                       中的实际路径\nCtrl+↑                 文本编辑器 上滚行\nCtrl+↓                 文本编辑器 下滚行\nCtrl+M                 最大化当前的 Edit 或 View （再按则反之）\nCtrl+O                 快速显示 OutLine\nCtrl+T                 快速显示当前类的继承结构\nCtrl+W                 关闭当前 Editer\nCtrl+L                 文本编辑器 转至行\nF2                     显示工具提示描述',normalizedContent:'# eclipse 快速入门\n\n\n# 代码智能提示\n\n\n# java 智能提示\n\nwindow -> preferences -> java -> editor -> content assist -> auto activation\n\n\n\ndelay 是自动弹出提示框的延时时间，我们可以修改成 100 毫秒；triggers 这里默认是"."，只要加上"abcdefghijklmnopqrstuvwxyz"或者"abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz"，嘿嘿！这下就能做到和 vs 一样的输入每个字母都能提示啦：\n\n\n\n其它类型的文件比如 html、javascript、jsp 如果也能提供提示那不是更爽了？有了第二点设置的基础，其实这些设置都是一样的。\n\n\n# javascript 智能提示\n\nwindow -> preferences -> javascript-> editor -> content assist -> auto-activation\n\n\n\n\n# html 智能提示\n\nwindow -> preferences -> web -> html files -> editor -> content assist -> auto-activation\n\n\n\n保存后，我们再来输入看看，感觉真是不错呀：\n\n\n\n\n# 插件安装\n\n很多教科书上说到 eclipse 的插件安装都是通过 help -> install new software 这种自动检索的方式，操作起来固然是方便，不过当我们不需要某种插件时不太容易找到要删除哪些内容，而且以后 eclipse 版本升级的时候，通过这种方式安装过的插件都得再重新装一次。另外一种通过 link 链接方式，就可以解决这些问题。\n\n我们以 eclipse 的中文汉化包插件为例，先到官方提供的汉化包地址下载一个：http://www.eclipse.org/babel/downloads.php，注意选好自己的 eclipse 版本：\n\n\n\n我的版本是 kepler，然后进入下载页面，单击红框框中的链接，即可下载汉化包了：\n\n\n\n下载完解压缩后，会有个包含 features 和 plugin 目录的 eclipse 文件夹，把这个 eclipse 放在我们的 eclipse 安装根目录，也就是和 eclipse.exe 同一级目录下。然后仍然在这一级目录下，新建一个 links 文件夹，并在该文件夹内，建一个 language.link 的文本文件。该文本文件的名字是可以任取的，后缀名是.link，而不是.txt 哟。好了，最后一步，编辑该文件，在里面写入刚才放入的语言包的地址，并用“\\”表示路径，一定要有 path= 这个前缀。\n\n\n\n保存文件后，重新打开 eclipse，熟悉的中文界面终于看到了。虽然汉化不完全，不过也够用了不是么。如果仍然出现的是英文，说明汉化失败，重新检查下 language.link 文件中配置的信息是否和汉化包的目录一致。　　其它的插件安装方法也是如此，当不需要某个插件时，只需删除存放插件的目录和 links 目录下相应的 link 文件，或者改变下 link 文件里面的路径变成无效路径即可；对 eclipse 做高版本升级时，也只需把老版存放插件的目录和 links 目录复制过去就行了。\n\n\n# 基本设置\n\n在 preference 的搜索项中搜索 text editors。 可以参考我的设置： show line numbers show print margin insert spaces for tabs\n\n设置代码的字体类型和大小：\n\nwindow -> preferences -> general -> appearance -> content assist -> colors and fornts，只需修改 basic 里面的 text font 就可以了。\n\n推荐 courier new。\n\n\n\n\n\n\n# 设置文本文件及 jsp 文件编码\n\nwindow -> preferences -> general -> workspace -> text file encoding -> other：\n\n\n\n\n\n\n# 设置 jdk 本地 javadoc api 路径及源码路径\n\n\n\n\n\n还都生成的是无意义的变量名，这样可能会对含有相同类型的变量参数的调用顺序造成干扰；\n\n这种问题，我们把 jdk 或者相应 jar 包的源码导入进去就能避免了：\n\nwindow -> preferences -> java -> installed jres -> edit：\n\n\n\n选中设置好的 jre 目录，编辑，然后全选 jre system libraries 下的所有 jar 包，点击右边的 source attachment；\n\n\n\nexternal location 下，选中 jdk 安装目录下的 src.zip 文件，一路 ok 下来。\n\n\n\n设置完，我们再来看看，幸福来的好突然有木有！\n\n\n\n\n# 设置 servlet 源码或其它 jar 包源码\n\n\n\n上一步已经设置过了 jdk 的源码或 javadoc 路径，为啥现在又出来了呢？其实这个不难理解，因为我们使用到的类的源码并不在 jdk 的源码包中。\n\n仔细看，我们会发现这些 jar 包其实都在 tomcat 根目录下的 lib 文件夹中，但是翻遍了 tomcat 目录也没有相应的 jar 或 zip 文件呀。既然本地没有，那就去官网上找找：\n\nhttp://tomcat.apache.org/download-70.cgi这里有tomcat的安装包和源码包；\n\n\n\n可以自定义一个专门用于存放 javasource 和 javadoc 的文件夹，把下载文件放到该目录下，\n\n然后再切换到 eclipse 下，选中没有代码提示的类或者函数， 按下 f3，点击 change attached source：\n\n\n\n选择我们刚才下载好的 tomcat 源码文件，一路 ok。\n\n\n\n然后再回过头看看我们的代码提示，友好多了：\n\n\n\n其它 jar 包源码的设置方式也一样。\n\n\n# 反编译插件 jd-eclipse\n\n无论是开发还是调试，反编译必不可少，每次都用 jd-gui 打开去看，多麻烦，干脆配置下 jd 插件，自动关联.class：\n\n先从 http://jd.benow.ca/ 上下载离线安装包 jdeclipse_update_site.zip，解压缩后把 features、plugins 这 2 个文件夹复制到 新建文件夹 jdeclipse，然后把 jdeclipse 文件夹整个复制到 eclipse 根目录的 dropins 文件夹下，重启 eclipse 即可。这种方式是不是比建 link 文件更方便了？\n\n\n\n打开 eclipse，window -> preferences -> general - > editors ，把 .class 文件设置关联成 jd 插件的 editor\n\n\n\n\n# validate 优化\n\n我们在 eclipse 里经常看到这个进程，validating... 逐个的检查每一个文件。那么如何关闭一些 validate 操作呢？\n\n\n\n打开 eclipse，点击【window】菜单，选择【preferences】选项。\n\n\n\n在左侧点击【validation】选项，在右侧可以看到 eclipse 进行的自动检查都有哪些内容。\n\n\n\n将 manual（手动）保持不动，将 build 里面只留下 classpath dependency validator，其他的全部去掉。\n\n\n\n最后点击【ok】按钮，保存设置。\n\n\n\n以后如果需要对文件进行校验检查的时候，在文件上点击右键，点击【validate】进行检查。\n\n\n# 常用快捷键\n\n快捷键                    描述\nctrl+1                 快速修复（最经典的快捷键,就不用多说了，可以解决很多问题，比如 import 类、try catch 包围等）\nctrl+shift+f           格式化当前代码\nctrl+shift+m           添加类的 import 导入\nctrl+shift+o           组织类的 import 导入（既有 ctrl+shift+m 的作用，又可以帮你去除没用的导入，很有用）\nctrl+y                 重做（与撤销 ctrl+z 相反）\nalt+/                  内容辅助（帮你省了多少次键盘敲打，太常用了）\nctrl+d                 删除当前行或者多行\nalt+↓                  当前行和下面一行交互位置（特别实用,可以省去先剪切,再粘贴了）\nalt+↑                  当前行和上面一行交互位置（同上）\nctrl+alt+↓             复制当前行到下一行（复制增加）\nctrl+alt+↑             复制当前行到上一行（复制增加）\nshift+enter            在当前行的下一行插入空行（这时鼠标可以在当前行的任一位置,不一定是最后）\nctrl+/                 注释当前行,再按则取消注释\nalt+shift+↑            选择封装元素\nalt+shift+←            选择上一个元素\nalt+shift+→            选择下一个元素\nshift+←                从光标处开始往左选择字符\nshift+→                从光标处开始往右选择字符\nctrl+shift+←           选中光标左边的单词\nctrl+shift+→           选中光标又边的单词\nctrl+←                 光标移到左边单词的开头，相当于 vim 的 b\nctrl+→                 光标移到右边单词的末尾，相当于 vim 的 e\nctrl+k                 参照选中的 word 快速定位到下一个（如果没有选中 word，则搜索上一次使用搜索的 word）\nctrl+shift+k           参照选中的 word 快速定位到上一个\nctrl+j                 正向增量查找（按下 ctrl+j\n                       后,你所输入的每个字母编辑器都提供快速匹配定位到某个单词,如果没有,则在状态栏中显示没有找到了,查一个单词时,特别实用,要退出这个模式，按\n                       escape 建）\nctrl+shift+j           反向增量查找（和上条相同,只不过是从后往前查）\nctrl+shift+u           列出所有包含字符串的行\nctrl+h                 打开搜索对话框\nctrl+g                 工作区中的声明\nctrl+shift+g           工作区中的引用\nctrl+shift+t           搜索类（包括工程和关联的第三 jar 包）\nctrl+shift+r           搜索工程中的文件\nctrl+e                 快速显示当前 editer 的下拉列表（如果当前页面没有显示的用黑体表示）\nf4                     打开类型层次结构\nf3                     跳转到声明处\nalt+←                  前一个编辑的页面\nalt+→                  下一个编辑的页面（当然是针对上面那条来说了）\nctrl+pageup/pagedown   在编辑器中，切换已经打开的文件\nf5                     单步跳入\nf6                     单步跳过\nf7                     单步返回\nf8                     继续\nctrl+shift+d           显示变量的值\nctrl+shift+b           在当前行设置或者去掉断点\nctrl+r                 运行至行(超好用，可以节省好多的断点)\nalt+shift+r            重命名方法名、属性或者变量名 （是我自己最爱用的一个了,尤其是变量和类的 rename,比手工方法能节省很多劳动力）\nalt+shift+m            把一段函数内的代码抽取成方法 （这是重构里面最常用的方法之一了,尤其是对一大堆泥团代码有用）\nalt+shift+c            修改函数结构（比较实用,有 n 个函数调用了这个方法,修改一次搞定）\nalt+shift+l            抽取本地变量（ 可以直接把一些魔法数字和字符串抽取成一个变量,尤其是多处调用的时候）\nalt+shift+f            把 class 中的 local 变量变为 field 变量 （比较实用的功能）\nalt+shift+i            合并变量（可能这样说有点不妥 inline）\nalt+shift+v            移动函数和变量（不怎么常用）\nalt+shift+z            重构的后悔药（undo）\nalt+enter              显示当前选择资源的属性，windows 下的查看文件的属性就是这个快捷键，通常用来查看文件在 windows\n                       中的实际路径\nctrl+↑                 文本编辑器 上滚行\nctrl+↓                 文本编辑器 下滚行\nctrl+m                 最大化当前的 edit 或 view （再按则反之）\nctrl+o                 快速显示 outline\nctrl+t                 快速显示当前类的继承结构\nctrl+w                 关闭当前 editer\nctrl+l                 文本编辑器 转至行\nf2                     显示工具提示描述',charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Vscode 快速入门",frontmatter:{title:"Vscode 快速入门",date:"2019-05-14T14:57:33.000Z",order:3,categories:["Java","软件","IDE"],tags:["Java","IDE"],permalink:"/pages/0f7153/"},regularPath:"/01.Java/11.%E8%BD%AF%E4%BB%B6/02.IDE/03.VsCode.html",relativePath:"01.Java/11.软件/02.IDE/03.VsCode.md",key:"v-51b6d2f2",path:"/pages/0f7153/",headers:[{level:2,title:"快捷键",slug:"快捷键",normalizedTitle:"快捷键",charIndex:18},{level:3,title:"命令面板（Command Palette）",slug:"命令面板-command-palette",normalizedTitle:"命令面板（command palette）",charIndex:26},{level:3,title:"快速打开文件（Quick Open）",slug:"快速打开文件-quick-open",normalizedTitle:"快速打开文件（quick open）",charIndex:134},{level:3,title:"Status Bar",slug:"status-bar",normalizedTitle:"status bar",charIndex:195},{level:3,title:"改变语言模式",slug:"改变语言模式",normalizedTitle:"改变语言模式",charIndex:260},{level:3,title:"设置",slug:"设置",normalizedTitle:"设置",charIndex:313},{level:2,title:"插件",slug:"插件",normalizedTitle:"插件",charIndex:391},{level:2,title:"更多内容",slug:"更多内容",normalizedTitle:"更多内容",charIndex:561}],headersStr:"快捷键 命令面板（Command Palette） 快速打开文件（Quick Open） Status Bar 改变语言模式 设置 插件 更多内容",content:"# Vscode 快速入门\n\n\n# 快捷键\n\n\n# 命令面板（Command Palette）\n\n根据您当前的上下文访问所有可用命令。\n\n> Mac: cmd+shift+p or f1 Windows / Linux: ctrl+shift+p or f1\n\n\n# 快速打开文件（Quick Open）\n\n> Mac: cmd+p Windows / Linux: ctrl+p\n\n\n# Status Bar\n\n> Mac: shift+cmd+m Windows / Linux: ctrl+shift+m\n\n\n# 改变语言模式\n\n> Mac: cmd+k m Windows / Linux: ctrl+k m\n\n\n# 设置\n\n> Mac: cmd+, Windows / Linux: File > Preferences > Settings or ctrl+,\n\n\n# 插件\n\n * Chinese (Simplified) Language Pack for Visual Studio Code\n * Prettier - Code formatter\n * IntelliJ IDEA Keybindings\n * EditorConfig for VS Code\n * Git History\n\n\n# 更多内容\n\n * 官方\n   * https://github.com/Microsoft/vscode\n   * https://github.com/Microsoft/vscode-docs\n   * https://github.com/Microsoft/vscode-tips-and-tricks\n * 更多资源\n   * https://github.com/viatsko/awesome-vscode",normalizedContent:"# vscode 快速入门\n\n\n# 快捷键\n\n\n# 命令面板（command palette）\n\n根据您当前的上下文访问所有可用命令。\n\n> mac: cmd+shift+p or f1 windows / linux: ctrl+shift+p or f1\n\n\n# 快速打开文件（quick open）\n\n> mac: cmd+p windows / linux: ctrl+p\n\n\n# status bar\n\n> mac: shift+cmd+m windows / linux: ctrl+shift+m\n\n\n# 改变语言模式\n\n> mac: cmd+k m windows / linux: ctrl+k m\n\n\n# 设置\n\n> mac: cmd+, windows / linux: file > preferences > settings or ctrl+,\n\n\n# 插件\n\n * chinese (simplified) language pack for visual studio code\n * prettier - code formatter\n * intellij idea keybindings\n * editorconfig for vs code\n * git history\n\n\n# 更多内容\n\n * 官方\n   * https://github.com/microsoft/vscode\n   * https://github.com/microsoft/vscode-docs\n   * https://github.com/microsoft/vscode-tips-and-tricks\n * 更多资源\n   * https://github.com/viatsko/awesome-vscode",charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Java IDE",frontmatter:{title:"Java IDE",date:"2022-02-18T08:53:11.000Z",categories:["Java","软件","IDE"],tags:["Java","IDE"],permalink:"/pages/8695a7/",hidden:!0,index:!1},regularPath:"/01.Java/11.%E8%BD%AF%E4%BB%B6/02.IDE/",relativePath:"01.Java/11.软件/02.IDE/README.md",key:"v-12f6b900",path:"/pages/8695a7/",headersStr:null,content:"# Java IDE\n\n> 自从有了 IDE，写代码从此就告别了刀耕火种的蛮荒时代。\n> \n>  * Eclipse 是久负盛名的开源 Java IDE，我的学生时代一直使用它写 Java。\n>  * 曾经抗拒从转 Intellij Idea ，但后来发现真香，不得不说，确实是目前最优秀的 Java IDE。\n>  * 你可以在 vscode 中写各种语言，只要安装相应插件即可。如果你的项目中使用了很多种编程语言，又懒得在多个 IDE 之间切换，那么就用 vscode 来一网打尽吧。\n\n * Intellij IDEA 快速入门\n * Eclipse 快速入门\n * Vscode 快速入门",normalizedContent:"# java ide\n\n> 自从有了 ide，写代码从此就告别了刀耕火种的蛮荒时代。\n> \n>  * eclipse 是久负盛名的开源 java ide，我的学生时代一直使用它写 java。\n>  * 曾经抗拒从转 intellij idea ，但后来发现真香，不得不说，确实是目前最优秀的 java ide。\n>  * 你可以在 vscode 中写各种语言，只要安装相应插件即可。如果你的项目中使用了很多种编程语言，又懒得在多个 ide 之间切换，那么就用 vscode 来一网打尽吧。\n\n * intellij idea 快速入门\n * eclipse 快速入门\n * vscode 快速入门",charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"监控工具对比",frontmatter:{title:"监控工具对比",date:"2020-02-11T17:48:32.000Z",order:1,categories:["Java","软件","监控诊断"],tags:["Java","监控"],permalink:"/pages/16563a/"},regularPath:"/01.Java/11.%E8%BD%AF%E4%BB%B6/03.%E7%9B%91%E6%8E%A7%E8%AF%8A%E6%96%AD/01.%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7%E5%AF%B9%E6%AF%94.html",relativePath:"01.Java/11.软件/03.监控诊断/01.监控工具对比.md",key:"v-596e4bb7",path:"/pages/16563a/",headers:[{level:2,title:"监控工具发展史",slug:"监控工具发展史",normalizedTitle:"监控工具发展史",charIndex:13},{level:2,title:"监控工具比对",slug:"监控工具比对",normalizedTitle:"监控工具比对",charIndex:27},{level:3,title:"特性对比",slug:"特性对比",normalizedTitle:"特性对比",charIndex:38},{level:3,title:"生态对比",slug:"生态对比",normalizedTitle:"生态对比",charIndex:49},{level:2,title:"技术选型",slug:"技术选型",normalizedTitle:"技术选型",charIndex:60},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:153}],headersStr:"监控工具发展史 监控工具比对 特性对比 生态对比 技术选型 参考资料",content:"# 监控工具对比\n\n\n# 监控工具发展史\n\n\n\n\n# 监控工具比对\n\n\n# 特性对比\n\n\n\n\n# 生态对比\n\n\n\n\n# 技术选型\n\n * Zipkin 欠缺 APM 报表能力，不推荐。\n * 企业级，推荐 CAT\n * 关注和试点 SkyWalking。\n\n用好调用链监控，需要订制化、自研能力。\n\n\n# 参考资料\n\nCAT、Zipkin 和 SkyWalking 该如何选型？",normalizedContent:"# 监控工具对比\n\n\n# 监控工具发展史\n\n\n\n\n# 监控工具比对\n\n\n# 特性对比\n\n\n\n\n# 生态对比\n\n\n\n\n# 技术选型\n\n * zipkin 欠缺 apm 报表能力，不推荐。\n * 企业级，推荐 cat\n * 关注和试点 skywalking。\n\n用好调用链监控，需要订制化、自研能力。\n\n\n# 参考资料\n\ncat、zipkin 和 skywalking 该如何选型？",charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"CAT 快速入门",frontmatter:{title:"CAT 快速入门",date:"2020-02-11T17:48:32.000Z",order:2,categories:["Java","软件","监控诊断"],tags:["Java","监控","CAT"],permalink:"/pages/821ca3/"},regularPath:"/01.Java/11.%E8%BD%AF%E4%BB%B6/03.%E7%9B%91%E6%8E%A7%E8%AF%8A%E6%96%AD/02.CAT.html",relativePath:"01.Java/11.软件/03.监控诊断/02.CAT.md",key:"v-5fd2a085",path:"/pages/821ca3/",headers:[{level:2,title:"CAT 简介",slug:"cat-简介",normalizedTitle:"cat 简介",charIndex:15},{level:3,title:"CAT 的优势",slug:"cat-的优势",normalizedTitle:"cat 的优势",charIndex:244},{level:3,title:"支持的消息类型",slug:"支持的消息类型",normalizedTitle:"支持的消息类型",charIndex:494},{level:2,title:"CAT 部署",slug:"cat-部署",normalizedTitle:"cat 部署",charIndex:895},{level:2,title:"CAT 报表",slug:"cat-报表",normalizedTitle:"cat 报表",charIndex:945},{level:2,title:"CAT 配置",slug:"cat-配置",normalizedTitle:"cat 配置",charIndex:1256},{level:2,title:"CAT 架构",slug:"cat-架构",normalizedTitle:"cat 架构",charIndex:1390},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:1886}],headersStr:"CAT 简介 CAT 的优势 支持的消息类型 CAT 部署 CAT 报表 CAT 配置 CAT 架构 参考资料",content:"# CAT 快速入门\n\n\n# CAT 简介\n\nCAT（Central Application Tracking），是基于 Java 开发的分布式实时监控系统。CAT 在基础存储、高性能通信、大规模在线访问、服务治理、实时监控、容器化及集群智能调度等领域提供业界领先的、统一的解决方案。CAT 目前在美团的产品定位是应用层的统一监控组件，基本接入了美团所有核心应用，在中间件（RPC、数据库、缓存、MQ 等）框架中得到广泛应用，为各业务线提供系统的性能指标、健康状况、实时告警等。\n\n\n# CAT 的优势\n\n * 实时处理：信息的价值会随时间锐减，尤其是事故处理过程中\n * 全量数据：最开始的设计目标就是全量采集，全量的好处有很多\n * 高可用：所有应用都倒下了，需要监控还站着，并告诉工程师发生了什么，做到故障还原和问题定位\n * 故障容忍：CAT 本身故障不应该影响业务正常运转，CAT 挂了，应用不该受影响，只是监控能力暂时减弱\n * 高吞吐：要想还原真相，需要全方位地监控和度量，必须要有超强的处理吞吐能力\n * 可扩展：支持分布式、跨 IDC 部署，横向扩展的监控系统\n\n\n# 支持的消息类型\n\nCAT 监控系统将每次 URL、Service 的请求内部执行情况都封装为一个完整的消息树、消息树可能包括 Transaction、Event、Heartbeat、Metric 等信息。\n\n * Transaction 适合记录跨越系统边界的程序访问行为,比如远程调用，数据库调用，也适合执行时间较长的业务逻辑监控，Transaction 用来记录一段代码的执行时间和次数\n * Event 用来记录一件事发生的次数，比如记录系统异常，它和 transaction 相比缺少了时间的统计，开销比 transaction 要小\n * Heartbeat 表示程序内定期产生的统计信息, 如 CPU 利用率, 内存利用率, 连接池状态, 系统负载等\n * Metric 用于记录业务指标、指标可能包含对一个指标记录次数、记录平均值、记录总和，业务指标最低统计粒度为 1 分钟\n\n\n\n\n# CAT 部署\n\nCat 部署可以参考 官方 Wiki - 服务端部署 ，非常详细，不赘述。\n\n\n# CAT 报表\n\n与其他监控工具（如 Zipkin、SkyWalking）相比，CAT 的报表功能最丰富。支持以下报表类型：\n\n * Transaction 报表 - 一段代码运行时间、次数，比如 URL、Cache、SQL 执行次数和响应时间\n * Event 报表 - 一行代码运行次数，比如出现一个异常\n * Problem 报表 - 根据 Transaction/Event 数据分析出来系统可能出现的异常，包括访问较慢的程序等\n * Heartbeat 报表 - JVM 内部一些状态信息，比如 Memory，Thread 等\n * Business 报表 - 业务监控报表，比如订单指标，支付等业务指标\n\n\n# CAT 配置\n\nCAT 提供了以下配置：\n\n * 项目配置 包括项目基本信息、机器分组配置\n * 告警配置 包括基本告警配置、告警规则、以及具体告警配置\n * 全局配置 包括服务端配置、消息采样配置、客户端路由\n * 业务指标 包括业务监控配置、业务标签配置\n\n\n# CAT 架构\n\nCAT 主要分为三个模块：\n\n * cat-client - 提供给业务以及中间层埋点的底层 SDK。\n * cat-consumer - 用于实时分析从客户端的提供的数据。\n * cat-home - 作为用户提供给用户的展示的控制端。\n\n在实际开发和部署中，cat-consumer 和 cat-home 是部署在一个 jvm 内部，每个 CAT 服务端都可以作为 consumer 也可以作为 home，这样既能减少整个 CAT 层级结构，也可以增加整个系统稳定性。\n\n\n\n上图是 CAT 目前多机房的整体结构图：\n\n * 路由中心是根据应用所在机房信息来决定客户端上报的 CAT 服务端地址\n * 每个机房内部都有的独立的原始信息存储集群 HDFS\n * cat-home 可以部署在一个机房也可以部署在多个机房，在做报表展示的时候，cat-home 会从 cat-consumer 中进行跨机房的调用，将所有的数据合并展示给用户\n * 实际过程中，cat-consumer、cat-home 以及路由中心都是部署在一起，每个服务端节点都可以充当任何一个角色\n\n\n# 参考资料\n\n * CAT Github",normalizedContent:"# cat 快速入门\n\n\n# cat 简介\n\ncat（central application tracking），是基于 java 开发的分布式实时监控系统。cat 在基础存储、高性能通信、大规模在线访问、服务治理、实时监控、容器化及集群智能调度等领域提供业界领先的、统一的解决方案。cat 目前在美团的产品定位是应用层的统一监控组件，基本接入了美团所有核心应用，在中间件（rpc、数据库、缓存、mq 等）框架中得到广泛应用，为各业务线提供系统的性能指标、健康状况、实时告警等。\n\n\n# cat 的优势\n\n * 实时处理：信息的价值会随时间锐减，尤其是事故处理过程中\n * 全量数据：最开始的设计目标就是全量采集，全量的好处有很多\n * 高可用：所有应用都倒下了，需要监控还站着，并告诉工程师发生了什么，做到故障还原和问题定位\n * 故障容忍：cat 本身故障不应该影响业务正常运转，cat 挂了，应用不该受影响，只是监控能力暂时减弱\n * 高吞吐：要想还原真相，需要全方位地监控和度量，必须要有超强的处理吞吐能力\n * 可扩展：支持分布式、跨 idc 部署，横向扩展的监控系统\n\n\n# 支持的消息类型\n\ncat 监控系统将每次 url、service 的请求内部执行情况都封装为一个完整的消息树、消息树可能包括 transaction、event、heartbeat、metric 等信息。\n\n * transaction 适合记录跨越系统边界的程序访问行为,比如远程调用，数据库调用，也适合执行时间较长的业务逻辑监控，transaction 用来记录一段代码的执行时间和次数\n * event 用来记录一件事发生的次数，比如记录系统异常，它和 transaction 相比缺少了时间的统计，开销比 transaction 要小\n * heartbeat 表示程序内定期产生的统计信息, 如 cpu 利用率, 内存利用率, 连接池状态, 系统负载等\n * metric 用于记录业务指标、指标可能包含对一个指标记录次数、记录平均值、记录总和，业务指标最低统计粒度为 1 分钟\n\n\n\n\n# cat 部署\n\ncat 部署可以参考 官方 wiki - 服务端部署 ，非常详细，不赘述。\n\n\n# cat 报表\n\n与其他监控工具（如 zipkin、skywalking）相比，cat 的报表功能最丰富。支持以下报表类型：\n\n * transaction 报表 - 一段代码运行时间、次数，比如 url、cache、sql 执行次数和响应时间\n * event 报表 - 一行代码运行次数，比如出现一个异常\n * problem 报表 - 根据 transaction/event 数据分析出来系统可能出现的异常，包括访问较慢的程序等\n * heartbeat 报表 - jvm 内部一些状态信息，比如 memory，thread 等\n * business 报表 - 业务监控报表，比如订单指标，支付等业务指标\n\n\n# cat 配置\n\ncat 提供了以下配置：\n\n * 项目配置 包括项目基本信息、机器分组配置\n * 告警配置 包括基本告警配置、告警规则、以及具体告警配置\n * 全局配置 包括服务端配置、消息采样配置、客户端路由\n * 业务指标 包括业务监控配置、业务标签配置\n\n\n# cat 架构\n\ncat 主要分为三个模块：\n\n * cat-client - 提供给业务以及中间层埋点的底层 sdk。\n * cat-consumer - 用于实时分析从客户端的提供的数据。\n * cat-home - 作为用户提供给用户的展示的控制端。\n\n在实际开发和部署中，cat-consumer 和 cat-home 是部署在一个 jvm 内部，每个 cat 服务端都可以作为 consumer 也可以作为 home，这样既能减少整个 cat 层级结构，也可以增加整个系统稳定性。\n\n\n\n上图是 cat 目前多机房的整体结构图：\n\n * 路由中心是根据应用所在机房信息来决定客户端上报的 cat 服务端地址\n * 每个机房内部都有的独立的原始信息存储集群 hdfs\n * cat-home 可以部署在一个机房也可以部署在多个机房，在做报表展示的时候，cat-home 会从 cat-consumer 中进行跨机房的调用，将所有的数据合并展示给用户\n * 实际过程中，cat-consumer、cat-home 以及路由中心都是部署在一起，每个服务端节点都可以充当任何一个角色\n\n\n# 参考资料\n\n * cat github",charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Zipkin 快速入门",frontmatter:{title:"Zipkin 快速入门",date:"2020-03-23T22:56:45.000Z",order:3,categories:["Java","软件","监控诊断"],tags:["Java","监控","Zipkin"],permalink:"/pages/0a8826/"},regularPath:"/01.Java/11.%E8%BD%AF%E4%BB%B6/03.%E7%9B%91%E6%8E%A7%E8%AF%8A%E6%96%AD/03.Zipkin.html",relativePath:"01.Java/11.软件/03.监控诊断/03.Zipkin.md",key:"v-5638950b",path:"/pages/0a8826/",headers:[{level:2,title:"一、Zipkin 简介",slug:"一、zipkin-简介",normalizedTitle:"一、zipkin 简介",charIndex:308},{level:3,title:"特性",slug:"特性",normalizedTitle:"特性",charIndex:324},{level:3,title:"多平台",slug:"多平台",normalizedTitle:"多平台",charIndex:516},{level:3,title:"数据",slug:"数据",normalizedTitle:"数据",charIndex:46},{level:2,title:"二、Zipkin 安装",slug:"二、zipkin-安装",normalizedTitle:"二、zipkin 安装",charIndex:809},{level:3,title:"Docker",slug:"docker",normalizedTitle:"docker",charIndex:825},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:28},{level:3,title:"编译方式",slug:"编译方式",normalizedTitle:"编译方式",charIndex:1014},{level:2,title:"三、Zipkin 架构",slug:"三、zipkin-架构",normalizedTitle:"三、zipkin 架构",charIndex:1307},{level:3,title:"Zipkin Server",slug:"zipkin-server",normalizedTitle:"zipkin server",charIndex:1468},{level:3,title:"Zipkin Client",slug:"zipkin-client",normalizedTitle:"zipkin client",charIndex:2035},{level:2,title:"四、Zipkin 客户端",slug:"四、zipkin-客户端",normalizedTitle:"四、zipkin 客户端",charIndex:5139},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:5297}],headersStr:"一、Zipkin 简介 特性 多平台 数据 二、Zipkin 安装 Docker Java 编译方式 三、Zipkin 架构 Zipkin Server Zipkin Client 四、Zipkin 客户端 参考资料",content:'# Zipkin 快速入门\n\nZipkin 是一个基于 Java 开发的、开源的、分布式实时数据跟踪系统（Distributed Tracking System）。它采集有助于解决服务架构中延迟问题的实时数据。\n\nZipkin 主要功能是聚集来自各个异构系统的实时监控数据。分布式跟踪系统还有其他比较成熟的实现，例如：Naver 的 Pinpoint、Apache 的 HTrace、阿里的鹰眼 Tracing、京东的 Hydra、新浪的 Watchman，美团点评的 CAT，skywalking 等。\n\nZipkin 基于 Google Dapper 的论文设计而来，由 Twitter 公司开发贡献。\n\n\n# 一、Zipkin 简介\n\n\n# 特性\n\n如果日志文件中有跟踪 ID，则可以直接跳至该跟踪 ID。 否则，您可以基于属性进行查询，例如服务，操作名称，标签和持续时间。 将为您总结一些有趣的数据，例如在服务中花费的时间百分比以及操作是否失败。\n\nZipkin UI 还提供了一个依赖关系图，该关系图显示了每个应用程序中跟踪了多少个请求。这对于识别聚合行为（包括错误路径或对不赞成使用的服务的调用）很有帮助。\n\n\n\n\n# 多平台\n\nZipkin 官方支持 C#、Go、Java、JavaScript、Ruby、Scala、PHP 语言。\n\n除此以外，社区还贡献了多种其他语言的支持，详情可以参考官方文档：Tracers and Instrumentation\n\n\n# 数据\n\nZipkin 服务器捆绑了用于采集和存储数据的扩展。\n\n默认情况下，数据可以通过 Http，Kafka 、RabbitMQ 或 RPC 传输。\n\n并存储在内存中或 MySQL、Cassandra 或 Elasticsearch 中。\n\n数据以 json 形式存储，可以参考：Zipkin 官方的 Swagger API\n\n\n\n\n# 二、Zipkin 安装\n\n\n# Docker\n\nDocker 启动方式：\n\ndocker run -d -p 9411:9411 openzipkin/zipkin\n\n\n\n# Java\n\n> 注意：必须运行在 JDK8+ 环境\n\nJava 启动方式：\n\ncurl -sSL https://zipkin.io/quickstart.sh | bash -s\njava -jar zipkin.jar\n\n\n\n# 编译方式\n\n适用于需要订制化的场景。\n\n# get the latest source\ngit clone https://github.com/openzipkin/zipkin\ncd zipkin\n# Build the server and also make its dependencies\n./mvnw -DskipTests --also-make -pl zipkin-server clean install\n# Run the server\njava -jar ./zipkin-server/target/zipkin-server-*exec.jar\n\n\n\n# 三、Zipkin 架构\n\nZipKin 可以分为两部分，\n\n * 一部分是 Zipkin server，用来作为数据的采集存储、数据分析与展示；\n * 另一部分是 Zipkin client 是 Zipkin 基于不同的语言及框架封装的一些列客户端工具，这些工具完成了追踪数据的生成与上报功能。\n\n架构如下：\n\n\n\n\n# Zipkin Server\n\nZipkin Server 主要包括四个模块：\n\n * Collector - 负责采集客户端传输的数据。\n * Storage - 负责存储采集的数据。当前支持 Memory，MySQL，Cassandra，ElasticSearch 等，默认存储在内存中。\n * API（Query） - 负责查询 Storage 中存储的数据。提供简单的 JSON API 获取数据，主要提供给 web UI 使用。\n * UI - 提供简单的 web 界面。\n\nInstrumented Client 和 Instrumented Server，是指分布式架构中使用了 Trace 工具的两个应用，Client 会调用 Server 提供的服务，两者都会向 Zipkin 上报 Trace 相关信息。在 Client 和 Server 通过 Transport 上报 Trace 信息后，由 Zipkin 的 Collector 模块接收，并由 Storage 模块将数据存储在对应的存储介质中，然后 Zipkin 提供 API 供 UI 界面查询 Trace 跟踪信息。Non-Instrumented Server，指的是未使用 Trace 工具的 Server，显然它不会上报 Trace 信息。\n\n\n# Zipkin Client\n\n * Tracer - Tracer 存在于你的应用中，它负责采集关于已发生操作的实时元数据。它们通常会检测库，因此对于用户是透明的。例如，已检测的 Web 服务器记录它何时接收到请求，以及何时发送响应。收集的跟踪数据称为跨度（Span）。\n * Instrumentation - Instrumentation 保证了生产环境的安全性和很少的开销。因此，它们仅在内部传播 ID，以告知接收方正在进行追踪。完成的 Span 将通过外部通信告知 Zipkin，类似于应用程序异步报告指标的方式。例如，当跟踪某个操作并且需要发出 http 请求时，会添加一些 header 来传播 ID。header 不用于发送详细信息，例如操作名称。\n * Reporter - 能够将数据发送到 Zipkin 的检测应用程序中的组件，被称为 Reporter。Reporter 有多种传输方式，可以将跟踪数据发送到 Zipkin 采集器，后者将跟踪数据持久化保存到存储中。稍后，API 会查询存储以向 UI 提供渲染数据。\n\n以下是 Zipkin 的一个示例工作流：\n\n┌─────────────┐ ┌───────────────────────┐  ┌─────────────┐  ┌──────────────────┐\n│ User Code   │ │ Trace Instrumentation │  │ Http Client │  │ Zipkin Collector │\n└─────────────┘ └───────────────────────┘  └─────────────┘  └──────────────────┘\n       │                 │                         │                 │\n           ┌─────────┐\n       │ ──┤GET /foo ├─▶ │ ────┐                   │                 │\n           └─────────┘         │ record tags\n       │                 │ ◀───┘                   │                 │\n                           ────┐\n       │                 │     │ add trace headers │                 │\n                           ◀───┘\n       │                 │ ────┐                   │                 │\n                               │ record timestamp\n       │                 │ ◀───┘                   │                 │\n                             ┌─────────────────┐\n       │                 │ ──┤GET /foo         ├─▶ │                 │\n                             │X-B3-TraceId: aa │     ────┐\n       │                 │   │X-B3-SpanId: 6b  │   │     │           │\n                             └─────────────────┘         │ invoke\n       │                 │                         │     │ request   │\n                                                         │\n       │                 │                         │     │           │\n                                 ┌────────┐          ◀───┘\n       │                 │ ◀─────┤200 OK  ├─────── │                 │\n                           ────┐ └────────┘\n       │                 │     │ record duration   │                 │\n            ┌────────┐     ◀───┘\n       │ ◀──┤200 OK  ├── │                         │                 │\n            └────────┘       ┌────────────────────────────────┐\n       │                 │ ──┤ asynchronously report span     ├────▶ │\n                             │                                │\n                             │{                               │\n                             │  "traceId": "aa",              │\n                             │  "id": "6b",                   │\n                             │  "name": "get",                │\n                             │  "timestamp": 1483945573944000,│\n                             │  "duration": 386000,           │\n                             │  "annotations": [              │\n                             │--snip--                        │\n                             └────────────────────────────────┘\n\n\nInstrumented client 和 server 是分别使用了 ZipKin Client 的服务，Zipkin Client 会根据配置将追踪数据发送到 Zipkin Server 中进行数据存储、分析和展示。\n\n\n# 四、Zipkin 客户端\n\nBrave 是 Java 版的 zipkin 客户端。\n\n一般不会手动编写 Trace 相关的代码，Brave 提供可一些开箱即用的库，帮助我们追踪一些特定的请求。比如：dubbo、grpc、servlet、mysql、httpClient、kafka、springMVC 等。\n\n\n# 参考资料\n\n * Zipkin 官网\n * Zipkin Github\n * brave',normalizedContent:'# zipkin 快速入门\n\nzipkin 是一个基于 java 开发的、开源的、分布式实时数据跟踪系统（distributed tracking system）。它采集有助于解决服务架构中延迟问题的实时数据。\n\nzipkin 主要功能是聚集来自各个异构系统的实时监控数据。分布式跟踪系统还有其他比较成熟的实现，例如：naver 的 pinpoint、apache 的 htrace、阿里的鹰眼 tracing、京东的 hydra、新浪的 watchman，美团点评的 cat，skywalking 等。\n\nzipkin 基于 google dapper 的论文设计而来，由 twitter 公司开发贡献。\n\n\n# 一、zipkin 简介\n\n\n# 特性\n\n如果日志文件中有跟踪 id，则可以直接跳至该跟踪 id。 否则，您可以基于属性进行查询，例如服务，操作名称，标签和持续时间。 将为您总结一些有趣的数据，例如在服务中花费的时间百分比以及操作是否失败。\n\nzipkin ui 还提供了一个依赖关系图，该关系图显示了每个应用程序中跟踪了多少个请求。这对于识别聚合行为（包括错误路径或对不赞成使用的服务的调用）很有帮助。\n\n\n\n\n# 多平台\n\nzipkin 官方支持 c#、go、java、javascript、ruby、scala、php 语言。\n\n除此以外，社区还贡献了多种其他语言的支持，详情可以参考官方文档：tracers and instrumentation\n\n\n# 数据\n\nzipkin 服务器捆绑了用于采集和存储数据的扩展。\n\n默认情况下，数据可以通过 http，kafka 、rabbitmq 或 rpc 传输。\n\n并存储在内存中或 mysql、cassandra 或 elasticsearch 中。\n\n数据以 json 形式存储，可以参考：zipkin 官方的 swagger api\n\n\n\n\n# 二、zipkin 安装\n\n\n# docker\n\ndocker 启动方式：\n\ndocker run -d -p 9411:9411 openzipkin/zipkin\n\n\n\n# java\n\n> 注意：必须运行在 jdk8+ 环境\n\njava 启动方式：\n\ncurl -ssl https://zipkin.io/quickstart.sh | bash -s\njava -jar zipkin.jar\n\n\n\n# 编译方式\n\n适用于需要订制化的场景。\n\n# get the latest source\ngit clone https://github.com/openzipkin/zipkin\ncd zipkin\n# build the server and also make its dependencies\n./mvnw -dskiptests --also-make -pl zipkin-server clean install\n# run the server\njava -jar ./zipkin-server/target/zipkin-server-*exec.jar\n\n\n\n# 三、zipkin 架构\n\nzipkin 可以分为两部分，\n\n * 一部分是 zipkin server，用来作为数据的采集存储、数据分析与展示；\n * 另一部分是 zipkin client 是 zipkin 基于不同的语言及框架封装的一些列客户端工具，这些工具完成了追踪数据的生成与上报功能。\n\n架构如下：\n\n\n\n\n# zipkin server\n\nzipkin server 主要包括四个模块：\n\n * collector - 负责采集客户端传输的数据。\n * storage - 负责存储采集的数据。当前支持 memory，mysql，cassandra，elasticsearch 等，默认存储在内存中。\n * api（query） - 负责查询 storage 中存储的数据。提供简单的 json api 获取数据，主要提供给 web ui 使用。\n * ui - 提供简单的 web 界面。\n\ninstrumented client 和 instrumented server，是指分布式架构中使用了 trace 工具的两个应用，client 会调用 server 提供的服务，两者都会向 zipkin 上报 trace 相关信息。在 client 和 server 通过 transport 上报 trace 信息后，由 zipkin 的 collector 模块接收，并由 storage 模块将数据存储在对应的存储介质中，然后 zipkin 提供 api 供 ui 界面查询 trace 跟踪信息。non-instrumented server，指的是未使用 trace 工具的 server，显然它不会上报 trace 信息。\n\n\n# zipkin client\n\n * tracer - tracer 存在于你的应用中，它负责采集关于已发生操作的实时元数据。它们通常会检测库，因此对于用户是透明的。例如，已检测的 web 服务器记录它何时接收到请求，以及何时发送响应。收集的跟踪数据称为跨度（span）。\n * instrumentation - instrumentation 保证了生产环境的安全性和很少的开销。因此，它们仅在内部传播 id，以告知接收方正在进行追踪。完成的 span 将通过外部通信告知 zipkin，类似于应用程序异步报告指标的方式。例如，当跟踪某个操作并且需要发出 http 请求时，会添加一些 header 来传播 id。header 不用于发送详细信息，例如操作名称。\n * reporter - 能够将数据发送到 zipkin 的检测应用程序中的组件，被称为 reporter。reporter 有多种传输方式，可以将跟踪数据发送到 zipkin 采集器，后者将跟踪数据持久化保存到存储中。稍后，api 会查询存储以向 ui 提供渲染数据。\n\n以下是 zipkin 的一个示例工作流：\n\n┌─────────────┐ ┌───────────────────────┐  ┌─────────────┐  ┌──────────────────┐\n│ user code   │ │ trace instrumentation │  │ http client │  │ zipkin collector │\n└─────────────┘ └───────────────────────┘  └─────────────┘  └──────────────────┘\n       │                 │                         │                 │\n           ┌─────────┐\n       │ ──┤get /foo ├─▶ │ ────┐                   │                 │\n           └─────────┘         │ record tags\n       │                 │ ◀───┘                   │                 │\n                           ────┐\n       │                 │     │ add trace headers │                 │\n                           ◀───┘\n       │                 │ ────┐                   │                 │\n                               │ record timestamp\n       │                 │ ◀───┘                   │                 │\n                             ┌─────────────────┐\n       │                 │ ──┤get /foo         ├─▶ │                 │\n                             │x-b3-traceid: aa │     ────┐\n       │                 │   │x-b3-spanid: 6b  │   │     │           │\n                             └─────────────────┘         │ invoke\n       │                 │                         │     │ request   │\n                                                         │\n       │                 │                         │     │           │\n                                 ┌────────┐          ◀───┘\n       │                 │ ◀─────┤200 ok  ├─────── │                 │\n                           ────┐ └────────┘\n       │                 │     │ record duration   │                 │\n            ┌────────┐     ◀───┘\n       │ ◀──┤200 ok  ├── │                         │                 │\n            └────────┘       ┌────────────────────────────────┐\n       │                 │ ──┤ asynchronously report span     ├────▶ │\n                             │                                │\n                             │{                               │\n                             │  "traceid": "aa",              │\n                             │  "id": "6b",                   │\n                             │  "name": "get",                │\n                             │  "timestamp": 1483945573944000,│\n                             │  "duration": 386000,           │\n                             │  "annotations": [              │\n                             │--snip--                        │\n                             └────────────────────────────────┘\n\n\ninstrumented client 和 server 是分别使用了 zipkin client 的服务，zipkin client 会根据配置将追踪数据发送到 zipkin server 中进行数据存储、分析和展示。\n\n\n# 四、zipkin 客户端\n\nbrave 是 java 版的 zipkin 客户端。\n\n一般不会手动编写 trace 相关的代码，brave 提供可一些开箱即用的库，帮助我们追踪一些特定的请求。比如：dubbo、grpc、servlet、mysql、httpclient、kafka、springmvc 等。\n\n\n# 参考资料\n\n * zipkin 官网\n * zipkin github\n * brave',charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"SkyWalking 快速入门",frontmatter:{title:"SkyWalking 快速入门",date:"2020-02-07T23:04:47.000Z",order:4,categories:["Java","软件","监控诊断"],tags:["Java","监控","SkyWalking"],permalink:"/pages/df7dec/"},regularPath:"/01.Java/11.%E8%BD%AF%E4%BB%B6/03.%E7%9B%91%E6%8E%A7%E8%AF%8A%E6%96%AD/04.Skywalking.html",relativePath:"01.Java/11.软件/03.监控诊断/04.Skywalking.md",key:"v-52bbe8ea",path:"/pages/df7dec/",headers:[{level:2,title:"一、SkyWalking 简介",slug:"一、skywalking-简介",normalizedTitle:"一、skywalking 简介",charIndex:106},{level:3,title:"SkyWalking 特性",slug:"skywalking-特性",normalizedTitle:"skywalking 特性",charIndex:194},{level:3,title:"SkyWalking 核心概念",slug:"skywalking-核心概念",normalizedTitle:"skywalking 核心概念",charIndex:337},{level:2,title:"二、SkyWalking 架构",slug:"二、skywalking-架构",normalizedTitle:"二、skywalking 架构",charIndex:569},{level:2,title:"三、SkyWalking 安装",slug:"三、skywalking-安装",normalizedTitle:"三、skywalking 安装",charIndex:1028},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:1177}],headersStr:"一、SkyWalking 简介 SkyWalking 特性 SkyWalking 核心概念 二、SkyWalking 架构 三、SkyWalking 安装 参考资料",content:"# SkyWalking 快速入门\n\nSkyWalking 是一个基于 Java 开发的分布式系统的应用程序性能监视工具，专为微服务、云原生架构和基于容器（Docker、K8s、Mesos）架构而设计。\n\n\n# 一、SkyWalking 简介\n\nSkyWalking 是观察性分析平台和应用性能管理系统。\n\n提供分布式追踪、服务网格遥测分析、度量聚合和可视化一体化解决方案。\n\n\n\n\n# SkyWalking 特性\n\n * 多种监控手段，语言探针和 service mesh\n * 多语言自动探针，Java，.NET Core 和 Node.JS\n * 轻量高效，不需要大数据\n * 模块化，UI、存储、集群管理多种机制可选\n * 支持告警\n * 优秀的可视化方案\n\n\n# SkyWalking 核心概念\n\n * Service - 服务。代表一组为传入请求提供相同的行为的工作负载。 使用代理或 SDK 时，可以定义服务名称。\n * Service Instance - 服务实例。服务组中的每个工作负载都称为一个实例。就像 Kubernetes 中的 Pod 一样，它在 OS 中不必是单个进程。\n * Endpoint - 端点。它是特定服务中用于传入请求的路径，例如 HTTP URI 路径或 RPC 服务类+方法签名。\n\n\n# 二、SkyWalking 架构\n\n从逻辑上讲，SkyWalking 分为四个部分：探针（Probes），平台后端，存储和 UI。\n\n\n\n * 探针（Probes） - 探针是指集成到目标系统中的代理或 SDK 库。它们负责收集数据（包括跟踪数据和统计数据）并将其按照 SkyWalking 的要求重新格式化为。\n * 平台后端 - 平台后端是一个提供后端服务的集群。它用于聚合、分析和驱动从探针到 UI 的流程。它还为传入格式（如 Zipkin 的格式），存储实现程序和集群管理提供可插入功能。 您甚至可以使用 Observability Analysis Language 自定义聚合和分析。\n * 存储 - 您可以选择一个 SkyWalking 已实现的存储，如由 Sharding-Sphere 管理的 ElasticSearch，H2 或 MySQL 集群，也可以自行实现一个存储。\n * UI - 用户界面很酷，对于 SkyWalking 最终用户而言非常强大。它也可以自定义以匹配您的自定义后端。\n\n\n# 三、SkyWalking 安装\n\n进入 Apache SkyWalking 官方下载页面，选择安装版本，下载解压到本地。\n\n\n\n安装分为三个部分：\n\n * Backend setup document\n * UI setup document\n * CLI set up document\n\n\n# 参考资料\n\n * SkyWalking Github",normalizedContent:"# skywalking 快速入门\n\nskywalking 是一个基于 java 开发的分布式系统的应用程序性能监视工具，专为微服务、云原生架构和基于容器（docker、k8s、mesos）架构而设计。\n\n\n# 一、skywalking 简介\n\nskywalking 是观察性分析平台和应用性能管理系统。\n\n提供分布式追踪、服务网格遥测分析、度量聚合和可视化一体化解决方案。\n\n\n\n\n# skywalking 特性\n\n * 多种监控手段，语言探针和 service mesh\n * 多语言自动探针，java，.net core 和 node.js\n * 轻量高效，不需要大数据\n * 模块化，ui、存储、集群管理多种机制可选\n * 支持告警\n * 优秀的可视化方案\n\n\n# skywalking 核心概念\n\n * service - 服务。代表一组为传入请求提供相同的行为的工作负载。 使用代理或 sdk 时，可以定义服务名称。\n * service instance - 服务实例。服务组中的每个工作负载都称为一个实例。就像 kubernetes 中的 pod 一样，它在 os 中不必是单个进程。\n * endpoint - 端点。它是特定服务中用于传入请求的路径，例如 http uri 路径或 rpc 服务类+方法签名。\n\n\n# 二、skywalking 架构\n\n从逻辑上讲，skywalking 分为四个部分：探针（probes），平台后端，存储和 ui。\n\n\n\n * 探针（probes） - 探针是指集成到目标系统中的代理或 sdk 库。它们负责收集数据（包括跟踪数据和统计数据）并将其按照 skywalking 的要求重新格式化为。\n * 平台后端 - 平台后端是一个提供后端服务的集群。它用于聚合、分析和驱动从探针到 ui 的流程。它还为传入格式（如 zipkin 的格式），存储实现程序和集群管理提供可插入功能。 您甚至可以使用 observability analysis language 自定义聚合和分析。\n * 存储 - 您可以选择一个 skywalking 已实现的存储，如由 sharding-sphere 管理的 elasticsearch，h2 或 mysql 集群，也可以自行实现一个存储。\n * ui - 用户界面很酷，对于 skywalking 最终用户而言非常强大。它也可以自定义以匹配您的自定义后端。\n\n\n# 三、skywalking 安装\n\n进入 apache skywalking 官方下载页面，选择安装版本，下载解压到本地。\n\n\n\n安装分为三个部分：\n\n * backend setup document\n * ui setup document\n * cli set up document\n\n\n# 参考资料\n\n * skywalking github",charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Arthas 快速入门",frontmatter:{title:"Arthas 快速入门",date:"2020-02-07T23:04:47.000Z",order:5,categories:["Java","软件","监控诊断"],tags:["Java","诊断","Arthas"],permalink:"/pages/c689d1/"},regularPath:"/01.Java/11.%E8%BD%AF%E4%BB%B6/03.%E7%9B%91%E6%8E%A7%E8%AF%8A%E6%96%AD/05.Arthas.html",relativePath:"01.Java/11.软件/03.监控诊断/05.Arthas.md",key:"v-877bb26a",path:"/pages/c689d1/",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:54},{level:2,title:"安装",slug:"安装",normalizedTitle:"安装",charIndex:376},{level:3,title:"使用arthas-boot（推荐）",slug:"使用arthas-boot-推荐",normalizedTitle:"使用arthas-boot（推荐）",charIndex:383},{level:3,title:"使用as.sh",slug:"使用as-sh",normalizedTitle:"使用as.sh",charIndex:756},{level:3,title:"全量安装",slug:"全量安装",normalizedTitle:"全量安装",charIndex:1097},{level:2,title:"基础使用",slug:"基础使用",normalizedTitle:"基础使用",charIndex:1236},{level:3,title:"启动 Demo",slug:"启动-demo",normalizedTitle:"启动 demo",charIndex:1245},{level:3,title:"启动 arthas",slug:"启动-arthas",normalizedTitle:"启动 arthas",charIndex:1410},{level:3,title:"查看 dashboard",slug:"查看-dashboard",normalizedTitle:"查看 dashboard",charIndex:2510},{level:3,title:"通过 thread 命令来获取到arthas-demo进程的 Main Class",slug:"通过-thread-命令来获取到arthas-demo进程的-main-class",normalizedTitle:"通过 thread 命令来获取到arthas-demo进程的 main class",charIndex:4594},{level:3,title:"通过 jad 来反编译 Main Class",slug:"通过-jad-来反编译-main-class",normalizedTitle:"通过 jad 来反编译 main class",charIndex:4751},{level:3,title:"watch",slug:"watch",normalizedTitle:"watch",charIndex:6952},{level:3,title:"退出 arthas",slug:"退出-arthas",normalizedTitle:"退出 arthas",charIndex:7824},{level:2,title:"进阶使用",slug:"进阶使用",normalizedTitle:"进阶使用",charIndex:7814},{level:3,title:"基础命令",slug:"基础命令",normalizedTitle:"基础命令",charIndex:7959},{level:3,title:"jvm 相关",slug:"jvm-相关",normalizedTitle:"jvm 相关",charIndex:8332},{level:3,title:"class/classloader 相关",slug:"class-classloader-相关",normalizedTitle:"class/classloader 相关",charIndex:8653},{level:3,title:"monitor/watch/trace 相关",slug:"monitor-watch-trace-相关",normalizedTitle:"monitor/watch/trace 相关",charIndex:8931},{level:3,title:"options",slug:"options",normalizedTitle:"options",charIndex:9236},{level:3,title:"管道",slug:"管道",normalizedTitle:"管道",charIndex:9279},{level:3,title:"后台异步任务",slug:"后台异步任务",normalizedTitle:"后台异步任务",charIndex:9428},{level:3,title:"Web Console",slug:"web-console",normalizedTitle:"web console",charIndex:9646},{level:3,title:"用户数据回报",slug:"用户数据回报",normalizedTitle:"用户数据回报",charIndex:9703},{level:3,title:"其他特性",slug:"其他特性",normalizedTitle:"其他特性",charIndex:9909},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:9967}],headersStr:"简介 安装 使用arthas-boot（推荐） 使用as.sh 全量安装 基础使用 启动 Demo 启动 arthas 查看 dashboard 通过 thread 命令来获取到arthas-demo进程的 Main Class 通过 jad 来反编译 Main Class watch 退出 arthas 进阶使用 基础命令 jvm 相关 class/classloader 相关 monitor/watch/trace 相关 options 管道 后台异步任务 Web Console 用户数据回报 其他特性 参考资料",content:"# Arthas 快速入门\n\n> Arthas 是 Alibaba 开源的 Java 诊断工具 。\n\n\n# 简介\n\nArthas可以解决的问题：\n\n 1. 这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？\n 2. 我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？\n 3. 遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？\n 4. 线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！\n 5. 是否有一个全局视角来查看系统的运行状况？\n 6. 有什么办法可以监控到 JVM 的实时运行状态？\n\nArthas支持 JDK 6+，支持 Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断。\n\n\n# 安装\n\n\n# 使用arthas-boot（推荐）\n\n下载arthas-boot.jar，然后用java -jar的方式启动：\n\nwget https://alibaba.github.io/arthas/arthas-boot.jar\njava -jar arthas-boot.jar\n\n\n打印帮助信息：\n\njava -jar arthas-boot.jar -h\n\n\n * 如果下载速度比较慢，可以使用 aliyun 的镜像：\n   \n   java -jar arthas-boot.jar --repo-mirror aliyun --use-http\n   \n\n * 如果从 github 下载有问题，可以使用 gitee 镜像\n   \n   wget https://arthas.gitee.io/arthas-boot.jar\n   \n\n\n# 使用as.sh\n\nArthas 支持在 Linux/Unix/Mac 等平台上一键安装，请复制以下内容，并粘贴到命令行中，敲 回车 执行即可：\n\ncurl -L https://alibaba.github.io/arthas/install.sh | sh\n\n\n上述命令会下载启动脚本文件 as.sh 到当前目录，你可以放在任何地方或将其加入到 $PATH 中。\n\n直接在 shell 下面执行./as.sh，就会进入交互界面。\n\n也可以执行./as.sh -h来获取更多参数信息。\n\n * 如果从 github 下载有问题，可以使用 gitee 镜像\n   \n   curl -L https://arthas.gitee.io/install.sh | sh\n   \n\n\n# 全量安装\n\n最新版本，点击下载：下载地址\n\n解压后，在文件夹里有arthas-boot.jar，直接用java -jar的方式启动：\n\njava -jar arthas-boot.jar\n\n\n打印帮助信息：\n\njava -jar arthas-boot.jar -h\n\n\n\n# 基础使用\n\n\n# 启动 Demo\n\nwget https://alibaba.github.io/arthas/arthas-demo.jar\njava -jar arthas-demo.jar\n\n\narthas-demo是一个简单的程序，每隔一秒生成一个随机数，再执行质因式分解，并打印出分解结果。\n\narthas-demo源代码：查看\n\n\n# 启动 arthas\n\n在命令行下面执行（使用和目标进程一致的用户启动，否则可能 attach 失败）：\n\nwget https://alibaba.github.io/arthas/arthas-boot.jar\njava -jar arthas-boot.jar\n\n\n * 执行该程序的用户需要和目标进程具有相同的权限。比如以admin用户来执行：sudo su admin && java -jar arthas-boot.jar 或 sudo -u admin -EH java -jar arthas-boot.jar。\n * 如果 attach 不上目标进程，可以查看~/logs/arthas/ 目录下的日志。\n * 如果下载速度比较慢，可以使用 aliyun 的镜像：java -jar arthas-boot.jar --repo-mirror aliyun --use-http\n * java -jar arthas-boot.jar -h 打印更多参数信息。\n\n选择应用 java 进程：\n\n$ $ java -jar arthas-boot.jar\n* [1]: 35542\n  [2]: 71560 arthas-demo.jar\n\n\nDemo 进程是第 2 个，则输入 2，再输入回车/enter。Arthas 会 attach 到目标进程上，并输出日志：\n\n[INFO] Try to attach process 71560\n[INFO] Attach process 71560 success.\n[INFO] arthas-client connect 127.0.0.1 3658\n  ,---.  ,------. ,--------.,--.  ,--.  ,---.   ,---.\n /  O  \\ |  .--. ''--.  .--'|  '--'  | /  O  \\ '   .-'\n|  .-.  ||  '--'.'   |  |   |  .--.  ||  .-.  |`.  `-.\n|  | |  ||  |\\  \\    |  |   |  |  |  ||  | |  |.-'    |\n`--' `--'`--' '--'   `--'   `--'  `--'`--' `--'`-----'\n\nwiki: https://alibaba.github.io/arthas\nversion: 3.0.5.20181127201536\npid: 71560\ntime: 2018-11-28 19:16:24\n\n$\n\n\n\n# 查看 dashboard\n\n输入dashboard，按回车/enter，会展示当前进程的信息，按ctrl+c可以中断执行。\n\n$ dashboard\nID     NAME                   GROUP          PRIORI STATE  %CPU    TIME   INTERRU DAEMON\n17     pool-2-thread-1        system         5      WAITIN 67      0:0    false   false\n27     Timer-for-arthas-dashb system         10     RUNNAB 32      0:0    false   true\n11     AsyncAppender-Worker-a system         9      WAITIN 0       0:0    false   true\n9      Attach Listener        system         9      RUNNAB 0       0:0    false   true\n3      Finalizer              system         8      WAITIN 0       0:0    false   true\n2      Reference Handler      system         10     WAITIN 0       0:0    false   true\n4      Signal Dispatcher      system         9      RUNNAB 0       0:0    false   true\n26     as-command-execute-dae system         10     TIMED_ 0       0:0    false   true\n13     job-timeout            system         9      TIMED_ 0       0:0    false   true\n1      main                   main           5      TIMED_ 0       0:0    false   false\n14     nioEventLoopGroup-2-1  system         10     RUNNAB 0       0:0    false   false\n18     nioEventLoopGroup-2-2  system         10     RUNNAB 0       0:0    false   false\n23     nioEventLoopGroup-2-3  system         10     RUNNAB 0       0:0    false   false\n15     nioEventLoopGroup-3-1  system         10     RUNNAB 0       0:0    false   false\nMemory             used   total max    usage GC\nheap               32M    155M  1820M  1.77% gc.ps_scavenge.count  4\nps_eden_space      14M    65M   672M   2.21% gc.ps_scavenge.time(m 166\nps_survivor_space  4M     5M    5M           s)\nps_old_gen         12M    85M   1365M  0.91% gc.ps_marksweep.count 0\nnonheap            20M    23M   -1           gc.ps_marksweep.time( 0\ncode_cache         3M     5M    240M   1.32% ms)\nRuntime\nos.name                Mac OS X\nos.version             10.13.4\njava.version           1.8.0_162\njava.home              /Library/Java/JavaVir\n                       tualMachines/jdk1.8.0\n                       _162.jdk/Contents/Hom\n                       e/jre\n\n\n\n# 通过 thread 命令来获取到arthas-demo进程的 Main Class\n\nthread 1会打印线程 ID 1 的栈，通常是 main 函数的线程。\n\n$ thread 1 | grep 'main('\n    at demo.MathGame.main(MathGame.java:17)\n\n\n\n# 通过 jad 来反编译 Main Class\n\n$ jad demo.MathGame\n\nClassLoader:\n+-sun.misc.Launcher$AppClassLoader@3d4eac69\n  +-sun.misc.Launcher$ExtClassLoader@66350f69\n\nLocation:\n/tmp/arthas-demo.jar\n\n/*\n * Decompiled with CFR 0_132.\n */\npackage demo;\n\nimport java.io.PrintStream;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Random;\nimport java.util.concurrent.TimeUnit;\n\npublic class MathGame {\n    private static Random random = new Random();\n    private int illegalArgumentCount = 0;\n\n    public static void main(String[] args) throws InterruptedException {\n        MathGame game = new MathGame();\n        do {\n            game.run();\n            TimeUnit.SECONDS.sleep(1L);\n        } while (true);\n    }\n\n    public void run() throws InterruptedException {\n        try {\n            int number = random.nextInt();\n            List<Integer> primeFactors = this.primeFactors(number);\n            MathGame.print(number, primeFactors);\n        }\n        catch (Exception e) {\n            System.out.println(String.format(\"illegalArgumentCount:%3d, \", this.illegalArgumentCount) + e.getMessage());\n        }\n    }\n\n    public static void print(int number, List<Integer> primeFactors) {\n        StringBuffer sb = new StringBuffer(\"\" + number + \"=\");\n        Iterator<Integer> iterator = primeFactors.iterator();\n        while (iterator.hasNext()) {\n            int factor = iterator.next();\n            sb.append(factor).append('*');\n        }\n        if (sb.charAt(sb.length() - 1) == '*') {\n            sb.deleteCharAt(sb.length() - 1);\n        }\n        System.out.println(sb);\n    }\n\n    public List<Integer> primeFactors(int number) {\n        if (number < 2) {\n            ++this.illegalArgumentCount;\n            throw new IllegalArgumentException(\"number is: \" + number + \", need >= 2\");\n        }\n        ArrayList<Integer> result = new ArrayList<Integer>();\n        int i = 2;\n        while (i <= number) {\n            if (number % i == 0) {\n                result.add(i);\n                number /= i;\n                i = 2;\n                continue;\n            }\n            ++i;\n        }\n        return result;\n    }\n}\n\nAffect(row-cnt:1) cost in 970 ms.\n\n\n\n# watch\n\n通过watch命令来查看demo.MathGame#primeFactors函数的返回值：\n\n$ watch demo.MathGame primeFactors returnObj\nPress Ctrl+C to abort.\nAffect(class-cnt:1 , method-cnt:1) cost in 107 ms.\nts=2018-11-28 19:22:30; [cost=1.715367ms] result=null\nts=2018-11-28 19:22:31; [cost=0.185203ms] result=null\nts=2018-11-28 19:22:32; [cost=19.012416ms] result=@ArrayList[\n    @Integer[5],\n    @Integer[47],\n    @Integer[2675531],\n]\nts=2018-11-28 19:22:33; [cost=0.311395ms] result=@ArrayList[\n    @Integer[2],\n    @Integer[5],\n    @Integer[317],\n    @Integer[503],\n    @Integer[887],\n]\nts=2018-11-28 19:22:34; [cost=10.136007ms] result=@ArrayList[\n    @Integer[2],\n    @Integer[2],\n    @Integer[3],\n    @Integer[3],\n    @Integer[31],\n    @Integer[717593],\n]\nts=2018-11-28 19:22:35; [cost=29.969732ms] result=@ArrayList[\n    @Integer[5],\n    @Integer[29],\n    @Integer[7651739],\n]\n\n\n更多的功能可以查看进阶使用。\n\n\n# 退出 arthas\n\n如果只是退出当前的连接，可以用quit或者exit命令。Attach 到目标进程上的 arthas 还会继续运行，端口会保持开放，下次连接时可以直接连接上。\n\n如果想完全退出 arthas，可以执行shutdown命令。\n\n\n# 进阶使用\n\n\n# 基础命令\n\n * help——查看命令帮助信息\n * cat——打印文件内容，和 linux 里的 cat 命令类似\n * pwd——返回当前的工作目录，和 linux 命令类似\n * cls——清空当前屏幕区域\n * session——查看当前会话的信息\n * reset——重置增强类，将被 Arthas 增强过的类全部还原，Arthas 服务端关闭时会重置所有增强过的类\n * version——输出当前目标 Java 进程所加载的 Arthas 版本号\n * history——打印命令历史\n * quit——退出当前 Arthas 客户端，其他 Arthas 客户端不受影响\n * shutdown——关闭 Arthas 服务端，所有 Arthas 客户端全部退出\n * keymap——Arthas 快捷键列表及自定义快捷键\n\n\n# jvm 相关\n\n * dashboard——当前系统的实时数据面板\n * thread——查看当前 JVM 的线程堆栈信息\n * jvm——查看当前 JVM 的信息\n * sysprop——查看和修改 JVM 的系统属性\n * sysenv——查看 JVM 的环境变量\n * vmoption——查看和修改 JVM 里诊断相关的 option\n * logger——查看和修改 logger\n * getstatic——查看类的静态属性\n * ognl——执行 ognl 表达式\n * mbean——查看 Mbean 的信息\n * heapdump——dump java heap, 类似 jmap 命令的 heap dump 功能\n\n\n# class/classloader 相关\n\n * sc——查看 JVM 已加载的类信息\n * sm——查看已加载类的方法信息\n * jad——反编译指定已加载类的源码\n * mc——内存编绎器，内存编绎.java文件为.class文件\n * redefine——加载外部的.class文件，redefine 到 JVM 里\n * dump——dump 已加载类的 byte code 到特定目录\n * classloader——查看 classloader 的继承树，urls，类加载信息，使用 classloader 去 getResource\n\n\n# monitor/watch/trace 相关\n\n> 请注意，这些命令，都通过字节码增强技术来实现的，会在指定类的方法中插入一些切面来实现数据统计和观测，因此在线上、预发使用时，请尽量明确需要观测的类、方法以及条件，诊断结束要执行 shutdown 或将增强过的类执行 reset 命令。\n\n * monitor——方法执行监控\n * watch——方法执行数据观测\n * trace——方法内部调用路径，并输出方法路径上的每个节点上耗时\n * stack——输出当前方法被调用的调用路径\n * tt——方法执行数据的时空隧道，记录下指定方法每次调用的入参和返回信息，并能对这些不同的时间下调用进行观测\n\n\n# options\n\n * options——查看或设置 Arthas 全局开关\n\n\n# 管道\n\nArthas 支持使用管道对上述命令的结果进行进一步的处理，如sm java.lang.String * | grep 'index'\n\n * grep——搜索满足条件的 \b 结果\n * plaintext——将 \b 命令的结果去除 ANSI 颜色\n * wc——按行统计输出结果\n\n\n# 后台异步任务\n\n当线上出现偶发的问题，比如需要 watch 某个条件，而这个条件一天可能才会出现一次时，异步后台任务就派上用场了，详情请参考这里\n\n * 使用 > 将结果重写向到日志文件，使用 & 指定命令是后台运行，session 断开不影响任务执行（生命周期默认为 1 天）\n * jobs——列出所有 job\n * kill——强制终止任务\n * fg——将暂停的任务拉到前台执行\n * bg——将暂停的任务放到后台执行\n\n\n# Web Console\n\n通过 websocket 连接 Arthas。\n\n * Web Console\n\n\n# 用户数据回报\n\n在3.1.4版本后，增加了用户数据回报功能，方便统一做安全或者历史数据统计。\n\n在启动时，指定stat-url，就会回报执行的每一行命令，比如： ./as.sh --stat-url 'http://192.168.10.11:8080/api/stat'\n\n在 tunnel server 里有一个示例的回报代码，用户可以自己在服务器上实现。\n\nStatController.java\n\n\n# 其他特性\n\n * 异步命令支持\n * 执行结果存日志\n * 批处理的支持\n * ognl 表达式的用法说明\n\n\n# 参考资料\n\n * Arthas Github\n * Arthas 用户文档\n * arthas 源码分析",normalizedContent:"# arthas 快速入门\n\n> arthas 是 alibaba 开源的 java 诊断工具 。\n\n\n# 简介\n\narthas可以解决的问题：\n\n 1. 这个类从哪个 jar 包加载的？为什么会报各种类相关的 exception？\n 2. 我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？\n 3. 遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？\n 4. 线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！\n 5. 是否有一个全局视角来查看系统的运行状况？\n 6. 有什么办法可以监控到 jvm 的实时运行状态？\n\narthas支持 jdk 6+，支持 linux/mac/windows，采用命令行交互模式，同时提供丰富的 tab 自动补全功能，进一步方便进行问题的定位和诊断。\n\n\n# 安装\n\n\n# 使用arthas-boot（推荐）\n\n下载arthas-boot.jar，然后用java -jar的方式启动：\n\nwget https://alibaba.github.io/arthas/arthas-boot.jar\njava -jar arthas-boot.jar\n\n\n打印帮助信息：\n\njava -jar arthas-boot.jar -h\n\n\n * 如果下载速度比较慢，可以使用 aliyun 的镜像：\n   \n   java -jar arthas-boot.jar --repo-mirror aliyun --use-http\n   \n\n * 如果从 github 下载有问题，可以使用 gitee 镜像\n   \n   wget https://arthas.gitee.io/arthas-boot.jar\n   \n\n\n# 使用as.sh\n\narthas 支持在 linux/unix/mac 等平台上一键安装，请复制以下内容，并粘贴到命令行中，敲 回车 执行即可：\n\ncurl -l https://alibaba.github.io/arthas/install.sh | sh\n\n\n上述命令会下载启动脚本文件 as.sh 到当前目录，你可以放在任何地方或将其加入到 $path 中。\n\n直接在 shell 下面执行./as.sh，就会进入交互界面。\n\n也可以执行./as.sh -h来获取更多参数信息。\n\n * 如果从 github 下载有问题，可以使用 gitee 镜像\n   \n   curl -l https://arthas.gitee.io/install.sh | sh\n   \n\n\n# 全量安装\n\n最新版本，点击下载：下载地址\n\n解压后，在文件夹里有arthas-boot.jar，直接用java -jar的方式启动：\n\njava -jar arthas-boot.jar\n\n\n打印帮助信息：\n\njava -jar arthas-boot.jar -h\n\n\n\n# 基础使用\n\n\n# 启动 demo\n\nwget https://alibaba.github.io/arthas/arthas-demo.jar\njava -jar arthas-demo.jar\n\n\narthas-demo是一个简单的程序，每隔一秒生成一个随机数，再执行质因式分解，并打印出分解结果。\n\narthas-demo源代码：查看\n\n\n# 启动 arthas\n\n在命令行下面执行（使用和目标进程一致的用户启动，否则可能 attach 失败）：\n\nwget https://alibaba.github.io/arthas/arthas-boot.jar\njava -jar arthas-boot.jar\n\n\n * 执行该程序的用户需要和目标进程具有相同的权限。比如以admin用户来执行：sudo su admin && java -jar arthas-boot.jar 或 sudo -u admin -eh java -jar arthas-boot.jar。\n * 如果 attach 不上目标进程，可以查看~/logs/arthas/ 目录下的日志。\n * 如果下载速度比较慢，可以使用 aliyun 的镜像：java -jar arthas-boot.jar --repo-mirror aliyun --use-http\n * java -jar arthas-boot.jar -h 打印更多参数信息。\n\n选择应用 java 进程：\n\n$ $ java -jar arthas-boot.jar\n* [1]: 35542\n  [2]: 71560 arthas-demo.jar\n\n\ndemo 进程是第 2 个，则输入 2，再输入回车/enter。arthas 会 attach 到目标进程上，并输出日志：\n\n[info] try to attach process 71560\n[info] attach process 71560 success.\n[info] arthas-client connect 127.0.0.1 3658\n  ,---.  ,------. ,--------.,--.  ,--.  ,---.   ,---.\n /  o  \\ |  .--. ''--.  .--'|  '--'  | /  o  \\ '   .-'\n|  .-.  ||  '--'.'   |  |   |  .--.  ||  .-.  |`.  `-.\n|  | |  ||  |\\  \\    |  |   |  |  |  ||  | |  |.-'    |\n`--' `--'`--' '--'   `--'   `--'  `--'`--' `--'`-----'\n\nwiki: https://alibaba.github.io/arthas\nversion: 3.0.5.20181127201536\npid: 71560\ntime: 2018-11-28 19:16:24\n\n$\n\n\n\n# 查看 dashboard\n\n输入dashboard，按回车/enter，会展示当前进程的信息，按ctrl+c可以中断执行。\n\n$ dashboard\nid     name                   group          priori state  %cpu    time   interru daemon\n17     pool-2-thread-1        system         5      waitin 67      0:0    false   false\n27     timer-for-arthas-dashb system         10     runnab 32      0:0    false   true\n11     asyncappender-worker-a system         9      waitin 0       0:0    false   true\n9      attach listener        system         9      runnab 0       0:0    false   true\n3      finalizer              system         8      waitin 0       0:0    false   true\n2      reference handler      system         10     waitin 0       0:0    false   true\n4      signal dispatcher      system         9      runnab 0       0:0    false   true\n26     as-command-execute-dae system         10     timed_ 0       0:0    false   true\n13     job-timeout            system         9      timed_ 0       0:0    false   true\n1      main                   main           5      timed_ 0       0:0    false   false\n14     nioeventloopgroup-2-1  system         10     runnab 0       0:0    false   false\n18     nioeventloopgroup-2-2  system         10     runnab 0       0:0    false   false\n23     nioeventloopgroup-2-3  system         10     runnab 0       0:0    false   false\n15     nioeventloopgroup-3-1  system         10     runnab 0       0:0    false   false\nmemory             used   total max    usage gc\nheap               32m    155m  1820m  1.77% gc.ps_scavenge.count  4\nps_eden_space      14m    65m   672m   2.21% gc.ps_scavenge.time(m 166\nps_survivor_space  4m     5m    5m           s)\nps_old_gen         12m    85m   1365m  0.91% gc.ps_marksweep.count 0\nnonheap            20m    23m   -1           gc.ps_marksweep.time( 0\ncode_cache         3m     5m    240m   1.32% ms)\nruntime\nos.name                mac os x\nos.version             10.13.4\njava.version           1.8.0_162\njava.home              /library/java/javavir\n                       tualmachines/jdk1.8.0\n                       _162.jdk/contents/hom\n                       e/jre\n\n\n\n# 通过 thread 命令来获取到arthas-demo进程的 main class\n\nthread 1会打印线程 id 1 的栈，通常是 main 函数的线程。\n\n$ thread 1 | grep 'main('\n    at demo.mathgame.main(mathgame.java:17)\n\n\n\n# 通过 jad 来反编译 main class\n\n$ jad demo.mathgame\n\nclassloader:\n+-sun.misc.launcher$appclassloader@3d4eac69\n  +-sun.misc.launcher$extclassloader@66350f69\n\nlocation:\n/tmp/arthas-demo.jar\n\n/*\n * decompiled with cfr 0_132.\n */\npackage demo;\n\nimport java.io.printstream;\nimport java.util.arraylist;\nimport java.util.iterator;\nimport java.util.list;\nimport java.util.random;\nimport java.util.concurrent.timeunit;\n\npublic class mathgame {\n    private static random random = new random();\n    private int illegalargumentcount = 0;\n\n    public static void main(string[] args) throws interruptedexception {\n        mathgame game = new mathgame();\n        do {\n            game.run();\n            timeunit.seconds.sleep(1l);\n        } while (true);\n    }\n\n    public void run() throws interruptedexception {\n        try {\n            int number = random.nextint();\n            list<integer> primefactors = this.primefactors(number);\n            mathgame.print(number, primefactors);\n        }\n        catch (exception e) {\n            system.out.println(string.format(\"illegalargumentcount:%3d, \", this.illegalargumentcount) + e.getmessage());\n        }\n    }\n\n    public static void print(int number, list<integer> primefactors) {\n        stringbuffer sb = new stringbuffer(\"\" + number + \"=\");\n        iterator<integer> iterator = primefactors.iterator();\n        while (iterator.hasnext()) {\n            int factor = iterator.next();\n            sb.append(factor).append('*');\n        }\n        if (sb.charat(sb.length() - 1) == '*') {\n            sb.deletecharat(sb.length() - 1);\n        }\n        system.out.println(sb);\n    }\n\n    public list<integer> primefactors(int number) {\n        if (number < 2) {\n            ++this.illegalargumentcount;\n            throw new illegalargumentexception(\"number is: \" + number + \", need >= 2\");\n        }\n        arraylist<integer> result = new arraylist<integer>();\n        int i = 2;\n        while (i <= number) {\n            if (number % i == 0) {\n                result.add(i);\n                number /= i;\n                i = 2;\n                continue;\n            }\n            ++i;\n        }\n        return result;\n    }\n}\n\naffect(row-cnt:1) cost in 970 ms.\n\n\n\n# watch\n\n通过watch命令来查看demo.mathgame#primefactors函数的返回值：\n\n$ watch demo.mathgame primefactors returnobj\npress ctrl+c to abort.\naffect(class-cnt:1 , method-cnt:1) cost in 107 ms.\nts=2018-11-28 19:22:30; [cost=1.715367ms] result=null\nts=2018-11-28 19:22:31; [cost=0.185203ms] result=null\nts=2018-11-28 19:22:32; [cost=19.012416ms] result=@arraylist[\n    @integer[5],\n    @integer[47],\n    @integer[2675531],\n]\nts=2018-11-28 19:22:33; [cost=0.311395ms] result=@arraylist[\n    @integer[2],\n    @integer[5],\n    @integer[317],\n    @integer[503],\n    @integer[887],\n]\nts=2018-11-28 19:22:34; [cost=10.136007ms] result=@arraylist[\n    @integer[2],\n    @integer[2],\n    @integer[3],\n    @integer[3],\n    @integer[31],\n    @integer[717593],\n]\nts=2018-11-28 19:22:35; [cost=29.969732ms] result=@arraylist[\n    @integer[5],\n    @integer[29],\n    @integer[7651739],\n]\n\n\n更多的功能可以查看进阶使用。\n\n\n# 退出 arthas\n\n如果只是退出当前的连接，可以用quit或者exit命令。attach 到目标进程上的 arthas 还会继续运行，端口会保持开放，下次连接时可以直接连接上。\n\n如果想完全退出 arthas，可以执行shutdown命令。\n\n\n# 进阶使用\n\n\n# 基础命令\n\n * help——查看命令帮助信息\n * cat——打印文件内容，和 linux 里的 cat 命令类似\n * pwd——返回当前的工作目录，和 linux 命令类似\n * cls——清空当前屏幕区域\n * session——查看当前会话的信息\n * reset——重置增强类，将被 arthas 增强过的类全部还原，arthas 服务端关闭时会重置所有增强过的类\n * version——输出当前目标 java 进程所加载的 arthas 版本号\n * history——打印命令历史\n * quit——退出当前 arthas 客户端，其他 arthas 客户端不受影响\n * shutdown——关闭 arthas 服务端，所有 arthas 客户端全部退出\n * keymap——arthas 快捷键列表及自定义快捷键\n\n\n# jvm 相关\n\n * dashboard——当前系统的实时数据面板\n * thread——查看当前 jvm 的线程堆栈信息\n * jvm——查看当前 jvm 的信息\n * sysprop——查看和修改 jvm 的系统属性\n * sysenv——查看 jvm 的环境变量\n * vmoption——查看和修改 jvm 里诊断相关的 option\n * logger——查看和修改 logger\n * getstatic——查看类的静态属性\n * ognl——执行 ognl 表达式\n * mbean——查看 mbean 的信息\n * heapdump——dump java heap, 类似 jmap 命令的 heap dump 功能\n\n\n# class/classloader 相关\n\n * sc——查看 jvm 已加载的类信息\n * sm——查看已加载类的方法信息\n * jad——反编译指定已加载类的源码\n * mc——内存编绎器，内存编绎.java文件为.class文件\n * redefine——加载外部的.class文件，redefine 到 jvm 里\n * dump——dump 已加载类的 byte code 到特定目录\n * classloader——查看 classloader 的继承树，urls，类加载信息，使用 classloader 去 getresource\n\n\n# monitor/watch/trace 相关\n\n> 请注意，这些命令，都通过字节码增强技术来实现的，会在指定类的方法中插入一些切面来实现数据统计和观测，因此在线上、预发使用时，请尽量明确需要观测的类、方法以及条件，诊断结束要执行 shutdown 或将增强过的类执行 reset 命令。\n\n * monitor——方法执行监控\n * watch——方法执行数据观测\n * trace——方法内部调用路径，并输出方法路径上的每个节点上耗时\n * stack——输出当前方法被调用的调用路径\n * tt——方法执行数据的时空隧道，记录下指定方法每次调用的入参和返回信息，并能对这些不同的时间下调用进行观测\n\n\n# options\n\n * options——查看或设置 arthas 全局开关\n\n\n# 管道\n\narthas 支持使用管道对上述命令的结果进行进一步的处理，如sm java.lang.string * | grep 'index'\n\n * grep——搜索满足条件的 \b 结果\n * plaintext——将 \b 命令的结果去除 ansi 颜色\n * wc——按行统计输出结果\n\n\n# 后台异步任务\n\n当线上出现偶发的问题，比如需要 watch 某个条件，而这个条件一天可能才会出现一次时，异步后台任务就派上用场了，详情请参考这里\n\n * 使用 > 将结果重写向到日志文件，使用 & 指定命令是后台运行，session 断开不影响任务执行（生命周期默认为 1 天）\n * jobs——列出所有 job\n * kill——强制终止任务\n * fg——将暂停的任务拉到前台执行\n * bg——将暂停的任务放到后台执行\n\n\n# web console\n\n通过 websocket 连接 arthas。\n\n * web console\n\n\n# 用户数据回报\n\n在3.1.4版本后，增加了用户数据回报功能，方便统一做安全或者历史数据统计。\n\n在启动时，指定stat-url，就会回报执行的每一行命令，比如： ./as.sh --stat-url 'http://192.168.10.11:8080/api/stat'\n\n在 tunnel server 里有一个示例的回报代码，用户可以自己在服务器上实现。\n\nstatcontroller.java\n\n\n# 其他特性\n\n * 异步命令支持\n * 执行结果存日志\n * 批处理的支持\n * ognl 表达式的用法说明\n\n\n# 参考资料\n\n * arthas github\n * arthas 用户文档\n * arthas 源码分析",charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Java 软件",frontmatter:{title:"Java 软件",date:"2022-02-18T08:53:11.000Z",categories:["Java","软件"],tags:["Java"],permalink:"/pages/2cb045/",hidden:!0,index:!1},regularPath:"/01.Java/11.%E8%BD%AF%E4%BB%B6/",relativePath:"01.Java/11.软件/README.md",key:"v-aa513a90",path:"/pages/2cb045/",headers:[{level:2,title:"📖 内容",slug:"📖-内容",normalizedTitle:"📖 内容",charIndex:71},{level:3,title:"构建",slug:"构建",normalizedTitle:"构建",charIndex:46},{level:3,title:"IDE",slug:"ide",normalizedTitle:"ide",charIndex:51},{level:3,title:"监控诊断",slug:"监控诊断",normalizedTitle:"监控诊断",charIndex:768},{level:2,title:"📚 资料",slug:"📚-资料",normalizedTitle:"📚 资料",charIndex:902},{level:2,title:"🚪 传送",slug:"🚪-传送",normalizedTitle:"🚪 传送",charIndex:989}],headersStr:"📖 内容 构建 IDE 监控诊断 📚 资料 🚪 传送",content:"# Java 软件\n\n> 本部分内容主要是 Java 开发领域使用的一些 Java 软件，如构建工具、IDE、服务器、日志中心等等。\n\n\n# 📖 内容\n\n\n# 构建\n\n> Java 项目需要通过 构建工具 来管理项目依赖，完成编译、打包、发布、生成 JavaDoc 等任务。\n> \n>  * 目前最主流的构建工具是 Maven，它的功能非常强大。\n>  * Gradle 号称是要替代 Maven 等构件工具，它的版本管理确实简洁，但是需要学习 Groovy，学习成本比 Maven 高。\n>  * Ant 功能比 Maven 和 Gradle 要弱，现代 Java 项目基本不用了，但也有一些传统的 Java 项目还在使用。\n\n * Maven 📚\n   * Maven 快速入门\n   * Maven 教程之 pom.xml 详解\n   * Maven 教程之 settings.xml 详解\n   * Maven 实战问题和最佳实践\n   * Maven 教程之发布 jar 到私服或中央仓库\n   * Maven 插件之代码检查\n * Ant 简易教程\n\n\n# IDE\n\n> 自从有了 IDE，写代码从此就告别了刀耕火种的蛮荒时代。\n> \n>  * Eclipse 是久负盛名的开源 Java IDE，我的学生时代一直使用它写 Java。\n>  * 曾经抗拒从转 Intellij Idea ，但后来发现真香，不得不说，确实是目前最优秀的 Java IDE。\n>  * 你可以在 vscode 中写各种语言，只要安装相应插件即可。如果你的项目中使用了很多种编程语言，又懒得在多个 IDE 之间切换，那么就用 vscode 来一网打尽吧。\n\n * Intellij Idea\n * Eclipse\n * vscode\n\n\n# 监控诊断\n\n> 监控/诊断 工具主要用于 Java 应用的运维。通过采集、分析、存储、可视化应用的有效数据，帮助开发者、使用者快速定位问题，找到性能瓶颈。\n\n * 监控工具对比\n * CAT\n * Zipkin\n * SkyWalking\n * Arthas\n\n\n# 📚 资料\n\n * 官网\n   * Maven Github\n   * Maven 官方文档\n   * Ant 官方手册\n * 书籍\n   * 《Maven 实战》\n\n\n# 🚪 传送\n\n◾ 💧 钝悟的 IT 知识图谱 ◾",normalizedContent:"# java 软件\n\n> 本部分内容主要是 java 开发领域使用的一些 java 软件，如构建工具、ide、服务器、日志中心等等。\n\n\n# 📖 内容\n\n\n# 构建\n\n> java 项目需要通过 构建工具 来管理项目依赖，完成编译、打包、发布、生成 javadoc 等任务。\n> \n>  * 目前最主流的构建工具是 maven，它的功能非常强大。\n>  * gradle 号称是要替代 maven 等构件工具，它的版本管理确实简洁，但是需要学习 groovy，学习成本比 maven 高。\n>  * ant 功能比 maven 和 gradle 要弱，现代 java 项目基本不用了，但也有一些传统的 java 项目还在使用。\n\n * maven 📚\n   * maven 快速入门\n   * maven 教程之 pom.xml 详解\n   * maven 教程之 settings.xml 详解\n   * maven 实战问题和最佳实践\n   * maven 教程之发布 jar 到私服或中央仓库\n   * maven 插件之代码检查\n * ant 简易教程\n\n\n# ide\n\n> 自从有了 ide，写代码从此就告别了刀耕火种的蛮荒时代。\n> \n>  * eclipse 是久负盛名的开源 java ide，我的学生时代一直使用它写 java。\n>  * 曾经抗拒从转 intellij idea ，但后来发现真香，不得不说，确实是目前最优秀的 java ide。\n>  * 你可以在 vscode 中写各种语言，只要安装相应插件即可。如果你的项目中使用了很多种编程语言，又懒得在多个 ide 之间切换，那么就用 vscode 来一网打尽吧。\n\n * intellij idea\n * eclipse\n * vscode\n\n\n# 监控诊断\n\n> 监控/诊断 工具主要用于 java 应用的运维。通过采集、分析、存储、可视化应用的有效数据，帮助开发者、使用者快速定位问题，找到性能瓶颈。\n\n * 监控工具对比\n * cat\n * zipkin\n * skywalking\n * arthas\n\n\n# 📚 资料\n\n * 官网\n   * maven github\n   * maven 官方文档\n   * ant 官方手册\n * 书籍\n   * 《maven 实战》\n\n\n# 🚪 传送\n\n◾ 💧 钝悟的 it 知识图谱 ◾",charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Java 和 JSON 序列化",frontmatter:{title:"Java 和 JSON 序列化",date:"2022-02-17T22:34:30.000Z",order:1,categories:["Java","工具","IO"],tags:["Java","IO","序列化","JSON"],permalink:"/pages/4622a6/"},regularPath:"/01.Java/12.%E5%B7%A5%E5%85%B7/01.IO/01.JSON%E5%BA%8F%E5%88%97%E5%8C%96.html",relativePath:"01.Java/12.工具/01.IO/01.JSON序列化.md",key:"v-18d04790",path:"/pages/4622a6/",headers:[{level:2,title:"JSON 简介",slug:"json-简介",normalizedTitle:"json 简介",charIndex:184},{level:3,title:"JSON 是什么",slug:"json-是什么",normalizedTitle:"json 是什么",charIndex:196},{level:3,title:"JSON 标准",slug:"json-标准",normalizedTitle:"json 标准",charIndex:426},{level:3,title:"JSON 优缺点",slug:"json-优缺点",normalizedTitle:"json 优缺点",charIndex:979},{level:3,title:"JSON 工具",slug:"json-工具",normalizedTitle:"json 工具",charIndex:1571},{level:3,title:"Java JSON 库",slug:"java-json-库",normalizedTitle:"java json 库",charIndex:1815},{level:3,title:"JSON 编码指南",slug:"json-编码指南",normalizedTitle:"json 编码指南",charIndex:2018},{level:2,title:"Fastjson 应用",slug:"fastjson-应用",normalizedTitle:"fastjson 应用",charIndex:2713},{level:3,title:"添加 maven 依赖",slug:"添加-maven-依赖",normalizedTitle:"添加 maven 依赖",charIndex:2729},{level:3,title:"Fastjson API",slug:"fastjson-api",normalizedTitle:"fastjson api",charIndex:2876},{level:4,title:"定义 Bean",slug:"定义-bean",normalizedTitle:"定义 bean",charIndex:2892},{level:4,title:"序列化",slug:"序列化",normalizedTitle:"序列化",charIndex:14},{level:4,title:"反序列化",slug:"反序列化",normalizedTitle:"反序列化",charIndex:3508},{level:3,title:"Fastjson 注解",slug:"fastjson-注解",normalizedTitle:"fastjson 注解",charIndex:3575},{level:4,title:"@JSONField",slug:"jsonfield",normalizedTitle:"@jsonfield",charIndex:3590},{level:4,title:"@JSONType",slug:"jsontype",normalizedTitle:"@jsontype",charIndex:4046},{level:2,title:"Jackson 应用",slug:"jackson-应用",normalizedTitle:"jackson 应用",charIndex:4338},{level:3,title:"添加 maven 依赖",slug:"添加-maven-依赖-2",normalizedTitle:"添加 maven 依赖",charIndex:2729},{level:3,title:"Jackson API",slug:"jackson-api",normalizedTitle:"jackson api",charIndex:4569},{level:4,title:"序列化",slug:"序列化-2",normalizedTitle:"序列化",charIndex:14},{level:4,title:"反序列化",slug:"反序列化-2",normalizedTitle:"反序列化",charIndex:3508},{level:4,title:"容器的序列化和反序列化",slug:"容器的序列化和反序列化",normalizedTitle:"容器的序列化和反序列化",charIndex:5132},{level:3,title:"Jackson 注解",slug:"jackson-注解",normalizedTitle:"jackson 注解",charIndex:5550},{level:4,title:"@JsonProperty",slug:"jsonproperty",normalizedTitle:"@jsonproperty",charIndex:5610},{level:4,title:"@JsonIgnoreProperties 和 @JsonIgnore",slug:"jsonignoreproperties-和-jsonignore",normalizedTitle:"@jsonignoreproperties 和 @jsonignore",charIndex:5968},{level:4,title:"@JsonCreator",slug:"jsoncreator",normalizedTitle:"@jsoncreator",charIndex:6556},{level:4,title:"@JsonPropertyOrder",slug:"jsonpropertyorder",normalizedTitle:"@jsonpropertyorder",charIndex:6858},{level:2,title:"Gson 应用",slug:"gson-应用",normalizedTitle:"gson 应用",charIndex:7008},{level:3,title:"添加 maven 依赖",slug:"添加-maven-依赖-3",normalizedTitle:"添加 maven 依赖",charIndex:2729},{level:3,title:"Gson API",slug:"gson-api",normalizedTitle:"gson api",charIndex:7198},{level:4,title:"序列化",slug:"序列化-3",normalizedTitle:"序列化",charIndex:14},{level:4,title:"反序列化",slug:"反序列化-3",normalizedTitle:"反序列化",charIndex:3508},{level:4,title:"GsonBuilder",slug:"gsonbuilder",normalizedTitle:"gsonbuilder",charIndex:7719},{level:3,title:"Gson 注解",slug:"gson-注解",normalizedTitle:"gson 注解",charIndex:7977},{level:4,title:"@Since",slug:"since",normalizedTitle:"@since",charIndex:7988},{level:4,title:"@SerializedName",slug:"serializedname",normalizedTitle:"@serializedname",charIndex:8605},{level:2,title:"示例源码",slug:"示例源码",normalizedTitle:"示例源码",charIndex:8904},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:8937}],headersStr:"JSON 简介 JSON 是什么 JSON 标准 JSON 优缺点 JSON 工具 Java JSON 库 JSON 编码指南 Fastjson 应用 添加 maven 依赖 Fastjson API 定义 Bean 序列化 反序列化 Fastjson 注解 @JSONField @JSONType Jackson 应用 添加 maven 依赖 Jackson API 序列化 反序列化 容器的序列化和反序列化 Jackson 注解 @JsonProperty @JsonIgnoreProperties 和 @JsonIgnore @JsonCreator @JsonPropertyOrder Gson 应用 添加 maven 依赖 Gson API 序列化 反序列化 GsonBuilder Gson 注解 @Since @SerializedName 示例源码 参考资料",content:'# Java 和 JSON 序列化\n\n> JSON（JavaScript Object Notation）是一种基于文本的数据交换格式。几乎所有的编程语言都有很好的库或第三方工具来提供基于 JSON 的 API 支持，因此你可以非常方便地使用任何自己喜欢的编程语言来处理 JSON 数据。\n> \n> 本文主要从 Java 语言的角度来讲解 JSON 的应用。\n\n\n# JSON 简介\n\n\n# JSON 是什么\n\nJSON 起源于 1999 年的 JS 语言规范 ECMA262 的一个子集（即 15.12 章节描述了格式与解析），后来 2003 年作为一个数据格式ECMA404（很囧的序号有不有？）发布。 2006 年，作为 rfc4627 发布，这时规范增加到 18 页，去掉没用的部分，十页不到。\n\nJSON 的应用很广泛，这里有超过 100 种语言下的 JSON 库：json.org。\n\n更多的可以参考这里，关于 json 的一切。\n\n\n# JSON 标准\n\n这估计是最简单标准规范之一：\n\n * 只有两种结构：对象内的键值对集合结构和数组，对象用 {} 表示、内部是 "key":"value"，数组用 [] 表示，不同值用逗号分开\n * 基本数值有 7 个： false / null / true / object / array / number / string\n * 再加上结构可以嵌套，进而可以用来表达复杂的数据\n * 一个简单实例：\n\n{\n  "Image": {\n    "Width": 800,\n    "Height": 600,\n    "Title": "View from 15th Floor",\n    "Thumbnail": {\n      "Url": "http://www.example.com/image/481989943",\n      "Height": 125,\n      "Width": "100"\n    },\n    "IDs": [116, 943, 234, 38793]\n  }\n}\n\n\n> 扩展阅读：\n> \n>  * http://www.json.org/json-zh.html - 图文并茂介绍 json 数据形式\n> \n>  * json 的 RFC 文档\n\n\n# JSON 优缺点\n\n优点：\n\n * 基于纯文本，所以对于人类阅读是很友好的。\n * 规范简单，所以容易处理，开箱即用，特别是 JS 类的 ECMA 脚本里是内建支持的，可以直接作为对象使用。\n * 平台无关性，因为类型和结构都是平台无关的，而且好处理，容易实现不同语言的处理类库，可以作为多个不同异构系统之间的数据传输格式协议，特别是在 HTTP/REST 下的数据格式。\n\n缺点：\n\n * 性能一般，文本表示的数据一般来说比二进制大得多，在数据传输上和解析处理上都要更影响性能。\n * 缺乏 schema，跟同是文本数据格式的 XML 比，在类型的严格性和丰富性上要差很多。XML 可以借由 XSD 或 DTD 来定义复杂的格式，并由此来验证 XML 文档是否符合格式要求，甚至进一步的，可以基于 XSD 来生成具体语言的操作代码，例如 apache xmlbeans。并且这些工具组合到一起，形成一套庞大的生态，例如基于 XML 可以实现 SOAP 和 WSDL，一系列的 ws-*规范。但是我们也可以看到 JSON 在缺乏规范的情况下，实际上有更大一些的灵活性，特别是近年来 REST 的快速发展，已经有一些 schema 相关的发展(例如理解 JSON Schema，使用 JSON Schema， 在线 schema 测试)，也有类似于 WSDL 的WADL出现。\n\n\n# JSON 工具\n\n * 使用 JSON 实现 RPC（类似 XML-RPC）：JSON-RPC\n\n * 使用 JSON 实现 path 查询操作（类似 XML-PATH）：JsonPATH\n\n * 在线查询工具：JsonPATH\n\n * 格式化工具：jsbeautifier\n\n * chrome 插件：5 个 Json View 插件\n\n * 在线 Mock: 在线 mock\n\n * 其他 Mock：SoapUI可以支持，SwaggerUI 也可以，RestMock也可以。\n\n\n# Java JSON 库\n\nJava 中比较流行的 JSON 库有：\n\n * Fastjson - 阿里巴巴开发的 JSON 库，性能十分优秀。\n * Jackson - 社区十分活跃且更新速度很快。Spring 框架默认 JSON 库。\n * Gson - 谷歌开发的 JSON 库，目前功能最全的 JSON 库 。\n\n从性能上来看，一般情况下：Fastjson > Jackson > Gson\n\n\n# JSON 编码指南\n\n> 遵循好的设计与编码风格，能提前解决 80%的问题，个人推荐 Google JSON 风格指南。\n> \n>  * 英文版Google JSON Style Guide：https://google.github.io/styleguide/jsoncstyleguide.xml\n>  * 中文版Google JSON 风格指南：https://github.com/darcyliu/google-styleguide/blob/master/JSONStyleGuide.md\n\n简单摘录如下：\n\n * 属性名和值都是用双引号，不要把注释写到对象里面，对象数据要简洁\n * 不要随意结构化分组对象，推荐是用扁平化方式，层次不要太复杂\n * 命名方式要有意义，比如单复数表示\n * 驼峰式命名，遵循 Bean 规范\n * 使用版本来控制变更冲突\n * 对于一些关键字，不要拿来做 key\n * 如果一个属性是可选的或者包含空值或 null 值，考虑从 JSON 中去掉该属性，除非它的存在有很强的语义原因\n * 序列化枚举类型时，使用 name 而不是 value\n * 日期要用标准格式处理\n * 设计好通用的分页参数\n * 设计好异常处理\n\nJSON API与 Google JSON 风格指南有很多可以相互参照之处。\n\nJSON API是数据交互规范，用以定义客户端如何获取与修改资源，以及服务器如何响应对应请求。\n\nJSON API 设计用来最小化请求的数量，以及客户端与服务器间传输的数据量。在高效实现的同时，无需牺牲可读性、灵活性和可发现性。\n\n\n# Fastjson 应用\n\n\n# 添加 maven 依赖\n\n<dependency>\n    <groupId>com.alibaba</groupId>\n    <artifactId>fastjson</artifactId>\n    <version>x.x.x</version>\n</dependency>\n\n\n\n# Fastjson API\n\n# 定义 Bean\n\nGroup.java\n\npublic class Group {\n\n    private Long       id;\n    private String     name;\n    private List<User> users = new ArrayList<User>();\n}\n\n\nUser.java\n\npublic class User {\n\n    private Long   id;\n    private String name;\n}\n\n\n初始化 Bean\n\nGroup group = new Group();\ngroup.setId(0L);\ngroup.setName("admin");\n\nUser guestUser = new User();\nguestUser.setId(2L);\nguestUser.setName("guest");\n\nUser rootUser = new User();\nrootUser.setId(3L);\nrootUser.setName("root");\n\ngroup.addUser(guestUser);\ngroup.addUser(rootUser);\n\n\n# 序列化\n\nString jsonString = JSON.toJSONString(group);\nSystem.out.println(jsonString);\n\n\n# 反序列化\n\nGroup bean = JSON.parseObject(jsonString, Group.class);\n\n\n\n# Fastjson 注解\n\n# @JSONField\n\n> 扩展阅读：更多 API 使用细节可以参考：JSONField 用法，这里介绍基本用法。\n\n可以配置在属性（setter、getter）和字段（必须是 public field）上。\n\n@JSONField(name="ID")\npublic int getId() {return id;}\n\n// 配置date序列化和反序列使用yyyyMMdd日期格式\n@JSONField(format="yyyyMMdd")\npublic Date date1;\n\n// 不序列化\n@JSONField(serialize=false)\npublic Date date2;\n\n// 不反序列化\n@JSONField(deserialize=false)\npublic Date date3;\n\n// 按ordinal排序\n@JSONField(ordinal = 2)\nprivate int f1;\n\n@JSONField(ordinal = 1)\nprivate int f2;\n\n\n# @JSONType\n\n * 自定义序列化：ObjectSerializer\n * 子类型处理：SeeAlso\n\nJSONType.alphabetic 属性: fastjson 缺省时会使用字母序序列化，如果你是希望按照 java fields/getters 的自然顺序序列化，可以配置 JSONType.alphabetic，使用方法如下：\n\n@JSONType(alphabetic = false)\npublic static class B {\n    public int f2;\n    public int f1;\n    public int f0;\n}\n\n\n\n# Jackson 应用\n\n> 扩展阅读：更多 API 使用细节可以参考 jackson-databind 官方说明\n\n\n# 添加 maven 依赖\n\n<dependency>\n    <groupId>com.fasterxml.jackson.core</groupId>\n    <artifactId>jackson-databind</artifactId>\n    <version>2.9.8</version>\n</dependency>\n\n\n\n# Jackson API\n\n# 序列化\n\nObjectMapper mapper = new ObjectMapper();\n\nmapper.writeValue(new File("result.json"), myResultObject);\n// or:\nbyte[] jsonBytes = mapper.writeValueAsBytes(myResultObject);\n// or:\nString jsonString = mapper.writeValueAsString(myResultObject);\n\n\n# 反序列化\n\nObjectMapper mapper = new ObjectMapper();\n\nMyValue value = mapper.readValue(new File("data.json"), MyValue.class);\n// or:\nvalue = mapper.readValue(new URL("http://some.com/api/entry.json"), MyValue.class);\n// or:\nvalue = mapper.readValue("{\\"name\\":\\"Bob\\", \\"age\\":13}", MyValue.class);\n\n\n# 容器的序列化和反序列化\n\nPerson p = new Person("Tom", 20);\nPerson p2 = new Person("Jack", 22);\nPerson p3 = new Person("Mary", 18);\n\nList<Person> persons = new LinkedList<>();\npersons.add(p);\npersons.add(p2);\npersons.add(p3);\n\nMap<String, List> map = new HashMap<>();\nmap.put("persons", persons);\n\nString json = null;\ntry {\n json = mapper.writeValueAsString(map);\n} catch (JsonProcessingException e) {\n e.printStackTrace();\n}\n\n\n\n# Jackson 注解\n\n> 扩展阅读：更多注解使用细节可以参考 jackson-annotations 官方说明\n\n# @JsonProperty\n\npublic class MyBean {\n   private String _name;\n\n   // without annotation, we\'d get "theName", but we want "name":\n   @JsonProperty("name")\n   public String getTheName() { return _name; }\n\n   // note: it is enough to add annotation on just getter OR setter;\n   // so we can omit it here\n   public void setTheName(String n) { _name = n; }\n}\n\n\n# @JsonIgnoreProperties 和 @JsonIgnore\n\n// means that if we see "foo" or "bar" in JSON, they will be quietly skipped\n// regardless of whether POJO has such properties\n@JsonIgnoreProperties({ "foo", "bar" })\npublic class MyBean {\n   // will not be written as JSON; nor assigned from JSON:\n   @JsonIgnore\n   public String internal;\n\n   // no annotation, public field is read/written normally\n   public String external;\n\n   @JsonIgnore\n   public void setCode(int c) { _code = c; }\n\n   // note: will also be ignored because setter has annotation!\n   public int getCode() { return _code; }\n}\n\n\n# @JsonCreator\n\npublic class CtorBean {\n  public final String name;\n  public final int age;\n\n  @JsonCreator // constructor can be public, private, whatever\n  private CtorBean(@JsonProperty("name") String name,\n    @JsonProperty("age") int age)\n  {\n      this.name = name;\n      this.age = age;\n  }\n}\n\n\n# @JsonPropertyOrder\n\nalphabetic 设为 true 表示，json 字段按自然顺序排列，默认为 false。\n\n@JsonPropertyOrder(alphabetic = true)\npublic class JacksonAnnotationBean {}\n\n\n\n# Gson 应用\n\n> 详细内容可以参考官方文档：Gson 用户指南\n\n\n# 添加 maven 依赖\n\n<dependency>\n    <groupId>com.google.code.gson</groupId>\n    <artifactId>gson</artifactId>\n    <version>2.8.6</version>\n</dependency>\n\n\n\n# Gson API\n\n# 序列化\n\nGson gson = new Gson();\ngson.toJson(1);            // ==> 1\ngson.toJson("abcd");       // ==> "abcd"\ngson.toJson(10L); // ==> 10\nint[] values = { 1 };\ngson.toJson(values);       // ==> [1]\n\n\n# 反序列化\n\nint i1 = gson.fromJson("1", int.class);\nInteger i2 = gson.fromJson("1", Integer.class);\nLong l1 = gson.fromJson("1", Long.class);\nBoolean b1 = gson.fromJson("false", Boolean.class);\nString str = gson.fromJson("\\"abc\\"", String.class);\nString[] anotherStr = gson.fromJson("[\\"abc\\"]", String[].class);\n\n\n# GsonBuilder\n\nGson 实例可以通过 GsonBuilder 来定制实例化，以控制其序列化、反序列化行为。\n\nGson gson = new GsonBuilder()\n  .setPrettyPrinting()\n  .setDateFormat("yyyy-MM-dd HH:mm:ss")\n  .excludeFieldsWithModifiers(Modifier.STATIC, Modifier.TRANSIENT, Modifier.VOLATILE)\n  .create();\n\n\n\n# Gson 注解\n\n# @Since\n\n@Since 用于控制对象的序列化版本。示例：\n\npublic class VersionedClass {\n  @Since(1.1) private final String newerField;\n  @Since(1.0) private final String newField;\n  private final String field;\n\n  public VersionedClass() {\n    this.newerField = "newer";\n    this.newField = "new";\n    this.field = "old";\n  }\n}\n\nVersionedClass versionedObject = new VersionedClass();\nGson gson = new GsonBuilder().setVersion(1.0).create();\nString jsonOutput = gson.toJson(versionedObject);\nSystem.out.println(jsonOutput);\nSystem.out.println();\n\ngson = new Gson();\njsonOutput = gson.toJson(versionedObject);\nSystem.out.println(jsonOutput);\n\n\n# @SerializedName\n\n@SerializedName 用于将类成员按照指定名称序列化、反序列化。示例：\n\nprivate class SomeObject {\n  @SerializedName("custom_naming") private final String someField;\n  private final String someOtherField;\n\n  public SomeObject(String a, String b) {\n    this.someField = a;\n    this.someOtherField = b;\n  }\n}\n\n\n\n# 示例源码\n\n> 示例源码：javalib-io-json\n\n\n# 参考资料\n\n * 官方\n   * Fastjson Github\n   * Gson Github\n   * jackson 官方文档\n   * jackson-databind\n * 文章\n   * http://www.json.org/json-zh.html\n   * json 的 RFC 文档\n   * JSON 最佳实践\n   * 【简明教程】JSON',normalizedContent:'# java 和 json 序列化\n\n> json（javascript object notation）是一种基于文本的数据交换格式。几乎所有的编程语言都有很好的库或第三方工具来提供基于 json 的 api 支持，因此你可以非常方便地使用任何自己喜欢的编程语言来处理 json 数据。\n> \n> 本文主要从 java 语言的角度来讲解 json 的应用。\n\n\n# json 简介\n\n\n# json 是什么\n\njson 起源于 1999 年的 js 语言规范 ecma262 的一个子集（即 15.12 章节描述了格式与解析），后来 2003 年作为一个数据格式ecma404（很囧的序号有不有？）发布。 2006 年，作为 rfc4627 发布，这时规范增加到 18 页，去掉没用的部分，十页不到。\n\njson 的应用很广泛，这里有超过 100 种语言下的 json 库：json.org。\n\n更多的可以参考这里，关于 json 的一切。\n\n\n# json 标准\n\n这估计是最简单标准规范之一：\n\n * 只有两种结构：对象内的键值对集合结构和数组，对象用 {} 表示、内部是 "key":"value"，数组用 [] 表示，不同值用逗号分开\n * 基本数值有 7 个： false / null / true / object / array / number / string\n * 再加上结构可以嵌套，进而可以用来表达复杂的数据\n * 一个简单实例：\n\n{\n  "image": {\n    "width": 800,\n    "height": 600,\n    "title": "view from 15th floor",\n    "thumbnail": {\n      "url": "http://www.example.com/image/481989943",\n      "height": 125,\n      "width": "100"\n    },\n    "ids": [116, 943, 234, 38793]\n  }\n}\n\n\n> 扩展阅读：\n> \n>  * http://www.json.org/json-zh.html - 图文并茂介绍 json 数据形式\n> \n>  * json 的 rfc 文档\n\n\n# json 优缺点\n\n优点：\n\n * 基于纯文本，所以对于人类阅读是很友好的。\n * 规范简单，所以容易处理，开箱即用，特别是 js 类的 ecma 脚本里是内建支持的，可以直接作为对象使用。\n * 平台无关性，因为类型和结构都是平台无关的，而且好处理，容易实现不同语言的处理类库，可以作为多个不同异构系统之间的数据传输格式协议，特别是在 http/rest 下的数据格式。\n\n缺点：\n\n * 性能一般，文本表示的数据一般来说比二进制大得多，在数据传输上和解析处理上都要更影响性能。\n * 缺乏 schema，跟同是文本数据格式的 xml 比，在类型的严格性和丰富性上要差很多。xml 可以借由 xsd 或 dtd 来定义复杂的格式，并由此来验证 xml 文档是否符合格式要求，甚至进一步的，可以基于 xsd 来生成具体语言的操作代码，例如 apache xmlbeans。并且这些工具组合到一起，形成一套庞大的生态，例如基于 xml 可以实现 soap 和 wsdl，一系列的 ws-*规范。但是我们也可以看到 json 在缺乏规范的情况下，实际上有更大一些的灵活性，特别是近年来 rest 的快速发展，已经有一些 schema 相关的发展(例如理解 json schema，使用 json schema， 在线 schema 测试)，也有类似于 wsdl 的wadl出现。\n\n\n# json 工具\n\n * 使用 json 实现 rpc（类似 xml-rpc）：json-rpc\n\n * 使用 json 实现 path 查询操作（类似 xml-path）：jsonpath\n\n * 在线查询工具：jsonpath\n\n * 格式化工具：jsbeautifier\n\n * chrome 插件：5 个 json view 插件\n\n * 在线 mock: 在线 mock\n\n * 其他 mock：soapui可以支持，swaggerui 也可以，restmock也可以。\n\n\n# java json 库\n\njava 中比较流行的 json 库有：\n\n * fastjson - 阿里巴巴开发的 json 库，性能十分优秀。\n * jackson - 社区十分活跃且更新速度很快。spring 框架默认 json 库。\n * gson - 谷歌开发的 json 库，目前功能最全的 json 库 。\n\n从性能上来看，一般情况下：fastjson > jackson > gson\n\n\n# json 编码指南\n\n> 遵循好的设计与编码风格，能提前解决 80%的问题，个人推荐 google json 风格指南。\n> \n>  * 英文版google json style guide：https://google.github.io/styleguide/jsoncstyleguide.xml\n>  * 中文版google json 风格指南：https://github.com/darcyliu/google-styleguide/blob/master/jsonstyleguide.md\n\n简单摘录如下：\n\n * 属性名和值都是用双引号，不要把注释写到对象里面，对象数据要简洁\n * 不要随意结构化分组对象，推荐是用扁平化方式，层次不要太复杂\n * 命名方式要有意义，比如单复数表示\n * 驼峰式命名，遵循 bean 规范\n * 使用版本来控制变更冲突\n * 对于一些关键字，不要拿来做 key\n * 如果一个属性是可选的或者包含空值或 null 值，考虑从 json 中去掉该属性，除非它的存在有很强的语义原因\n * 序列化枚举类型时，使用 name 而不是 value\n * 日期要用标准格式处理\n * 设计好通用的分页参数\n * 设计好异常处理\n\njson api与 google json 风格指南有很多可以相互参照之处。\n\njson api是数据交互规范，用以定义客户端如何获取与修改资源，以及服务器如何响应对应请求。\n\njson api 设计用来最小化请求的数量，以及客户端与服务器间传输的数据量。在高效实现的同时，无需牺牲可读性、灵活性和可发现性。\n\n\n# fastjson 应用\n\n\n# 添加 maven 依赖\n\n<dependency>\n    <groupid>com.alibaba</groupid>\n    <artifactid>fastjson</artifactid>\n    <version>x.x.x</version>\n</dependency>\n\n\n\n# fastjson api\n\n# 定义 bean\n\ngroup.java\n\npublic class group {\n\n    private long       id;\n    private string     name;\n    private list<user> users = new arraylist<user>();\n}\n\n\nuser.java\n\npublic class user {\n\n    private long   id;\n    private string name;\n}\n\n\n初始化 bean\n\ngroup group = new group();\ngroup.setid(0l);\ngroup.setname("admin");\n\nuser guestuser = new user();\nguestuser.setid(2l);\nguestuser.setname("guest");\n\nuser rootuser = new user();\nrootuser.setid(3l);\nrootuser.setname("root");\n\ngroup.adduser(guestuser);\ngroup.adduser(rootuser);\n\n\n# 序列化\n\nstring jsonstring = json.tojsonstring(group);\nsystem.out.println(jsonstring);\n\n\n# 反序列化\n\ngroup bean = json.parseobject(jsonstring, group.class);\n\n\n\n# fastjson 注解\n\n# @jsonfield\n\n> 扩展阅读：更多 api 使用细节可以参考：jsonfield 用法，这里介绍基本用法。\n\n可以配置在属性（setter、getter）和字段（必须是 public field）上。\n\n@jsonfield(name="id")\npublic int getid() {return id;}\n\n// 配置date序列化和反序列使用yyyymmdd日期格式\n@jsonfield(format="yyyymmdd")\npublic date date1;\n\n// 不序列化\n@jsonfield(serialize=false)\npublic date date2;\n\n// 不反序列化\n@jsonfield(deserialize=false)\npublic date date3;\n\n// 按ordinal排序\n@jsonfield(ordinal = 2)\nprivate int f1;\n\n@jsonfield(ordinal = 1)\nprivate int f2;\n\n\n# @jsontype\n\n * 自定义序列化：objectserializer\n * 子类型处理：seealso\n\njsontype.alphabetic 属性: fastjson 缺省时会使用字母序序列化，如果你是希望按照 java fields/getters 的自然顺序序列化，可以配置 jsontype.alphabetic，使用方法如下：\n\n@jsontype(alphabetic = false)\npublic static class b {\n    public int f2;\n    public int f1;\n    public int f0;\n}\n\n\n\n# jackson 应用\n\n> 扩展阅读：更多 api 使用细节可以参考 jackson-databind 官方说明\n\n\n# 添加 maven 依赖\n\n<dependency>\n    <groupid>com.fasterxml.jackson.core</groupid>\n    <artifactid>jackson-databind</artifactid>\n    <version>2.9.8</version>\n</dependency>\n\n\n\n# jackson api\n\n# 序列化\n\nobjectmapper mapper = new objectmapper();\n\nmapper.writevalue(new file("result.json"), myresultobject);\n// or:\nbyte[] jsonbytes = mapper.writevalueasbytes(myresultobject);\n// or:\nstring jsonstring = mapper.writevalueasstring(myresultobject);\n\n\n# 反序列化\n\nobjectmapper mapper = new objectmapper();\n\nmyvalue value = mapper.readvalue(new file("data.json"), myvalue.class);\n// or:\nvalue = mapper.readvalue(new url("http://some.com/api/entry.json"), myvalue.class);\n// or:\nvalue = mapper.readvalue("{\\"name\\":\\"bob\\", \\"age\\":13}", myvalue.class);\n\n\n# 容器的序列化和反序列化\n\nperson p = new person("tom", 20);\nperson p2 = new person("jack", 22);\nperson p3 = new person("mary", 18);\n\nlist<person> persons = new linkedlist<>();\npersons.add(p);\npersons.add(p2);\npersons.add(p3);\n\nmap<string, list> map = new hashmap<>();\nmap.put("persons", persons);\n\nstring json = null;\ntry {\n json = mapper.writevalueasstring(map);\n} catch (jsonprocessingexception e) {\n e.printstacktrace();\n}\n\n\n\n# jackson 注解\n\n> 扩展阅读：更多注解使用细节可以参考 jackson-annotations 官方说明\n\n# @jsonproperty\n\npublic class mybean {\n   private string _name;\n\n   // without annotation, we\'d get "thename", but we want "name":\n   @jsonproperty("name")\n   public string getthename() { return _name; }\n\n   // note: it is enough to add annotation on just getter or setter;\n   // so we can omit it here\n   public void setthename(string n) { _name = n; }\n}\n\n\n# @jsonignoreproperties 和 @jsonignore\n\n// means that if we see "foo" or "bar" in json, they will be quietly skipped\n// regardless of whether pojo has such properties\n@jsonignoreproperties({ "foo", "bar" })\npublic class mybean {\n   // will not be written as json; nor assigned from json:\n   @jsonignore\n   public string internal;\n\n   // no annotation, public field is read/written normally\n   public string external;\n\n   @jsonignore\n   public void setcode(int c) { _code = c; }\n\n   // note: will also be ignored because setter has annotation!\n   public int getcode() { return _code; }\n}\n\n\n# @jsoncreator\n\npublic class ctorbean {\n  public final string name;\n  public final int age;\n\n  @jsoncreator // constructor can be public, private, whatever\n  private ctorbean(@jsonproperty("name") string name,\n    @jsonproperty("age") int age)\n  {\n      this.name = name;\n      this.age = age;\n  }\n}\n\n\n# @jsonpropertyorder\n\nalphabetic 设为 true 表示，json 字段按自然顺序排列，默认为 false。\n\n@jsonpropertyorder(alphabetic = true)\npublic class jacksonannotationbean {}\n\n\n\n# gson 应用\n\n> 详细内容可以参考官方文档：gson 用户指南\n\n\n# 添加 maven 依赖\n\n<dependency>\n    <groupid>com.google.code.gson</groupid>\n    <artifactid>gson</artifactid>\n    <version>2.8.6</version>\n</dependency>\n\n\n\n# gson api\n\n# 序列化\n\ngson gson = new gson();\ngson.tojson(1);            // ==> 1\ngson.tojson("abcd");       // ==> "abcd"\ngson.tojson(10l); // ==> 10\nint[] values = { 1 };\ngson.tojson(values);       // ==> [1]\n\n\n# 反序列化\n\nint i1 = gson.fromjson("1", int.class);\ninteger i2 = gson.fromjson("1", integer.class);\nlong l1 = gson.fromjson("1", long.class);\nboolean b1 = gson.fromjson("false", boolean.class);\nstring str = gson.fromjson("\\"abc\\"", string.class);\nstring[] anotherstr = gson.fromjson("[\\"abc\\"]", string[].class);\n\n\n# gsonbuilder\n\ngson 实例可以通过 gsonbuilder 来定制实例化，以控制其序列化、反序列化行为。\n\ngson gson = new gsonbuilder()\n  .setprettyprinting()\n  .setdateformat("yyyy-mm-dd hh:mm:ss")\n  .excludefieldswithmodifiers(modifier.static, modifier.transient, modifier.volatile)\n  .create();\n\n\n\n# gson 注解\n\n# @since\n\n@since 用于控制对象的序列化版本。示例：\n\npublic class versionedclass {\n  @since(1.1) private final string newerfield;\n  @since(1.0) private final string newfield;\n  private final string field;\n\n  public versionedclass() {\n    this.newerfield = "newer";\n    this.newfield = "new";\n    this.field = "old";\n  }\n}\n\nversionedclass versionedobject = new versionedclass();\ngson gson = new gsonbuilder().setversion(1.0).create();\nstring jsonoutput = gson.tojson(versionedobject);\nsystem.out.println(jsonoutput);\nsystem.out.println();\n\ngson = new gson();\njsonoutput = gson.tojson(versionedobject);\nsystem.out.println(jsonoutput);\n\n\n# @serializedname\n\n@serializedname 用于将类成员按照指定名称序列化、反序列化。示例：\n\nprivate class someobject {\n  @serializedname("custom_naming") private final string somefield;\n  private final string someotherfield;\n\n  public someobject(string a, string b) {\n    this.somefield = a;\n    this.someotherfield = b;\n  }\n}\n\n\n\n# 示例源码\n\n> 示例源码：javalib-io-json\n\n\n# 参考资料\n\n * 官方\n   * fastjson github\n   * gson github\n   * jackson 官方文档\n   * jackson-databind\n * 文章\n   * http://www.json.org/json-zh.html\n   * json 的 rfc 文档\n   * json 最佳实践\n   * 【简明教程】json',charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Java 监控诊断",frontmatter:{title:"Java 监控诊断",date:"2020-02-11T17:48:32.000Z",categories:["Java","软件","监控诊断"],tags:["Java","监控","诊断"],permalink:"/pages/3d16d3/",hidden:!0,index:!1},regularPath:"/01.Java/11.%E8%BD%AF%E4%BB%B6/03.%E7%9B%91%E6%8E%A7%E8%AF%8A%E6%96%AD/",relativePath:"01.Java/11.软件/03.监控诊断/README.md",key:"v-1fa4716e",path:"/pages/3d16d3/",headers:[{level:2,title:"内容",slug:"内容",normalizedTitle:"内容",charIndex:16},{level:2,title:"资料",slug:"资料",normalizedTitle:"资料",charIndex:75}],headersStr:"内容 资料",content:"# Java 监控诊断\n\n\n# 内容\n\n * 监控工具对比\n * CAT\n * Zipkin\n * SkyWalking\n * Arthas\n\n\n# 资料\n\n * CAT Github\n * Zipkin Github\n * SkyWalking Github\n * PinPoint Github\n * Arthas Github",normalizedContent:"# java 监控诊断\n\n\n# 内容\n\n * 监控工具对比\n * cat\n * zipkin\n * skywalking\n * arthas\n\n\n# 资料\n\n * cat github\n * zipkin github\n * skywalking github\n * pinpoint github\n * arthas github",charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Java 二进制序列化",frontmatter:{title:"Java 二进制序列化",date:"2022-02-17T22:34:30.000Z",order:2,categories:["Java","工具","IO"],tags:["Java","IO","序列化","二进制"],permalink:"/pages/08d872/"},regularPath:"/01.Java/12.%E5%B7%A5%E5%85%B7/01.IO/02.%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%BA%8F%E5%88%97%E5%8C%96.html",relativePath:"01.Java/12.工具/01.IO/02.二进制序列化.md",key:"v-4e5dcd45",path:"/pages/08d872/",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:18},{level:3,title:"为什么需要二进制序列化库",slug:"为什么需要二进制序列化库",normalizedTitle:"为什么需要二进制序列化库",charIndex:25},{level:3,title:"主流序列化库简介",slug:"主流序列化库简介",normalizedTitle:"主流序列化库简介",charIndex:379},{level:4,title:"Protobuf",slug:"protobuf",normalizedTitle:"protobuf",charIndex:391},{level:4,title:"Thrift",slug:"thrift",normalizedTitle:"thrift",charIndex:805},{level:4,title:"Hessian",slug:"hessian",normalizedTitle:"hessian",charIndex:598},{level:4,title:"Kryo",slug:"kryo",normalizedTitle:"kryo",charIndex:1470},{level:4,title:"FST",slug:"fst",normalizedTitle:"fst",charIndex:1610},{level:4,title:"小结",slug:"小结",normalizedTitle:"小结",charIndex:1768},{level:2,title:"FST 应用",slug:"fst-应用",normalizedTitle:"fst 应用",charIndex:2146},{level:3,title:"引入依赖",slug:"引入依赖",normalizedTitle:"引入依赖",charIndex:2157},{level:3,title:"FST API",slug:"fst-api",normalizedTitle:"fst api",charIndex:2289},{level:2,title:"Kryo 应用",slug:"kryo-应用",normalizedTitle:"kryo 应用",charIndex:4178},{level:3,title:"引入依赖",slug:"引入依赖-2",normalizedTitle:"引入依赖",charIndex:2157},{level:3,title:"Kryo API",slug:"kryo-api",normalizedTitle:"kryo api",charIndex:4333},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:7980}],headersStr:"简介 为什么需要二进制序列化库 主流序列化库简介 Protobuf Thrift Hessian Kryo FST 小结 FST 应用 引入依赖 FST API Kryo 应用 引入依赖 Kryo API 参考资料",content:'# Java 二进制序列化\n\n\n# 简介\n\n\n# 为什么需要二进制序列化库\n\n原因很简单，就是 Java 默认的序列化机制（ObjectInputStream 和 ObjectOutputStream）具有很多缺点。\n\n> 不了解 Java 默认的序列化机制，可以参考：Java 序列化\n\nJava 自身的序列化方式具有以下缺点：\n\n * 无法跨语言使用。这点最为致命，对于很多需要跨语言通信的异构系统来说，不能跨语言序列化，即意味着完全无法通信（彼此数据不能识别，当然无法交互了）。\n * 序列化的性能不高。序列化后的数据体积较大，这大大影响存储和传输的效率。\n * 序列化一定需要实现 Serializable 接口。\n * 需要关注 serialVersionUID。\n\n引入二进制序列化库就是为了解决这些问题，这在 RPC 应用中尤为常见。\n\n\n# 主流序列化库简介\n\n# Protobuf\n\nProtobuf 是 Google 公司内部的混合语言数据标准，是一种轻便、高效的结构化数据存储 格式，可以用于结构化数据序列化，支持 Java、Python、C++、Go 等语言。Protobuf 使用的时候需要定义 IDL（Interface description language），然后使用不同语言的 IDL 编译器，生成序列化工具类。\n\n优点：\n\n * 序列化后体积相比 JSON、Hessian 小很多\n * 序列化反序列化速度很快，不需要通过反射获取类型\n * 语言和平台无关（基于 IDL），IDL 能清晰地描述语义，所以足以帮助并保证应用程序之间的类型不会丢失，无需类似 XML 解析器\n * 消息格式升级和兼容性不错，可以做到后向兼容\n * 支持 Java, C++, Python 三种语言\n\n缺点：\n\n * Protobuf 对于具有反射和动态能力的语言来说，用起来很费劲。\n\n# Thrift\n\n> Thrift 是 apache 开源项目，是一个点对点的 RPC 实现。\n\n它具有以下特性：\n\n * 支持多种语言（目前支持 28 种语言，如：C++、go、Java、Php、Python、Ruby 等等）。\n * 使用了组建大型数据交换及存储工具，对于大型系统中的内部数据传输，相对于 Json 和 xml 在性能上和传输大小上都有明显的优势。\n * 支持三种比较典型的编码方式（通用二进制编码，压缩二进制编码，优化的可选字段压缩编解码）。\n\n# Hessian\n\nHessian 是动态类型、二进制、紧凑的，并且可跨语言移植的一种序列化框架。Hessian 协 议要比 JDK、JSON 更加紧凑，性能上要比 JDK、JSON 序列化高效很多，而且生成的字节 数也更小。\n\nRPC 框架 Dubbo 就支持 Thrift 和 Hession。\n\n它具有以下特性：\n\n * 支持多种语言。如：Java、Python、C++、C#、PHP、Ruby 等。\n * 相对其他二进制序列化库较慢。\n\nHessian 本身也有问题，官方版本对 Java 里面一些常见对象的类型不支持：\n\n * Linked 系列，LinkedHashMap、LinkedHashSet 等，但是可以通过扩展 CollectionDeserializer 类修复；\n * Locale 类，可以通过扩展 ContextSerializerFactory 类修复；\n * Byte/Short 反序列化的时候变成 Integer。\n\n# Kryo\n\n> Kryo 是用于 Java 的快速高效的二进制对象图序列化框架。Kryo 还可以执行自动的深拷贝和浅拷贝。 这是从对象到对象的直接复制，而不是从对象到字节的复制。\n\n它具有以下特性：\n\n * 速度快，序列化体积小\n * 官方不支持 Java 以外的其他语言\n\n# FST\n\n> FST 是一个 Java 实现二进制序列化库。\n\n它具有以下特性：\n\n * 近乎于 100% 兼容 JDK 序列化，且比 JDK 原序列化方式快 10 倍\n * 2.17 开始与 Android 兼容\n * （可选）2.29 开始支持将任何可序列化的对象图编码/解码为 JSON（包括共享引用）\n\n# 小结\n\n了解了以上这些常见的二进制序列化库的特性。在技术选型时，我们就可以做到有的放矢。\n\n（1）选型参考依据\n\n对于二进制序列化库，我们的选型考量一般有以下几点：\n\n * 是否支持跨语言\n   * 根据业务实际需求来决定。一般来说，支持跨语言，为了兼容，使用复杂度上一般会更高一些。\n * 序列化、反序列化的性能\n * 类库是否轻量化，API 是否简单易懂\n\n（2）选型建议\n\n * 如果需要跨语言通信，那么可以考虑：Protobuf、Thrift、Hession。\n   \n   * thrift、protobuf - 适用于对性能敏感，对开发体验要求不高的内部系统。\n   * hessian - 适用于对开发体验敏感，性能有要求的内外部系统。\n\n * 如果不需要跨语言通信，可以考虑：Kryo 和 FST，性能不错，且 API 十分简单。\n\n\n# FST 应用\n\n\n# 引入依赖\n\n<dependency>\n <groupId>de.ruedigermoeller</groupId>\n <artifactId>fst</artifactId>\n <version>2.56</version>\n</dependency>\n\n\n\n# FST API\n\n示例：\n\nimport org.nustaq.serialization.FSTConfiguration;\n\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Base64;\n\npublic class FstDemo {\n\n private static FSTConfiguration DEFAULT_CONFIG = FSTConfiguration.createDefaultConfiguration();\n\n /**\n  * 将对象序列化为 byte 数组\n  *\n  * @param obj 任意对象\n  * @param <T> 对象的类型\n  * @return 序列化后的 byte 数组\n  */\n public static <T> byte[] writeToBytes(T obj) {\n  return DEFAULT_CONFIG.asByteArray(obj);\n }\n\n /**\n  * 将对象序列化为 byte 数组后，再使用 Base64 编码\n  *\n  * @param obj 任意对象\n  * @param <T> 对象的类型\n  * @return 序列化后的字符串\n  */\n public static <T> String writeToString(T obj) {\n  byte[] bytes = writeToBytes(obj);\n  return new String(Base64.getEncoder().encode(bytes), StandardCharsets.UTF_8);\n }\n\n /**\n  * 将 byte 数组反序列化为原对象\n  *\n  * @param bytes {@link #writeToBytes} 方法序列化后的 byte 数组\n  * @param clazz 原对象的类型\n  * @param <T>   原对象的类型\n  * @return 原对象\n  */\n public static <T> T readFromBytes(byte[] bytes, Class<T> clazz) throws IOException {\n  Object obj = DEFAULT_CONFIG.asObject(bytes);\n  if (clazz.isInstance(obj)) {\n   return (T) obj;\n  } else {\n   throw new IOException("derialize failed");\n  }\n }\n\n /**\n  * 将字符串反序列化为原对象，先使用 Base64 解码\n  *\n  * @param str   {@link #writeToString} 方法序列化后的字符串\n  * @param clazz 原对象的类型\n  * @param <T>   原对象的类型\n  * @return 原对象\n  */\n public static <T> T readFromString(String str, Class<T> clazz) throws IOException {\n  byte[] bytes = str.getBytes(StandardCharsets.UTF_8);\n  return readFromBytes(Base64.getDecoder().decode(bytes), clazz);\n }\n\n}\n\n\n测试：\n\nlong begin = System.currentTimeMillis();\nfor (int i = 0; i < BATCH_SIZE; i++) {\n    TestBean oldBean = BeanUtils.initJdk8Bean();\n    byte[] bytes = FstDemo.writeToBytes(oldBean);\n    TestBean newBean = FstDemo.readFromBytes(bytes, TestBean.class);\n}\nlong end = System.currentTimeMillis();\nSystem.out.printf("FST 序列化/反序列化耗时：%s", (end - begin));\n\n\n\n# Kryo 应用\n\n\n# 引入依赖\n\n<dependency>\n  <groupId>com.esotericsoftware</groupId>\n  <artifactId>kryo</artifactId>\n  <version>5.0.0-RC4</version>\n</dependency>\n\n\n\n# Kryo API\n\n示例：\n\nimport com.esotericsoftware.kryo.Kryo;\nimport com.esotericsoftware.kryo.io.Input;\nimport com.esotericsoftware.kryo.io.Output;\nimport com.esotericsoftware.kryo.util.DefaultInstantiatorStrategy;\nimport org.objenesis.strategy.StdInstantiatorStrategy;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Base64;\n\npublic class KryoDemo {\n\n // 每个线程的 Kryo 实例\n private static final ThreadLocal<Kryo> kryoLocal = ThreadLocal.withInitial(() -> {\n  Kryo kryo = new Kryo();\n\n  /**\n   * 不要轻易改变这里的配置！更改之后，序列化的格式就会发生变化，\n   * 上线的同时就必须清除 Redis 里的所有缓存，\n   * 否则那些缓存再回来反序列化的时候，就会报错\n   */\n  //支持对象循环引用（否则会栈溢出）\n  kryo.setReferences(true); //默认值就是 true，添加此行的目的是为了提醒维护者，不要改变这个配置\n\n  //不强制要求注册类（注册行为无法保证多个 JVM 内同一个类的注册编号相同；而且业务系统中大量的 Class 也难以一一注册）\n  kryo.setRegistrationRequired(false); //默认值就是 false，添加此行的目的是为了提醒维护者，不要改变这个配置\n\n  //Fix the NPE bug when deserializing Collections.\n  ((DefaultInstantiatorStrategy) kryo.getInstantiatorStrategy())\n   .setFallbackInstantiatorStrategy(new StdInstantiatorStrategy());\n\n  return kryo;\n });\n\n /**\n  * 获得当前线程的 Kryo 实例\n  *\n  * @return 当前线程的 Kryo 实例\n  */\n public static Kryo getInstance() {\n  return kryoLocal.get();\n }\n\n /**\n  * 将对象序列化为 byte 数组\n  *\n  * @param obj 任意对象\n  * @param <T> 对象的类型\n  * @return 序列化后的 byte 数组\n  */\n public static <T> byte[] writeToBytes(T obj) {\n  ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n  Output output = new Output(byteArrayOutputStream);\n\n  Kryo kryo = getInstance();\n  kryo.writeObject(output, obj);\n  output.flush();\n\n  return byteArrayOutputStream.toByteArray();\n }\n\n /**\n  * 将对象序列化为 byte 数组后，再使用 Base64 编码\n  *\n  * @param obj 任意对象\n  * @param <T> 对象的类型\n  * @return 序列化后的字符串\n  */\n public static <T> String writeToString(T obj) {\n  byte[] bytes = writeToBytes(obj);\n  return new String(Base64.getEncoder().encode(bytes), StandardCharsets.UTF_8);\n }\n\n /**\n  * 将 byte 数组反序列化为原对象\n  *\n  * @param bytes {@link #writeToBytes} 方法序列化后的 byte 数组\n  * @param clazz 原对象的类型\n  * @param <T>   原对象的类型\n  * @return 原对象\n  */\n @SuppressWarnings("unchecked")\n public static <T> T readFromBytes(byte[] bytes, Class<T> clazz) {\n  ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes);\n  Input input = new Input(byteArrayInputStream);\n\n  Kryo kryo = getInstance();\n  return (T) kryo.readObject(input, clazz);\n }\n\n /**\n  * 将字符串反序列化为原对象，先使用 Base64 解码\n  *\n  * @param str   {@link #writeToString} 方法序列化后的字符串\n  * @param clazz 原对象的类型\n  * @param <T>   原对象的类型\n  * @return 原对象\n  */\n public static <T> T readFromString(String str, Class<T> clazz) {\n  byte[] bytes = str.getBytes(StandardCharsets.UTF_8);\n  return readFromBytes(Base64.getDecoder().decode(bytes), clazz);\n }\n\n}\n\n\n测试：\n\nlong begin = System.currentTimeMillis();\nfor (int i = 0; i < BATCH_SIZE; i++) {\n    TestBean oldBean = BeanUtils.initJdk8Bean();\n    byte[] bytes = KryoDemo.writeToBytes(oldBean);\n    TestBean newBean = KryoDemo.readFromBytes(bytes, TestBean.class);\n}\nlong end = System.currentTimeMillis();\nSystem.out.printf("Kryo 序列化/反序列化耗时：%s", (end - begin));\n\n\nHessian 应用\n\nStudent student = new Student();\nstudent.setNo(101);\nstudent.setName("HESSIAN");\n//把student对象转化为byte数组\nByteArrayOutputStream bos = new ByteArrayOutputStream();\nHessian2Output output = new Hessian2Output(bos);\noutput.writeObject(student);\noutput.flushBuffer();\nbyte[] data = bos.toByteArray();\nbos.close();\n//把刚才序列化出来的byte数组转化为student对象\nByteArrayInputStream bis = new ByteArrayInputStream(data);\nHessian2Input input = new Hessian2Input(bis);\nStudent deStudent = (Student) input.readObject();\ninput.close();\nSystem.out.println(deStudent);\n\n\n\n# 参考资料\n\n * 官方\n   * Protobuf 官网\n   * Protobuf Github\n   * Thrift Github\n   * Kryo Github\n   * Hessian 官网\n   * FST Github\n * 文章\n   * java 序列化框架对比',normalizedContent:'# java 二进制序列化\n\n\n# 简介\n\n\n# 为什么需要二进制序列化库\n\n原因很简单，就是 java 默认的序列化机制（objectinputstream 和 objectoutputstream）具有很多缺点。\n\n> 不了解 java 默认的序列化机制，可以参考：java 序列化\n\njava 自身的序列化方式具有以下缺点：\n\n * 无法跨语言使用。这点最为致命，对于很多需要跨语言通信的异构系统来说，不能跨语言序列化，即意味着完全无法通信（彼此数据不能识别，当然无法交互了）。\n * 序列化的性能不高。序列化后的数据体积较大，这大大影响存储和传输的效率。\n * 序列化一定需要实现 serializable 接口。\n * 需要关注 serialversionuid。\n\n引入二进制序列化库就是为了解决这些问题，这在 rpc 应用中尤为常见。\n\n\n# 主流序列化库简介\n\n# protobuf\n\nprotobuf 是 google 公司内部的混合语言数据标准，是一种轻便、高效的结构化数据存储 格式，可以用于结构化数据序列化，支持 java、python、c++、go 等语言。protobuf 使用的时候需要定义 idl（interface description language），然后使用不同语言的 idl 编译器，生成序列化工具类。\n\n优点：\n\n * 序列化后体积相比 json、hessian 小很多\n * 序列化反序列化速度很快，不需要通过反射获取类型\n * 语言和平台无关（基于 idl），idl 能清晰地描述语义，所以足以帮助并保证应用程序之间的类型不会丢失，无需类似 xml 解析器\n * 消息格式升级和兼容性不错，可以做到后向兼容\n * 支持 java, c++, python 三种语言\n\n缺点：\n\n * protobuf 对于具有反射和动态能力的语言来说，用起来很费劲。\n\n# thrift\n\n> thrift 是 apache 开源项目，是一个点对点的 rpc 实现。\n\n它具有以下特性：\n\n * 支持多种语言（目前支持 28 种语言，如：c++、go、java、php、python、ruby 等等）。\n * 使用了组建大型数据交换及存储工具，对于大型系统中的内部数据传输，相对于 json 和 xml 在性能上和传输大小上都有明显的优势。\n * 支持三种比较典型的编码方式（通用二进制编码，压缩二进制编码，优化的可选字段压缩编解码）。\n\n# hessian\n\nhessian 是动态类型、二进制、紧凑的，并且可跨语言移植的一种序列化框架。hessian 协 议要比 jdk、json 更加紧凑，性能上要比 jdk、json 序列化高效很多，而且生成的字节 数也更小。\n\nrpc 框架 dubbo 就支持 thrift 和 hession。\n\n它具有以下特性：\n\n * 支持多种语言。如：java、python、c++、c#、php、ruby 等。\n * 相对其他二进制序列化库较慢。\n\nhessian 本身也有问题，官方版本对 java 里面一些常见对象的类型不支持：\n\n * linked 系列，linkedhashmap、linkedhashset 等，但是可以通过扩展 collectiondeserializer 类修复；\n * locale 类，可以通过扩展 contextserializerfactory 类修复；\n * byte/short 反序列化的时候变成 integer。\n\n# kryo\n\n> kryo 是用于 java 的快速高效的二进制对象图序列化框架。kryo 还可以执行自动的深拷贝和浅拷贝。 这是从对象到对象的直接复制，而不是从对象到字节的复制。\n\n它具有以下特性：\n\n * 速度快，序列化体积小\n * 官方不支持 java 以外的其他语言\n\n# fst\n\n> fst 是一个 java 实现二进制序列化库。\n\n它具有以下特性：\n\n * 近乎于 100% 兼容 jdk 序列化，且比 jdk 原序列化方式快 10 倍\n * 2.17 开始与 android 兼容\n * （可选）2.29 开始支持将任何可序列化的对象图编码/解码为 json（包括共享引用）\n\n# 小结\n\n了解了以上这些常见的二进制序列化库的特性。在技术选型时，我们就可以做到有的放矢。\n\n（1）选型参考依据\n\n对于二进制序列化库，我们的选型考量一般有以下几点：\n\n * 是否支持跨语言\n   * 根据业务实际需求来决定。一般来说，支持跨语言，为了兼容，使用复杂度上一般会更高一些。\n * 序列化、反序列化的性能\n * 类库是否轻量化，api 是否简单易懂\n\n（2）选型建议\n\n * 如果需要跨语言通信，那么可以考虑：protobuf、thrift、hession。\n   \n   * thrift、protobuf - 适用于对性能敏感，对开发体验要求不高的内部系统。\n   * hessian - 适用于对开发体验敏感，性能有要求的内外部系统。\n\n * 如果不需要跨语言通信，可以考虑：kryo 和 fst，性能不错，且 api 十分简单。\n\n\n# fst 应用\n\n\n# 引入依赖\n\n<dependency>\n <groupid>de.ruedigermoeller</groupid>\n <artifactid>fst</artifactid>\n <version>2.56</version>\n</dependency>\n\n\n\n# fst api\n\n示例：\n\nimport org.nustaq.serialization.fstconfiguration;\n\nimport java.io.ioexception;\nimport java.nio.charset.standardcharsets;\nimport java.util.base64;\n\npublic class fstdemo {\n\n private static fstconfiguration default_config = fstconfiguration.createdefaultconfiguration();\n\n /**\n  * 将对象序列化为 byte 数组\n  *\n  * @param obj 任意对象\n  * @param <t> 对象的类型\n  * @return 序列化后的 byte 数组\n  */\n public static <t> byte[] writetobytes(t obj) {\n  return default_config.asbytearray(obj);\n }\n\n /**\n  * 将对象序列化为 byte 数组后，再使用 base64 编码\n  *\n  * @param obj 任意对象\n  * @param <t> 对象的类型\n  * @return 序列化后的字符串\n  */\n public static <t> string writetostring(t obj) {\n  byte[] bytes = writetobytes(obj);\n  return new string(base64.getencoder().encode(bytes), standardcharsets.utf_8);\n }\n\n /**\n  * 将 byte 数组反序列化为原对象\n  *\n  * @param bytes {@link #writetobytes} 方法序列化后的 byte 数组\n  * @param clazz 原对象的类型\n  * @param <t>   原对象的类型\n  * @return 原对象\n  */\n public static <t> t readfrombytes(byte[] bytes, class<t> clazz) throws ioexception {\n  object obj = default_config.asobject(bytes);\n  if (clazz.isinstance(obj)) {\n   return (t) obj;\n  } else {\n   throw new ioexception("derialize failed");\n  }\n }\n\n /**\n  * 将字符串反序列化为原对象，先使用 base64 解码\n  *\n  * @param str   {@link #writetostring} 方法序列化后的字符串\n  * @param clazz 原对象的类型\n  * @param <t>   原对象的类型\n  * @return 原对象\n  */\n public static <t> t readfromstring(string str, class<t> clazz) throws ioexception {\n  byte[] bytes = str.getbytes(standardcharsets.utf_8);\n  return readfrombytes(base64.getdecoder().decode(bytes), clazz);\n }\n\n}\n\n\n测试：\n\nlong begin = system.currenttimemillis();\nfor (int i = 0; i < batch_size; i++) {\n    testbean oldbean = beanutils.initjdk8bean();\n    byte[] bytes = fstdemo.writetobytes(oldbean);\n    testbean newbean = fstdemo.readfrombytes(bytes, testbean.class);\n}\nlong end = system.currenttimemillis();\nsystem.out.printf("fst 序列化/反序列化耗时：%s", (end - begin));\n\n\n\n# kryo 应用\n\n\n# 引入依赖\n\n<dependency>\n  <groupid>com.esotericsoftware</groupid>\n  <artifactid>kryo</artifactid>\n  <version>5.0.0-rc4</version>\n</dependency>\n\n\n\n# kryo api\n\n示例：\n\nimport com.esotericsoftware.kryo.kryo;\nimport com.esotericsoftware.kryo.io.input;\nimport com.esotericsoftware.kryo.io.output;\nimport com.esotericsoftware.kryo.util.defaultinstantiatorstrategy;\nimport org.objenesis.strategy.stdinstantiatorstrategy;\n\nimport java.io.bytearrayinputstream;\nimport java.io.bytearrayoutputstream;\nimport java.nio.charset.standardcharsets;\nimport java.util.base64;\n\npublic class kryodemo {\n\n // 每个线程的 kryo 实例\n private static final threadlocal<kryo> kryolocal = threadlocal.withinitial(() -> {\n  kryo kryo = new kryo();\n\n  /**\n   * 不要轻易改变这里的配置！更改之后，序列化的格式就会发生变化，\n   * 上线的同时就必须清除 redis 里的所有缓存，\n   * 否则那些缓存再回来反序列化的时候，就会报错\n   */\n  //支持对象循环引用（否则会栈溢出）\n  kryo.setreferences(true); //默认值就是 true，添加此行的目的是为了提醒维护者，不要改变这个配置\n\n  //不强制要求注册类（注册行为无法保证多个 jvm 内同一个类的注册编号相同；而且业务系统中大量的 class 也难以一一注册）\n  kryo.setregistrationrequired(false); //默认值就是 false，添加此行的目的是为了提醒维护者，不要改变这个配置\n\n  //fix the npe bug when deserializing collections.\n  ((defaultinstantiatorstrategy) kryo.getinstantiatorstrategy())\n   .setfallbackinstantiatorstrategy(new stdinstantiatorstrategy());\n\n  return kryo;\n });\n\n /**\n  * 获得当前线程的 kryo 实例\n  *\n  * @return 当前线程的 kryo 实例\n  */\n public static kryo getinstance() {\n  return kryolocal.get();\n }\n\n /**\n  * 将对象序列化为 byte 数组\n  *\n  * @param obj 任意对象\n  * @param <t> 对象的类型\n  * @return 序列化后的 byte 数组\n  */\n public static <t> byte[] writetobytes(t obj) {\n  bytearrayoutputstream bytearrayoutputstream = new bytearrayoutputstream();\n  output output = new output(bytearrayoutputstream);\n\n  kryo kryo = getinstance();\n  kryo.writeobject(output, obj);\n  output.flush();\n\n  return bytearrayoutputstream.tobytearray();\n }\n\n /**\n  * 将对象序列化为 byte 数组后，再使用 base64 编码\n  *\n  * @param obj 任意对象\n  * @param <t> 对象的类型\n  * @return 序列化后的字符串\n  */\n public static <t> string writetostring(t obj) {\n  byte[] bytes = writetobytes(obj);\n  return new string(base64.getencoder().encode(bytes), standardcharsets.utf_8);\n }\n\n /**\n  * 将 byte 数组反序列化为原对象\n  *\n  * @param bytes {@link #writetobytes} 方法序列化后的 byte 数组\n  * @param clazz 原对象的类型\n  * @param <t>   原对象的类型\n  * @return 原对象\n  */\n @suppresswarnings("unchecked")\n public static <t> t readfrombytes(byte[] bytes, class<t> clazz) {\n  bytearrayinputstream bytearrayinputstream = new bytearrayinputstream(bytes);\n  input input = new input(bytearrayinputstream);\n\n  kryo kryo = getinstance();\n  return (t) kryo.readobject(input, clazz);\n }\n\n /**\n  * 将字符串反序列化为原对象，先使用 base64 解码\n  *\n  * @param str   {@link #writetostring} 方法序列化后的字符串\n  * @param clazz 原对象的类型\n  * @param <t>   原对象的类型\n  * @return 原对象\n  */\n public static <t> t readfromstring(string str, class<t> clazz) {\n  byte[] bytes = str.getbytes(standardcharsets.utf_8);\n  return readfrombytes(base64.getdecoder().decode(bytes), clazz);\n }\n\n}\n\n\n测试：\n\nlong begin = system.currenttimemillis();\nfor (int i = 0; i < batch_size; i++) {\n    testbean oldbean = beanutils.initjdk8bean();\n    byte[] bytes = kryodemo.writetobytes(oldbean);\n    testbean newbean = kryodemo.readfrombytes(bytes, testbean.class);\n}\nlong end = system.currenttimemillis();\nsystem.out.printf("kryo 序列化/反序列化耗时：%s", (end - begin));\n\n\nhessian 应用\n\nstudent student = new student();\nstudent.setno(101);\nstudent.setname("hessian");\n//把student对象转化为byte数组\nbytearrayoutputstream bos = new bytearrayoutputstream();\nhessian2output output = new hessian2output(bos);\noutput.writeobject(student);\noutput.flushbuffer();\nbyte[] data = bos.tobytearray();\nbos.close();\n//把刚才序列化出来的byte数组转化为student对象\nbytearrayinputstream bis = new bytearrayinputstream(data);\nhessian2input input = new hessian2input(bis);\nstudent destudent = (student) input.readobject();\ninput.close();\nsystem.out.println(destudent);\n\n\n\n# 参考资料\n\n * 官方\n   * protobuf 官网\n   * protobuf github\n   * thrift github\n   * kryo github\n   * hessian 官网\n   * fst github\n * 文章\n   * java 序列化框架对比',charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Java 序列化工具",frontmatter:{title:"Java 序列化工具",date:"2022-02-17T22:34:30.000Z",categories:["Java","工具","IO"],tags:["Java","IO","序列化"],permalink:"/pages/08b504/",hidden:!0,index:!1},regularPath:"/01.Java/12.%E5%B7%A5%E5%85%B7/01.IO/",relativePath:"01.Java/12.工具/01.IO/README.md",key:"v-1fa328ca",path:"/pages/08b504/",headers:[{level:2,title:"内容",slug:"内容",normalizedTitle:"内容",charIndex:273},{level:2,title:"资料",slug:"资料",normalizedTitle:"资料",charIndex:355}],headersStr:"内容 资料",content:"# Java 序列化工具\n\nJava 官方的序列化存在许多问题，因此，很多人更愿意使用优秀的第三方序列化工具来替代 Java 自身的序列化机制。 如果想详细了解 Java 自身序列化方式，可以参考：Java 序列化\n\n序列化库技术选型：\n\n * thrift、protobuf - 适用于对性能敏感，对开发体验要求不高的内部系统。\n * hessian - 适用于对开发体验敏感，性能有要求的内外部系统。\n * jackson、gson、fastjson - 适用于对序列化后的数据要求有良好的可读性（转为 json 、xml 形式）。\n\n\n# 内容\n\n * JSON - Fastjson、Jackson、Gson\n * 二进制 - Protobuf、Thrift、Hessian、Kryo、FST\n\n\n# 资料\n\n * Thrift Github\n * Protobuf Github\n * Hessian 官网\n * Fastjson Github\n * Jackson Github\n * Gson Github",normalizedContent:"# java 序列化工具\n\njava 官方的序列化存在许多问题，因此，很多人更愿意使用优秀的第三方序列化工具来替代 java 自身的序列化机制。 如果想详细了解 java 自身序列化方式，可以参考：java 序列化\n\n序列化库技术选型：\n\n * thrift、protobuf - 适用于对性能敏感，对开发体验要求不高的内部系统。\n * hessian - 适用于对开发体验敏感，性能有要求的内外部系统。\n * jackson、gson、fastjson - 适用于对序列化后的数据要求有良好的可读性（转为 json 、xml 形式）。\n\n\n# 内容\n\n * json - fastjson、jackson、gson\n * 二进制 - protobuf、thrift、hessian、kryo、fst\n\n\n# 资料\n\n * thrift github\n * protobuf github\n * hessian 官网\n * fastjson github\n * jackson github\n * gson github",charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Lombok 快速入门",frontmatter:{title:"Lombok 快速入门",date:"2022-02-17T22:34:30.000Z",order:1,categories:["Java","工具","JavaBean"],tags:["Java","JavaBean","Lombok"],permalink:"/pages/eb1d46/"},regularPath:"/01.Java/12.%E5%B7%A5%E5%85%B7/02.JavaBean/01.Lombok.html",relativePath:"01.Java/12.工具/02.JavaBean/01.Lombok.md",key:"v-6cd70b6c",path:"/pages/eb1d46/",headers:[{level:2,title:"Lombok 简介",slug:"lombok-简介",normalizedTitle:"lombok 简介",charIndex:18},{level:2,title:"Lombok 安装",slug:"lombok-安装",normalizedTitle:"lombok 安装",charIndex:222},{level:2,title:"Lombok 使用",slug:"lombok-使用",normalizedTitle:"lombok 使用",charIndex:789},{level:3,title:"@Getter and @Setter",slug:"getter-and-setter",normalizedTitle:"@getter and @setter",charIndex:829},{level:3,title:"@NonNull",slug:"nonnull",normalizedTitle:"@nonnull",charIndex:1264},{level:3,title:"@ToString",slug:"tostring",normalizedTitle:"@tostring",charIndex:1810},{level:3,title:"@EqualsAndHashCode",slug:"equalsandhashcode",normalizedTitle:"@equalsandhashcode",charIndex:2434},{level:3,title:"@Data",slug:"data",normalizedTitle:"@data",charIndex:4312},{level:3,title:"@Cleanup",slug:"cleanup",normalizedTitle:"@cleanup",charIndex:6361},{level:3,title:"@Synchronized",slug:"synchronized",normalizedTitle:"@synchronized",charIndex:7025},{level:3,title:"@SneakyThrows",slug:"sneakythrows",normalizedTitle:"@sneakythrows",charIndex:7492},{level:3,title:"示例源码",slug:"示例源码",normalizedTitle:"示例源码",charIndex:7824},{level:2,title:"Lombok 使用注意点",slug:"lombok-使用注意点",normalizedTitle:"lombok 使用注意点",charIndex:7854},{level:3,title:"谨慎使用 @Builder",slug:"谨慎使用-builder",normalizedTitle:"谨慎使用 @builder",charIndex:7871},{level:3,title:"@Data 注解和继承",slug:"data-注解和继承",normalizedTitle:"@data 注解和继承",charIndex:10399},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:12933}],headersStr:"Lombok 简介 Lombok 安装 Lombok 使用 @Getter and @Setter @NonNull @ToString @EqualsAndHashCode @Data @Cleanup @Synchronized @SneakyThrows 示例源码 Lombok 使用注意点 谨慎使用 @Builder @Data 注解和继承 参考资料",content:'# Lombok 快速入门\n\n\n# Lombok 简介\n\nLombok 是一种 Java 实用工具，可用来帮助开发人员消除 Java 的冗长，尤其是对于简单的 Java 对象（POJO）。它通过注释实现这一目的。通过在开发环境中实现 Lombok，开发人员可以节省构建诸如 hashCode() 和 equals() 、getter / setter 这样的方法以及以往用来分类各种 accessor 和 mutator 的大量时间。\n\n\n# Lombok 安装\n\n由于 Lombok 仅在编译阶段生成代码，所以使用 Lombok 注解的源代码，在 IDE 中会被高亮显示错误，针对这个问题可以通过安装 IDE 对应的插件来解决。具体的安装方式可以参考：Setting up Lombok with Eclipse and Intellij\n\n使 IntelliJ IDEA 支持 Lombok 方式如下：\n\n * Intellij 设置支持注解处理\n   * 点击 File > Settings > Build > Annotation Processors\n   * 勾选 Enable annotation processing\n * 安装插件\n   * 点击 Settings > Plugins > Browse repositories\n   * 查找 Lombok Plugin 并进行安装\n   * 重启 IntelliJ IDEA\n * 将 lombok 添加到 pom 文件\n\n<dependency>\n    <groupId>org.projectlombok</groupId>\n    <artifactId>lombok</artifactId>\n    <version>1.16.8</version>\n</dependency>\n\n\n\n# Lombok 使用\n\nLombok 提供注解 API 来修饰指定的类：\n\n\n# @Getter and @Setter\n\n@Getter and @Setter Lombok 代码：\n\n@Getter @Setter private boolean employed = true;\n@Setter(AccessLevel.PROTECTED) private String name;\n\n\n等价于 Java 源码：\n\nprivate boolean employed = true;\nprivate String name;\n\npublic boolean isEmployed() {\n    return employed;\n}\n\npublic void setEmployed(final boolean employed) {\n    this.employed = employed;\n}\n\nprotected void setName(final String name) {\n    this.name = name;\n}\n\n\n\n# @NonNull\n\n@NonNull Lombok 代码：\n\n@Getter @Setter @NonNull\nprivate List<Person> members;\n\n\n等价于 Java 源码：\n\n@NonNull\nprivate List<Person> members;\n\npublic Family(@NonNull final List<Person> members) {\n    if (members == null) throw new java.lang.NullPointerException("members");\n    this.members = members;\n}\n\n@NonNull\npublic List<Person> getMembers() {\n    return members;\n}\n\npublic void setMembers(@NonNull final List<Person> members) {\n    if (members == null) throw new java.lang.NullPointerException("members");\n    this.members = members;\n}\n\n\n\n# @ToString\n\n@ToString Lombok 代码：\n\n@ToString(callSuper=true,exclude="someExcludedField")\npublic class Foo extends Bar {\n    private boolean someBoolean = true;\n    private String someStringField;\n    private float someExcludedField;\n}\n\n\n等价于 Java 源码：\n\npublic class Foo extends Bar {\n    private boolean someBoolean = true;\n    private String someStringField;\n    private float someExcludedField;\n\n    @java.lang.Override\n    public java.lang.String toString() {\n        return "Foo(super=" + super.toString() +\n            ", someBoolean=" + someBoolean +\n            ", someStringField=" + someStringField + ")";\n    }\n}\n\n\n\n# @EqualsAndHashCode\n\n@EqualsAndHashCode Lombok 代码：\n\n@EqualsAndHashCode(callSuper=true,exclude={"address","city","state","zip"})\npublic class Person extends SentientBeing {\n    enum Gender { Male, Female }\n\n    @NonNull private String name;\n    @NonNull private Gender gender;\n\n    private String ssn;\n    private String address;\n    private String city;\n    private String state;\n    private String zip;\n}\n\n\n等价于 Java 源码：\n\npublic class Person extends SentientBeing {\n\n    enum Gender {\n        /*public static final*/ Male /* = new Gender() */,\n        /*public static final*/ Female /* = new Gender() */;\n    }\n    @NonNull\n    private String name;\n    @NonNull\n    private Gender gender;\n    private String ssn;\n    private String address;\n    private String city;\n    private String state;\n    private String zip;\n\n    @java.lang.Override\n    public boolean equals(final java.lang.Object o) {\n        if (o == this) return true;\n        if (o == null) return false;\n        if (o.getClass() != this.getClass()) return false;\n        if (!super.equals(o)) return false;\n        final Person other = (Person)o;\n        if (this.name == null ? other.name != null : !this.name.equals(other.name)) return false;\n        if (this.gender == null ? other.gender != null : !this.gender.equals(other.gender)) return false;\n        if (this.ssn == null ? other.ssn != null : !this.ssn.equals(other.ssn)) return false;\n        return true;\n    }\n\n    @java.lang.Override\n    public int hashCode() {\n        final int PRIME = 31;\n        int result = 1;\n        result = result * PRIME + super.hashCode();\n        result = result * PRIME + (this.name == null ? 0 : this.name.hashCode());\n        result = result * PRIME + (this.gender == null ? 0 : this.gender.hashCode());\n        result = result * PRIME + (this.ssn == null ? 0 : this.ssn.hashCode());\n        return result;\n    }\n}\n\n\n\n# @Data\n\n@Data Lombok 代码：\n\n@Data(staticConstructor="of")\npublic class Company {\n    private final Person founder;\n    private String name;\n    private List<Person> employees;\n}\n\n\n等价于 Java 源码：\n\npublic class Company {\n    private final Person founder;\n    private String name;\n    private List<Person> employees;\n\n    private Company(final Person founder) {\n        this.founder = founder;\n    }\n\n    public static Company of(final Person founder) {\n        return new Company(founder);\n    }\n\n    public Person getFounder() {\n        return founder;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(final String name) {\n        this.name = name;\n    }\n\n    public List<Person> getEmployees() {\n        return employees;\n    }\n\n    public void setEmployees(final List<Person> employees) {\n        this.employees = employees;\n    }\n\n    @java.lang.Override\n    public boolean equals(final java.lang.Object o) {\n        if (o == this) return true;\n        if (o == null) return false;\n        if (o.getClass() != this.getClass()) return false;\n        final Company other = (Company)o;\n        if (this.founder == null ? other.founder != null : !this.founder.equals(other.founder)) return false;\n        if (this.name == null ? other.name != null : !this.name.equals(other.name)) return false;\n        if (this.employees == null ? other.employees != null : !this.employees.equals(other.employees)) return false;\n        return true;\n    }\n\n    @java.lang.Override\n    public int hashCode() {\n        final int PRIME = 31;\n        int result = 1;\n        result = result * PRIME + (this.founder == null ? 0 : this.founder.hashCode());\n        result = result * PRIME + (this.name == null ? 0 : this.name.hashCode());\n        result = result * PRIME + (this.employees == null ? 0 : this.employees.hashCode());\n        return result;\n    }\n\n    @java.lang.Override\n    public java.lang.String toString() {\n        return "Company(founder=" + founder + ", name=" + name + ", employees=" + employees + ")";\n    }\n}\n\n\n\n# @Cleanup\n\n@Cleanup Lombok 代码：\n\npublic void testCleanUp() {\n    try {\n        @Cleanup ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        baos.write(new byte[] {\'Y\',\'e\',\'s\'});\n        System.out.println(baos.toString());\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}\n\n\n等价于 Java 源码：\n\npublic void testCleanUp() {\n    try {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        try {\n            baos.write(new byte[]{\'Y\', \'e\', \'s\'});\n            System.out.println(baos.toString());\n        } finally {\n            baos.close();\n        }\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}\n\n\n\n# @Synchronized\n\n@Synchronized Lombok 代码：\n\nprivate DateFormat format = new SimpleDateFormat("MM-dd-YYYY");\n\n@Synchronized\npublic String synchronizedFormat(Date date) {\n    return format.format(date);\n}\n\n\n等价于 Java 源码：\n\nprivate final java.lang.Object $lock = new java.lang.Object[0];\nprivate DateFormat format = new SimpleDateFormat("MM-dd-YYYY");\n\npublic String synchronizedFormat(Date date) {\n    synchronized ($lock) {\n        return format.format(date);\n    }\n}\n\n\n\n# @SneakyThrows\n\n@SneakyThrows Lombok 代码：\n\n@SneakyThrows\npublic void testSneakyThrows() {\n    throw new IllegalAccessException();\n}\n\n\n等价于 Java 源码：\n\npublic void testSneakyThrows() {\n    try {\n        throw new IllegalAccessException();\n    } catch (java.lang.Throwable $ex) {\n        throw lombok.Lombok.sneakyThrow($ex);\n    }\n}\n\n\n\n# 示例源码\n\n> 示例源码：javalib-bean\n\n\n# Lombok 使用注意点\n\n\n# 谨慎使用 @Builder\n\n在类上标注了 @Data 和 @Builder 注解的时候，编译时，lombok 优化后的 Class 中会没有默认的构造方法。在反序列化的时候，没有默认构造方法就可能会报错。\n\n【示例】使用 @Builder 不当导致 json 反序列化失败\n\n@Data\n@Builder\npublic class BuilderDemo01 {\n\n    private String name;\n\n    public static void main(String[] args) throws JsonProcessingException {\n        BuilderDemo01 demo01 = BuilderDemo01.builder().name("demo01").build();\n        ObjectMapper mapper = new ObjectMapper();\n        String json = mapper.writeValueAsString(demo01);\n        BuilderDemo01 expectDemo01 = mapper.readValue(json, BuilderDemo01.class);\n        System.out.println(expectDemo01.toString());\n    }\n\n}\n\n\n运行时会抛出异常：\n\nException in thread "main" com.fasterxml.jackson.databind.exc.MismatchedInputException: Cannot construct instance of `io.github.dunwu.javatech.bean.lombok.BuilderDemo01` (although at least one Creator exists): cannot deserialize from Object value (no delegate- or property-based Creator)\n at [Source: (String)"{"name":"demo01"}"; line: 1, column: 2]\n\tat com.fasterxml.jackson.databind.exc.MismatchedInputException.from(MismatchedInputException.java:63)\n\tat com.fasterxml.jackson.databind.DeserializationContext.reportInputMismatch(DeserializationContext.java:1432)\n\tat com.fasterxml.jackson.databind.DeserializationContext.handleMissingInstantiator(DeserializationContext.java:1062)\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializerBase.deserializeFromObjectUsingNonDefault(BeanDeserializerBase.java:1297)\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializer.deserializeFromObject(BeanDeserializer.java:326)\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:159)\n\tat com.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:4218)\n\tat com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:3214)\n\tat com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:3182)\n\tat io.github.dunwu.javatech.bean.lombok.BuilderDemo01.main(BuilderDemo01.java:22)\n\n\n【示例】使用 @Builder 正确方法\n\n@Data\n@Builder\n@NoArgsConstructor\n@AllArgsConstructor\npublic class BuilderDemo02 {\n\n    private String name;\n\n    public static void main(String[] args) throws JsonProcessingException {\n        BuilderDemo02 demo02 = BuilderDemo02.builder().name("demo01").build();\n        ObjectMapper mapper = new ObjectMapper();\n        String json = mapper.writeValueAsString(demo02);\n        BuilderDemo02 expectDemo02 = mapper.readValue(json, BuilderDemo02.class);\n        System.out.println(expectDemo02.toString());\n    }\n\n}\n\n\n\n# @Data 注解和继承\n\n使用 @Data 注解时，则有了 @EqualsAndHashCode 注解，那么就会在此类中存在 equals(Object other) 和 hashCode() 方法，且不会使用父类的属性，这就导致了可能的问题。比如，有多个类有相同的部分属性，把它们定义到父类中，恰好 id（数据库主键）也在父类中，那么就会存在部分对象在比较时，它们并不相等，这是因为：lombok 自动生成的 equals(Object other) 和 hashCode() 方法判定为相等，从而导致和预期不符。\n\n修复此问题的方法很简单：\n\n * 使用 @Data 时，加上 @EqualsAndHashCode(callSuper=true) 注解。\n * 使用 @Getter @Setter @ToString 代替 @Data 并且自定义 equals(Object other) 和 hashCode() 方法。\n\n【示例】测试 @Data 和 @EqualsAndHashCode\n\n@Data\n@ToString(exclude = "age")\n@EqualsAndHashCode(exclude = { "age", "sex" })\npublic class Person {\n\n    protected String name;\n\n    protected Integer age;\n\n    protected String sex;\n\n}\n\n@Data\n@EqualsAndHashCode(callSuper = true, exclude = { "address", "city", "state", "zip" })\npublic class EqualsAndHashCodeDemo extends Person {\n\n    @NonNull\n    private String name;\n\n    @NonNull\n    private Gender gender;\n\n    private String ssn;\n\n    private String address;\n\n    private String city;\n\n    private String state;\n\n    private String zip;\n\n    public EqualsAndHashCodeDemo(@NonNull String name, @NonNull Gender gender) {\n        this.name = name;\n        this.gender = gender;\n    }\n\n    public EqualsAndHashCodeDemo(@NonNull String name, @NonNull Gender gender,\n        String ssn, String address, String city, String state, String zip) {\n        this.name = name;\n        this.gender = gender;\n        this.ssn = ssn;\n        this.address = address;\n        this.city = city;\n        this.state = state;\n        this.zip = zip;\n    }\n\n    public enum Gender {\n        Male,\n        Female\n    }\n\n}\n\n@Test\n@DisplayName("测试 @EqualsAndHashCode")\npublic void testEqualsAndHashCodeDemo() {\n    EqualsAndHashCodeDemo demo1 =\n        new EqualsAndHashCodeDemo("name1", EqualsAndHashCodeDemo.Gender.Female, "ssn", "xxx", "xxx", "xxx", "xxx");\n    EqualsAndHashCodeDemo demo2 =\n        new EqualsAndHashCodeDemo("name1", EqualsAndHashCodeDemo.Gender.Female, "ssn", "ooo", "ooo", "ooo", "ooo");\n    Assertions.assertEquals(demo1, demo2);\n\n    Person person = new Person();\n    person.setName("张三");\n    person.setAge(20);\n    person.setSex("男");\n\n    Person person2 = new Person();\n    person2.setName("张三");\n    person2.setAge(18);\n    person2.setSex("男");\n\n    Person person3 = new Person();\n    person3.setName("李四");\n    person3.setAge(20);\n    person3.setSex("男");\n\n    Assertions.assertEquals(person2, person);\n    Assertions.assertNotEquals(person3, person);\n}\n\n\n上面的单元测试可以通过，但如果将 @EqualsAndHashCode(callSuper = true, exclude = { "address", "city", "state", "zip" }) 注掉就会报错。\n\n\n# 参考资料\n\n * Lombok 官网\n * Lombok Github\n * IntelliJ IDEA - Lombok Plugin',normalizedContent:'# lombok 快速入门\n\n\n# lombok 简介\n\nlombok 是一种 java 实用工具，可用来帮助开发人员消除 java 的冗长，尤其是对于简单的 java 对象（pojo）。它通过注释实现这一目的。通过在开发环境中实现 lombok，开发人员可以节省构建诸如 hashcode() 和 equals() 、getter / setter 这样的方法以及以往用来分类各种 accessor 和 mutator 的大量时间。\n\n\n# lombok 安装\n\n由于 lombok 仅在编译阶段生成代码，所以使用 lombok 注解的源代码，在 ide 中会被高亮显示错误，针对这个问题可以通过安装 ide 对应的插件来解决。具体的安装方式可以参考：setting up lombok with eclipse and intellij\n\n使 intellij idea 支持 lombok 方式如下：\n\n * intellij 设置支持注解处理\n   * 点击 file > settings > build > annotation processors\n   * 勾选 enable annotation processing\n * 安装插件\n   * 点击 settings > plugins > browse repositories\n   * 查找 lombok plugin 并进行安装\n   * 重启 intellij idea\n * 将 lombok 添加到 pom 文件\n\n<dependency>\n    <groupid>org.projectlombok</groupid>\n    <artifactid>lombok</artifactid>\n    <version>1.16.8</version>\n</dependency>\n\n\n\n# lombok 使用\n\nlombok 提供注解 api 来修饰指定的类：\n\n\n# @getter and @setter\n\n@getter and @setter lombok 代码：\n\n@getter @setter private boolean employed = true;\n@setter(accesslevel.protected) private string name;\n\n\n等价于 java 源码：\n\nprivate boolean employed = true;\nprivate string name;\n\npublic boolean isemployed() {\n    return employed;\n}\n\npublic void setemployed(final boolean employed) {\n    this.employed = employed;\n}\n\nprotected void setname(final string name) {\n    this.name = name;\n}\n\n\n\n# @nonnull\n\n@nonnull lombok 代码：\n\n@getter @setter @nonnull\nprivate list<person> members;\n\n\n等价于 java 源码：\n\n@nonnull\nprivate list<person> members;\n\npublic family(@nonnull final list<person> members) {\n    if (members == null) throw new java.lang.nullpointerexception("members");\n    this.members = members;\n}\n\n@nonnull\npublic list<person> getmembers() {\n    return members;\n}\n\npublic void setmembers(@nonnull final list<person> members) {\n    if (members == null) throw new java.lang.nullpointerexception("members");\n    this.members = members;\n}\n\n\n\n# @tostring\n\n@tostring lombok 代码：\n\n@tostring(callsuper=true,exclude="someexcludedfield")\npublic class foo extends bar {\n    private boolean someboolean = true;\n    private string somestringfield;\n    private float someexcludedfield;\n}\n\n\n等价于 java 源码：\n\npublic class foo extends bar {\n    private boolean someboolean = true;\n    private string somestringfield;\n    private float someexcludedfield;\n\n    @java.lang.override\n    public java.lang.string tostring() {\n        return "foo(super=" + super.tostring() +\n            ", someboolean=" + someboolean +\n            ", somestringfield=" + somestringfield + ")";\n    }\n}\n\n\n\n# @equalsandhashcode\n\n@equalsandhashcode lombok 代码：\n\n@equalsandhashcode(callsuper=true,exclude={"address","city","state","zip"})\npublic class person extends sentientbeing {\n    enum gender { male, female }\n\n    @nonnull private string name;\n    @nonnull private gender gender;\n\n    private string ssn;\n    private string address;\n    private string city;\n    private string state;\n    private string zip;\n}\n\n\n等价于 java 源码：\n\npublic class person extends sentientbeing {\n\n    enum gender {\n        /*public static final*/ male /* = new gender() */,\n        /*public static final*/ female /* = new gender() */;\n    }\n    @nonnull\n    private string name;\n    @nonnull\n    private gender gender;\n    private string ssn;\n    private string address;\n    private string city;\n    private string state;\n    private string zip;\n\n    @java.lang.override\n    public boolean equals(final java.lang.object o) {\n        if (o == this) return true;\n        if (o == null) return false;\n        if (o.getclass() != this.getclass()) return false;\n        if (!super.equals(o)) return false;\n        final person other = (person)o;\n        if (this.name == null ? other.name != null : !this.name.equals(other.name)) return false;\n        if (this.gender == null ? other.gender != null : !this.gender.equals(other.gender)) return false;\n        if (this.ssn == null ? other.ssn != null : !this.ssn.equals(other.ssn)) return false;\n        return true;\n    }\n\n    @java.lang.override\n    public int hashcode() {\n        final int prime = 31;\n        int result = 1;\n        result = result * prime + super.hashcode();\n        result = result * prime + (this.name == null ? 0 : this.name.hashcode());\n        result = result * prime + (this.gender == null ? 0 : this.gender.hashcode());\n        result = result * prime + (this.ssn == null ? 0 : this.ssn.hashcode());\n        return result;\n    }\n}\n\n\n\n# @data\n\n@data lombok 代码：\n\n@data(staticconstructor="of")\npublic class company {\n    private final person founder;\n    private string name;\n    private list<person> employees;\n}\n\n\n等价于 java 源码：\n\npublic class company {\n    private final person founder;\n    private string name;\n    private list<person> employees;\n\n    private company(final person founder) {\n        this.founder = founder;\n    }\n\n    public static company of(final person founder) {\n        return new company(founder);\n    }\n\n    public person getfounder() {\n        return founder;\n    }\n\n    public string getname() {\n        return name;\n    }\n\n    public void setname(final string name) {\n        this.name = name;\n    }\n\n    public list<person> getemployees() {\n        return employees;\n    }\n\n    public void setemployees(final list<person> employees) {\n        this.employees = employees;\n    }\n\n    @java.lang.override\n    public boolean equals(final java.lang.object o) {\n        if (o == this) return true;\n        if (o == null) return false;\n        if (o.getclass() != this.getclass()) return false;\n        final company other = (company)o;\n        if (this.founder == null ? other.founder != null : !this.founder.equals(other.founder)) return false;\n        if (this.name == null ? other.name != null : !this.name.equals(other.name)) return false;\n        if (this.employees == null ? other.employees != null : !this.employees.equals(other.employees)) return false;\n        return true;\n    }\n\n    @java.lang.override\n    public int hashcode() {\n        final int prime = 31;\n        int result = 1;\n        result = result * prime + (this.founder == null ? 0 : this.founder.hashcode());\n        result = result * prime + (this.name == null ? 0 : this.name.hashcode());\n        result = result * prime + (this.employees == null ? 0 : this.employees.hashcode());\n        return result;\n    }\n\n    @java.lang.override\n    public java.lang.string tostring() {\n        return "company(founder=" + founder + ", name=" + name + ", employees=" + employees + ")";\n    }\n}\n\n\n\n# @cleanup\n\n@cleanup lombok 代码：\n\npublic void testcleanup() {\n    try {\n        @cleanup bytearrayoutputstream baos = new bytearrayoutputstream();\n        baos.write(new byte[] {\'y\',\'e\',\'s\'});\n        system.out.println(baos.tostring());\n    } catch (ioexception e) {\n        e.printstacktrace();\n    }\n}\n\n\n等价于 java 源码：\n\npublic void testcleanup() {\n    try {\n        bytearrayoutputstream baos = new bytearrayoutputstream();\n        try {\n            baos.write(new byte[]{\'y\', \'e\', \'s\'});\n            system.out.println(baos.tostring());\n        } finally {\n            baos.close();\n        }\n    } catch (ioexception e) {\n        e.printstacktrace();\n    }\n}\n\n\n\n# @synchronized\n\n@synchronized lombok 代码：\n\nprivate dateformat format = new simpledateformat("mm-dd-yyyy");\n\n@synchronized\npublic string synchronizedformat(date date) {\n    return format.format(date);\n}\n\n\n等价于 java 源码：\n\nprivate final java.lang.object $lock = new java.lang.object[0];\nprivate dateformat format = new simpledateformat("mm-dd-yyyy");\n\npublic string synchronizedformat(date date) {\n    synchronized ($lock) {\n        return format.format(date);\n    }\n}\n\n\n\n# @sneakythrows\n\n@sneakythrows lombok 代码：\n\n@sneakythrows\npublic void testsneakythrows() {\n    throw new illegalaccessexception();\n}\n\n\n等价于 java 源码：\n\npublic void testsneakythrows() {\n    try {\n        throw new illegalaccessexception();\n    } catch (java.lang.throwable $ex) {\n        throw lombok.lombok.sneakythrow($ex);\n    }\n}\n\n\n\n# 示例源码\n\n> 示例源码：javalib-bean\n\n\n# lombok 使用注意点\n\n\n# 谨慎使用 @builder\n\n在类上标注了 @data 和 @builder 注解的时候，编译时，lombok 优化后的 class 中会没有默认的构造方法。在反序列化的时候，没有默认构造方法就可能会报错。\n\n【示例】使用 @builder 不当导致 json 反序列化失败\n\n@data\n@builder\npublic class builderdemo01 {\n\n    private string name;\n\n    public static void main(string[] args) throws jsonprocessingexception {\n        builderdemo01 demo01 = builderdemo01.builder().name("demo01").build();\n        objectmapper mapper = new objectmapper();\n        string json = mapper.writevalueasstring(demo01);\n        builderdemo01 expectdemo01 = mapper.readvalue(json, builderdemo01.class);\n        system.out.println(expectdemo01.tostring());\n    }\n\n}\n\n\n运行时会抛出异常：\n\nexception in thread "main" com.fasterxml.jackson.databind.exc.mismatchedinputexception: cannot construct instance of `io.github.dunwu.javatech.bean.lombok.builderdemo01` (although at least one creator exists): cannot deserialize from object value (no delegate- or property-based creator)\n at [source: (string)"{"name":"demo01"}"; line: 1, column: 2]\n\tat com.fasterxml.jackson.databind.exc.mismatchedinputexception.from(mismatchedinputexception.java:63)\n\tat com.fasterxml.jackson.databind.deserializationcontext.reportinputmismatch(deserializationcontext.java:1432)\n\tat com.fasterxml.jackson.databind.deserializationcontext.handlemissinginstantiator(deserializationcontext.java:1062)\n\tat com.fasterxml.jackson.databind.deser.beandeserializerbase.deserializefromobjectusingnondefault(beandeserializerbase.java:1297)\n\tat com.fasterxml.jackson.databind.deser.beandeserializer.deserializefromobject(beandeserializer.java:326)\n\tat com.fasterxml.jackson.databind.deser.beandeserializer.deserialize(beandeserializer.java:159)\n\tat com.fasterxml.jackson.databind.objectmapper._readmapandclose(objectmapper.java:4218)\n\tat com.fasterxml.jackson.databind.objectmapper.readvalue(objectmapper.java:3214)\n\tat com.fasterxml.jackson.databind.objectmapper.readvalue(objectmapper.java:3182)\n\tat io.github.dunwu.javatech.bean.lombok.builderdemo01.main(builderdemo01.java:22)\n\n\n【示例】使用 @builder 正确方法\n\n@data\n@builder\n@noargsconstructor\n@allargsconstructor\npublic class builderdemo02 {\n\n    private string name;\n\n    public static void main(string[] args) throws jsonprocessingexception {\n        builderdemo02 demo02 = builderdemo02.builder().name("demo01").build();\n        objectmapper mapper = new objectmapper();\n        string json = mapper.writevalueasstring(demo02);\n        builderdemo02 expectdemo02 = mapper.readvalue(json, builderdemo02.class);\n        system.out.println(expectdemo02.tostring());\n    }\n\n}\n\n\n\n# @data 注解和继承\n\n使用 @data 注解时，则有了 @equalsandhashcode 注解，那么就会在此类中存在 equals(object other) 和 hashcode() 方法，且不会使用父类的属性，这就导致了可能的问题。比如，有多个类有相同的部分属性，把它们定义到父类中，恰好 id（数据库主键）也在父类中，那么就会存在部分对象在比较时，它们并不相等，这是因为：lombok 自动生成的 equals(object other) 和 hashcode() 方法判定为相等，从而导致和预期不符。\n\n修复此问题的方法很简单：\n\n * 使用 @data 时，加上 @equalsandhashcode(callsuper=true) 注解。\n * 使用 @getter @setter @tostring 代替 @data 并且自定义 equals(object other) 和 hashcode() 方法。\n\n【示例】测试 @data 和 @equalsandhashcode\n\n@data\n@tostring(exclude = "age")\n@equalsandhashcode(exclude = { "age", "sex" })\npublic class person {\n\n    protected string name;\n\n    protected integer age;\n\n    protected string sex;\n\n}\n\n@data\n@equalsandhashcode(callsuper = true, exclude = { "address", "city", "state", "zip" })\npublic class equalsandhashcodedemo extends person {\n\n    @nonnull\n    private string name;\n\n    @nonnull\n    private gender gender;\n\n    private string ssn;\n\n    private string address;\n\n    private string city;\n\n    private string state;\n\n    private string zip;\n\n    public equalsandhashcodedemo(@nonnull string name, @nonnull gender gender) {\n        this.name = name;\n        this.gender = gender;\n    }\n\n    public equalsandhashcodedemo(@nonnull string name, @nonnull gender gender,\n        string ssn, string address, string city, string state, string zip) {\n        this.name = name;\n        this.gender = gender;\n        this.ssn = ssn;\n        this.address = address;\n        this.city = city;\n        this.state = state;\n        this.zip = zip;\n    }\n\n    public enum gender {\n        male,\n        female\n    }\n\n}\n\n@test\n@displayname("测试 @equalsandhashcode")\npublic void testequalsandhashcodedemo() {\n    equalsandhashcodedemo demo1 =\n        new equalsandhashcodedemo("name1", equalsandhashcodedemo.gender.female, "ssn", "xxx", "xxx", "xxx", "xxx");\n    equalsandhashcodedemo demo2 =\n        new equalsandhashcodedemo("name1", equalsandhashcodedemo.gender.female, "ssn", "ooo", "ooo", "ooo", "ooo");\n    assertions.assertequals(demo1, demo2);\n\n    person person = new person();\n    person.setname("张三");\n    person.setage(20);\n    person.setsex("男");\n\n    person person2 = new person();\n    person2.setname("张三");\n    person2.setage(18);\n    person2.setsex("男");\n\n    person person3 = new person();\n    person3.setname("李四");\n    person3.setage(20);\n    person3.setsex("男");\n\n    assertions.assertequals(person2, person);\n    assertions.assertnotequals(person3, person);\n}\n\n\n上面的单元测试可以通过，但如果将 @equalsandhashcode(callsuper = true, exclude = { "address", "city", "state", "zip" }) 注掉就会报错。\n\n\n# 参考资料\n\n * lombok 官网\n * lombok github\n * intellij idea - lombok plugin',charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Dozer 快速入门",frontmatter:{title:"Dozer 快速入门",date:"2022-02-17T22:34:30.000Z",order:2,categories:["Java","工具","JavaBean"],tags:["Java","JavaBean","Dozer"],permalink:"/pages/45e21b/"},regularPath:"/01.Java/12.%E5%B7%A5%E5%85%B7/02.JavaBean/02.Dozer.html",relativePath:"01.Java/12.工具/02.JavaBean/02.Dozer.md",key:"v-a648697c",path:"/pages/45e21b/",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:127},{level:2,title:"安装",slug:"安装",normalizedTitle:"安装",charIndex:259},{level:3,title:"引入 jar 包",slug:"引入-jar-包",normalizedTitle:"引入 jar 包",charIndex:266},{level:3,title:"Eclipse 插件",slug:"eclipse-插件",normalizedTitle:"eclipse 插件",charIndex:580},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:292},{level:3,title:"准备",slug:"准备",normalizedTitle:"准备",charIndex:761},{level:3,title:"Dozer 的配置",slug:"dozer-的配置",normalizedTitle:"dozer 的配置",charIndex:1126},{level:4,title:"为什么要有映射配置?",slug:"为什么要有映射配置",normalizedTitle:"为什么要有映射配置?",charIndex:1139},{level:4,title:"映射配置文件",slug:"映射配置文件",normalizedTitle:"映射配置文件",charIndex:1501},{level:3,title:"与 Spring 整合",slug:"与-spring-整合",normalizedTitle:"与 spring 整合",charIndex:2226},{level:4,title:"配置 DozerBeanMapperFactoryBean",slug:"配置-dozerbeanmapperfactorybean",normalizedTitle:"配置 dozerbeanmapperfactorybean",charIndex:2241},{level:4,title:"自动装配",slug:"自动装配",normalizedTitle:"自动装配",charIndex:3075},{level:2,title:"Dozer 支持的数据类型转换",slug:"dozer-支持的数据类型转换",normalizedTitle:"dozer 支持的数据类型转换",charIndex:3686},{level:2,title:"Dozer 的映射配置",slug:"dozer-的映射配置",normalizedTitle:"dozer 的映射配置",charIndex:5053},{level:3,title:"用注解来配置映射",slug:"用注解来配置映射",normalizedTitle:"用注解来配置映射",charIndex:5184},{level:3,title:"用 API 来配置映射",slug:"用-api-来配置映射",normalizedTitle:"用 api 来配置映射",charIndex:6247},{level:3,title:"用 XML 来配置映射",slug:"用-xml-来配置映射",normalizedTitle:"用 xml 来配置映射",charIndex:6297},{level:4,title:"属性名不同时的映射(Basic Property Mapping)",slug:"属性名不同时的映射-basic-property-mapping",normalizedTitle:"属性名不同时的映射(basic property mapping)",charIndex:6382},{level:4,title:"字符串和日期映射(String to Date Mapping)",slug:"字符串和日期映射-string-to-date-mapping",normalizedTitle:"字符串和日期映射(string to date mapping)",charIndex:6507},{level:4,title:"集合和数组映射(Collection and Array Mapping)",slug:"集合和数组映射-collection-and-array-mapping",normalizedTitle:"集合和数组映射(collection and array mapping)",charIndex:7304},{level:4,title:"深度映射(Deep Mapping)",slug:"深度映射-deep-mapping",normalizedTitle:"深度映射(deep mapping)",charIndex:8457},{level:4,title:"排除属性(Excluding Fields)",slug:"排除属性-excluding-fields",normalizedTitle:"排除属性(excluding fields)",charIndex:8945},{level:4,title:"单向映射(One-Way Mapping)",slug:"单向映射-one-way-mapping",normalizedTitle:"单向映射(one-way mapping)",charIndex:9175},{level:4,title:"全局配置(Global Configuration)",slug:"全局配置-global-configuration",normalizedTitle:"全局配置(global configuration)",charIndex:9772},{level:4,title:"定制转换(Custom Converters)",slug:"定制转换-custom-converters",normalizedTitle:"定制转换(custom converters)",charIndex:10716},{level:4,title:"映射的继承(Inheritance Mapping)",slug:"映射的继承-inheritance-mapping",normalizedTitle:"映射的继承(inheritance mapping)",charIndex:13131},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:9054}],headersStr:"简介 安装 引入 jar 包 Eclipse 插件 使用 准备 Dozer 的配置 为什么要有映射配置? 映射配置文件 与 Spring 整合 配置 DozerBeanMapperFactoryBean 自动装配 Dozer 支持的数据类型转换 Dozer 的映射配置 用注解来配置映射 用 API 来配置映射 用 XML 来配置映射 属性名不同时的映射(Basic Property Mapping) 字符串和日期映射(String to Date Mapping) 集合和数组映射(Collection and Array Mapping) 深度映射(Deep Mapping) 排除属性(Excluding Fields) 单向映射(One-Way Mapping) 全局配置(Global Configuration) 定制转换(Custom Converters) 映射的继承(Inheritance Mapping) 参考",content:'# Dozer 快速入门\n\n这篇文章是本人在阅读 Dozer 官方文档（5.5.1 版本，官网已经一年多没更新了）的过程中，整理下来我认为比较基础的应用场景。\n\n本文中提到的例子应该能覆盖 JavaBean 映射的大部分场景，希望对你有所帮助。\n\n\n# 简介\n\nDozer 是什么?\n\nDozer 是一个 JavaBean 映射工具库。\n\n它支持简单的属性映射，复杂类型映射，双向映射，隐式显式的映射，以及递归映射。\n\n它支持三种映射方式：注解、API、XML。\n\n它是开源的，遵从Apache 2.0 协议\n\n\n# 安装\n\n\n# 引入 jar 包\n\nmaven 方式\n\n如果你的项目使用 maven，添加以下依赖到你的 pom.xml 即可：\n\n<dependency>\n    <groupId>net.sf.dozer</groupId>\n    <artifactId>dozer</artifactId>\n    <version>5.4.0</version>\n</dependency>\n\n\n非 maven 方式\n\n如果你的项目不使用 maven，那就只能发扬不怕苦不怕累的精神了。\n\n使用 Dozer 需要引入 Dozer 的 jar 包以及其依赖的第三方 jar 包。\n\n * Dozer\n * Dozer 依赖的第三方 jar 包\n\n\n# Eclipse 插件\n\nDozer 有插件可以在 Eclipse 中使用(不知道是否好用，反正我没用过)\n\n插件地址: http://dozer.sourceforge.net/eclipse-plugin\n\n\n# 使用\n\n将 Dozer 引入到工程中后，我们就可以来小试一番了。\n\n实践出真知，先以一个最简单的例子来展示 Dozer 映射的处理过程。\n\n\n# 准备\n\n我们先准备两个要互相映射的类\n\nNotSameAttributeA.java\n\npublic class NotSameAttributeA {\n    private long id;\n    private String name;\n    private Date date;\n\n    // 省略getter/setter\n}\n\n\nNotSameAttributeB.java\n\npublic class NotSameAttributeB {\n    private long id;\n    private String value;\n    private Date date;\n\n    // 省略getter/setter\n}\n\n\n这两个类存在属性名不完全相同的情况：name 和 value。\n\n\n# Dozer 的配置\n\n# 为什么要有映射配置?\n\n如果要映射的两个对象有完全相同的属性名，那么一切都很简单。\n\n只需要直接使用 Dozer 的 API 即可：\n\nMapper mapper = new DozerBeanMapper();\nDestinationObject destObject =\n    mapper.map(sourceObject, DestinationObject.class);\n\n\n但实际映射时，往往存在属性名不同的情况。\n\n所以，你需要一些配置来告诉 Dozer 应该转换什么，怎么转换。\n\n注：官网着重建议：在现实应用中，最好不要每次映射对象时都创建一个Mapper实例来工作，这样会产生不必要的开销。如果你不使用 IoC 容器（如：spring）来管理你的项目，那么，最好将Mapper定义为单例模式。\n\n# 映射配置文件\n\n在src/test/resources目录下添加dozer/dozer-mapping.xml文件。 <mapping>标签中允许你定义<class-a>和<class-b>，对应着相互映射的类。 <field>标签里定义要映射的特殊属性。需要注意<a>和<class-a>对应，<b>和<class-b>对应，聪明的你，猜也猜出来了吧。\n\n<?xml version="1.0" encoding="UTF-8"?>\n<mappings xmlns="http://dozer.sourceforge.net" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n          xsi:schemaLocation="http://dozer.sourceforge.net\n          http://dozer.sourceforge.net/schema/beanmapping.xsd">\n  <mapping date-format="yyyy-MM-dd">\n    <class-a>org.zp.notes.spring.common.dozer.vo.NotSameAttributeA</class-a>\n    <class-b>org.zp.notes.spring.common.dozer.vo.NotSameAttributeB</class-b>\n    <field>\n      <a>name</a>\n      <b>value</b>\n    </field>\n  </mapping>\n</mappings>\n\n\n\n# 与 Spring 整合\n\n# 配置 DozerBeanMapperFactoryBean\n\n在src/test/resources目录下添加spring/spring-dozer.xml文件。\n\nDozer 与 Spring 的整合很便利，你只需要声明一个DozerBeanMapperFactoryBean， 将所有的 dozer 映射配置文件作为属性注入到mappingFiles， DozerBeanMapperFactoryBean会加载这些规则。\n\nspring-dozer.xml 文件范例\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans-2.0.xsd"\n       default-autowire="byName" default-lazy-init="false">\n\n  <bean id="mapper" class="org.dozer.spring.DozerBeanMapperFactoryBean">\n    <property name="mappingFiles">\n      <list>\n        <value>classpath*:dozer/dozer-mapping.xml</value>\n      </list>\n    </property>\n  </bean>\n</beans>\n\n\n# 自动装配\n\n至此，万事具备，你只需要自动装配mapper。\n\nRunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(locations = {"classpath:spring/spring-dozer.xml"})\n@TransactionConfiguration(defaultRollback = false)\npublic class DozerTest extends TestCase {\n    @Autowired\n    Mapper mapper;\n\n    @Test\n    public void testNotSameAttributeMapping() {\n        NotSameAttributeA src = new NotSameAttributeA();\n        src.setId(007);\n        src.setName("邦德");\n        src.setDate(new Date());\n\n        NotSameAttributeB desc = mapper.map(src, NotSameAttributeB.class);\n        Assert.assertNotNull(desc);\n    }\n}\n\n\n运行一下单元测试，绿灯通过。\n\n\n# Dozer 支持的数据类型转换\n\nDozer 可以自动做数据类型转换。当前，Dozer 支持以下数据类型转换（都是双向的）\n\n * Primitive to Primitive Wrapper\n   \n   原型(int、long 等)和原型包装类(Integer、Long)\n\n * Primitive to Custom Wrapper\n   \n   原型和定制的包装\n\n * Primitive Wrapper to Primitive Wrapper\n   \n   原型包装类和包装类\n\n * Primitive to Primitive\n   \n   原型和原型\n\n * Complex Type to Complex Type\n   \n   复杂类型和复杂类型\n\n * String to Primitive\n   \n   字符串和原型\n\n * String to Primitive Wrapper\n   \n   字符串和原型包装类\n\n * String to Complex Type if the Complex Type contains a String constructor\n   \n   字符串和有字符串构造器的复杂类型（类）\n\n * String to Map\n   \n   字符串和 Map\n\n * Collection to Collection\n   \n   集合和集合\n\n * Collection to Array\n   \n   集合和数组\n\n * Map to Complex Type\n   \n   Map 和复杂类型\n\n * Map to Custom Map Type\n   \n   Map 和定制 Map 类型\n\n * Enum to Enum\n   \n   枚举和枚举\n\n * Each of these can be mapped to one another: java.util.Date, java.sql.Date, java.sql.Time, java.sql.Timestamp, java.util.Calendar, java.util.GregorianCalendar\n   \n   这些时间相关的常见类可以互换：java.util.Date, java.sql.Date, java.sql.Time, java.sql.Timestamp, java.util.Calendar, java.util.GregorianCalendar\n\n * String to any of the supported Date/Calendar Objects.\n   \n   字符串和支持 Date/Calendar 的对象\n\n * Objects containing a toString() method that produces a long representing time in (ms) to any supported Date/Calendar object.\n   \n   如果一个对象的 toString()方法返回的是一个代表 long 型的时间数值（单位：ms），就可以和任何支持 Date/Calendar 的对象转换。\n\n\n# Dozer 的映射配置\n\n在前面的简单例子中，我们体验了一把 Dozer 的映射流程。但是两个类进行映射，有很多复杂的情况，相应的，你也需要一些更复杂的配置。\n\nDozer 有三种映射配置方式：\n\n * 注解方式\n * API 方式\n * XML 方式\n\n\n# 用注解来配置映射\n\nDozer 5.3.2版本开始支持注解方式配置映射（只有一个注解：@Mapping）。可以应对一些简单的映射处理，复杂的就玩不转了。\n\n看一下@Mapping的声明就可以知道，这个注解只能用于元素和方法。\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ElementType.FIELD, ElementType.METHOD})\npublic @interface Mapping {\n  String value() default "";\n}\n\n\n让我们来试试吧：\n\nTargetBean.java\n\npublic class SourceBean {\n\n    private Long id;\n\n    private String name;\n\n    @Mapping("binaryData")\n    private String data;\n\n    @Mapping("pk")\n    public Long getId() {\n        return this.id;\n    }\n\n    //其余getter/setter方法略\n}\n\n\nTargetBean.java\n\npublic class TargetBean {\n\n    private String pk;\n\n    private String name;\n\n    private String binaryData;\n\n    //getter/setter方法略\n}\n\n\n定义了两个相互映射的 Java 类，只需要在源类中用@Mapping标记和目标类中对应的属性就可以了。\n\n@Test\npublic void testAnnotationMapping() {\n SourceBean src = new SourceBean();\n src.setId(7L);\n src.setName("邦德");\n src.setData("00000111");\n\n TargetBean desc = mapper.map(src, TargetBean.class);\n Assert.assertNotNull(desc);\n}\n\n\n测试一下，绿灯通过。\n\n官方文档说，虽然当前版本（文档的版本对应 Dozer 5.5.1）仅支持@Mapping，但是在未来的发布版本会提供其他的注解功能，那就敬请期待吧（再次吐槽一下：一年多没更新了）。\n\n\n# 用 API 来配置映射\n\n个人觉得这种方式比较麻烦，不推荐，也不想多做介绍，就是这么任性。\n\n\n# 用 XML 来配置映射\n\n需要强调的是：如果两个类的所有属性都能很好的互转，可以你中有我，我中有你，不分彼此，那么就不要画蛇添足的在 xml 中去声明映射规则了。\n\n# 属性名不同时的映射(Basic Property Mapping)\n\nDozer 会自动映射属性名相同的属性，所以不必添加在 xml 文件中。\n\n<field>\n  <a>one</a>\n  <b>onePrime</b>\n</field>\n\n\n# 字符串和日期映射(String to Date Mapping)\n\n字符串在和日期进行映射时，允许用户指定日期的格式。\n\n格式的设置分为三个作用域级别：\n\n属性级别\n\n对当前属性有效（这个属性必须是日期字符串）\n\n<field>\n  <a date-format="MM/dd/yyyy HH:mm:ss:SS">dateString</a>\n  <b>dateObject</b>\n</field>\n\n\n类级别\n\n对这个类中的所有日期相关的属性有效\n\n<mapping date-format="MM-dd-yyyy HH:mm:ss">\n  <class-a>org.dozer.vo.TestObject</class-a>\n  <class-b>org.dozer.vo.TestObjectPrime</class-b>\n  <field>\n    <a>dateString</a>\n    <b>dateObject</b>\n  </field>\n</mapping>\n\n\n全局级别\n\n对整个文件中的所有日期相关的属性有效。\n\n<mappings>\n  <configuration>\n    <date-format>MM/dd/yyyy HH:mm</date-format>\n  </configuration>\n\n  <mapping wildcard="true">\n    <class-a>org.dozer.vo.TestObject</class-a>\n    <class-b>org.dozer.vo.TestObjectPrime</class-b>\n    <field>\n      <a>dateString</a>\n      <b>dateObject</b>\n    </field>\n  </mapping>\n</mappings>\n\n\n# 集合和数组映射(Collection and Array Mapping)\n\nDozer 可以自动处理以下类型的双向转换。\n\n * List to List\n * List to Array\n * Array to Array\n * Set to Set\n * Set to Array\n * Set to List\n\n使用 hint\n\n如果使用泛型或数组，没有必要使用 hint。\n\n如果不使用泛型或数组。在处理集合或数组之间的转换时，你需要用hint指定目标列表的数据类型。\n\n若你不指定hint，Dozer 将认为目标集合和源集合的类型是一致的。\n\n使用 Hints 的范例：\n\n<field>\n  <a>hintList</a>\n  <b>hintList</b>\n  <b-hint>org.dozer.vo.TheFirstSubClassPrime</b-hint>\n</field>\n\n\n累计映射和非累计映射（Cumulative vs. Non-Cumulative List Mapping）\n\n如果你要转换的目标类已经初始化，你可以选择让 Dozer 添加或更新对象到你的集合中。\n\n而这取决于relationship-type配置，默认是累计。\n\n它的设置有作用域级别：\n\n * 全局级\n\n<mappings>\n  <configuration>\n     <relationship-type>non-cumulative</relationship-type>\n  </configuration>\n</mappings>\n\n\n * 类级别\n\n<mappings>\n  <mapping relationship-type="non-cumulative">\n    \x3c!-- 省略 --\x3e\n  </mapping>\n</mappings>\n\n\n * 属性级别\n\n<field relationship-type="cumulative">\n  <a>hintList</a>\n  <b>hintList</b>\n  <a-hint>org.dozer.vo.TheFirstSubClass</a-hint>\n  <b-hint>org.dozer.vo.TheFirstSubClassPrime</b-hint>\n</field>\n\n\n移动孤儿(Removing Orphans)\n\n这里的孤儿是指目标集合中存在，但是源集合中不存在的元素。\n\n你可以使用remove-orphans开关来选择是否移除这样的元素。\n\n<field remove-orphans="true">\n  <a>srcList</a>\n  <b>destList</b>\n</field>\n\n\n# 深度映射(Deep Mapping)\n\n所谓深度映射，是指允许你指定属性的属性（比如一个类的属性本身也是一个类）。举例来说\n\nSource.java\n\npublic class Source {\n private long id;\n    private String info;\n}\n\n\nDest.java\n\npublic class Dest {\n private long id;\n    private Info info;\n}\n\n\npublic class Info {\n private String content;\n}\n\n\n映射规则\n\n<mapping>\n  <class-a>org.zp.notes.spring.common.dozer.vo.Source</class-a>\n  <class-b>org.zp.notes.spring.common.dozer.vo.Dest</class-b>\n  <field>\n    <a>info</a>\n    <b>info.content</b>\n  </field>\n</mapping>\n\n\n# 排除属性(Excluding Fields)\n\n就像任何团体都有捣乱分子，类之间转换时也有想要排除的因子。\n\n如何在做类型转换时，自动排除一些属性，Dozer 提供了几种方法，这里只介绍一种比较通用的方法。\n\n更多详情参考官网。\n\nfield-exclude 可以排除不需要映射的属性。\n\n<field-exclude>\n  <a>fieldToExclude</a>\n  <b>fieldToExclude</b>\n</field-exclude>\n\n\n# 单向映射(One-Way Mapping)\n\n注：本文的映射方式，无特殊说明，都是双向映射的。\n\n有的场景可能希望转换过程不可逆，即单向转换。\n\n单向转换可以通过使用one-way来开启\n\n类级别\n\n<mapping type="one-way">\n  <class-a>org.dozer.vo.TestObjectFoo</class-a>\n  <class-b>org.dozer.vo.TestObjectFooPrime</class-b>\n    <field>\n      <a>oneFoo</a>\n      <b>oneFooPrime</b>\n    </field>\n</mapping>\n\n\n属性级别\n\n<mapping>\n  <class-a>org.dozer.vo.TestObjectFoo2</class-a>\n  <class-b>org.dozer.vo.TestObjectFooPrime2</class-b>\n  <field type="one-way">\n    <a>oneFoo2</a>\n    <b>oneFooPrime2</b>\n  </field>\n\n  <field type="one-way">\n    <a>oneFoo3.prime</a>\n    <b>oneFooPrime3</b>\n  </field>\n\n\n# 全局配置(Global Configuration)\n\n全局配置用来设置全局的配置信息。此外，任何定制转换都是在这里定义的。\n\n全局配置都是可选的。\n\n * <date-format>表示日期格式\n * <stop-on-errors>错误处理开关\n * <wildcard>通配符\n * <trim-strings>裁剪字符串开关\n\n<configuration >\n\n  <date-format>MM/dd/yyyy HH:mm</date-format>\n  <stop-on-errors>true</stop-on-errors>\n  <wildcard>true</wildcard>\n  <trim-strings>false</trim-strings>\n\n  <custom-converters> \x3c!-- these are always bi-directional --\x3e\n    <converter type="org.dozer.converters.TestCustomConverter" >\n      <class-a>org.dozer.vo.TestCustomConverterObject</class-a>\n      <class-b>another.type.to.Associate</class-b>\n    </converter>\n\n  </custom-converters>\n</configuration>\n\n\n全局配置的作用是帮助你少配置一些参数，如果个别类的映射规则需要变更，你可以 mapping 中覆盖它。\n\n覆盖的范例如下\n\n<mapping date-format="MM-dd-yyyy HH:mm:ss">\n  \x3c!-- 省略 --\x3e\n</mapping>\n\n<mapping wildcard="false">\n  \x3c!-- 省略 --\x3e\n</mapping>\n\n<mapping stop-on-errors="false">\n  \x3c!-- 省略 --\x3e\n</mapping>\n\n<mapping trim-strings="true">\n  \x3c!-- 省略 --\x3e\n</mapping>\n\n\n# 定制转换(Custom Converters)\n\n如果 Dozer 默认的转换规则不能满足实际需要，你可以选择定制转换。\n\n定制转换通过配置 XML 来告诉 Dozer 如何去转换两个指定的类。当 Dozer 转换这两个指定类的时候，会调用你的映射规则去替换标准映射规则。\n\n为了让 Dozer 识别，你必须实现org.dozer.CustomConverter接口。否则，Dozer 会抛异常。\n\n具体做法：\n\n(1) 创建一个类实现org.dozer.CustomConverter接口。\n\npublic class TestCustomConverter implements CustomConverter {\n\n  public Object convert(Object destination, Object source,\n      Class destClass, Class sourceClass) {\n    if (source == null) {\n      return null;\n    }\n    CustomDoubleObject dest = null;\n    if (source instanceof Double) {\n      // check to see if the object already exists\n      if (destination == null) {\n        dest = new CustomDoubleObject();\n      } else {\n        dest = (CustomDoubleObject) destination;\n      }\n      dest.setTheDouble(((Double) source).doubleValue());\n      return dest;\n    } else if (source instanceof CustomDoubleObject) {\n      double sourceObj =\n        ((CustomDoubleObject) source).getTheDouble();\n      return new Double(sourceObj);\n    } else {\n      throw new MappingException("Converter TestCustomConverter "\n          + "used incorrectly. Arguments passed in were:"\n          + destination + " and " + source);\n    }\n  }\n\n\n(2) 在 xml 中引用定制的映射规则\n\n引用定制的映射规则也是分级的，你可以酌情使用。\n\n * 全局级\n\n<?xml version="1.0" encoding="UTF-8"?>\n<mappings xmlns="http://dozer.sourceforge.net"\n          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n          xsi:schemaLocation="http://dozer.sourceforge.net\n          http://dozer.sourceforge.net/schema/beanmapping.xsd">\n  <configuration>\n    \x3c!-- 总是双向转换的 --\x3e\n    <custom-converters>\n      <converter type="org.dozer.converters.TestCustomConverter" >\n        <class-a>org.dozer.vo.CustomDoubleObject</class-a>\n        <class-b>java.lang.Double</class-b>\n      </converter>\n\n      \x3c!-- You are responsible for mapping everything between\n           ClassA and ClassB --\x3e\n      <converter\n        type="org.dozer.converters.TestCustomHashMapConverter" >\n        <class-a>org.dozer.vo.TestCustomConverterHashMapObject</class-a>\n        <class-b>org.dozer.vo.TestCustomConverterHashMapPrimeObject</class-b>\n      </converter>\n    </custom-converters>\n  </configuration>\n</mappings>\n\n\n * 属性级\n\n<mapping>\n  <class-a>org.dozer.vo.SimpleObj</class-a>\n  <class-b>org.dozer.vo.SimpleObjPrime2</class-b>\n  <field custom-converter=\n    "org.dozer.converters.TestCustomConverter">\n    <a>field1</a>\n    <b>field1Prime</b>\n  </field>\n</mapping>\n\n\n# 映射的继承(Inheritance Mapping)\n\nDozer 支持映射规则的继承机制。\n\n属性如果有着相同的名字则不需要在 xml 中配置，除非使用了hint\n\n我们来看一个例子\n\n<mapping>\n  <class-a>org.dozer.vo.SuperClass</class-a>\n  <class-b>org.dozer.vo.SuperClassPrime</class-b>\n\n  <field>\n    <a>superAttribute</a>\n    <b>superAttr</b>\n  </field>\n</mapping>\n\n<mapping>\n  <class-a>org.dozer.vo.SubClass</class-a>\n  <class-b>org.dozer.vo.SubClassPrime</class-b>\n\n  <field>\n    <a>attribute</a>\n    <b>attributePrime</b>\n  </field>\n</mapping>\n\n<mapping>\n  <class-a>org.dozer.vo.SubClass2</class-a>\n  <class-b>org.dozer.vo.SubClassPrime2</class-b>\n\n  <field>\n    <a>attribute2</a>\n    <b>attributePrime2</b>\n  </field>\n</mapping>\n\n\n在上面的例子中 SubClass、SubClass2 是 SuperClass 的子类；\n\nSubClassPrime 和 SubClassPrime2 是 SuperClassPrime 的子类。\n\nsuperAttribute 和 superAttr 的映射规则会被子类所继承，所以不必再重复的在子类中去声明。\n\n\n# 参考\n\nDozer 官方文档 | Dozer 源码地址',normalizedContent:'# dozer 快速入门\n\n这篇文章是本人在阅读 dozer 官方文档（5.5.1 版本，官网已经一年多没更新了）的过程中，整理下来我认为比较基础的应用场景。\n\n本文中提到的例子应该能覆盖 javabean 映射的大部分场景，希望对你有所帮助。\n\n\n# 简介\n\ndozer 是什么?\n\ndozer 是一个 javabean 映射工具库。\n\n它支持简单的属性映射，复杂类型映射，双向映射，隐式显式的映射，以及递归映射。\n\n它支持三种映射方式：注解、api、xml。\n\n它是开源的，遵从apache 2.0 协议\n\n\n# 安装\n\n\n# 引入 jar 包\n\nmaven 方式\n\n如果你的项目使用 maven，添加以下依赖到你的 pom.xml 即可：\n\n<dependency>\n    <groupid>net.sf.dozer</groupid>\n    <artifactid>dozer</artifactid>\n    <version>5.4.0</version>\n</dependency>\n\n\n非 maven 方式\n\n如果你的项目不使用 maven，那就只能发扬不怕苦不怕累的精神了。\n\n使用 dozer 需要引入 dozer 的 jar 包以及其依赖的第三方 jar 包。\n\n * dozer\n * dozer 依赖的第三方 jar 包\n\n\n# eclipse 插件\n\ndozer 有插件可以在 eclipse 中使用(不知道是否好用，反正我没用过)\n\n插件地址: http://dozer.sourceforge.net/eclipse-plugin\n\n\n# 使用\n\n将 dozer 引入到工程中后，我们就可以来小试一番了。\n\n实践出真知，先以一个最简单的例子来展示 dozer 映射的处理过程。\n\n\n# 准备\n\n我们先准备两个要互相映射的类\n\nnotsameattributea.java\n\npublic class notsameattributea {\n    private long id;\n    private string name;\n    private date date;\n\n    // 省略getter/setter\n}\n\n\nnotsameattributeb.java\n\npublic class notsameattributeb {\n    private long id;\n    private string value;\n    private date date;\n\n    // 省略getter/setter\n}\n\n\n这两个类存在属性名不完全相同的情况：name 和 value。\n\n\n# dozer 的配置\n\n# 为什么要有映射配置?\n\n如果要映射的两个对象有完全相同的属性名，那么一切都很简单。\n\n只需要直接使用 dozer 的 api 即可：\n\nmapper mapper = new dozerbeanmapper();\ndestinationobject destobject =\n    mapper.map(sourceobject, destinationobject.class);\n\n\n但实际映射时，往往存在属性名不同的情况。\n\n所以，你需要一些配置来告诉 dozer 应该转换什么，怎么转换。\n\n注：官网着重建议：在现实应用中，最好不要每次映射对象时都创建一个mapper实例来工作，这样会产生不必要的开销。如果你不使用 ioc 容器（如：spring）来管理你的项目，那么，最好将mapper定义为单例模式。\n\n# 映射配置文件\n\n在src/test/resources目录下添加dozer/dozer-mapping.xml文件。 <mapping>标签中允许你定义<class-a>和<class-b>，对应着相互映射的类。 <field>标签里定义要映射的特殊属性。需要注意<a>和<class-a>对应，<b>和<class-b>对应，聪明的你，猜也猜出来了吧。\n\n<?xml version="1.0" encoding="utf-8"?>\n<mappings xmlns="http://dozer.sourceforge.net" xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n          xsi:schemalocation="http://dozer.sourceforge.net\n          http://dozer.sourceforge.net/schema/beanmapping.xsd">\n  <mapping date-format="yyyy-mm-dd">\n    <class-a>org.zp.notes.spring.common.dozer.vo.notsameattributea</class-a>\n    <class-b>org.zp.notes.spring.common.dozer.vo.notsameattributeb</class-b>\n    <field>\n      <a>name</a>\n      <b>value</b>\n    </field>\n  </mapping>\n</mappings>\n\n\n\n# 与 spring 整合\n\n# 配置 dozerbeanmapperfactorybean\n\n在src/test/resources目录下添加spring/spring-dozer.xml文件。\n\ndozer 与 spring 的整合很便利，你只需要声明一个dozerbeanmapperfactorybean， 将所有的 dozer 映射配置文件作为属性注入到mappingfiles， dozerbeanmapperfactorybean会加载这些规则。\n\nspring-dozer.xml 文件范例\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n       xsi:schemalocation="http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans-2.0.xsd"\n       default-autowire="byname" default-lazy-init="false">\n\n  <bean id="mapper" class="org.dozer.spring.dozerbeanmapperfactorybean">\n    <property name="mappingfiles">\n      <list>\n        <value>classpath*:dozer/dozer-mapping.xml</value>\n      </list>\n    </property>\n  </bean>\n</beans>\n\n\n# 自动装配\n\n至此，万事具备，你只需要自动装配mapper。\n\nrunwith(springjunit4classrunner.class)\n@contextconfiguration(locations = {"classpath:spring/spring-dozer.xml"})\n@transactionconfiguration(defaultrollback = false)\npublic class dozertest extends testcase {\n    @autowired\n    mapper mapper;\n\n    @test\n    public void testnotsameattributemapping() {\n        notsameattributea src = new notsameattributea();\n        src.setid(007);\n        src.setname("邦德");\n        src.setdate(new date());\n\n        notsameattributeb desc = mapper.map(src, notsameattributeb.class);\n        assert.assertnotnull(desc);\n    }\n}\n\n\n运行一下单元测试，绿灯通过。\n\n\n# dozer 支持的数据类型转换\n\ndozer 可以自动做数据类型转换。当前，dozer 支持以下数据类型转换（都是双向的）\n\n * primitive to primitive wrapper\n   \n   原型(int、long 等)和原型包装类(integer、long)\n\n * primitive to custom wrapper\n   \n   原型和定制的包装\n\n * primitive wrapper to primitive wrapper\n   \n   原型包装类和包装类\n\n * primitive to primitive\n   \n   原型和原型\n\n * complex type to complex type\n   \n   复杂类型和复杂类型\n\n * string to primitive\n   \n   字符串和原型\n\n * string to primitive wrapper\n   \n   字符串和原型包装类\n\n * string to complex type if the complex type contains a string constructor\n   \n   字符串和有字符串构造器的复杂类型（类）\n\n * string to map\n   \n   字符串和 map\n\n * collection to collection\n   \n   集合和集合\n\n * collection to array\n   \n   集合和数组\n\n * map to complex type\n   \n   map 和复杂类型\n\n * map to custom map type\n   \n   map 和定制 map 类型\n\n * enum to enum\n   \n   枚举和枚举\n\n * each of these can be mapped to one another: java.util.date, java.sql.date, java.sql.time, java.sql.timestamp, java.util.calendar, java.util.gregoriancalendar\n   \n   这些时间相关的常见类可以互换：java.util.date, java.sql.date, java.sql.time, java.sql.timestamp, java.util.calendar, java.util.gregoriancalendar\n\n * string to any of the supported date/calendar objects.\n   \n   字符串和支持 date/calendar 的对象\n\n * objects containing a tostring() method that produces a long representing time in (ms) to any supported date/calendar object.\n   \n   如果一个对象的 tostring()方法返回的是一个代表 long 型的时间数值（单位：ms），就可以和任何支持 date/calendar 的对象转换。\n\n\n# dozer 的映射配置\n\n在前面的简单例子中，我们体验了一把 dozer 的映射流程。但是两个类进行映射，有很多复杂的情况，相应的，你也需要一些更复杂的配置。\n\ndozer 有三种映射配置方式：\n\n * 注解方式\n * api 方式\n * xml 方式\n\n\n# 用注解来配置映射\n\ndozer 5.3.2版本开始支持注解方式配置映射（只有一个注解：@mapping）。可以应对一些简单的映射处理，复杂的就玩不转了。\n\n看一下@mapping的声明就可以知道，这个注解只能用于元素和方法。\n\n@retention(retentionpolicy.runtime)\n@target({elementtype.field, elementtype.method})\npublic @interface mapping {\n  string value() default "";\n}\n\n\n让我们来试试吧：\n\ntargetbean.java\n\npublic class sourcebean {\n\n    private long id;\n\n    private string name;\n\n    @mapping("binarydata")\n    private string data;\n\n    @mapping("pk")\n    public long getid() {\n        return this.id;\n    }\n\n    //其余getter/setter方法略\n}\n\n\ntargetbean.java\n\npublic class targetbean {\n\n    private string pk;\n\n    private string name;\n\n    private string binarydata;\n\n    //getter/setter方法略\n}\n\n\n定义了两个相互映射的 java 类，只需要在源类中用@mapping标记和目标类中对应的属性就可以了。\n\n@test\npublic void testannotationmapping() {\n sourcebean src = new sourcebean();\n src.setid(7l);\n src.setname("邦德");\n src.setdata("00000111");\n\n targetbean desc = mapper.map(src, targetbean.class);\n assert.assertnotnull(desc);\n}\n\n\n测试一下，绿灯通过。\n\n官方文档说，虽然当前版本（文档的版本对应 dozer 5.5.1）仅支持@mapping，但是在未来的发布版本会提供其他的注解功能，那就敬请期待吧（再次吐槽一下：一年多没更新了）。\n\n\n# 用 api 来配置映射\n\n个人觉得这种方式比较麻烦，不推荐，也不想多做介绍，就是这么任性。\n\n\n# 用 xml 来配置映射\n\n需要强调的是：如果两个类的所有属性都能很好的互转，可以你中有我，我中有你，不分彼此，那么就不要画蛇添足的在 xml 中去声明映射规则了。\n\n# 属性名不同时的映射(basic property mapping)\n\ndozer 会自动映射属性名相同的属性，所以不必添加在 xml 文件中。\n\n<field>\n  <a>one</a>\n  <b>oneprime</b>\n</field>\n\n\n# 字符串和日期映射(string to date mapping)\n\n字符串在和日期进行映射时，允许用户指定日期的格式。\n\n格式的设置分为三个作用域级别：\n\n属性级别\n\n对当前属性有效（这个属性必须是日期字符串）\n\n<field>\n  <a date-format="mm/dd/yyyy hh:mm:ss:ss">datestring</a>\n  <b>dateobject</b>\n</field>\n\n\n类级别\n\n对这个类中的所有日期相关的属性有效\n\n<mapping date-format="mm-dd-yyyy hh:mm:ss">\n  <class-a>org.dozer.vo.testobject</class-a>\n  <class-b>org.dozer.vo.testobjectprime</class-b>\n  <field>\n    <a>datestring</a>\n    <b>dateobject</b>\n  </field>\n</mapping>\n\n\n全局级别\n\n对整个文件中的所有日期相关的属性有效。\n\n<mappings>\n  <configuration>\n    <date-format>mm/dd/yyyy hh:mm</date-format>\n  </configuration>\n\n  <mapping wildcard="true">\n    <class-a>org.dozer.vo.testobject</class-a>\n    <class-b>org.dozer.vo.testobjectprime</class-b>\n    <field>\n      <a>datestring</a>\n      <b>dateobject</b>\n    </field>\n  </mapping>\n</mappings>\n\n\n# 集合和数组映射(collection and array mapping)\n\ndozer 可以自动处理以下类型的双向转换。\n\n * list to list\n * list to array\n * array to array\n * set to set\n * set to array\n * set to list\n\n使用 hint\n\n如果使用泛型或数组，没有必要使用 hint。\n\n如果不使用泛型或数组。在处理集合或数组之间的转换时，你需要用hint指定目标列表的数据类型。\n\n若你不指定hint，dozer 将认为目标集合和源集合的类型是一致的。\n\n使用 hints 的范例：\n\n<field>\n  <a>hintlist</a>\n  <b>hintlist</b>\n  <b-hint>org.dozer.vo.thefirstsubclassprime</b-hint>\n</field>\n\n\n累计映射和非累计映射（cumulative vs. non-cumulative list mapping）\n\n如果你要转换的目标类已经初始化，你可以选择让 dozer 添加或更新对象到你的集合中。\n\n而这取决于relationship-type配置，默认是累计。\n\n它的设置有作用域级别：\n\n * 全局级\n\n<mappings>\n  <configuration>\n     <relationship-type>non-cumulative</relationship-type>\n  </configuration>\n</mappings>\n\n\n * 类级别\n\n<mappings>\n  <mapping relationship-type="non-cumulative">\n    \x3c!-- 省略 --\x3e\n  </mapping>\n</mappings>\n\n\n * 属性级别\n\n<field relationship-type="cumulative">\n  <a>hintlist</a>\n  <b>hintlist</b>\n  <a-hint>org.dozer.vo.thefirstsubclass</a-hint>\n  <b-hint>org.dozer.vo.thefirstsubclassprime</b-hint>\n</field>\n\n\n移动孤儿(removing orphans)\n\n这里的孤儿是指目标集合中存在，但是源集合中不存在的元素。\n\n你可以使用remove-orphans开关来选择是否移除这样的元素。\n\n<field remove-orphans="true">\n  <a>srclist</a>\n  <b>destlist</b>\n</field>\n\n\n# 深度映射(deep mapping)\n\n所谓深度映射，是指允许你指定属性的属性（比如一个类的属性本身也是一个类）。举例来说\n\nsource.java\n\npublic class source {\n private long id;\n    private string info;\n}\n\n\ndest.java\n\npublic class dest {\n private long id;\n    private info info;\n}\n\n\npublic class info {\n private string content;\n}\n\n\n映射规则\n\n<mapping>\n  <class-a>org.zp.notes.spring.common.dozer.vo.source</class-a>\n  <class-b>org.zp.notes.spring.common.dozer.vo.dest</class-b>\n  <field>\n    <a>info</a>\n    <b>info.content</b>\n  </field>\n</mapping>\n\n\n# 排除属性(excluding fields)\n\n就像任何团体都有捣乱分子，类之间转换时也有想要排除的因子。\n\n如何在做类型转换时，自动排除一些属性，dozer 提供了几种方法，这里只介绍一种比较通用的方法。\n\n更多详情参考官网。\n\nfield-exclude 可以排除不需要映射的属性。\n\n<field-exclude>\n  <a>fieldtoexclude</a>\n  <b>fieldtoexclude</b>\n</field-exclude>\n\n\n# 单向映射(one-way mapping)\n\n注：本文的映射方式，无特殊说明，都是双向映射的。\n\n有的场景可能希望转换过程不可逆，即单向转换。\n\n单向转换可以通过使用one-way来开启\n\n类级别\n\n<mapping type="one-way">\n  <class-a>org.dozer.vo.testobjectfoo</class-a>\n  <class-b>org.dozer.vo.testobjectfooprime</class-b>\n    <field>\n      <a>onefoo</a>\n      <b>onefooprime</b>\n    </field>\n</mapping>\n\n\n属性级别\n\n<mapping>\n  <class-a>org.dozer.vo.testobjectfoo2</class-a>\n  <class-b>org.dozer.vo.testobjectfooprime2</class-b>\n  <field type="one-way">\n    <a>onefoo2</a>\n    <b>onefooprime2</b>\n  </field>\n\n  <field type="one-way">\n    <a>onefoo3.prime</a>\n    <b>onefooprime3</b>\n  </field>\n\n\n# 全局配置(global configuration)\n\n全局配置用来设置全局的配置信息。此外，任何定制转换都是在这里定义的。\n\n全局配置都是可选的。\n\n * <date-format>表示日期格式\n * <stop-on-errors>错误处理开关\n * <wildcard>通配符\n * <trim-strings>裁剪字符串开关\n\n<configuration >\n\n  <date-format>mm/dd/yyyy hh:mm</date-format>\n  <stop-on-errors>true</stop-on-errors>\n  <wildcard>true</wildcard>\n  <trim-strings>false</trim-strings>\n\n  <custom-converters> \x3c!-- these are always bi-directional --\x3e\n    <converter type="org.dozer.converters.testcustomconverter" >\n      <class-a>org.dozer.vo.testcustomconverterobject</class-a>\n      <class-b>another.type.to.associate</class-b>\n    </converter>\n\n  </custom-converters>\n</configuration>\n\n\n全局配置的作用是帮助你少配置一些参数，如果个别类的映射规则需要变更，你可以 mapping 中覆盖它。\n\n覆盖的范例如下\n\n<mapping date-format="mm-dd-yyyy hh:mm:ss">\n  \x3c!-- 省略 --\x3e\n</mapping>\n\n<mapping wildcard="false">\n  \x3c!-- 省略 --\x3e\n</mapping>\n\n<mapping stop-on-errors="false">\n  \x3c!-- 省略 --\x3e\n</mapping>\n\n<mapping trim-strings="true">\n  \x3c!-- 省略 --\x3e\n</mapping>\n\n\n# 定制转换(custom converters)\n\n如果 dozer 默认的转换规则不能满足实际需要，你可以选择定制转换。\n\n定制转换通过配置 xml 来告诉 dozer 如何去转换两个指定的类。当 dozer 转换这两个指定类的时候，会调用你的映射规则去替换标准映射规则。\n\n为了让 dozer 识别，你必须实现org.dozer.customconverter接口。否则，dozer 会抛异常。\n\n具体做法：\n\n(1) 创建一个类实现org.dozer.customconverter接口。\n\npublic class testcustomconverter implements customconverter {\n\n  public object convert(object destination, object source,\n      class destclass, class sourceclass) {\n    if (source == null) {\n      return null;\n    }\n    customdoubleobject dest = null;\n    if (source instanceof double) {\n      // check to see if the object already exists\n      if (destination == null) {\n        dest = new customdoubleobject();\n      } else {\n        dest = (customdoubleobject) destination;\n      }\n      dest.setthedouble(((double) source).doublevalue());\n      return dest;\n    } else if (source instanceof customdoubleobject) {\n      double sourceobj =\n        ((customdoubleobject) source).getthedouble();\n      return new double(sourceobj);\n    } else {\n      throw new mappingexception("converter testcustomconverter "\n          + "used incorrectly. arguments passed in were:"\n          + destination + " and " + source);\n    }\n  }\n\n\n(2) 在 xml 中引用定制的映射规则\n\n引用定制的映射规则也是分级的，你可以酌情使用。\n\n * 全局级\n\n<?xml version="1.0" encoding="utf-8"?>\n<mappings xmlns="http://dozer.sourceforge.net"\n          xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n          xsi:schemalocation="http://dozer.sourceforge.net\n          http://dozer.sourceforge.net/schema/beanmapping.xsd">\n  <configuration>\n    \x3c!-- 总是双向转换的 --\x3e\n    <custom-converters>\n      <converter type="org.dozer.converters.testcustomconverter" >\n        <class-a>org.dozer.vo.customdoubleobject</class-a>\n        <class-b>java.lang.double</class-b>\n      </converter>\n\n      \x3c!-- you are responsible for mapping everything between\n           classa and classb --\x3e\n      <converter\n        type="org.dozer.converters.testcustomhashmapconverter" >\n        <class-a>org.dozer.vo.testcustomconverterhashmapobject</class-a>\n        <class-b>org.dozer.vo.testcustomconverterhashmapprimeobject</class-b>\n      </converter>\n    </custom-converters>\n  </configuration>\n</mappings>\n\n\n * 属性级\n\n<mapping>\n  <class-a>org.dozer.vo.simpleobj</class-a>\n  <class-b>org.dozer.vo.simpleobjprime2</class-b>\n  <field custom-converter=\n    "org.dozer.converters.testcustomconverter">\n    <a>field1</a>\n    <b>field1prime</b>\n  </field>\n</mapping>\n\n\n# 映射的继承(inheritance mapping)\n\ndozer 支持映射规则的继承机制。\n\n属性如果有着相同的名字则不需要在 xml 中配置，除非使用了hint\n\n我们来看一个例子\n\n<mapping>\n  <class-a>org.dozer.vo.superclass</class-a>\n  <class-b>org.dozer.vo.superclassprime</class-b>\n\n  <field>\n    <a>superattribute</a>\n    <b>superattr</b>\n  </field>\n</mapping>\n\n<mapping>\n  <class-a>org.dozer.vo.subclass</class-a>\n  <class-b>org.dozer.vo.subclassprime</class-b>\n\n  <field>\n    <a>attribute</a>\n    <b>attributeprime</b>\n  </field>\n</mapping>\n\n<mapping>\n  <class-a>org.dozer.vo.subclass2</class-a>\n  <class-b>org.dozer.vo.subclassprime2</class-b>\n\n  <field>\n    <a>attribute2</a>\n    <b>attributeprime2</b>\n  </field>\n</mapping>\n\n\n在上面的例子中 subclass、subclass2 是 superclass 的子类；\n\nsubclassprime 和 subclassprime2 是 superclassprime 的子类。\n\nsuperattribute 和 superattr 的映射规则会被子类所继承，所以不必再重复的在子类中去声明。\n\n\n# 参考\n\ndozer 官方文档 | dozer 源码地址',charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Freemark 快速入门",frontmatter:{title:"Freemark 快速入门",date:"2022-02-17T22:34:30.000Z",order:1,categories:["Java","工具","模板引擎"],tags:["Java","模板引擎","Freemark"],permalink:"/pages/a60ccf/"},regularPath:"/01.Java/12.%E5%B7%A5%E5%85%B7/03.%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/01.Freemark.html",relativePath:"01.Java/12.工具/03.模板引擎/01.Freemark.md",key:"v-b1567070",path:"/pages/a60ccf/",headers:[{level:2,title:"Freemark 简介",slug:"freemark-简介",normalizedTitle:"freemark 简介",charIndex:145},{level:2,title:"总体结构",slug:"总体结构",normalizedTitle:"总体结构",charIndex:456},{level:3,title:"指令",slug:"指令",normalizedTitle:"指令",charIndex:823},{level:3,title:"表达式",slug:"表达式",normalizedTitle:"表达式",charIndex:1073},{level:3,title:"变量",slug:"变量",normalizedTitle:"变量",charIndex:1357},{level:2,title:"数据类型",slug:"数据类型",normalizedTitle:"数据类型",charIndex:2450},{level:3,title:"标量",slug:"标量",normalizedTitle:"标量",charIndex:2477},{level:3,title:"容器",slug:"容器",normalizedTitle:"容器",charIndex:2688},{level:3,title:"子程序",slug:"子程序",normalizedTitle:"子程序",charIndex:2715},{level:3,title:"其它",slug:"其它",normalizedTitle:"其它",charIndex:2744},{level:2,title:"转义符",slug:"转义符",normalizedTitle:"转义符",charIndex:2758},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:3075}],headersStr:"Freemark 简介 总体结构 指令 表达式 变量 数据类型 标量 容器 子程序 其它 转义符 参考资料",content:'# Freemark 快速入门\n\n> FreeMarker 是一款模板引擎： 即一种基于模板和要改变的数据， 并用来生成输出文本(HTML 网页，电子邮件，配置文件，源代码等)的通用工具。 它不是面向最终用户的，而是一个 Java 类库，是一款程序员可以嵌入他们所开发产品的组件。\n\n\n# Freemark 简介\n\nFreemark 模板编写为 FreeMarker Template Language (FTL)。它是简单的，专用的语言， 不是 像 PHP 那样成熟的编程语言。在模板中，你可以专注于如何展现数据， 而在模板之外可以专注于要展示什么数据。\n\n\n\n这种方式通常被称为 MVC (模型 视图 控制器) 模式，对于动态网页来说，是一种特别流行的模式。 它帮助从开发人员(Java 程序员)中分离出网页设计师(HTML 设计师)。设计师无需面对模板中的复杂逻辑， 在没有程序员来修改或重新编译代码时，也可以修改页面的样式。\n\nFreemark 模板一句话概括就是：模板 + 数据模型 = 输出\n\n\n# 总体结构\n\n * 文本：文本会照着原样来输出。\n * 插值：这部分的输出会被计算的值来替换。插值由 ${ and } 所分隔(或者 #{ and }，这种风格已经不建议再使用了；点击查看更多)。\n * FTL 标签：FTL 标签和 HTML 标签很相似，但是它们却是给 FreeMarker 的指示， 而且不会打印在输出内容中。\n * 注释：注释和 HTML 的注释也很相似，但它们是由 <#-- 和 --\x3e来分隔的。注释会被 FreeMarker 直接忽略， 更不会在输出内容中显示。\n\n\n\n> 🔔 注意：\n> \n>  * FTL 是区分大小写的。\n>  * 插值 仅仅可以在 文本 中使用。\n>  * FTL 标签 不可以在其他 FTL 标签 和 插值 中使用。\n>  * 注释 可以放在 FTL 标签 和 插值 中。\n\n\n# 指令\n\nFTL 指令有两种类型： 预定义指令 和 用户自定义指令。 对于用户自定义的指令使用 @ 来代替 #。\n\n> 🔔 注意：\n> \n>  * FreeMarker 仅仅关心 FTL 标签的嵌套而不关心 HTML 标签的嵌套。 它只会把 HTML 看做是文本，不会来解释 HTML。\n>  * 如果你尝试使用一个不存在的指令(比如，输错了指令的名称)， FreeMarker 就会拒绝执行模板，同时抛出错误信息。\n>  * FreeMarker 会忽略 FTL 标签中多余的 空白标记。\n\n\n# 表达式\n\n以下为快速浏览清单，如果需要了解更多细节，请参考这里。\n\n * 直接指定值\n   * 字符串： "Foo" 或者 \'Foo\' 或者 "It\'s \\"quoted\\"" 或者 \'It\\\'s "quoted"\' 或者 r"C:\\raw\\string"\n   * 数字： 123.45\n   * 布尔值： true， false\n   * 序列： ["foo", "bar", 123.45]； 值域： 0..9, 0..<10 (或 0..!10), 0..\n   * 哈希表： {"name":"green mouse", "price":150}\n * 检索变量\n   * 顶层变量： user\n   * 从哈希表中检索数据： user.name， user["name"]\n   * 从序列中检索数据： products[5]\n   * 特殊变量： .main\n * 字符串操作\n   * 插值(或连接)： "Hello ${user}!" (或 "Hello " + user + "!")\n   * 获取一个字符： name[0]\n   * 字符串切分： 包含结尾： name[0..4]，不包含结尾： name[0..<5]，基于长度(宽容处理)： name[0..*5]，去除开头：name[5..]\n * 序列操作\n   * 连接： users + ["guest"]\n   * 序列切分：包含结尾： products[20..29]， 不包含结尾： products[20..<30]，基于长度(宽容处理)：products[20..*10]，去除开头： products[20..]\n * 哈希表操作\n   * 连接： passwords + { "joe": "secret42" }\n * 算术运算： (x * 1.5 + 10) / 2 - y % 100\n * 比较运算： x == y， x != y， x < y， x > y， x >= y， x <= y， x lt y， x lte y， x gt y， x gte y， 等等。。。。。。\n * 逻辑操作： !registered && (firstVisit || fromEurope)\n * 内建函数： name?upper_case, path?ensure_starts_with(\'/\')\n * 方法调用： repeat("What", 3)\n * 处理不存在的值\n   * 默认值： name!"unknown" 或者 (user.name)!"unknown" 或者 name! 或者 (user.name)!\n   * 检测不存在的值： name?? 或者 (user.name)??\n * 赋值操作： =, +=, -=, *=, /=, %=, ++, --\n\n\n# 变量\n\n注意：变量 仅仅 在 文本区 (比如 <h1>Hello ${name}!</h1>) 和 字符串 中起作用。\n\n正确示例：\n\n<#include "/footer/${company}.html">\n<#if big>...</#if>\n\n\n错误示例：\n\n<#if ${big}>...</#if>\n<#if "${big}">...</#if>\n\n\n\n# 数据类型\n\nFreemark 支持的类型有：\n\n\n# 标量\n\n字符串\n\n${"Hello ${user}"}\n${"I can escape with \\\\ ${user}"}\n${r"Now I can read dollar signs $"}\n\n\n输出：\n\nHello deister\nI can escape with \\ deister\nNow I can read dollar signs $\n\n\n数字\n\n布尔值\n\n日期/时间 (日期，时间或日期时间)\n\n\n# 容器\n\n * 哈希表\n * 序列\n * 集合\n\n\n# 子程序\n\n * 方法和函数\n * 用户自定义指令\n\n\n# 其它\n\n * 结点\n\n\n# 转义符\n\nFTL 支持的所有转义字符：\n\n转义序列     含义\n\\"       引号 (u0022)\n\\\'       单引号(又称为撇号) (u0027)\n\\{       起始花括号：{\n\\\\       反斜杠 (u005C)\n\\n       换行符 (u000A)\n\\r       回车 (u000D)\n\\t       水平制表符(又称为 tab) (u0009)\n\\b       退格 (u0008)\n\\f       换页 (u000C)\n\\l       小于号：<\n\\g       大于号：>\n\\a       &符：&\n\\xCode   字符的 16 进制 Unicode 码 (UCS 码)\n\n\n# 参考资料\n\n * Freemark Github\n * Freemark 中文教程\n * 在线 Freemark 工具',normalizedContent:'# freemark 快速入门\n\n> freemarker 是一款模板引擎： 即一种基于模板和要改变的数据， 并用来生成输出文本(html 网页，电子邮件，配置文件，源代码等)的通用工具。 它不是面向最终用户的，而是一个 java 类库，是一款程序员可以嵌入他们所开发产品的组件。\n\n\n# freemark 简介\n\nfreemark 模板编写为 freemarker template language (ftl)。它是简单的，专用的语言， 不是 像 php 那样成熟的编程语言。在模板中，你可以专注于如何展现数据， 而在模板之外可以专注于要展示什么数据。\n\n\n\n这种方式通常被称为 mvc (模型 视图 控制器) 模式，对于动态网页来说，是一种特别流行的模式。 它帮助从开发人员(java 程序员)中分离出网页设计师(html 设计师)。设计师无需面对模板中的复杂逻辑， 在没有程序员来修改或重新编译代码时，也可以修改页面的样式。\n\nfreemark 模板一句话概括就是：模板 + 数据模型 = 输出\n\n\n# 总体结构\n\n * 文本：文本会照着原样来输出。\n * 插值：这部分的输出会被计算的值来替换。插值由 ${ and } 所分隔(或者 #{ and }，这种风格已经不建议再使用了；点击查看更多)。\n * ftl 标签：ftl 标签和 html 标签很相似，但是它们却是给 freemarker 的指示， 而且不会打印在输出内容中。\n * 注释：注释和 html 的注释也很相似，但它们是由 <#-- 和 --\x3e来分隔的。注释会被 freemarker 直接忽略， 更不会在输出内容中显示。\n\n\n\n> 🔔 注意：\n> \n>  * ftl 是区分大小写的。\n>  * 插值 仅仅可以在 文本 中使用。\n>  * ftl 标签 不可以在其他 ftl 标签 和 插值 中使用。\n>  * 注释 可以放在 ftl 标签 和 插值 中。\n\n\n# 指令\n\nftl 指令有两种类型： 预定义指令 和 用户自定义指令。 对于用户自定义的指令使用 @ 来代替 #。\n\n> 🔔 注意：\n> \n>  * freemarker 仅仅关心 ftl 标签的嵌套而不关心 html 标签的嵌套。 它只会把 html 看做是文本，不会来解释 html。\n>  * 如果你尝试使用一个不存在的指令(比如，输错了指令的名称)， freemarker 就会拒绝执行模板，同时抛出错误信息。\n>  * freemarker 会忽略 ftl 标签中多余的 空白标记。\n\n\n# 表达式\n\n以下为快速浏览清单，如果需要了解更多细节，请参考这里。\n\n * 直接指定值\n   * 字符串： "foo" 或者 \'foo\' 或者 "it\'s \\"quoted\\"" 或者 \'it\\\'s "quoted"\' 或者 r"c:\\raw\\string"\n   * 数字： 123.45\n   * 布尔值： true， false\n   * 序列： ["foo", "bar", 123.45]； 值域： 0..9, 0..<10 (或 0..!10), 0..\n   * 哈希表： {"name":"green mouse", "price":150}\n * 检索变量\n   * 顶层变量： user\n   * 从哈希表中检索数据： user.name， user["name"]\n   * 从序列中检索数据： products[5]\n   * 特殊变量： .main\n * 字符串操作\n   * 插值(或连接)： "hello ${user}!" (或 "hello " + user + "!")\n   * 获取一个字符： name[0]\n   * 字符串切分： 包含结尾： name[0..4]，不包含结尾： name[0..<5]，基于长度(宽容处理)： name[0..*5]，去除开头：name[5..]\n * 序列操作\n   * 连接： users + ["guest"]\n   * 序列切分：包含结尾： products[20..29]， 不包含结尾： products[20..<30]，基于长度(宽容处理)：products[20..*10]，去除开头： products[20..]\n * 哈希表操作\n   * 连接： passwords + { "joe": "secret42" }\n * 算术运算： (x * 1.5 + 10) / 2 - y % 100\n * 比较运算： x == y， x != y， x < y， x > y， x >= y， x <= y， x lt y， x lte y， x gt y， x gte y， 等等。。。。。。\n * 逻辑操作： !registered && (firstvisit || fromeurope)\n * 内建函数： name?upper_case, path?ensure_starts_with(\'/\')\n * 方法调用： repeat("what", 3)\n * 处理不存在的值\n   * 默认值： name!"unknown" 或者 (user.name)!"unknown" 或者 name! 或者 (user.name)!\n   * 检测不存在的值： name?? 或者 (user.name)??\n * 赋值操作： =, +=, -=, *=, /=, %=, ++, --\n\n\n# 变量\n\n注意：变量 仅仅 在 文本区 (比如 <h1>hello ${name}!</h1>) 和 字符串 中起作用。\n\n正确示例：\n\n<#include "/footer/${company}.html">\n<#if big>...</#if>\n\n\n错误示例：\n\n<#if ${big}>...</#if>\n<#if "${big}">...</#if>\n\n\n\n# 数据类型\n\nfreemark 支持的类型有：\n\n\n# 标量\n\n字符串\n\n${"hello ${user}"}\n${"i can escape with \\\\ ${user}"}\n${r"now i can read dollar signs $"}\n\n\n输出：\n\nhello deister\ni can escape with \\ deister\nnow i can read dollar signs $\n\n\n数字\n\n布尔值\n\n日期/时间 (日期，时间或日期时间)\n\n\n# 容器\n\n * 哈希表\n * 序列\n * 集合\n\n\n# 子程序\n\n * 方法和函数\n * 用户自定义指令\n\n\n# 其它\n\n * 结点\n\n\n# 转义符\n\nftl 支持的所有转义字符：\n\n转义序列     含义\n\\"       引号 (u0022)\n\\\'       单引号(又称为撇号) (u0027)\n\\{       起始花括号：{\n\\\\       反斜杠 (u005c)\n\\n       换行符 (u000a)\n\\r       回车 (u000d)\n\\t       水平制表符(又称为 tab) (u0009)\n\\b       退格 (u0008)\n\\f       换页 (u000c)\n\\l       小于号：<\n\\g       大于号：>\n\\a       &符：&\n\\xcode   字符的 16 进制 unicode 码 (ucs 码)\n\n\n# 参考资料\n\n * freemark github\n * freemark 中文教程\n * 在线 freemark 工具',charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Thymeleaf 快速入门",frontmatter:{title:"Thymeleaf 快速入门",date:"2022-02-17T22:34:30.000Z",order:2,categories:["Java","工具","模板引擎"],tags:["Java","模板引擎","Thymeleaf"],permalink:"/pages/e7d2ad/"},regularPath:"/01.Java/12.%E5%B7%A5%E5%85%B7/03.%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/02.Thymeleaf.html",relativePath:"01.Java/12.工具/03.模板引擎/02.Thymeleaf.md",key:"v-d73a1b24",path:"/pages/e7d2ad/",headers:[{level:2,title:"标准方言",slug:"标准方言",normalizedTitle:"标准方言",charIndex:21},{level:3,title:"表达式",slug:"表达式",normalizedTitle:"表达式",charIndex:130},{level:4,title:"变量表达式",slug:"变量表达式",normalizedTitle:"变量表达式",charIndex:144},{level:4,title:"选择表达式",slug:"选择表达式",normalizedTitle:"选择表达式",charIndex:161},{level:4,title:"消息(i18n)表达式",slug:"消息-i18n-表达式",normalizedTitle:"消息(i18n)表达式",charIndex:1027},{level:4,title:"链接(URL)表达式",slug:"链接-url-表达式",normalizedTitle:"链接(url)表达式",charIndex:1485},{level:4,title:"片段表达式",slug:"片段表达式",normalizedTitle:"片段表达式",charIndex:227},{level:4,title:"表达式预处理",slug:"表达式预处理",normalizedTitle:"表达式预处理",charIndex:2876},{level:3,title:"文字和操作",slug:"文字和操作",normalizedTitle:"文字和操作",charIndex:3067},{level:3,title:"基本属性",slug:"基本属性",normalizedTitle:"基本属性",charIndex:3614},{level:3,title:"标准 URL",slug:"标准-url",normalizedTitle:"标准 url",charIndex:4096},{level:4,title:"绝对网址",slug:"绝对网址",normalizedTitle:"绝对网址",charIndex:4246},{level:4,title:"上下文相关 URL",slug:"上下文相关-url",normalizedTitle:"上下文相关 url",charIndex:4511},{level:4,title:"与服务器相关 URL",slug:"与服务器相关-url",normalizedTitle:"与服务器相关 url",charIndex:4834},{level:4,title:"协议相关 URL",slug:"协议相关-url",normalizedTitle:"协议相关 url",charIndex:5097},{level:4,title:"添加参数",slug:"添加参数",normalizedTitle:"添加参数",charIndex:5361},{level:4,title:"网址片段标识符",slug:"网址片段标识符",normalizedTitle:"网址片段标识符",charIndex:5852},{level:4,title:"URL 重写",slug:"url-重写",normalizedTitle:"url 重写",charIndex:1532},{level:4,title:"URL 其它属性",slug:"url-其它属性",normalizedTitle:"url 其它属性",charIndex:6360},{level:4,title:"在 URL 中使用表达式",slug:"在-url-中使用表达式",normalizedTitle:"在 url 中使用表达式",charIndex:6656},{level:2,title:"扩展",slug:"扩展",normalizedTitle:"扩展",charIndex:7655},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:7668}],headersStr:"标准方言 表达式 变量表达式 选择表达式 消息(i18n)表达式 链接(URL)表达式 片段表达式 表达式预处理 文字和操作 基本属性 标准 URL 绝对网址 上下文相关 URL 与服务器相关 URL 协议相关 URL 添加参数 网址片段标识符 URL 重写 URL 其它属性 在 URL 中使用表达式 扩展 参考资料",content:'# Thymeleaf 快速入门\n\n\n# 标准方言\n\n标准方言是指 Thymeleaf 定义了一组功能，这些功能应该足以满足大多数情况。可以识别这些标准方言在模板中的使用，因为它将包含以th前缀开头的属性，如<span th:text="...">。\n\n\n# 表达式\n\n${...} : 变量表达式。\n\n*{...} : 选择表达式。\n\n#{...} : 消息 (i18n) 表达式。\n\n@{...} : 链接 (URL) 表达式。\n\n~{...} : 片段表达式。\n\n# 变量表达式\n\n变量表达式是 OGNL 表达式 - 如果将 Thymeleaf 与 Spring - 集成在上下文变量上(也称为 Spring 术语中的模型属性)，则为 Spring EL。 它们看起来像这样:\n\n${session.user.name}\n\n\n它们作为属性值或作为它们的一部分，取决于属性:\n\n<span th:text="${book.author.name}"></span>\n\n\n上面的表达式与下面是相同的(在 OGNL 和 SpringEL 中):\n\n((Book)context.getVariable("book")).getAuthor().getName()\n\n\n但是不仅在涉及输出的场景中找到变量表达式，而且还可以使用更复杂的处理方式，如:条件，迭代…等等。\n\n<li th:each="book : ${books}"></li>\n\n\n这里${books}从上下文中选择名为books的变量，并在th:each中使用循环将其评估为迭代器。\n\n# 选择表达式\n\n选择表达式就像变量表达式一样，它们不是整个上下文变量映射上执行，而是在先前选择的对象。 它们看起来像这样:\n\n*{customer.name}\n\n\n它们所作用的对象由th:object属性指定:\n\n<div th:object="${book}">\n  ...\n  <span th:text="*{title}">...</span>\n  ...\n</div>\n\n\n所以这相当于:\n\n{\n  // th:object="${book}"\n  final Book selection = (Book) context.getVariable("book");\n  // th:text="*{title}"\n  output(selection.getTitle());\n}\n\n\n# 消息(i18n)表达式\n\n消息表达式(通常称为文本外部化，国际化或 i18n)允许从外部源(如:.properties)文件中检索特定于语言环境的消息，通过键来引用这引用消息。\n\n在 Spring 应用程序中，它将自动与 Spring 的 MessageSource 机制集成。如下 -\n\n#{main.title}\n#{message.entrycreated(${entryId})}\n\n\n以下是在模板中使用它们的方式:\n\n<table>\n  ...\n  <th th:text="#{header.address.city}">...</th>\n  <th th:text="#{header.address.country}">...</th>\n  ...\n</table>\n\n\n请注意，如果希望消息键由上下文变量的值确定，或者希望将变量指定为参数，则可以在消息表达式中使用变量表达式:\n\n#{${config.adminWelcomeKey}(${session.user.name})} Jsp\n\n\n# 链接(URL)表达式\n\n链接表达式在构建 URL 并向其添加有用的上下文和会话信息(通常称为 URL 重写的过程)。 因此，对于部署在 Web 服务器的/myapp上下文中的 Web 应用程序，可以使用以下表达式:\n\n<a th:href="@{/order/list}">...</a>\n\n\n可以转换成如下的东西:\n\n<a href="/myapp/order/list">...</a>\n\n\n甚至，如果需要保持会话，并且 cookie 未启用(或者服务器还不知道)，那么生成的格式为:\n\n<a href="/myapp/order/list;jsessionid=s2ds3fa31abd241e2a01932">...</a> HTML\n\n\n网址也可以带参数，如下所示:\n\n<a th:href="@{/order/details(id=${orderId},type=${orderType})}">...</a>\n\n\n这将产生类似以下的结果 -\n\n\x3c!-- 注意＆符号会在标签属性中进行HTML转义... --\x3e\n<a href="/myapp/order/details?id=23&type=online">...</a>\n\n\n链接表达式可以是相对的，在这种情况下，应用程序上下文将不会被加到 URL 的前面:\n\n<a th:href="@{../documents/report}">...</a>\n\n\n也是服务器相对的(同样，没有应用程序上下文的前缀):\n\n<a th:href="@{~/contents/main}">...</a>\n\n\n和协议相关(就像绝对 URL 一样，但浏览器将使用与正在显示的页面相同的 HTTP 或 HTTPS 协议):\n\n<a th:href="@{//static.mycompany.com/res/initial}">...</a>\n\n\n当然，链接表达式也可以是绝对的:\n\n<a th:href="@{http://www.mycompany.com/main}">...</a>\n\n\n但是绝对(或协议相对)URL ，在 Thymeleaf 链接表达式中应该添加什么值？ 很简单:由响应过滤器定义 URL 重写:在基于 Servlet 的 Web 应用程序中，对于每个输出的 URL(上下文相对，相对，绝对…)，在显示 URL 之前，Thymeleaf 总是调用HttpServletResponse.encodeUrl(...)机制。 这意味着一个过滤器可以通过包装 HttpServletResponse 对象来为应用程序执行自定义的 URL 重写。\n\n# 片段表达式\n\n片段表达式是一种简单的方法用来表示标记的片段并将其移动到模板中。 由于这些表达式，片段可以被复制，传递给其他模板的参数等等。\n\n最常见的是使用th:insert或th:replace来插入片段:\n\n<div th:insert="~{commons :: main}">...</div>\n\n\n但是它们可以在任何地方使用，就像任何其他变量一样:\n\n<div th:with="frag=~{footer :: #main/text()}">\n  <p th:insert="${frag}"></p>\n</div>\n\n\n片段表达式可以有参数。\n\n# 表达式预处理\n\n关于表达式的最后一件事是知道表达式预处理，在__之间指定，如下所示:\n\n#{selection.__${sel.code}__}\n\n\n上面代码中，第一个被执行的变量表达式是:${sel.code}，并且将使用它的结果作为表达式的一部分(假设${sel.code}的结果为:ALL)，在此处执行国际化的情况下(这将查找与关键selection.ALL消息)。\n\n\n# 文字和操作\n\n有很多类型的文字和操作可用，它们分别如下:\n\n * 文字\n   * 文本文字，例如:\'one text\', \'Another one!\',…\n   * 数字文字，例如:0,10, 314, 31.01, 112.83,…\n   * 布尔文字，例如:true,false\n   * Null 文字，例如:Null\n   * 文字标记，例如:one, sometext, main,…\n * 文本操作:\n   * 字符串连接:+\n   * 文字替换:|The name is ${name}|\n * 算术运算:\n   * 二进制操作:+, -, *, /, %\n   * 减号(一元运算符):-\n * 布尔运算:\n   * 二进制运算符，and,or\n   * 布尔否定(一元运算符):!,not\n * 比较和相等:\n   * 比较运算符:>,<,>=,<=(gt,lt,ge,le)\n   * 相等运算符:==, != (eq, ne)\n * 条件操作符:\n   * If-then:(if) ? (then)\n   * If-then-else:(if) ? (then) : (else)\n   * Default: (value) ?: (defaultvalue)\n\n\n# 基本属性\n\n下面来看看标准方言中的几个最基本的属性。 从th:文本开始，它代替了标签的主体:\n\n<p th:text="#{msg.welcome}">Welcome everyone!</p>\n\n\n现在，th:each重复它所在元素的次数，由它的表达式返回的数组或列表所指定的次数，为迭代元素创建一个内部变量，其语法与 Java 的 foreach 表达式相同:\n\n<li th:each="book : ${books}" th:text="${book.title}">\n  En las Orillas del Sar\n</li>\n\n\n最后，Thymeleaf 为特定的 XHTML 和 HTML5 属性提供了许多th属性，这些属性只评估它们的表达式，并将这些属性的值设置为结果。\n\n<form th:action="@{/createOrder}">\n  <input type="button" th:value="#{form.submit}" />\n  <a th:href="@{/admin/users}"></a>\n</form>\n\n\n\n# 标准 URL\n\nThymeleaf 标准方言(称为 Standard 和 SpringStandard)提供了一种在 Web 应用程序中轻松创建 URL 的方法，以便它们包含任何所需的 URL 工件。 这是通过连接表达方式来完成的，这是一种类似于 Thymeleaf 标准的表现:@{...}\n\n# 绝对网址\n\n绝对 URL 用于创建到其他服务器的链接。它们需要指定一个协议名称(http://或https://)开头。\n\n<a th:href="@{https://www.yiibai.com/thymeleaf/}"></a>\n\n\n上面链接不会被修改，除非在服务器上配置了 URL 重写过滤器，并在HttpServletResponse.encodeUrl(...)方法中执行修改。最后生成的 HTML 代码如下:\n\n<a href="https://www.yiibai.com/thymeleaf/"></a>\n\n\n# 上下文相关 URL\n\n最常用的 URL 类型是上下文相关的。 这些 URL 是一旦安装在服务器上，就会与 Web 应用程序根相关联 URL。 例如，如果将一个名称为myapp.war的文件部署到一个 Tomcat 服务器中，那么应用程序一般是通过 URL:http://localhost:8080/myapp来访问，myapp就是上下文名称。\n\n与上下文相关的 URL 以/字符开头:\n\n<a th:href="@{/order/list}"></a>\n\n\n如果应用程序访问 URL 为:http://localhost:8080/myapp，则此 URL 将输出:\n\n<a href="/myapp/order/list"></a>\n\n\n# 与服务器相关 URL\n\n服务器相关的 URL 与上下文相关的 URL 非常相似，只是它们不假定 URL 要链接到应用程序上下文中的资源，因此允许链接到同一服务器中的不同上下文:\n\n<a th:href="@{~/billing-app/showDetails.html}"></a>\n\n\n当前应用程序的上下文将被忽略，因此尽管应用程序部署在http:// localhost:8080 / myapp，但该 URL 将输出:\n\n<a href="/billing-app/showDetails.html"></a>\n\n\n# 协议相关 URL\n\n与协议相关的 URL 实际上是绝对的 URL，它将保持用于显示当前页面的协议(HTTP，HTTPS)。 它们通常用于包括样式，脚本等外部资源:\n\n<script th:src="@{//scriptserver.example.net/myscript.js}">\n  ...\n<\/script>\n\n\n它将呈现与上面一致的 URL(URL 重写除外)，如:\n\n<script src="//scriptserver.example.net/myscript.js">\n  ...\n<\/script>\n\n\n# 添加参数\n\n如何向使用@{...}表达式创建的 URL 添加参数？ 这也很简单:\n\n<a th:href="@{/order/details(id=3)}"></a>\n\n\n上面示例代码，最终将输出为:\n\n<a href="/order/details?id=3"></a>\n\n\n也可以添加几个参数，用逗号分隔它们:\n\n<a th:href="@{/order/details(id=3,action=\'show_all\')}"></a>\n\n\n上面代码将输出结果为:\n\n\x3c!-- 注意＆符号在标签属性中进行HTML转义... --\x3e\n<a href="/order/details?id=3&action=show_all"></a>\n\n\n还可以使用正常参数的路径变量的形式包含参数，但在 URL 的路径中指定一个占位符:\n\n<a th:href="@{/order/{id}/details(id=3,action=\'show_all\')}"></a>\n\n\n上面输出结果为:\n\n<a href="/order/3/details?action=show_all"></a>\n\n\n# 网址片段标识符\n\n片段标识符可以包含在 URL 中，包含参数和不包含参数。 它们将始终包含在网址的基础上，参考以下代码:\n\n<a th:href="@{/home#all_info(action=\'show\')}"></a>\n\n\n执行输出结果如下 -\n\n<a href="/home?action=show#all_info">\n\n\n# URL 重写\n\nThymeleaf 允许在应用程序中配置 URL 重写过滤器，它通过调用 Thymeleaf 模板生成的每个 URL 的 Servlet API 的javax.servlet.http.HttpServletResponse类中的response.encodeURL()方法来实现。\n\n下面在 Java Web 应用程序中支持 URL 重写操作的标准方式，并允许 URL:\n\n * 自动检测用户是否启用了 Cookie，如果未启用或者如果它是第一个请求并且 cookie 配置仍未知。则将;jsessionid=...片段添加到 URL。\n * 在需要时自动将代理配置应用于 URL。\n * 使用不同的 CDN 设置，以便链接到分布在多个服务器中的内容。\n\n# URL 其它属性\n\n不要以为在@{...}表达式中只有th:href属性来表示 URL 。 事实上，它们可以像变量表达式(${...})或消息外部化/国际化(＃{...})一样用于任何地方。\n\n例如，表单提交时，可使用以下写法 -\n\n<form th:action="@{/order/processOrder}"></form>\n\n\n或作为其他表达的一部分。 如下作为外部化/国际化字符串的参数:\n\n<p\n  th:text="#{orders.explanation(\'3\', @{/order/details(id=3,action=\'show_all\')})}"\n></p>\n\n\n# 在 URL 中使用表达式\n\n下面来看看，如下所示的 URL 表达式:\n\n<a th:href="@{/order/details(id=3,action=\'show_all\')}"></a>\n\n\n但3和\'show_all\'都不能是文字值，因为只有在运行时才能知道它们的值，怎么办？\n\n<a\n  th:href="@{/order/details(id=${order.id},action=(${user.admin} ? \'show_all\' : \'show_public\'))}"\n></a>\n\n\n下面看看另一个 URL 表达式，如下所示:\n\n<a th:href="@{/order/details(id=${order.id})}"></a>\n\n\n它其实是下面 URL 的一个快捷方式:\n\n<a th:href="@{\'/order/details\'(id=${order.id})}"></a>\n\n\n这意味着 URL 基本身可以被指定为一个表达式，例如一个变量表达式:\n\n<a th:href="@{${detailsURL}(id=${order.id})}"></a>\n\n\n或外部化/国际化的文本:\n\n<a th:href="@{#{orders.details.localized_url}(id=${order.id})}"></a>\n\n\n甚至可以使用复杂的表达式，包括条件表达式，例如:\n\n<a\n  th:href="@{(${user.admin}? \'/admin/home\' : ${user.homeUrl})(id=${order.id})}"\n></a>\n\n\n如果要更清洁，那么可以使用th:with :\n\n<a\n  th:with="baseUrl=(${user.admin}? \'/admin/home\' : ${user.homeUrl})"\n  th:href="@{${baseUrl}(id=${order.id})}"\n></a>\n\n\n又或者 -\n\n<div th:with="baseUrl=(${user.admin}? \'/admin/home\' : ${user.homeUrl})">\n  ...\n  <a th:href="@{${baseUrl}(id=${order.id})}">...</a>\n  ...\n</div>\n\n\n\n# 扩展\n\nTODO\n\n\n# 参考资料\n\n * Thymeleaf 官网\n * Thymeleaf Github\n * Thymeleaf 教程',normalizedContent:'# thymeleaf 快速入门\n\n\n# 标准方言\n\n标准方言是指 thymeleaf 定义了一组功能，这些功能应该足以满足大多数情况。可以识别这些标准方言在模板中的使用，因为它将包含以th前缀开头的属性，如<span th:text="...">。\n\n\n# 表达式\n\n${...} : 变量表达式。\n\n*{...} : 选择表达式。\n\n#{...} : 消息 (i18n) 表达式。\n\n@{...} : 链接 (url) 表达式。\n\n~{...} : 片段表达式。\n\n# 变量表达式\n\n变量表达式是 ognl 表达式 - 如果将 thymeleaf 与 spring - 集成在上下文变量上(也称为 spring 术语中的模型属性)，则为 spring el。 它们看起来像这样:\n\n${session.user.name}\n\n\n它们作为属性值或作为它们的一部分，取决于属性:\n\n<span th:text="${book.author.name}"></span>\n\n\n上面的表达式与下面是相同的(在 ognl 和 springel 中):\n\n((book)context.getvariable("book")).getauthor().getname()\n\n\n但是不仅在涉及输出的场景中找到变量表达式，而且还可以使用更复杂的处理方式，如:条件，迭代…等等。\n\n<li th:each="book : ${books}"></li>\n\n\n这里${books}从上下文中选择名为books的变量，并在th:each中使用循环将其评估为迭代器。\n\n# 选择表达式\n\n选择表达式就像变量表达式一样，它们不是整个上下文变量映射上执行，而是在先前选择的对象。 它们看起来像这样:\n\n*{customer.name}\n\n\n它们所作用的对象由th:object属性指定:\n\n<div th:object="${book}">\n  ...\n  <span th:text="*{title}">...</span>\n  ...\n</div>\n\n\n所以这相当于:\n\n{\n  // th:object="${book}"\n  final book selection = (book) context.getvariable("book");\n  // th:text="*{title}"\n  output(selection.gettitle());\n}\n\n\n# 消息(i18n)表达式\n\n消息表达式(通常称为文本外部化，国际化或 i18n)允许从外部源(如:.properties)文件中检索特定于语言环境的消息，通过键来引用这引用消息。\n\n在 spring 应用程序中，它将自动与 spring 的 messagesource 机制集成。如下 -\n\n#{main.title}\n#{message.entrycreated(${entryid})}\n\n\n以下是在模板中使用它们的方式:\n\n<table>\n  ...\n  <th th:text="#{header.address.city}">...</th>\n  <th th:text="#{header.address.country}">...</th>\n  ...\n</table>\n\n\n请注意，如果希望消息键由上下文变量的值确定，或者希望将变量指定为参数，则可以在消息表达式中使用变量表达式:\n\n#{${config.adminwelcomekey}(${session.user.name})} jsp\n\n\n# 链接(url)表达式\n\n链接表达式在构建 url 并向其添加有用的上下文和会话信息(通常称为 url 重写的过程)。 因此，对于部署在 web 服务器的/myapp上下文中的 web 应用程序，可以使用以下表达式:\n\n<a th:href="@{/order/list}">...</a>\n\n\n可以转换成如下的东西:\n\n<a href="/myapp/order/list">...</a>\n\n\n甚至，如果需要保持会话，并且 cookie 未启用(或者服务器还不知道)，那么生成的格式为:\n\n<a href="/myapp/order/list;jsessionid=s2ds3fa31abd241e2a01932">...</a> html\n\n\n网址也可以带参数，如下所示:\n\n<a th:href="@{/order/details(id=${orderid},type=${ordertype})}">...</a>\n\n\n这将产生类似以下的结果 -\n\n\x3c!-- 注意＆符号会在标签属性中进行html转义... --\x3e\n<a href="/myapp/order/details?id=23&type=online">...</a>\n\n\n链接表达式可以是相对的，在这种情况下，应用程序上下文将不会被加到 url 的前面:\n\n<a th:href="@{../documents/report}">...</a>\n\n\n也是服务器相对的(同样，没有应用程序上下文的前缀):\n\n<a th:href="@{~/contents/main}">...</a>\n\n\n和协议相关(就像绝对 url 一样，但浏览器将使用与正在显示的页面相同的 http 或 https 协议):\n\n<a th:href="@{//static.mycompany.com/res/initial}">...</a>\n\n\n当然，链接表达式也可以是绝对的:\n\n<a th:href="@{http://www.mycompany.com/main}">...</a>\n\n\n但是绝对(或协议相对)url ，在 thymeleaf 链接表达式中应该添加什么值？ 很简单:由响应过滤器定义 url 重写:在基于 servlet 的 web 应用程序中，对于每个输出的 url(上下文相对，相对，绝对…)，在显示 url 之前，thymeleaf 总是调用httpservletresponse.encodeurl(...)机制。 这意味着一个过滤器可以通过包装 httpservletresponse 对象来为应用程序执行自定义的 url 重写。\n\n# 片段表达式\n\n片段表达式是一种简单的方法用来表示标记的片段并将其移动到模板中。 由于这些表达式，片段可以被复制，传递给其他模板的参数等等。\n\n最常见的是使用th:insert或th:replace来插入片段:\n\n<div th:insert="~{commons :: main}">...</div>\n\n\n但是它们可以在任何地方使用，就像任何其他变量一样:\n\n<div th:with="frag=~{footer :: #main/text()}">\n  <p th:insert="${frag}"></p>\n</div>\n\n\n片段表达式可以有参数。\n\n# 表达式预处理\n\n关于表达式的最后一件事是知道表达式预处理，在__之间指定，如下所示:\n\n#{selection.__${sel.code}__}\n\n\n上面代码中，第一个被执行的变量表达式是:${sel.code}，并且将使用它的结果作为表达式的一部分(假设${sel.code}的结果为:all)，在此处执行国际化的情况下(这将查找与关键selection.all消息)。\n\n\n# 文字和操作\n\n有很多类型的文字和操作可用，它们分别如下:\n\n * 文字\n   * 文本文字，例如:\'one text\', \'another one!\',…\n   * 数字文字，例如:0,10, 314, 31.01, 112.83,…\n   * 布尔文字，例如:true,false\n   * null 文字，例如:null\n   * 文字标记，例如:one, sometext, main,…\n * 文本操作:\n   * 字符串连接:+\n   * 文字替换:|the name is ${name}|\n * 算术运算:\n   * 二进制操作:+, -, *, /, %\n   * 减号(一元运算符):-\n * 布尔运算:\n   * 二进制运算符，and,or\n   * 布尔否定(一元运算符):!,not\n * 比较和相等:\n   * 比较运算符:>,<,>=,<=(gt,lt,ge,le)\n   * 相等运算符:==, != (eq, ne)\n * 条件操作符:\n   * if-then:(if) ? (then)\n   * if-then-else:(if) ? (then) : (else)\n   * default: (value) ?: (defaultvalue)\n\n\n# 基本属性\n\n下面来看看标准方言中的几个最基本的属性。 从th:文本开始，它代替了标签的主体:\n\n<p th:text="#{msg.welcome}">welcome everyone!</p>\n\n\n现在，th:each重复它所在元素的次数，由它的表达式返回的数组或列表所指定的次数，为迭代元素创建一个内部变量，其语法与 java 的 foreach 表达式相同:\n\n<li th:each="book : ${books}" th:text="${book.title}">\n  en las orillas del sar\n</li>\n\n\n最后，thymeleaf 为特定的 xhtml 和 html5 属性提供了许多th属性，这些属性只评估它们的表达式，并将这些属性的值设置为结果。\n\n<form th:action="@{/createorder}">\n  <input type="button" th:value="#{form.submit}" />\n  <a th:href="@{/admin/users}"></a>\n</form>\n\n\n\n# 标准 url\n\nthymeleaf 标准方言(称为 standard 和 springstandard)提供了一种在 web 应用程序中轻松创建 url 的方法，以便它们包含任何所需的 url 工件。 这是通过连接表达方式来完成的，这是一种类似于 thymeleaf 标准的表现:@{...}\n\n# 绝对网址\n\n绝对 url 用于创建到其他服务器的链接。它们需要指定一个协议名称(http://或https://)开头。\n\n<a th:href="@{https://www.yiibai.com/thymeleaf/}"></a>\n\n\n上面链接不会被修改，除非在服务器上配置了 url 重写过滤器，并在httpservletresponse.encodeurl(...)方法中执行修改。最后生成的 html 代码如下:\n\n<a href="https://www.yiibai.com/thymeleaf/"></a>\n\n\n# 上下文相关 url\n\n最常用的 url 类型是上下文相关的。 这些 url 是一旦安装在服务器上，就会与 web 应用程序根相关联 url。 例如，如果将一个名称为myapp.war的文件部署到一个 tomcat 服务器中，那么应用程序一般是通过 url:http://localhost:8080/myapp来访问，myapp就是上下文名称。\n\n与上下文相关的 url 以/字符开头:\n\n<a th:href="@{/order/list}"></a>\n\n\n如果应用程序访问 url 为:http://localhost:8080/myapp，则此 url 将输出:\n\n<a href="/myapp/order/list"></a>\n\n\n# 与服务器相关 url\n\n服务器相关的 url 与上下文相关的 url 非常相似，只是它们不假定 url 要链接到应用程序上下文中的资源，因此允许链接到同一服务器中的不同上下文:\n\n<a th:href="@{~/billing-app/showdetails.html}"></a>\n\n\n当前应用程序的上下文将被忽略，因此尽管应用程序部署在http:// localhost:8080 / myapp，但该 url 将输出:\n\n<a href="/billing-app/showdetails.html"></a>\n\n\n# 协议相关 url\n\n与协议相关的 url 实际上是绝对的 url，它将保持用于显示当前页面的协议(http，https)。 它们通常用于包括样式，脚本等外部资源:\n\n<script th:src="@{//scriptserver.example.net/myscript.js}">\n  ...\n<\/script>\n\n\n它将呈现与上面一致的 url(url 重写除外)，如:\n\n<script src="//scriptserver.example.net/myscript.js">\n  ...\n<\/script>\n\n\n# 添加参数\n\n如何向使用@{...}表达式创建的 url 添加参数？ 这也很简单:\n\n<a th:href="@{/order/details(id=3)}"></a>\n\n\n上面示例代码，最终将输出为:\n\n<a href="/order/details?id=3"></a>\n\n\n也可以添加几个参数，用逗号分隔它们:\n\n<a th:href="@{/order/details(id=3,action=\'show_all\')}"></a>\n\n\n上面代码将输出结果为:\n\n\x3c!-- 注意＆符号在标签属性中进行html转义... --\x3e\n<a href="/order/details?id=3&action=show_all"></a>\n\n\n还可以使用正常参数的路径变量的形式包含参数，但在 url 的路径中指定一个占位符:\n\n<a th:href="@{/order/{id}/details(id=3,action=\'show_all\')}"></a>\n\n\n上面输出结果为:\n\n<a href="/order/3/details?action=show_all"></a>\n\n\n# 网址片段标识符\n\n片段标识符可以包含在 url 中，包含参数和不包含参数。 它们将始终包含在网址的基础上，参考以下代码:\n\n<a th:href="@{/home#all_info(action=\'show\')}"></a>\n\n\n执行输出结果如下 -\n\n<a href="/home?action=show#all_info">\n\n\n# url 重写\n\nthymeleaf 允许在应用程序中配置 url 重写过滤器，它通过调用 thymeleaf 模板生成的每个 url 的 servlet api 的javax.servlet.http.httpservletresponse类中的response.encodeurl()方法来实现。\n\n下面在 java web 应用程序中支持 url 重写操作的标准方式，并允许 url:\n\n * 自动检测用户是否启用了 cookie，如果未启用或者如果它是第一个请求并且 cookie 配置仍未知。则将;jsessionid=...片段添加到 url。\n * 在需要时自动将代理配置应用于 url。\n * 使用不同的 cdn 设置，以便链接到分布在多个服务器中的内容。\n\n# url 其它属性\n\n不要以为在@{...}表达式中只有th:href属性来表示 url 。 事实上，它们可以像变量表达式(${...})或消息外部化/国际化(＃{...})一样用于任何地方。\n\n例如，表单提交时，可使用以下写法 -\n\n<form th:action="@{/order/processorder}"></form>\n\n\n或作为其他表达的一部分。 如下作为外部化/国际化字符串的参数:\n\n<p\n  th:text="#{orders.explanation(\'3\', @{/order/details(id=3,action=\'show_all\')})}"\n></p>\n\n\n# 在 url 中使用表达式\n\n下面来看看，如下所示的 url 表达式:\n\n<a th:href="@{/order/details(id=3,action=\'show_all\')}"></a>\n\n\n但3和\'show_all\'都不能是文字值，因为只有在运行时才能知道它们的值，怎么办？\n\n<a\n  th:href="@{/order/details(id=${order.id},action=(${user.admin} ? \'show_all\' : \'show_public\'))}"\n></a>\n\n\n下面看看另一个 url 表达式，如下所示:\n\n<a th:href="@{/order/details(id=${order.id})}"></a>\n\n\n它其实是下面 url 的一个快捷方式:\n\n<a th:href="@{\'/order/details\'(id=${order.id})}"></a>\n\n\n这意味着 url 基本身可以被指定为一个表达式，例如一个变量表达式:\n\n<a th:href="@{${detailsurl}(id=${order.id})}"></a>\n\n\n或外部化/国际化的文本:\n\n<a th:href="@{#{orders.details.localized_url}(id=${order.id})}"></a>\n\n\n甚至可以使用复杂的表达式，包括条件表达式，例如:\n\n<a\n  th:href="@{(${user.admin}? \'/admin/home\' : ${user.homeurl})(id=${order.id})}"\n></a>\n\n\n如果要更清洁，那么可以使用th:with :\n\n<a\n  th:with="baseurl=(${user.admin}? \'/admin/home\' : ${user.homeurl})"\n  th:href="@{${baseurl}(id=${order.id})}"\n></a>\n\n\n又或者 -\n\n<div th:with="baseurl=(${user.admin}? \'/admin/home\' : ${user.homeurl})">\n  ...\n  <a th:href="@{${baseurl}(id=${order.id})}">...</a>\n  ...\n</div>\n\n\n\n# 扩展\n\ntodo\n\n\n# 参考资料\n\n * thymeleaf 官网\n * thymeleaf github\n * thymeleaf 教程',charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Velocity 快速入门",frontmatter:{title:"Velocity 快速入门",date:"2022-02-17T22:34:30.000Z",order:3,categories:["Java","工具","模板引擎"],tags:["Java","模板引擎","Velocity"],permalink:"/pages/3ba0ff/"},regularPath:"/01.Java/12.%E5%B7%A5%E5%85%B7/03.%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/03.Velocity.html",relativePath:"01.Java/12.工具/03.模板引擎/03.Velocity.md",key:"v-f62f42f0",path:"/pages/3ba0ff/",headers:[{level:2,title:"注释",slug:"注释",normalizedTitle:"注释",charIndex:247},{level:2,title:"引用",slug:"引用",normalizedTitle:"引用",charIndex:64},{level:3,title:"变量",slug:"变量",normalizedTitle:"变量",charIndex:667},{level:3,title:"属性",slug:"属性",normalizedTitle:"属性",charIndex:670},{level:3,title:"方法",slug:"方法",normalizedTitle:"方法",charIndex:78},{level:2,title:"赋值",slug:"赋值",normalizedTitle:"赋值",charIndex:947},{level:2,title:"字符串",slug:"字符串",normalizedTitle:"字符串",charIndex:1802},{level:2,title:"条件",slug:"条件",normalizedTitle:"条件",charIndex:1952},{level:2,title:"逻辑",slug:"逻辑",normalizedTitle:"逻辑",charIndex:2192},{level:2,title:"循环",slug:"循环",normalizedTitle:"循环",charIndex:2401},{level:2,title:"包含",slug:"包含",normalizedTitle:"包含",charIndex:2507},{level:2,title:"解析",slug:"解析",normalizedTitle:"解析",charIndex:1832},{level:2,title:"停止",slug:"停止",normalizedTitle:"停止",charIndex:2818},{level:2,title:"宏",slug:"宏",normalizedTitle:"宏",charIndex:2873},{level:2,title:"转义",slug:"转义",normalizedTitle:"转义",charIndex:3566},{level:2,title:"语义要点",slug:"语义要点",normalizedTitle:"语义要点",charIndex:3712},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:4105}],headersStr:"注释 引用 变量 属性 方法 赋值 字符串 条件 逻辑 循环 包含 解析 停止 宏 转义 语义要点 参考资料",content:'# Velocity 快速入门\n\nVelocity （简称 VTL）是一个基于 Java 的模版引擎。它允许 web 页面设计者引用 JAVA 代码预定义的方法。Web 设计者可以根据 MVC 模式和 JAVA 程序员并行工作，这意味着 Web 设计者可以单独专注于设计良好的站点，而程序员则可单独专注于编写底层代码。Velocity 将 Java 代码从 web 页面中分离出来，使站点在长时间运行后仍然具有很好的可维护性，并提供了一个除 JSP 和 PHP 之外的可行的被选方案。\n\n\n# 注释\n\n单行注释以##开始，并在本行结束。\n\n## This is a single line comment.\n\n\n多行注释，以 # 开始并以 # 结束可以处理这种情况。\n\n#*\n Thus begins a multi-line comment. Online visitors won\'t\n see this text because the Velocity Templating Engine will\n ignore it.\n*#\n\n\n注释块 ，可以用来存储诸如文档作者、版本信息等。\n\n#**\nThis is a VTL comment block and\nmay be used to store such information\nas the document author and versioning\ninformation:\n@author\n@version 5\n*#\n\n\n\n# 引用\n\nVTL 中有三种类型的引用：变量，属性和方法。\n\n\n# 变量\n\n变量（Variables）的简略标记是有一个前导 $ 字符后跟一个 VTL 标识符（Identifier.）组成。一个 VTL 标识符必须以一个字母开始(a .. z 或 A .. Z)。\n\n剩下的字符将由以下类型的字符组成：\n\n * 字母 (a .. z, A .. Z)\n * 数字 (0 .. 9)\n * 连字符("-")\n * 下划线 ("_")\n\n示例：有效变量\n\n## 有效变量变量名\n$foo\n$mudSlinger\n$mud-slinger\n$mud_slinger\n$mudSlinger1\n\n## 给变量赋值\n#set( $foo = "bar" )\n\n\n\n# 属性\n\nVTL 引用的第二种元素是属性，而属性具有独特的格式。属性的简略标记识前导符 $ 后跟一个 VTL 标识符，在后跟一个点号(".")最后又是一个 VTL 标识符。\n\n示例：有效属性\n\n$customer.Address\n$purchase.Total\n\n\n\n# 方法\n\n方法在 JAVA 代码中定义，并作一些有用的事情，比如运行一个计算器或者作出一个决定。方法是实际上也是引用，由前导符 $ 后跟一个 VTL 标识符，后跟一个 VTL 方法体（Method Body）。 VTL 方法体由一个 VTL 标识符后跟一个左括号，再跟可选的参数列表，最后是右括号。\n\n示例：有效方法\n\n$customer.getAddress()\n$purchase.getTotal()\n$page.setTitle( "My Home Page" )\n$person.setAttributes( ["Strange", "Weird", "Excited"] )\n\n\n\n# 赋值\n\n#set 指令用来为引用设置相应的值。值可以被值派给变量引用或者是属性引用，而且赋值要在括号里括起来。\n\n#set( $monkey = $bill ) ## variable reference\n#set( $monkey.Friend = "monica" ) ## string literal\n#set( $monkey.Blame = $whitehouse.Leak ) ## property reference\n#set( $monkey.Plan = $spindoctor.weave($web) ) ## method reference\n#set( $monkey.Number = 123 ) ##number literal\n#set( $monkey.Say = ["Not", $my, "fault"] ) ## ArrayList\n\n\n\n# 字符串\n\n使用 #set 指令时，括在双引号中的字面字符串将解析和重新解释 。 然而，当字面字符串括在单引号中时，不被解析：\n\n示例：\n\n#set( $foo = "bar" )\n$foo\n#set( $blargh = \'$foo\' )\n$blargh\n\n\n输出：\n\nBar\n $foo\n\n\n\n# 条件\n\nVTL 使用 #If、#elseif、#else 指令做条件语句控制。\n\n示例：\n\n#if( $foo < 10 )\n    <strong>Go North</strong>\n#elseif( $foo == 10 )\n    <strong>Go East</strong>\n#elseif( $bar == 6 )\n    <strong>Go South</strong>\n#else\n    <strong>Go West</strong>\n#end\n\n\n\n# 逻辑\n\nVTL 支持与（&&）、或（||）、非（!）逻辑判断。\n\n示例：\n\n#if( $foo && $bar )\n   <strong> This AND that</strong>\n#end\n\n#if( $foo || $bar )\n    <strong>This or That</strong>\n#end\n\n#if( !$foo )\n <strong>NOT that</strong>\n#end\n\n\n\n# 循环\n\nVTL 通过 #foreach 支持循环\n\n<ul>\n#foreach( $product in $allProducts )\n    <li>$product</li>\n#end\n</ul>\n\n\n\n# 包含\n\nVTL 通过 #include 来导入其他文件。\n\n示例：\n\n#include( "one.txt" )\n\n#include( "one.gif","two.txt","three.htm" )\n\n#include( "greetings.txt", $seasonalstock )\n\n\n\n# 解析\n\nVTL 通过 #parse 导入其他 vm 文件。\n\n$count\n#set( $count = $count - 1 )\n#if( $count > 0 )\n    #parse( "parsefoo.vm" )\n#else\n    All done with parsefoo.vm!\n#end\n\n\n\n# 停止\n\nVTL 使用 #stop 停止模板引擎的执行，并返回。这通常用作调试。\n\n#stop ##\n\n\n\n# 宏\n\nVTL 使用 #macro 和 #end 配合来定义宏，以此实现自定义指令。\n\n示例一：\n\n## 定义宏\n#macro( d )\n<tr><td></td></tr>\n#end\n\n## 使用宏\n#d()\n\n\n示例二：\n\n## 定义宏\n#macro( tablerows $color $somelist )\n  #foreach( $something in $somelist )\n    <tr><td bgcolor=$color>$something</td></tr>\n  #end\n#end\n\n## 使用宏\n#set( $greatlakes = ["Superior","Michigan","Huron","Erie","Ontario"] )\n#set( $color = "blue" )\n<table>\n    #tablerows( $color $greatlakes )\n</table>\n\n\n输出：\n\n<table>\n  <tr>\n    <td bgcolor="blue">Superior</td>\n  </tr>\n  <tr>\n    <td bgcolor="blue">Michigan</td>\n  </tr>\n  <tr>\n    <td bgcolor="blue">Huron</td>\n  </tr>\n  <tr>\n    <td bgcolor="blue">Erie</td>\n  </tr>\n  <tr>\n    <td bgcolor="blue">Ontario</td>\n  </tr>\n</table>\n\n\n\n# 转义\n\nVTL 使用 \\ 符号来进行字符转义。\n\n示例一\n\n## The following line defines $email in this template:\n#set( $email = "foo" )\n$email\n\\$email\n\n\n输出：\n\nfoo\n$email\n\n\n\n# 语义要点\n\nVelocity 有一些语义要点，容易产生歧义，这里归纳一下。\n\n（1）Velocity 的行为并不受空格的影响。\n\n示例：以下三种写法效果一致\n\n## 写法一\nSend me #set($foo = ["$10 and ","a cake"])#foreach($a in $foo)$a #end please.\n\n## 写法二\nSend me\n#set( $foo = ["$10 and ","a cake"] )\n#foreach( $a in $foo )\n$a\n#end\nplease.\n\n## 写法三\nSend me\n#set($foo       = ["$10 and ","a cake"])\n                 #foreach           ($a in $foo )$a\n         #end please.\n\n\n\n# 参考资料\n\n * Velocity Github\n * Velocity 官网\n * Velocity 中文文档\n * velocity-spring-boot-project',normalizedContent:'# velocity 快速入门\n\nvelocity （简称 vtl）是一个基于 java 的模版引擎。它允许 web 页面设计者引用 java 代码预定义的方法。web 设计者可以根据 mvc 模式和 java 程序员并行工作，这意味着 web 设计者可以单独专注于设计良好的站点，而程序员则可单独专注于编写底层代码。velocity 将 java 代码从 web 页面中分离出来，使站点在长时间运行后仍然具有很好的可维护性，并提供了一个除 jsp 和 php 之外的可行的被选方案。\n\n\n# 注释\n\n单行注释以##开始，并在本行结束。\n\n## this is a single line comment.\n\n\n多行注释，以 # 开始并以 # 结束可以处理这种情况。\n\n#*\n thus begins a multi-line comment. online visitors won\'t\n see this text because the velocity templating engine will\n ignore it.\n*#\n\n\n注释块 ，可以用来存储诸如文档作者、版本信息等。\n\n#**\nthis is a vtl comment block and\nmay be used to store such information\nas the document author and versioning\ninformation:\n@author\n@version 5\n*#\n\n\n\n# 引用\n\nvtl 中有三种类型的引用：变量，属性和方法。\n\n\n# 变量\n\n变量（variables）的简略标记是有一个前导 $ 字符后跟一个 vtl 标识符（identifier.）组成。一个 vtl 标识符必须以一个字母开始(a .. z 或 a .. z)。\n\n剩下的字符将由以下类型的字符组成：\n\n * 字母 (a .. z, a .. z)\n * 数字 (0 .. 9)\n * 连字符("-")\n * 下划线 ("_")\n\n示例：有效变量\n\n## 有效变量变量名\n$foo\n$mudslinger\n$mud-slinger\n$mud_slinger\n$mudslinger1\n\n## 给变量赋值\n#set( $foo = "bar" )\n\n\n\n# 属性\n\nvtl 引用的第二种元素是属性，而属性具有独特的格式。属性的简略标记识前导符 $ 后跟一个 vtl 标识符，在后跟一个点号(".")最后又是一个 vtl 标识符。\n\n示例：有效属性\n\n$customer.address\n$purchase.total\n\n\n\n# 方法\n\n方法在 java 代码中定义，并作一些有用的事情，比如运行一个计算器或者作出一个决定。方法是实际上也是引用，由前导符 $ 后跟一个 vtl 标识符，后跟一个 vtl 方法体（method body）。 vtl 方法体由一个 vtl 标识符后跟一个左括号，再跟可选的参数列表，最后是右括号。\n\n示例：有效方法\n\n$customer.getaddress()\n$purchase.gettotal()\n$page.settitle( "my home page" )\n$person.setattributes( ["strange", "weird", "excited"] )\n\n\n\n# 赋值\n\n#set 指令用来为引用设置相应的值。值可以被值派给变量引用或者是属性引用，而且赋值要在括号里括起来。\n\n#set( $monkey = $bill ) ## variable reference\n#set( $monkey.friend = "monica" ) ## string literal\n#set( $monkey.blame = $whitehouse.leak ) ## property reference\n#set( $monkey.plan = $spindoctor.weave($web) ) ## method reference\n#set( $monkey.number = 123 ) ##number literal\n#set( $monkey.say = ["not", $my, "fault"] ) ## arraylist\n\n\n\n# 字符串\n\n使用 #set 指令时，括在双引号中的字面字符串将解析和重新解释 。 然而，当字面字符串括在单引号中时，不被解析：\n\n示例：\n\n#set( $foo = "bar" )\n$foo\n#set( $blargh = \'$foo\' )\n$blargh\n\n\n输出：\n\nbar\n $foo\n\n\n\n# 条件\n\nvtl 使用 #if、#elseif、#else 指令做条件语句控制。\n\n示例：\n\n#if( $foo < 10 )\n    <strong>go north</strong>\n#elseif( $foo == 10 )\n    <strong>go east</strong>\n#elseif( $bar == 6 )\n    <strong>go south</strong>\n#else\n    <strong>go west</strong>\n#end\n\n\n\n# 逻辑\n\nvtl 支持与（&&）、或（||）、非（!）逻辑判断。\n\n示例：\n\n#if( $foo && $bar )\n   <strong> this and that</strong>\n#end\n\n#if( $foo || $bar )\n    <strong>this or that</strong>\n#end\n\n#if( !$foo )\n <strong>not that</strong>\n#end\n\n\n\n# 循环\n\nvtl 通过 #foreach 支持循环\n\n<ul>\n#foreach( $product in $allproducts )\n    <li>$product</li>\n#end\n</ul>\n\n\n\n# 包含\n\nvtl 通过 #include 来导入其他文件。\n\n示例：\n\n#include( "one.txt" )\n\n#include( "one.gif","two.txt","three.htm" )\n\n#include( "greetings.txt", $seasonalstock )\n\n\n\n# 解析\n\nvtl 通过 #parse 导入其他 vm 文件。\n\n$count\n#set( $count = $count - 1 )\n#if( $count > 0 )\n    #parse( "parsefoo.vm" )\n#else\n    all done with parsefoo.vm!\n#end\n\n\n\n# 停止\n\nvtl 使用 #stop 停止模板引擎的执行，并返回。这通常用作调试。\n\n#stop ##\n\n\n\n# 宏\n\nvtl 使用 #macro 和 #end 配合来定义宏，以此实现自定义指令。\n\n示例一：\n\n## 定义宏\n#macro( d )\n<tr><td></td></tr>\n#end\n\n## 使用宏\n#d()\n\n\n示例二：\n\n## 定义宏\n#macro( tablerows $color $somelist )\n  #foreach( $something in $somelist )\n    <tr><td bgcolor=$color>$something</td></tr>\n  #end\n#end\n\n## 使用宏\n#set( $greatlakes = ["superior","michigan","huron","erie","ontario"] )\n#set( $color = "blue" )\n<table>\n    #tablerows( $color $greatlakes )\n</table>\n\n\n输出：\n\n<table>\n  <tr>\n    <td bgcolor="blue">superior</td>\n  </tr>\n  <tr>\n    <td bgcolor="blue">michigan</td>\n  </tr>\n  <tr>\n    <td bgcolor="blue">huron</td>\n  </tr>\n  <tr>\n    <td bgcolor="blue">erie</td>\n  </tr>\n  <tr>\n    <td bgcolor="blue">ontario</td>\n  </tr>\n</table>\n\n\n\n# 转义\n\nvtl 使用 \\ 符号来进行字符转义。\n\n示例一\n\n## the following line defines $email in this template:\n#set( $email = "foo" )\n$email\n\\$email\n\n\n输出：\n\nfoo\n$email\n\n\n\n# 语义要点\n\nvelocity 有一些语义要点，容易产生歧义，这里归纳一下。\n\n（1）velocity 的行为并不受空格的影响。\n\n示例：以下三种写法效果一致\n\n## 写法一\nsend me #set($foo = ["$10 and ","a cake"])#foreach($a in $foo)$a #end please.\n\n## 写法二\nsend me\n#set( $foo = ["$10 and ","a cake"] )\n#foreach( $a in $foo )\n$a\n#end\nplease.\n\n## 写法三\nsend me\n#set($foo       = ["$10 and ","a cake"])\n                 #foreach           ($a in $foo )$a\n         #end please.\n\n\n\n# 参考资料\n\n * velocity github\n * velocity 官网\n * velocity 中文文档\n * velocity-spring-boot-project',charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Java 模板引擎",frontmatter:{title:"Java 模板引擎",date:"2022-02-17T22:34:30.000Z",categories:["Java","工具","模板引擎"],tags:["Java","模板引擎"],permalink:"/pages/9d37fa/",hidden:!0,index:!1},regularPath:"/01.Java/12.%E5%B7%A5%E5%85%B7/03.%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/",relativePath:"01.Java/12.工具/03.模板引擎/README.md",key:"v-19120fca",path:"/pages/9d37fa/",headers:[{level:2,title:"内容",slug:"内容",normalizedTitle:"内容",charIndex:60},{level:2,title:"资源",slug:"资源",normalizedTitle:"资源",charIndex:342}],headersStr:"内容 资源",content:"# Java 模板引擎\n\n模板引擎不属于特定技术领域，它是跨领域跨平台的概念。 模板引擎的作用就是分离业务数据和最终呈现内容，它可以生成特定格式的文档（模板） 。\n\n模板引擎简单来说，就是：模板 + 数据模型 = 输出\n\n较早，也比较经典的模板引擎是 JavaEE 的标准技术 JSP。\n\n但 JSP 存在以下缺点，导致逐渐被淘汰：\n\n * 性能差\n   * JSP 本质上是 Servlet，第一次请求 JSP 页面，必须要在 web 服务器中编译成 servlet，所以第一次响应较慢。\n   * 每次请求 JSP 都是访问 servlet 再用输出流输出的 html 页面。\n   * JSP 中的内容很多，页面响应会很慢，因为是同步加载。\n * 无法前后端分离\n   * 动态资源和静态资源全部耦合在一起，无法做到前后端分离。一旦服务器出现状况，前后台一起玩完。\n   * 而且 Java 工程师既当爹又当妈，又要维护 Java 代码，又要维护 JSP 代码，痛苦。\n   * 前端工程师如果不理解 JSP 语法，面对各种 JSP 标签、表达式、指令，会一脸懵逼，痛苦。\n * 不是所有服务器都支持 - JSP 必须要在支持 JSP 技术的 web 服务器里运行（如 Tomcat）。但有些服务器则不支持 JSP ，如 Nginx。\n\n在 Java 领域，目前最常见的模板引擎就是：\n\n * Freemark\n * Thymeleaf\n * Velocity\n\n\n# 内容\n\n * Freemark\n * Thymeleaf\n * Velocity\n\n\n# 资源\n\n * Freemark\n   * Freemark Github\n   * Freemark 中文教程\n   * 在线 Freemark 工具\n * Velocity\n   * Velocity Github\n   * Velocity 官网\n   * Velocity 中文文档\n   * velocity-spring-boot-project",normalizedContent:"# java 模板引擎\n\n模板引擎不属于特定技术领域，它是跨领域跨平台的概念。 模板引擎的作用就是分离业务数据和最终呈现内容，它可以生成特定格式的文档（模板） 。\n\n模板引擎简单来说，就是：模板 + 数据模型 = 输出\n\n较早，也比较经典的模板引擎是 javaee 的标准技术 jsp。\n\n但 jsp 存在以下缺点，导致逐渐被淘汰：\n\n * 性能差\n   * jsp 本质上是 servlet，第一次请求 jsp 页面，必须要在 web 服务器中编译成 servlet，所以第一次响应较慢。\n   * 每次请求 jsp 都是访问 servlet 再用输出流输出的 html 页面。\n   * jsp 中的内容很多，页面响应会很慢，因为是同步加载。\n * 无法前后端分离\n   * 动态资源和静态资源全部耦合在一起，无法做到前后端分离。一旦服务器出现状况，前后台一起玩完。\n   * 而且 java 工程师既当爹又当妈，又要维护 java 代码，又要维护 jsp 代码，痛苦。\n   * 前端工程师如果不理解 jsp 语法，面对各种 jsp 标签、表达式、指令，会一脸懵逼，痛苦。\n * 不是所有服务器都支持 - jsp 必须要在支持 jsp 技术的 web 服务器里运行（如 tomcat）。但有些服务器则不支持 jsp ，如 nginx。\n\n在 java 领域，目前最常见的模板引擎就是：\n\n * freemark\n * thymeleaf\n * velocity\n\n\n# 内容\n\n * freemark\n * thymeleaf\n * velocity\n\n\n# 资源\n\n * freemark\n   * freemark github\n   * freemark 中文教程\n   * 在线 freemark 工具\n * velocity\n   * velocity github\n   * velocity 官网\n   * velocity 中文文档\n   * velocity-spring-boot-project",charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"JUnit5 快速入门",frontmatter:{title:"JUnit5 快速入门",date:"2022-02-17T22:34:30.000Z",order:1,categories:["Java","工具","测试"],tags:["Java","测试","JUnit"],permalink:"/pages/b39f47/"},regularPath:"/01.Java/12.%E5%B7%A5%E5%85%B7/04.%E6%B5%8B%E8%AF%95/01.Junit.html",relativePath:"01.Java/12.工具/04.测试/01.Junit.md",key:"v-5cda01e4",path:"/pages/b39f47/",headers:[{level:2,title:"JUnit5 简介",slug:"junit5-简介",normalizedTitle:"junit5 简介",charIndex:18},{level:2,title:"JUnit5 安装",slug:"junit5-安装",normalizedTitle:"junit5 安装",charIndex:514},{level:2,title:"JUnit5 注解",slug:"junit5-注解",normalizedTitle:"junit5 注解",charIndex:1248},{level:2,title:"JUnit5 示例",slug:"junit5-示例",normalizedTitle:"junit5 示例",charIndex:5251},{level:3,title:"基本的单元测试类和方法",slug:"基本的单元测试类和方法",normalizedTitle:"基本的单元测试类和方法",charIndex:5440},{level:3,title:"定制测试类和方法的显示名称",slug:"定制测试类和方法的显示名称",normalizedTitle:"定制测试类和方法的显示名称",charIndex:6394},{level:3,title:"断言（Assertions）",slug:"断言-assertions",normalizedTitle:"断言（assertions）",charIndex:6879},{level:3,title:"假想（Assumptions）",slug:"假想-assumptions",normalizedTitle:"假想（assumptions）",charIndex:10650},{level:3,title:"禁用",slug:"禁用",normalizedTitle:"禁用",charIndex:11612},{level:3,title:"测试条件",slug:"测试条件",normalizedTitle:"测试条件",charIndex:12022},{level:4,title:"操作系统条件",slug:"操作系统条件",normalizedTitle:"操作系统条件",charIndex:12030},{level:4,title:"Java 运行时版本条件",slug:"java-运行时版本条件",normalizedTitle:"java 运行时版本条件",charIndex:12394},{level:4,title:"系统属性条件",slug:"系统属性条件",normalizedTitle:"系统属性条件",charIndex:12613},{level:3,title:"嵌套测试",slug:"嵌套测试",normalizedTitle:"嵌套测试",charIndex:12851},{level:3,title:"重复测试",slug:"重复测试",normalizedTitle:"重复测试",charIndex:15162},{level:3,title:"参数化测试",slug:"参数化测试",normalizedTitle:"参数化测试",charIndex:16874},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:17061}],headersStr:"JUnit5 简介 JUnit5 安装 JUnit5 注解 JUnit5 示例 基本的单元测试类和方法 定制测试类和方法的显示名称 断言（Assertions） 假想（Assumptions） 禁用 测试条件 操作系统条件 Java 运行时版本条件 系统属性条件 嵌套测试 重复测试 参数化测试 参考资料",content:'# JUnit5 快速入门\n\n\n# JUnit5 简介\n\n与以前的 JUnit 版本不同，JUnit 5 由来自三个不同子项目的几个不同模块组成。\n\nJUnit 5 = JUnit Platform + JUnit Jupiter + JUnit Vintage\n\nJUnit Platform 是在 JVM 上启动测试框架的基础。它还定义了用于开发在平台上运行的测试框架的 TestEngine API。此外，该平台还提供了一个控制台启动器，用于从命令行启动平台，并提供 JUnit 平台套件引擎，用于使用平台上的一个或多个测试引擎运行自定义测试套件。\n\nJUnit Jupiter 是编程模型和扩展模型的组合，用于在 JUnit 5 中编写测试和扩展。Jupiter 子项目提供了一个 测试引擎（TestEngine ）用于在平台上运行基于 Jupiter 的测试。\n\nJUnit Vintage 提供了一个测试引擎（TestEngine ），用于在平台上运行基于 JUnit 3 和 JUnit 4 的测试。它要求 JUnit 4.12 或更高版本。\n\nJUnit 5 在运行时需要 Java 8（或更高版本）。\n\n\n# JUnit5 安装\n\n在 pom 中添加依赖\n\n<properties>\n  <junit.jupiter.version>5.3.2</junit.jupiter.version>\n</properties>\n\n<dependencies>\n  <dependency>\n    <groupId>org.junit.jupiter</groupId>\n    <artifactId>junit-jupiter-api</artifactId>\n    <version>${junit.jupiter.version}</version>\n    <scope>test</scope>\n  </dependency>\n  <dependency>\n    <groupId>org.junit.jupiter</groupId>\n    <artifactId>junit-jupiter-params</artifactId>\n    <version>${junit.jupiter.version}</version>\n    <scope>test</scope>\n  </dependency>\n  <dependency>\n    <groupId>org.junit.jupiter</groupId>\n    <artifactId>junit-jupiter-engine</artifactId>\n    <version>${junit.jupiter.version}</version>\n    <scope>test</scope>\n  </dependency>\n</dependencies>\n\n\n组件间依赖关系：\n\n\n\n\n# JUnit5 注解\n\nANNOTATION           DESCRIPTION\n@Test                Denotes that a method is a test method. Unlike JUnit 4’s\n                     @Test annotation, this annotation does not declare any\n                     attributes, since test extensions in JUnit Jupiter operate\n                     based on their own dedicated annotations. Such methods are\n                     inherited unless they are overridden.\n@ParameterizedTest   Denotes that a method is a parameterized test. Such methods\n                     are inherited unless they are overridden.\n@RepeatedTest        Denotes that a method is a test template for a repeated\n                     test. Such methods are inherited unless they are overridden.\n@TestFactory         Denotes that a method is a test factory for dynamic tests.\n                     Such methods are inherited unless they are overridden.\n@TestInstance        Used to configure the test instance lifecycle for the\n                     annotated test class. Such annotations are inherited.\n@TestTemplate        Denotes that a method is a template for test cases designed\n                     to be invoked multiple times depending on the number of\n                     invocation contexts returned by the registered providers.\n                     Such methods are inherited unless they are overridden.\n@DisplayName         Declares a custom display name for the test class or test\n                     method. Such annotations are not inherited.\n@BeforeEach          Denotes that the annotated method should be executed before\n                     each @Test, @RepeatedTest, @ParameterizedTest, or\n                     @TestFactory method in the current class; analogous to JUnit\n                     4’s @Before. Such methods are inherited unless they are\n                     overridden.\n@AfterEach           Denotes that the annotated method should be executed after\n                     each @Test, @RepeatedTest, @ParameterizedTest, or\n                     @TestFactory method in the current class; analogous to JUnit\n                     4’s @After. Such methods are inherited unless they are\n                     overridden.\n@BeforeAll           Denotes that the annotated method should be executed before\n                     all @Test, @RepeatedTest, @ParameterizedTest, and\n                     @TestFactory methods in the current class; analogous to\n                     JUnit 4’s @BeforeClass. Such methods are inherited (unless\n                     they are hidden or overridden) and must be static (unless\n                     the "per-class" test instance lifecycle is used).\n@AfterAll            Denotes that the annotated method should be executed after\n                     all @Test, @RepeatedTest, @ParameterizedTest, and\n                     @TestFactory methods in the current class; analogous to\n                     JUnit 4’s @AfterClass. Such methods are inherited (unless\n                     they are hidden or overridden) and must be static (unless\n                     the "per-class" test instance lifecycle is used).\n@Nested              Denotes that the annotated class is a nested, non-static\n                     test class. @BeforeAll and @AfterAllmethods cannot be used\n                     directly in a @Nested test class unless the "per-class" test\n                     instance lifecycle is used. Such annotations are not\n                     inherited.\n@Tag                 Used to declare tags for filtering tests, either at the\n                     class or method level; analogous to test groups in TestNG or\n                     Categories in JUnit 4. Such annotations are inherited at the\n                     class level but not at the method level.\n@Disabled            Used to disable a test class or test method; analogous to\n                     JUnit 4’s @Ignore. Such annotations are not inherited.\n@ExtendWith          Used to register custom extensions. Such annotations are\n                     inherited.\n\n\n# JUnit5 示例\n\n> 我将一部分官方示例放在了我的个人项目中，可以直接下载测试。\n> \n> 示例源码路径：https://github.com/dunwu/java-tutorial/tree/master/codes/javatech/javatech-lib/src/test/java/io/github/dunwu/javatech/test/junit5\n\n\n# 基本的单元测试类和方法\n\nimport org.junit.jupiter.api.*;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nclass Junit5StandardTests {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(Junit5StandardTests.class);\n\n    @BeforeAll\n    static void beforeAll() {\n        LOGGER.info("call beforeAll()");\n    }\n\n    @BeforeEach\n    void beforeEach() {\n        LOGGER.info("call beforeEach()");\n    }\n\n    @Test\n    void succeedingTest() {\n        LOGGER.info("call succeedingTest()");\n    }\n\n    @Test\n    void failingTest() {\n        LOGGER.info("call failingTest()");\n        // fail("a failing test");\n    }\n\n    @Test\n    @Disabled("for demonstration purposes")\n    void skippedTest() {\n        LOGGER.info("call skippedTest()");\n        // not executed\n    }\n\n    @AfterEach\n    void afterEach() {\n        LOGGER.info("call afterEach()");\n    }\n\n    @AfterAll\n    static void afterAll() {\n        LOGGER.info("call afterAll()");\n    }\n}\n\n\n\n# 定制测试类和方法的显示名称\n\n支持普通字符、特殊符号、emoji\n\nimport org.junit.jupiter.api.DisplayName;\nimport org.junit.jupiter.api.Test;\n\n@DisplayName("A special test case")\nclass JunitDisplayNameDemo {\n\n    @Test\n    @DisplayName("Custom test name containing spaces")\n    void testWithDisplayNameContainingSpaces() { }\n\n    @Test\n    @DisplayName("╯°□°）╯")\n    void testWithDisplayNameContainingSpecialCharacters() { }\n\n    @Test\n    @DisplayName("😱")\n    void testWithDisplayNameContainingEmoji() { }\n}\n\n\n\n# 断言（Assertions）\n\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.Test;\n\nimport static java.time.Duration.ofMillis;\nimport static java.time.Duration.ofMinutes;\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass AssertionsDemo {\n\n    private static Person person;\n\n    @BeforeAll\n    public static void beforeAll() {\n        person = new Person("John", "Doe");\n    }\n\n    @Test\n    void standardAssertions() {\n        assertEquals(2, 2);\n        assertEquals(4, 4, "The optional assertion message is now the last parameter.");\n        assertTrue(\'a\' < \'b\', () -> "Assertion messages can be lazily evaluated -- "\n            + "to avoid constructing complex messages unnecessarily.");\n    }\n\n    @Test\n    void groupedAssertions() {\n        // In a grouped assertion all assertions are executed, and any\n        // failures will be reported together.\n        assertAll("person", () -> assertEquals("John", person.getFirstName()),\n            () -> assertEquals("Doe", person.getLastName()));\n    }\n\n    @Test\n    void dependentAssertions() {\n        // Within a code block, if an assertion fails the\n        // subsequent code in the same block will be skipped.\n        assertAll("properties", () -> {\n            String firstName = person.getFirstName();\n            assertNotNull(firstName);\n\n            // Executed only if the previous assertion is valid.\n            assertAll("first name", () -> assertTrue(firstName.startsWith("J")),\n                () -> assertTrue(firstName.endsWith("n")));\n        }, () -> {\n            // Grouped assertion, so processed independently\n            // of results of first name assertions.\n            String lastName = person.getLastName();\n            assertNotNull(lastName);\n\n            // Executed only if the previous assertion is valid.\n            assertAll("last name", () -> assertTrue(lastName.startsWith("D")),\n                () -> assertTrue(lastName.endsWith("e")));\n        });\n    }\n\n    @Test\n    void exceptionTesting() {\n        Throwable exception = assertThrows(IllegalArgumentException.class, () -> {\n            throw new IllegalArgumentException("a message");\n        });\n        assertEquals("a message", exception.getMessage());\n    }\n\n    @Test\n    void timeoutNotExceeded() {\n        // The following assertion succeeds.\n        assertTimeout(ofMinutes(2), () -> {\n            // Perform task that takes less than 2 minutes.\n        });\n    }\n\n    @Test\n    void timeoutNotExceededWithResult() {\n        // The following assertion succeeds, and returns the supplied object.\n        String actualResult = assertTimeout(ofMinutes(2), () -> {\n            return "a result";\n        });\n        assertEquals("a result", actualResult);\n    }\n\n    @Test\n    void timeoutNotExceededWithMethod() {\n        // The following assertion invokes a method reference and returns an object.\n        String actualGreeting = assertTimeout(ofMinutes(2), AssertionsDemo::greeting);\n        assertEquals("Hello, World!", actualGreeting);\n    }\n\n    @Test\n    void timeoutExceeded() {\n        // The following assertion fails with an error message similar to:\n        // execution exceeded timeout of 10 ms by 91 ms\n        assertTimeout(ofMillis(10), () -> {\n            // Simulate task that takes more than 10 ms.\n            Thread.sleep(100);\n        });\n    }\n\n    @Test\n    void timeoutExceededWithPreemptiveTermination() {\n        // The following assertion fails with an error message similar to:\n        // execution timed out after 10 ms\n        assertTimeoutPreemptively(ofMillis(10), () -> {\n            // Simulate task that takes more than 10 ms.\n            Thread.sleep(100);\n        });\n    }\n\n    private static String greeting() {\n        return "Hello, World!";\n    }\n\n}\n\n\n\n# 假想（Assumptions）\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assumptions.assumeTrue;\nimport static org.junit.jupiter.api.Assumptions.assumingThat;\n\nimport org.junit.jupiter.api.Test;\n\nclass AssumptionsDemo {\n\n    @Test\n    void testOnlyOnCiServer() {\n        assumeTrue("CI".equals(System.getenv("ENV")));\n        // remainder of test\n    }\n\n    @Test\n    void testOnlyOnDeveloperWorkstation() {\n        assumeTrue("DEV".equals(System.getenv("ENV")),\n            () -> "Aborting test: not on developer workstation");\n        // remainder of test\n    }\n\n    @Test\n    void testInAllEnvironments() {\n        assumingThat("CI".equals(System.getenv("ENV")),\n            () -> {\n                // perform these assertions only on the CI server\n                assertEquals(2, 2);\n            });\n\n        // perform these assertions in all environments\n        assertEquals("a string", "a string");\n    }\n\n}\n\n\n\n# 禁用\n\n禁用单元测试类示例：\n\nimport org.junit.jupiter.api.Disabled;\nimport org.junit.jupiter.api.Test;\n\n@Disabled\nclass DisabledClassDemo {\n    @Test\n    void testWillBeSkipped() {\n    }\n}\n\n\n禁用单元测试方法示例：\n\nimport org.junit.jupiter.api.Disabled;\nimport org.junit.jupiter.api.Test;\n\nclass DisabledTestsDemo {\n\n    @Disabled\n    @Test\n    void testWillBeSkipped() {\n    }\n\n    @Test\n    void testWillBeExecuted() {\n    }\n}\n\n\n\n# 测试条件\n\n# 操作系统条件\n\n@Test\n@EnabledOnOs(MAC)\nvoid onlyOnMacOs() {\n    // ...\n}\n\n@TestOnMac\nvoid testOnMac() {\n    // ...\n}\n\n@Test\n@EnabledOnOs({ LINUX, MAC })\nvoid onLinuxOrMac() {\n    // ...\n}\n\n@Test\n@DisabledOnOs(WINDOWS)\nvoid notOnWindows() {\n    // ...\n}\n\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\n@Test\n@EnabledOnOs(MAC)\n@interface TestOnMac {\n}\n\n\n# Java 运行时版本条件\n\n@Test\n@EnabledOnJre(JAVA_8)\nvoid onlyOnJava8() {\n    // ...\n}\n\n@Test\n@EnabledOnJre({ JAVA_9, JAVA_10 })\nvoid onJava9Or10() {\n    // ...\n}\n\n@Test\n@DisabledOnJre(JAVA_9)\nvoid notOnJava9() {\n    // ...\n}\n\n\n# 系统属性条件\n\n@Test\n@EnabledIfSystemProperty(named = "os.arch", matches = ".*64.*")\nvoid onlyOn64BitArchitectures() {\n    // ...\n}\n\n@Test\n@DisabledIfSystemProperty(named = "ci-server", matches = "true")\nvoid notOnCiServer() {\n    // ...\n}\n\n\n\n# 嵌套测试\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.util.EmptyStackException;\nimport java.util.Stack;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.DisplayName;\nimport org.junit.jupiter.api.Nested;\nimport org.junit.jupiter.api.Test;\n\n@DisplayName("A stack")\nclass TestingAStackDemo {\n\n    Stack<Object> stack;\n\n    @Test\n    @DisplayName("is instantiated with new Stack()")\n    void isInstantiatedWithNew() {\n        new Stack<>();\n    }\n\n    @Nested\n    @DisplayName("when new")\n    class WhenNew {\n\n        @BeforeEach\n        void createNewStack() {\n            stack = new Stack<>();\n        }\n\n        @Test\n        @DisplayName("is empty")\n        void isEmpty() {\n            assertTrue(stack.isEmpty());\n        }\n\n        @Test\n        @DisplayName("throws EmptyStackException when popped")\n        void throwsExceptionWhenPopped() {\n            assertThrows(EmptyStackException.class, () -> stack.pop());\n        }\n\n        @Test\n        @DisplayName("throws EmptyStackException when peeked")\n        void throwsExceptionWhenPeeked() {\n            assertThrows(EmptyStackException.class, () -> stack.peek());\n        }\n\n        @Nested\n        @DisplayName("after pushing an element")\n        class AfterPushing {\n\n            String anElement = "an element";\n\n            @BeforeEach\n            void pushAnElement() {\n                stack.push(anElement);\n            }\n\n            @Test\n            @DisplayName("it is no longer empty")\n            void isNotEmpty() {\n                assertFalse(stack.isEmpty());\n            }\n\n            @Test\n            @DisplayName("returns the element when popped and is empty")\n            void returnElementWhenPopped() {\n                assertEquals(anElement, stack.pop());\n                assertTrue(stack.isEmpty());\n            }\n\n            @Test\n            @DisplayName("returns the element when peeked but remains not empty")\n            void returnElementWhenPeeked() {\n                assertEquals(anElement, stack.peek());\n                assertFalse(stack.isEmpty());\n            }\n        }\n    }\n}\n\n\n\n# 重复测试\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.util.logging.Logger;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.DisplayName;\nimport org.junit.jupiter.api.RepeatedTest;\nimport org.junit.jupiter.api.RepetitionInfo;\nimport org.junit.jupiter.api.TestInfo;\n\nclass RepeatedTestsDemo {\n\n    private Logger logger = // ...\n\n    @BeforeEach\n    void beforeEach(TestInfo testInfo, RepetitionInfo repetitionInfo) {\n        int currentRepetition = repetitionInfo.getCurrentRepetition();\n        int totalRepetitions = repetitionInfo.getTotalRepetitions();\n        String methodName = testInfo.getTestMethod().get().getName();\n        logger.info(String.format("About to execute repetition %d of %d for %s", //\n            currentRepetition, totalRepetitions, methodName));\n    }\n\n    @RepeatedTest(10)\n    void repeatedTest() {\n        // ...\n    }\n\n    @RepeatedTest(5)\n    void repeatedTestWithRepetitionInfo(RepetitionInfo repetitionInfo) {\n        assertEquals(5, repetitionInfo.getTotalRepetitions());\n    }\n\n    @RepeatedTest(value = 1, name = "{displayName} {currentRepetition}/{totalRepetitions}")\n    @DisplayName("Repeat!")\n    void customDisplayName(TestInfo testInfo) {\n        assertEquals(testInfo.getDisplayName(), "Repeat! 1/1");\n    }\n\n    @RepeatedTest(value = 1, name = RepeatedTest.LONG_DISPLAY_NAME)\n    @DisplayName("Details...")\n    void customDisplayNameWithLongPattern(TestInfo testInfo) {\n        assertEquals(testInfo.getDisplayName(), "Details... :: repetition 1 of 1");\n    }\n\n    @RepeatedTest(value = 5, name = "Wiederholung {currentRepetition} von {totalRepetitions}")\n    void repeatedTestInGerman() {\n        // ...\n    }\n\n}\n\n\n\n# 参数化测试\n\n@ParameterizedTest\n@ValueSource(strings = { "racecar", "radar", "able was I ere I saw elba" })\nvoid palindromes(String candidate) {\n    assertTrue(isPalindrome(candidate));\n}\n\n\n\n# 参考资料\n\n * Junit5 Github\n * Junit5 官方用户手册\n * Junit5 Javadoc\n * Junit5 官方示例',normalizedContent:'# junit5 快速入门\n\n\n# junit5 简介\n\n与以前的 junit 版本不同，junit 5 由来自三个不同子项目的几个不同模块组成。\n\njunit 5 = junit platform + junit jupiter + junit vintage\n\njunit platform 是在 jvm 上启动测试框架的基础。它还定义了用于开发在平台上运行的测试框架的 testengine api。此外，该平台还提供了一个控制台启动器，用于从命令行启动平台，并提供 junit 平台套件引擎，用于使用平台上的一个或多个测试引擎运行自定义测试套件。\n\njunit jupiter 是编程模型和扩展模型的组合，用于在 junit 5 中编写测试和扩展。jupiter 子项目提供了一个 测试引擎（testengine ）用于在平台上运行基于 jupiter 的测试。\n\njunit vintage 提供了一个测试引擎（testengine ），用于在平台上运行基于 junit 3 和 junit 4 的测试。它要求 junit 4.12 或更高版本。\n\njunit 5 在运行时需要 java 8（或更高版本）。\n\n\n# junit5 安装\n\n在 pom 中添加依赖\n\n<properties>\n  <junit.jupiter.version>5.3.2</junit.jupiter.version>\n</properties>\n\n<dependencies>\n  <dependency>\n    <groupid>org.junit.jupiter</groupid>\n    <artifactid>junit-jupiter-api</artifactid>\n    <version>${junit.jupiter.version}</version>\n    <scope>test</scope>\n  </dependency>\n  <dependency>\n    <groupid>org.junit.jupiter</groupid>\n    <artifactid>junit-jupiter-params</artifactid>\n    <version>${junit.jupiter.version}</version>\n    <scope>test</scope>\n  </dependency>\n  <dependency>\n    <groupid>org.junit.jupiter</groupid>\n    <artifactid>junit-jupiter-engine</artifactid>\n    <version>${junit.jupiter.version}</version>\n    <scope>test</scope>\n  </dependency>\n</dependencies>\n\n\n组件间依赖关系：\n\n\n\n\n# junit5 注解\n\nannotation           description\n@test                denotes that a method is a test method. unlike junit 4’s\n                     @test annotation, this annotation does not declare any\n                     attributes, since test extensions in junit jupiter operate\n                     based on their own dedicated annotations. such methods are\n                     inherited unless they are overridden.\n@parameterizedtest   denotes that a method is a parameterized test. such methods\n                     are inherited unless they are overridden.\n@repeatedtest        denotes that a method is a test template for a repeated\n                     test. such methods are inherited unless they are overridden.\n@testfactory         denotes that a method is a test factory for dynamic tests.\n                     such methods are inherited unless they are overridden.\n@testinstance        used to configure the test instance lifecycle for the\n                     annotated test class. such annotations are inherited.\n@testtemplate        denotes that a method is a template for test cases designed\n                     to be invoked multiple times depending on the number of\n                     invocation contexts returned by the registered providers.\n                     such methods are inherited unless they are overridden.\n@displayname         declares a custom display name for the test class or test\n                     method. such annotations are not inherited.\n@beforeeach          denotes that the annotated method should be executed before\n                     each @test, @repeatedtest, @parameterizedtest, or\n                     @testfactory method in the current class; analogous to junit\n                     4’s @before. such methods are inherited unless they are\n                     overridden.\n@aftereach           denotes that the annotated method should be executed after\n                     each @test, @repeatedtest, @parameterizedtest, or\n                     @testfactory method in the current class; analogous to junit\n                     4’s @after. such methods are inherited unless they are\n                     overridden.\n@beforeall           denotes that the annotated method should be executed before\n                     all @test, @repeatedtest, @parameterizedtest, and\n                     @testfactory methods in the current class; analogous to\n                     junit 4’s @beforeclass. such methods are inherited (unless\n                     they are hidden or overridden) and must be static (unless\n                     the "per-class" test instance lifecycle is used).\n@afterall            denotes that the annotated method should be executed after\n                     all @test, @repeatedtest, @parameterizedtest, and\n                     @testfactory methods in the current class; analogous to\n                     junit 4’s @afterclass. such methods are inherited (unless\n                     they are hidden or overridden) and must be static (unless\n                     the "per-class" test instance lifecycle is used).\n@nested              denotes that the annotated class is a nested, non-static\n                     test class. @beforeall and @afterallmethods cannot be used\n                     directly in a @nested test class unless the "per-class" test\n                     instance lifecycle is used. such annotations are not\n                     inherited.\n@tag                 used to declare tags for filtering tests, either at the\n                     class or method level; analogous to test groups in testng or\n                     categories in junit 4. such annotations are inherited at the\n                     class level but not at the method level.\n@disabled            used to disable a test class or test method; analogous to\n                     junit 4’s @ignore. such annotations are not inherited.\n@extendwith          used to register custom extensions. such annotations are\n                     inherited.\n\n\n# junit5 示例\n\n> 我将一部分官方示例放在了我的个人项目中，可以直接下载测试。\n> \n> 示例源码路径：https://github.com/dunwu/java-tutorial/tree/master/codes/javatech/javatech-lib/src/test/java/io/github/dunwu/javatech/test/junit5\n\n\n# 基本的单元测试类和方法\n\nimport org.junit.jupiter.api.*;\nimport org.slf4j.logger;\nimport org.slf4j.loggerfactory;\n\nclass junit5standardtests {\n\n    private static final logger logger = loggerfactory.getlogger(junit5standardtests.class);\n\n    @beforeall\n    static void beforeall() {\n        logger.info("call beforeall()");\n    }\n\n    @beforeeach\n    void beforeeach() {\n        logger.info("call beforeeach()");\n    }\n\n    @test\n    void succeedingtest() {\n        logger.info("call succeedingtest()");\n    }\n\n    @test\n    void failingtest() {\n        logger.info("call failingtest()");\n        // fail("a failing test");\n    }\n\n    @test\n    @disabled("for demonstration purposes")\n    void skippedtest() {\n        logger.info("call skippedtest()");\n        // not executed\n    }\n\n    @aftereach\n    void aftereach() {\n        logger.info("call aftereach()");\n    }\n\n    @afterall\n    static void afterall() {\n        logger.info("call afterall()");\n    }\n}\n\n\n\n# 定制测试类和方法的显示名称\n\n支持普通字符、特殊符号、emoji\n\nimport org.junit.jupiter.api.displayname;\nimport org.junit.jupiter.api.test;\n\n@displayname("a special test case")\nclass junitdisplaynamedemo {\n\n    @test\n    @displayname("custom test name containing spaces")\n    void testwithdisplaynamecontainingspaces() { }\n\n    @test\n    @displayname("╯°□°）╯")\n    void testwithdisplaynamecontainingspecialcharacters() { }\n\n    @test\n    @displayname("😱")\n    void testwithdisplaynamecontainingemoji() { }\n}\n\n\n\n# 断言（assertions）\n\nimport org.junit.jupiter.api.beforeall;\nimport org.junit.jupiter.api.test;\n\nimport static java.time.duration.ofmillis;\nimport static java.time.duration.ofminutes;\nimport static org.junit.jupiter.api.assertions.*;\n\nclass assertionsdemo {\n\n    private static person person;\n\n    @beforeall\n    public static void beforeall() {\n        person = new person("john", "doe");\n    }\n\n    @test\n    void standardassertions() {\n        assertequals(2, 2);\n        assertequals(4, 4, "the optional assertion message is now the last parameter.");\n        asserttrue(\'a\' < \'b\', () -> "assertion messages can be lazily evaluated -- "\n            + "to avoid constructing complex messages unnecessarily.");\n    }\n\n    @test\n    void groupedassertions() {\n        // in a grouped assertion all assertions are executed, and any\n        // failures will be reported together.\n        assertall("person", () -> assertequals("john", person.getfirstname()),\n            () -> assertequals("doe", person.getlastname()));\n    }\n\n    @test\n    void dependentassertions() {\n        // within a code block, if an assertion fails the\n        // subsequent code in the same block will be skipped.\n        assertall("properties", () -> {\n            string firstname = person.getfirstname();\n            assertnotnull(firstname);\n\n            // executed only if the previous assertion is valid.\n            assertall("first name", () -> asserttrue(firstname.startswith("j")),\n                () -> asserttrue(firstname.endswith("n")));\n        }, () -> {\n            // grouped assertion, so processed independently\n            // of results of first name assertions.\n            string lastname = person.getlastname();\n            assertnotnull(lastname);\n\n            // executed only if the previous assertion is valid.\n            assertall("last name", () -> asserttrue(lastname.startswith("d")),\n                () -> asserttrue(lastname.endswith("e")));\n        });\n    }\n\n    @test\n    void exceptiontesting() {\n        throwable exception = assertthrows(illegalargumentexception.class, () -> {\n            throw new illegalargumentexception("a message");\n        });\n        assertequals("a message", exception.getmessage());\n    }\n\n    @test\n    void timeoutnotexceeded() {\n        // the following assertion succeeds.\n        asserttimeout(ofminutes(2), () -> {\n            // perform task that takes less than 2 minutes.\n        });\n    }\n\n    @test\n    void timeoutnotexceededwithresult() {\n        // the following assertion succeeds, and returns the supplied object.\n        string actualresult = asserttimeout(ofminutes(2), () -> {\n            return "a result";\n        });\n        assertequals("a result", actualresult);\n    }\n\n    @test\n    void timeoutnotexceededwithmethod() {\n        // the following assertion invokes a method reference and returns an object.\n        string actualgreeting = asserttimeout(ofminutes(2), assertionsdemo::greeting);\n        assertequals("hello, world!", actualgreeting);\n    }\n\n    @test\n    void timeoutexceeded() {\n        // the following assertion fails with an error message similar to:\n        // execution exceeded timeout of 10 ms by 91 ms\n        asserttimeout(ofmillis(10), () -> {\n            // simulate task that takes more than 10 ms.\n            thread.sleep(100);\n        });\n    }\n\n    @test\n    void timeoutexceededwithpreemptivetermination() {\n        // the following assertion fails with an error message similar to:\n        // execution timed out after 10 ms\n        asserttimeoutpreemptively(ofmillis(10), () -> {\n            // simulate task that takes more than 10 ms.\n            thread.sleep(100);\n        });\n    }\n\n    private static string greeting() {\n        return "hello, world!";\n    }\n\n}\n\n\n\n# 假想（assumptions）\n\nimport static org.junit.jupiter.api.assertions.assertequals;\nimport static org.junit.jupiter.api.assumptions.assumetrue;\nimport static org.junit.jupiter.api.assumptions.assumingthat;\n\nimport org.junit.jupiter.api.test;\n\nclass assumptionsdemo {\n\n    @test\n    void testonlyonciserver() {\n        assumetrue("ci".equals(system.getenv("env")));\n        // remainder of test\n    }\n\n    @test\n    void testonlyondeveloperworkstation() {\n        assumetrue("dev".equals(system.getenv("env")),\n            () -> "aborting test: not on developer workstation");\n        // remainder of test\n    }\n\n    @test\n    void testinallenvironments() {\n        assumingthat("ci".equals(system.getenv("env")),\n            () -> {\n                // perform these assertions only on the ci server\n                assertequals(2, 2);\n            });\n\n        // perform these assertions in all environments\n        assertequals("a string", "a string");\n    }\n\n}\n\n\n\n# 禁用\n\n禁用单元测试类示例：\n\nimport org.junit.jupiter.api.disabled;\nimport org.junit.jupiter.api.test;\n\n@disabled\nclass disabledclassdemo {\n    @test\n    void testwillbeskipped() {\n    }\n}\n\n\n禁用单元测试方法示例：\n\nimport org.junit.jupiter.api.disabled;\nimport org.junit.jupiter.api.test;\n\nclass disabledtestsdemo {\n\n    @disabled\n    @test\n    void testwillbeskipped() {\n    }\n\n    @test\n    void testwillbeexecuted() {\n    }\n}\n\n\n\n# 测试条件\n\n# 操作系统条件\n\n@test\n@enabledonos(mac)\nvoid onlyonmacos() {\n    // ...\n}\n\n@testonmac\nvoid testonmac() {\n    // ...\n}\n\n@test\n@enabledonos({ linux, mac })\nvoid onlinuxormac() {\n    // ...\n}\n\n@test\n@disabledonos(windows)\nvoid notonwindows() {\n    // ...\n}\n\n@target(elementtype.method)\n@retention(retentionpolicy.runtime)\n@test\n@enabledonos(mac)\n@interface testonmac {\n}\n\n\n# java 运行时版本条件\n\n@test\n@enabledonjre(java_8)\nvoid onlyonjava8() {\n    // ...\n}\n\n@test\n@enabledonjre({ java_9, java_10 })\nvoid onjava9or10() {\n    // ...\n}\n\n@test\n@disabledonjre(java_9)\nvoid notonjava9() {\n    // ...\n}\n\n\n# 系统属性条件\n\n@test\n@enabledifsystemproperty(named = "os.arch", matches = ".*64.*")\nvoid onlyon64bitarchitectures() {\n    // ...\n}\n\n@test\n@disabledifsystemproperty(named = "ci-server", matches = "true")\nvoid notonciserver() {\n    // ...\n}\n\n\n\n# 嵌套测试\n\nimport static org.junit.jupiter.api.assertions.assertequals;\nimport static org.junit.jupiter.api.assertions.assertfalse;\nimport static org.junit.jupiter.api.assertions.assertthrows;\nimport static org.junit.jupiter.api.assertions.asserttrue;\n\nimport java.util.emptystackexception;\nimport java.util.stack;\n\nimport org.junit.jupiter.api.beforeeach;\nimport org.junit.jupiter.api.displayname;\nimport org.junit.jupiter.api.nested;\nimport org.junit.jupiter.api.test;\n\n@displayname("a stack")\nclass testingastackdemo {\n\n    stack<object> stack;\n\n    @test\n    @displayname("is instantiated with new stack()")\n    void isinstantiatedwithnew() {\n        new stack<>();\n    }\n\n    @nested\n    @displayname("when new")\n    class whennew {\n\n        @beforeeach\n        void createnewstack() {\n            stack = new stack<>();\n        }\n\n        @test\n        @displayname("is empty")\n        void isempty() {\n            asserttrue(stack.isempty());\n        }\n\n        @test\n        @displayname("throws emptystackexception when popped")\n        void throwsexceptionwhenpopped() {\n            assertthrows(emptystackexception.class, () -> stack.pop());\n        }\n\n        @test\n        @displayname("throws emptystackexception when peeked")\n        void throwsexceptionwhenpeeked() {\n            assertthrows(emptystackexception.class, () -> stack.peek());\n        }\n\n        @nested\n        @displayname("after pushing an element")\n        class afterpushing {\n\n            string anelement = "an element";\n\n            @beforeeach\n            void pushanelement() {\n                stack.push(anelement);\n            }\n\n            @test\n            @displayname("it is no longer empty")\n            void isnotempty() {\n                assertfalse(stack.isempty());\n            }\n\n            @test\n            @displayname("returns the element when popped and is empty")\n            void returnelementwhenpopped() {\n                assertequals(anelement, stack.pop());\n                asserttrue(stack.isempty());\n            }\n\n            @test\n            @displayname("returns the element when peeked but remains not empty")\n            void returnelementwhenpeeked() {\n                assertequals(anelement, stack.peek());\n                assertfalse(stack.isempty());\n            }\n        }\n    }\n}\n\n\n\n# 重复测试\n\nimport static org.junit.jupiter.api.assertions.assertequals;\n\nimport java.util.logging.logger;\n\nimport org.junit.jupiter.api.beforeeach;\nimport org.junit.jupiter.api.displayname;\nimport org.junit.jupiter.api.repeatedtest;\nimport org.junit.jupiter.api.repetitioninfo;\nimport org.junit.jupiter.api.testinfo;\n\nclass repeatedtestsdemo {\n\n    private logger logger = // ...\n\n    @beforeeach\n    void beforeeach(testinfo testinfo, repetitioninfo repetitioninfo) {\n        int currentrepetition = repetitioninfo.getcurrentrepetition();\n        int totalrepetitions = repetitioninfo.gettotalrepetitions();\n        string methodname = testinfo.gettestmethod().get().getname();\n        logger.info(string.format("about to execute repetition %d of %d for %s", //\n            currentrepetition, totalrepetitions, methodname));\n    }\n\n    @repeatedtest(10)\n    void repeatedtest() {\n        // ...\n    }\n\n    @repeatedtest(5)\n    void repeatedtestwithrepetitioninfo(repetitioninfo repetitioninfo) {\n        assertequals(5, repetitioninfo.gettotalrepetitions());\n    }\n\n    @repeatedtest(value = 1, name = "{displayname} {currentrepetition}/{totalrepetitions}")\n    @displayname("repeat!")\n    void customdisplayname(testinfo testinfo) {\n        assertequals(testinfo.getdisplayname(), "repeat! 1/1");\n    }\n\n    @repeatedtest(value = 1, name = repeatedtest.long_display_name)\n    @displayname("details...")\n    void customdisplaynamewithlongpattern(testinfo testinfo) {\n        assertequals(testinfo.getdisplayname(), "details... :: repetition 1 of 1");\n    }\n\n    @repeatedtest(value = 5, name = "wiederholung {currentrepetition} von {totalrepetitions}")\n    void repeatedtestingerman() {\n        // ...\n    }\n\n}\n\n\n\n# 参数化测试\n\n@parameterizedtest\n@valuesource(strings = { "racecar", "radar", "able was i ere i saw elba" })\nvoid palindromes(string candidate) {\n    asserttrue(ispalindrome(candidate));\n}\n\n\n\n# 参考资料\n\n * junit5 github\n * junit5 官方用户手册\n * junit5 javadoc\n * junit5 官方示例',charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Mockito 快速入门",frontmatter:{title:"Mockito 快速入门",date:"2022-02-17T22:34:30.000Z",order:2,categories:["Java","工具","测试"],tags:["Java","测试","Mockito"],permalink:"/pages/f2c6f5/"},regularPath:"/01.Java/12.%E5%B7%A5%E5%85%B7/04.%E6%B5%8B%E8%AF%95/02.Mockito.html",relativePath:"01.Java/12.工具/04.测试/02.Mockito.md",key:"v-98b41d6c",path:"/pages/f2c6f5/",headers:[{level:2,title:"预备知识",slug:"预备知识",normalizedTitle:"预备知识",charIndex:52},{level:2,title:"使用 mock 对象来进行测试",slug:"使用-mock-对象来进行测试",normalizedTitle:"使用 mock 对象来进行测试",charIndex:120},{level:3,title:"单元测试的目标和挑战",slug:"单元测试的目标和挑战",normalizedTitle:"单元测试的目标和挑战",charIndex:140},{level:3,title:"测试类的分类",slug:"测试类的分类",normalizedTitle:"测试类的分类",charIndex:259},{level:3,title:"Mock 对象的产生",slug:"mock-对象的产生",normalizedTitle:"mock 对象的产生",charIndex:727},{level:3,title:"使用 Mockito 生成 Mock 对象",slug:"使用-mockito-生成-mock-对象",normalizedTitle:"使用 mockito 生成 mock 对象",charIndex:1021},{level:2,title:"为自己的项目添加 Mockito 依赖",slug:"为自己的项目添加-mockito-依赖",normalizedTitle:"为自己的项目添加 mockito 依赖",charIndex:1219},{level:3,title:"在 Gradle 添加 Mockito 依赖",slug:"在-gradle-添加-mockito-依赖",normalizedTitle:"在 gradle 添加 mockito 依赖",charIndex:1243},{level:3,title:"在 Maven 添加 Mockito 依赖",slug:"在-maven-添加-mockito-依赖",normalizedTitle:"在 maven 添加 mockito 依赖",charIndex:1427},{level:3,title:"在 Eclipse IDE 使用 Mockito",slug:"在-eclipse-ide-使用-mockito",normalizedTitle:"在 eclipse ide 使用 mockito",charIndex:1550},{level:3,title:"以 OSGi 或者 Eclipse 插件形式添加 Mockito 依赖",slug:"以-osgi-或者-eclipse-插件形式添加-mockito-依赖",normalizedTitle:"以 osgi 或者 eclipse 插件形式添加 mockito 依赖",charIndex:1653},{level:2,title:"使用 Mockito API",slug:"使用-mockito-api",normalizedTitle:"使用 mockito api",charIndex:1843},{level:3,title:"静态引用",slug:"静态引用",normalizedTitle:"静态引用",charIndex:1862},{level:3,title:"使用 Mockito 创建和配置 mock 对象",slug:"使用-mockito-创建和配置-mock-对象",normalizedTitle:"使用 mockito 创建和配置 mock 对象",charIndex:1951},{level:3,title:"配置 mock",slug:"配置-mock",normalizedTitle:"配置 mock",charIndex:1097},{level:3,title:"验证 mock 对象方法是否被调用",slug:"验证-mock-对象方法是否被调用",normalizedTitle:"验证 mock 对象方法是否被调用",charIndex:5121},{level:3,title:"使用 Spy 封装 java 对象",slug:"使用-spy-封装-java-对象",normalizedTitle:"使用 spy 封装 java 对象",charIndex:6082},{level:3,title:"使用 @InjectMocks 在 Mockito 中进行依赖注入",slug:"使用-injectmocks-在-mockito-中进行依赖注入",normalizedTitle:"使用 @injectmocks 在 mockito 中进行依赖注入",charIndex:6507},{level:3,title:"捕捉参数",slug:"捕捉参数",normalizedTitle:"捕捉参数",charIndex:7645},{level:3,title:"Mockito 的限制",slug:"mockito-的限制",normalizedTitle:"mockito 的限制",charIndex:8707},{level:2,title:"在 Android 中使用 Mockito",slug:"在-android-中使用-mockito",normalizedTitle:"在 android 中使用 mockito",charIndex:8817},{level:2,title:"实例：使用 Mockito 写一个 Instrumented Unit Test",slug:"实例-使用-mockito-写一个-instrumented-unit-test",normalizedTitle:"实例：使用 mockito 写一个 instrumented unit test",charIndex:9369},{level:3,title:"创建一个测试的 Android 应用",slug:"创建一个测试的-android-应用",normalizedTitle:"创建一个测试的 android 应用",charIndex:9414},{level:3,title:"在 app/build.gradle 文件中添加 Mockito 依赖",slug:"在-app-build-gradle-文件中添加-mockito-依赖",normalizedTitle:"在 app/build.gradle 文件中添加 mockito 依赖",charIndex:9789},{level:3,title:"创建测试",slug:"创建测试",normalizedTitle:"创建测试",charIndex:10344},{level:2,title:"实例：使用 Mockito 创建一个 mock 对象",slug:"实例-使用-mockito-创建一个-mock-对象",normalizedTitle:"实例：使用 mockito 创建一个 mock 对象",charIndex:11236},{level:3,title:"目标",slug:"目标",normalizedTitle:"目标",charIndex:145},{level:3,title:"创建一个 Twitter API 的例子",slug:"创建一个-twitter-api-的例子",normalizedTitle:"创建一个 twitter api 的例子",charIndex:11307},{level:3,title:"模拟 ITweet 的实例",slug:"模拟-itweet-的实例",normalizedTitle:"模拟 itweet 的实例",charIndex:11657},{level:3,title:"验证方法调用",slug:"验证方法调用",normalizedTitle:"验证方法调用",charIndex:12078},{level:3,title:"验证",slug:"验证",normalizedTitle:"验证",charIndex:619},{level:2,title:"模拟静态方法",slug:"模拟静态方法",normalizedTitle:"模拟静态方法",charIndex:12456},{level:3,title:"使用 Powermock 来模拟静态方法",slug:"使用-powermock-来模拟静态方法",normalizedTitle:"使用 powermock 来模拟静态方法",charIndex:12467},{level:3,title:"用封装的方法代替 Powermock",slug:"用封装的方法代替-powermock",normalizedTitle:"用封装的方法代替 powermock",charIndex:13368},{level:2,title:"引用和引申",slug:"引用和引申",normalizedTitle:"引用和引申",charIndex:13527}],headersStr:"预备知识 使用 mock 对象来进行测试 单元测试的目标和挑战 测试类的分类 Mock 对象的产生 使用 Mockito 生成 Mock 对象 为自己的项目添加 Mockito 依赖 在 Gradle 添加 Mockito 依赖 在 Maven 添加 Mockito 依赖 在 Eclipse IDE 使用 Mockito 以 OSGi 或者 Eclipse 插件形式添加 Mockito 依赖 使用 Mockito API 静态引用 使用 Mockito 创建和配置 mock 对象 配置 mock 验证 mock 对象方法是否被调用 使用 Spy 封装 java 对象 使用 @InjectMocks 在 Mockito 中进行依赖注入 捕捉参数 Mockito 的限制 在 Android 中使用 Mockito 实例：使用 Mockito 写一个 Instrumented Unit Test 创建一个测试的 Android 应用 在 app/build.gradle 文件中添加 Mockito 依赖 创建测试 实例：使用 Mockito 创建一个 mock 对象 目标 创建一个 Twitter API 的例子 模拟 ITweet 的实例 验证方法调用 验证 模拟静态方法 使用 Powermock 来模拟静态方法 用封装的方法代替 Powermock 引用和引申",content:'# Mockito 快速入门\n\n> Mockito 是一个针对 Java 的 mock 框架。\n\n\n# 预备知识\n\n如果需要往下学习，你需要先理解 Junit 框架中的单元测试。\n\n如果你不熟悉 JUnit，请看 Junit 教程\n\n\n# 使用 mock 对象来进行测试\n\n\n# 单元测试的目标和挑战\n\n单元测试的思路是在不涉及依赖关系的情况下测试代码（隔离性），所以测试代码与其他类或者系统的关系应该尽量被消除。一个可行的消除方法是替换掉依赖类（测试替换），也就是说我们可以使用替身来替换掉真正的依赖对象。\n\n\n# 测试类的分类\n\n * dummy object 做为参数传递给方法但是绝对不会被使用。譬如说，这种测试类内部的方法不会被调用，或者是用来填充某个方法的参数。\n * Fake 是真正接口或抽象类的实现体，但给对象内部实现很简单。譬如说，它存在内存中而不是真正的数据库中。（译者注：Fake 实现了真正的逻辑，但它的存在只是为了测试，而不适合于用在产品中。）\n * stub 类是依赖类的部分方法实现，而这些方法在你测试类和接口的时候会被用到，也就是说 stub 类在测试中会被实例化。stub 类会回应任何外部测试的调用。stub 类有时候还会记录调用的一些信息。\n * mock object 是指类或者接口的模拟实现，你可以自定义这个对象中某个方法的输出结果。\n\n测试替代技术能够在测试中模拟测试类以外对象。因此你可以验证测试类是否响应正常。譬如说，你可以验证在 Mock 对象的某一个方法是否被调用。这可以确保隔离了外部依赖的干扰只测试测试类。\n\n我们选择 Mock 对象的原因是因为 Mock 对象只需要少量代码的配置。\n\n\n# Mock 对象的产生\n\n你可以手动创建一个 Mock 对象或者使用 Mock 框架来模拟这些类，Mock 框架允许你在运行时创建 Mock 对象并且定义它的行为。\n\n一个典型的例子是把 Mock 对象模拟成数据的提供者。在正式的生产环境中它会被实现用来连接数据源。但是我们在测试的时候 Mock 对象将会模拟成数据提供者来确保我们的测试环境始终是相同的。\n\nMock 对象可以被提供来进行测试。因此，我们测试的类应该避免任何外部数据的强依赖。\n\n通过 Mock 对象或者 Mock 框架，我们可以测试代码中期望的行为。譬如说，验证只有某个存在 Mock 对象的方法是否被调用了。\n\n\n# 使用 Mockito 生成 Mock 对象\n\nMockito 是一个流行 mock 框架，可以和 JUnit 结合起来使用。Mockito 允许你创建和配置 mock 对象。使用 Mockito 可以明显的简化对外部依赖的测试类的开发。\n\n一般使用 Mockito 需要执行下面三步\n\n 1. 模拟并替换测试代码中外部依赖\n 2. 执行测试代码\n 3. 验证测试代码是否被正确的执行 0\n\n\n# 为自己的项目添加 Mockito 依赖\n\n\n# 在 Gradle 添加 Mockito 依赖\n\n如果你的项目使用 Gradle 构建，将下面代码加入 Gradle 的构建文件中为自己项目添加 Mockito 依赖\n\nrepositories { jcenter() }\ndependencies { testCompile "org.mockito:mockito-core:2.0.57-beta" }\n\n\n\n# 在 Maven 添加 Mockito 依赖\n\n需要在 Maven 声明依赖，您可以在 http://search.maven.org 网站中搜索 g:"org.mockito", a:"mockito-core" 来得到具体的声明方式。\n\n\n# 在 Eclipse IDE 使用 Mockito\n\nEclipse IDE 支持 Gradle 和 Maven 两种构建工具，所以在 Eclipse IDE 添加依赖取决你使用的是哪一个构建工具。\n\n\n# 以 OSGi 或者 Eclipse 插件形式添加 Mockito 依赖\n\n在 Eclipse RCP 应用依赖通常可以在 p2 update 上得到。Orbit 是一个很好的第三方仓库，我们可以在里面寻找能在 Eclipse 上使用的应用和插件。\n\nOrbit 仓库地址：http://download.eclipse.org/tools/orbit/downloads\n\n\n# 使用 Mockito API\n\n\n# 静态引用\n\n如果在代码中静态引用了org.mockito.Mockito.*;，那你你就可以直接调用静态方法和静态变量而不用创建对象，譬如直接调用 mock() 方法。\n\n\n# 使用 Mockito 创建和配置 mock 对象\n\n除了上面所说的使用 mock() 静态方法外，Mockito 还支持通过 @Mock 注解的方式来创建 mock 对象。\n\n如果你使用注解，那么必须要实例化 mock 对象。Mockito 在遇到使用注解的字段的时候，会调用MockitoAnnotations.initMocks(this) 来初始化该 mock 对象。另外也可以通过使用@RunWith(MockitoJUnitRunner.class)来达到相同的效果。\n\n通过下面的例子我们可以了解到使用@Mock 的方法和MockitoRule规则。\n\nimport static org.mockito.Mockito.*;\n\npublic class MockitoTest  {\n\n        @Mock\n        MyDatabase databaseMock; (1)\n\n        @Rule public MockitoRule mockitoRule = MockitoJUnit.rule(); (2)\n\n        @Test\n        public void testQuery()  {\n                ClassToTest t  = new ClassToTest(databaseMock); (3)\n                boolean check = t.query("* from t"); (4)\n                assertTrue(check); (5)\n                verify(databaseMock).query("* from t"); (6)\n        }\n}\n\n\n 1. 告诉 Mockito 模拟 databaseMock 实例\n 2. Mockito 通过 @mock 注解创建 mock 对象\n 3. 使用已经创建的 mock 初始化这个类\n 4. 在测试环境下，执行测试类中的代码\n 5. 使用断言确保调用的方法返回值为 true\n 6. 验证 query 方法是否被 MyDatabase 的 mock 对象调用\n\n\n# 配置 mock\n\n当我们需要配置某个方法的返回值的时候，Mockito 提供了链式的 API 供我们方便的调用\n\nwhen(….).thenReturn(….)可以被用来定义当条件满足时函数的返回值，如果你需要定义多个返回值，可以多次定义。当你多次调用函数的时候，Mockito 会根据你定义的先后顺序来返回返回值。Mocks 还可以根据传入参数的不同来定义不同的返回值。譬如说你的函数可以将anyString 或者 anyInt作为输入参数，然后定义其特定的放回值。\n\nimport static org.mockito.Mockito.*;\nimport static org.junit.Assert.*;\n\n@Test\npublic void test1()  {\n        //  创建 mock\n        MyClass test = Mockito.mock(MyClass.class);\n\n        // 自定义 getUniqueId() 的返回值\n        when(test.getUniqueId()).thenReturn(43);\n\n        // 在测试中使用mock对象\n        assertEquals(test.getUniqueId(), 43);\n}\n\n// 返回多个值\n@Test\npublic void testMoreThanOneReturnValue()  {\n        Iterator i= mock(Iterator.class);\n        when(i.next()).thenReturn("Mockito").thenReturn("rocks");\n        String result=i.next()+" "+i.next();\n        // 断言\n        assertEquals("Mockito rocks", result);\n}\n\n// 如何根据输入来返回值\n@Test\npublic void testReturnValueDependentOnMethodParameter()  {\n        Comparable c= mock(Comparable.class);\n        when(c.compareTo("Mockito")).thenReturn(1);\n        when(c.compareTo("Eclipse")).thenReturn(2);\n        // 断言\n        assertEquals(1,c.compareTo("Mockito"));\n}\n\n// 如何让返回值不依赖于输入\n@Test\npublic void testReturnValueInDependentOnMethodParameter()  {\n        Comparable c= mock(Comparable.class);\n        when(c.compareTo(anyInt())).thenReturn(-1);\n        // 断言\n        assertEquals(-1 ,c.compareTo(9));\n}\n\n// 根据参数类型来返回值\n@Test\npublic void testReturnValueInDependentOnMethodParameter()  {\n        Comparable c= mock(Comparable.class);\n        when(c.compareTo(isA(Todo.class))).thenReturn(0);\n        // 断言\n        Todo todo = new Todo(5);\n        assertEquals(todo ,c.compareTo(new Todo(1)));\n}\n\n\n对于无返回值的函数，我们可以使用doReturn(…).when(…).methodCall来获得类似的效果。例如我们想在调用某些无返回值函数的时候抛出异常，那么可以使用doThrow 方法。如下面代码片段所示\n\nimport static org.mockito.Mockito.*;\nimport static org.junit.Assert.*;\n\n// 下面测试用例描述了如何使用doThrow()方法\n\n@Test(expected=IOException.class)\npublic void testForIOException() {\n        // 创建并配置 mock 对象\n        OutputStream mockStream = mock(OutputStream.class);\n        doThrow(new IOException()).when(mockStream).close();\n\n        // 使用 mock\n        OutputStreamWriter streamWriter= new OutputStreamWriter(mockStream);\n        streamWriter.close();\n}\n\n\n\n# 验证 mock 对象方法是否被调用\n\nMockito 会跟踪 mock 对象里面所有的方法和变量。所以我们可以用来验证函数在传入特定参数的时候是否被调用。这种方式的测试称行为测试，行为测试并不会检查函数的返回值，而是检查在传入正确参数时候函数是否被调用。\n\nimport static org.mockito.Mockito.*;\n\n@Test\npublic void testVerify()  {\n        // 创建并配置 mock 对象\n        MyClass test = Mockito.mock(MyClass.class);\n        when(test.getUniqueId()).thenReturn(43);\n\n        // 调用mock对象里面的方法并传入参数为12\n        test.testing(12);\n        test.getUniqueId();\n        test.getUniqueId();\n\n        // 查看在传入参数为12的时候方法是否被调用\n        verify(test).testing(Matchers.eq(12));\n\n        // 方法是否被调用两次\n        verify(test, times(2)).getUniqueId();\n\n        // 其他用来验证函数是否被调用的方法\n        verify(mock, never()).someMethod("never called");\n        verify(mock, atLeastOnce()).someMethod("called at least once");\n        verify(mock, atLeast(2)).someMethod("called at least twice");\n        verify(mock, times(5)).someMethod("called five times");\n        verify(mock, atMost(3)).someMethod("called at most 3 times");\n}\n\n\n\n# 使用 Spy 封装 java 对象\n\n@Spy 或者spy()方法可以被用来封装 java 对象。被封装后，除非特殊声明（打桩 stub），否则都会真正的调用对象里面的每一个方法\n\nimport static org.mockito.Mockito.*;\n\n// Lets mock a LinkedList\nList list = new LinkedList();\nList spy = spy(list);\n\n// 可用 doReturn() 来打桩\ndoReturn("foo").when(spy).get(0);\n\n// 下面代码不生效\n// 真正的方法会被调用\n// 将会抛出 IndexOutOfBoundsException 的异常，因为 List 为空\nwhen(spy.get(0)).thenReturn("foo");\n\n\n方法verifyNoMoreInteractions()允许你检查没有其他的方法被调用了。\n\n\n# 使用 @InjectMocks 在 Mockito 中进行依赖注入\n\n我们也可以使用@InjectMocks 注解来创建对象，它会根据类型来注入对象里面的成员方法和变量。假定我们有 ArticleManager 类\n\npublic class ArticleManager {\n    private User user;\n    private ArticleDatabase database;\n\n    ArticleManager(User user) {\n     this.user = user;\n    }\n\n    void setDatabase(ArticleDatabase database) { }\n}\n\n\n这个类会被 Mockito 构造，而类的成员方法和变量都会被 mock 对象所代替，正如下面的代码片段所示：\n\n@RunWith(MockitoJUnitRunner.class)\npublic class ArticleManagerTest  {\n\n       @Mock ArticleCalculator calculator;\n       @Mock ArticleDatabase database;\n       @Most User user;\n\n       @Spy private UserProvider userProvider = new ConsumerUserProvider();\n\n       @InjectMocks private ArticleManager manager; (1)\n\n       @Test public void shouldDoSomething() {\n               // 假定 ArticleManager 有一个叫 initialize() 的方法被调用了\n               // 使用 ArticleListener 来调用 addListener 方法\n               manager.initialize();\n\n               // 验证 addListener 方法被调用\n               verify(database).addListener(any(ArticleListener.class));\n       }\n}\n\n\n 1. 创建 ArticleManager 实例并注入 Mock 对象\n\n更多的详情可以查看 http://docs.mockito.googlecode.com/hg/1.9.5/org/mockito/InjectMocks.html\n\n\n# 捕捉参数\n\nArgumentCaptor类允许我们在 verification 期间访问方法的参数。得到方法的参数后我们可以使用它进行测试。\n\nimport static org.hamcrest.Matchers.hasItem;\nimport static org.junit.Assert.assertThat;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.verify;\n\nimport java.util.Arrays;\nimport java.util.List;\n\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.mockito.ArgumentCaptor;\nimport org.mockito.Captor;\nimport org.mockito.junit.MockitoJUnit;\nimport org.mockito.junit.MockitoRule;\n\npublic class MockitoTests {\n    @Rule\n    public MockitoRule rule = MockitoJUnit.rule();\n\n    @Captor\n    private ArgumentCaptor<List<String>> captor;\n\n    @Test\n    public final void shouldContainCertainListItem() {\n        List<String> asList = Arrays.asList("someElement_test", "someElement");\n        final List<String> mockedList = mock(List.class);\n        mockedList.addAll(asList);\n\n        verify(mockedList).addAll(captor.capture());\n        final List<String> capturedArgument = captor.getValue();\n        assertThat(capturedArgument, hasItem("someElement"));\n    }\n}\n\n\n\n# Mockito 的限制\n\nMockito 当然也有一定的限制。而下面三种数据类型则不能够被测试\n\n * final classes\n * anonymous classes\n * primitive types\n\n\n# 在 Android 中使用 Mockito\n\n在 Android 中的 Gradle 构建文件中加入 Mockito 依赖后就可以直接使用 Mockito 了。若想使用 Android Instrumented tests 的话，还需要添加 dexmaker 和 dexmaker-mockito 依赖到 Gradle 的构建文件中。（需要 Mockito 1.9.5 版本以上）\n\ndependencies {\n    testCompile \'junit:junit:4.12\'\n    // Mockito unit test 的依赖\n    testCompile \'org.mockito:mockito-core:1.+\'\n    // Mockito Android instrumentation tests 的依赖\n    androidTestCompile \'org.mockito:mockito-core:1.+\'\n    androidTestCompile "com.google.dexmaker:dexmaker:1.2"\n    androidTestCompile "com.google.dexmaker:dexmaker-mockito:1.2"\n}\n\n\n\n# 实例：使用 Mockito 写一个 Instrumented Unit Test\n\n\n# 创建一个测试的 Android 应用\n\n创建一个包名为com.vogella.android.testing.mockito.contextmock的 Android 应用，添加一个静态方法 ，方法里面创建一个包含参数的 Intent，如下代码所示：\n\npublic static Intent createQuery(Context context, String query, String value) {\n    // 简单起见，重用MainActivity\n    Intent i = new Intent(context, MainActivity.class);\n    i.putExtra("QUERY", query);\n    i.putExtra("VALUE", value);\n    return i;\n}\n\n\n\n# 在 app/build.gradle 文件中添加 Mockito 依赖\n\ndependencies {\n    // Mockito 和 JUnit 的依赖\n    // instrumentation unit tests on the JVM\n    androidTestCompile \'junit:junit:4.12\'\n    androidTestCompile \'org.mockito:mockito-core:2.0.57-beta\'\n    androidTestCompile \'com.android.support.test:runner:0.3\'\n    androidTestCompile "com.google.dexmaker:dexmaker:1.2"\n    androidTestCompile "com.google.dexmaker:dexmaker-mockito:1.2"\n\n    // Mockito 和 JUnit 的依赖\n    // tests on the JVM\n    testCompile \'junit:junit:4.12\'\n    testCompile \'org.mockito:mockito-core:1.+\'\n\n}\n\n\n\n# 创建测试\n\n使用 Mockito 创建一个单元测试来验证在传递正确 extra data 的情况下，intent 是否被触发。\n\n因此我们需要使用 Mockito 来 mock 一个Context对象，如下代码所示：\n\npackage com.vogella.android.testing.mockitocontextmock;\n\nimport android.content.Context;\nimport android.content.Intent;\nimport android.os.Bundle;\n\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.Mockito;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNotNull;\n\npublic class TextIntentCreation {\n\n    @Test\n    public void testIntentShouldBeCreated() {\n        Context context = Mockito.mock(Context.class);\n        Intent intent = MainActivity.createQuery(context, "query", "value");\n        assertNotNull(intent);\n        Bundle extras = intent.getExtras();\n        assertNotNull(extras);\n        assertEquals("query", extras.getString("QUERY"));\n        assertEquals("value", extras.getString("VALUE"));\n    }\n}\n\n\n\n# 实例：使用 Mockito 创建一个 mock 对象\n\n\n# 目标\n\n创建一个 Api，它可以被 Mockito 来模拟并做一些工作\n\n\n# 创建一个 Twitter API 的例子\n\n实现 TwitterClient类，它内部使用到了 ITweet 的实现。但是ITweet实例很难得到，譬如说他需要启动一个很复杂的服务来得到。\n\npublic interface ITweet {\n\n        String getMessage();\n}\n\n\npublic class TwitterClient {\n\n        public void sendTweet(ITweet tweet) {\n                String message = tweet.getMessage();\n\n                // send the message to Twitter\n        }\n}\n\n\n\n# 模拟 ITweet 的实例\n\n为了能够不启动复杂的服务来得到 ITweet，我们可以使用 Mockito 来模拟得到该实例。\n\n@Test\npublic void testSendingTweet() {\n        TwitterClient twitterClient = new TwitterClient();\n\n        ITweet iTweet = mock(ITweet.class);\n\n        when(iTweet.getMessage()).thenReturn("Using mockito is great");\n\n        twitterClient.sendTweet(iTweet);\n}\n\n\n现在 TwitterClient 可以使用 ITweet 接口的实现，当调用 getMessage() 方法的时候将会打印 "Using Mockito is great" 信息。\n\n\n# 验证方法调用\n\n确保 getMessage() 方法至少调用一次。\n\n@Test\npublic void testSendingTweet() {\n        TwitterClient twitterClient = new TwitterClient();\n\n        ITweet iTweet = mock(ITweet.class);\n\n        when(iTweet.getMessage()).thenReturn("Using mockito is great");\n\n        twitterClient.sendTweet(iTweet);\n\n        verify(iTweet, atLeastOnce()).getMessage();\n}\n\n\n\n# 验证\n\n运行测试，查看代码是否测试通过。\n\n\n# 模拟静态方法\n\n\n# 使用 Powermock 来模拟静态方法\n\n因为 Mockito 不能够 mock 静态方法，因此我们可以使用 Powermock。\n\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\n\npublic final class NetworkReader {\n    public static String getLocalHostname() {\n        String hostname = "";\n        try {\n            InetAddress addr = InetAddress.getLocalHost();\n            // Get hostname\n            hostname = addr.getHostName();\n        } catch ( UnknownHostException e ) {\n        }\n        return hostname;\n    }\n}\n\n\n我们模拟了 NetworkReader 的依赖，如下代码所示：\n\nimport org.junit.runner.RunWith;\nimport org.powermock.core.classloader.annotations.PrepareForTest;\n\n@RunWith( PowerMockRunner.class )\n@PrepareForTest( NetworkReader.class )\npublic class MyTest {\n\n// 测试代码\n\n @Test\npublic void testSomething() {\n    mockStatic( NetworkUtil.class );\n    when( NetworkReader.getLocalHostname() ).andReturn( "localhost" );\n\n    // 与 NetworkReader 协作的测试\n}\n\n\n\n# 用封装的方法代替 Powermock\n\n有时候我们可以在静态方法周围包含非静态的方法来达到和 Powermock 同样的效果。\n\nclass FooWraper {\n      void someMethod() {\n           Foo.someStaticMethod()\n       }\n}\n\n\n\n# 引用和引申\n\n * 官网\n * Github\n * 使用强大的 Mockito 测试框架来测试你的代码',normalizedContent:'# mockito 快速入门\n\n> mockito 是一个针对 java 的 mock 框架。\n\n\n# 预备知识\n\n如果需要往下学习，你需要先理解 junit 框架中的单元测试。\n\n如果你不熟悉 junit，请看 junit 教程\n\n\n# 使用 mock 对象来进行测试\n\n\n# 单元测试的目标和挑战\n\n单元测试的思路是在不涉及依赖关系的情况下测试代码（隔离性），所以测试代码与其他类或者系统的关系应该尽量被消除。一个可行的消除方法是替换掉依赖类（测试替换），也就是说我们可以使用替身来替换掉真正的依赖对象。\n\n\n# 测试类的分类\n\n * dummy object 做为参数传递给方法但是绝对不会被使用。譬如说，这种测试类内部的方法不会被调用，或者是用来填充某个方法的参数。\n * fake 是真正接口或抽象类的实现体，但给对象内部实现很简单。譬如说，它存在内存中而不是真正的数据库中。（译者注：fake 实现了真正的逻辑，但它的存在只是为了测试，而不适合于用在产品中。）\n * stub 类是依赖类的部分方法实现，而这些方法在你测试类和接口的时候会被用到，也就是说 stub 类在测试中会被实例化。stub 类会回应任何外部测试的调用。stub 类有时候还会记录调用的一些信息。\n * mock object 是指类或者接口的模拟实现，你可以自定义这个对象中某个方法的输出结果。\n\n测试替代技术能够在测试中模拟测试类以外对象。因此你可以验证测试类是否响应正常。譬如说，你可以验证在 mock 对象的某一个方法是否被调用。这可以确保隔离了外部依赖的干扰只测试测试类。\n\n我们选择 mock 对象的原因是因为 mock 对象只需要少量代码的配置。\n\n\n# mock 对象的产生\n\n你可以手动创建一个 mock 对象或者使用 mock 框架来模拟这些类，mock 框架允许你在运行时创建 mock 对象并且定义它的行为。\n\n一个典型的例子是把 mock 对象模拟成数据的提供者。在正式的生产环境中它会被实现用来连接数据源。但是我们在测试的时候 mock 对象将会模拟成数据提供者来确保我们的测试环境始终是相同的。\n\nmock 对象可以被提供来进行测试。因此，我们测试的类应该避免任何外部数据的强依赖。\n\n通过 mock 对象或者 mock 框架，我们可以测试代码中期望的行为。譬如说，验证只有某个存在 mock 对象的方法是否被调用了。\n\n\n# 使用 mockito 生成 mock 对象\n\nmockito 是一个流行 mock 框架，可以和 junit 结合起来使用。mockito 允许你创建和配置 mock 对象。使用 mockito 可以明显的简化对外部依赖的测试类的开发。\n\n一般使用 mockito 需要执行下面三步\n\n 1. 模拟并替换测试代码中外部依赖\n 2. 执行测试代码\n 3. 验证测试代码是否被正确的执行 0\n\n\n# 为自己的项目添加 mockito 依赖\n\n\n# 在 gradle 添加 mockito 依赖\n\n如果你的项目使用 gradle 构建，将下面代码加入 gradle 的构建文件中为自己项目添加 mockito 依赖\n\nrepositories { jcenter() }\ndependencies { testcompile "org.mockito:mockito-core:2.0.57-beta" }\n\n\n\n# 在 maven 添加 mockito 依赖\n\n需要在 maven 声明依赖，您可以在 http://search.maven.org 网站中搜索 g:"org.mockito", a:"mockito-core" 来得到具体的声明方式。\n\n\n# 在 eclipse ide 使用 mockito\n\neclipse ide 支持 gradle 和 maven 两种构建工具，所以在 eclipse ide 添加依赖取决你使用的是哪一个构建工具。\n\n\n# 以 osgi 或者 eclipse 插件形式添加 mockito 依赖\n\n在 eclipse rcp 应用依赖通常可以在 p2 update 上得到。orbit 是一个很好的第三方仓库，我们可以在里面寻找能在 eclipse 上使用的应用和插件。\n\norbit 仓库地址：http://download.eclipse.org/tools/orbit/downloads\n\n\n# 使用 mockito api\n\n\n# 静态引用\n\n如果在代码中静态引用了org.mockito.mockito.*;，那你你就可以直接调用静态方法和静态变量而不用创建对象，譬如直接调用 mock() 方法。\n\n\n# 使用 mockito 创建和配置 mock 对象\n\n除了上面所说的使用 mock() 静态方法外，mockito 还支持通过 @mock 注解的方式来创建 mock 对象。\n\n如果你使用注解，那么必须要实例化 mock 对象。mockito 在遇到使用注解的字段的时候，会调用mockitoannotations.initmocks(this) 来初始化该 mock 对象。另外也可以通过使用@runwith(mockitojunitrunner.class)来达到相同的效果。\n\n通过下面的例子我们可以了解到使用@mock 的方法和mockitorule规则。\n\nimport static org.mockito.mockito.*;\n\npublic class mockitotest  {\n\n        @mock\n        mydatabase databasemock; (1)\n\n        @rule public mockitorule mockitorule = mockitojunit.rule(); (2)\n\n        @test\n        public void testquery()  {\n                classtotest t  = new classtotest(databasemock); (3)\n                boolean check = t.query("* from t"); (4)\n                asserttrue(check); (5)\n                verify(databasemock).query("* from t"); (6)\n        }\n}\n\n\n 1. 告诉 mockito 模拟 databasemock 实例\n 2. mockito 通过 @mock 注解创建 mock 对象\n 3. 使用已经创建的 mock 初始化这个类\n 4. 在测试环境下，执行测试类中的代码\n 5. 使用断言确保调用的方法返回值为 true\n 6. 验证 query 方法是否被 mydatabase 的 mock 对象调用\n\n\n# 配置 mock\n\n当我们需要配置某个方法的返回值的时候，mockito 提供了链式的 api 供我们方便的调用\n\nwhen(….).thenreturn(….)可以被用来定义当条件满足时函数的返回值，如果你需要定义多个返回值，可以多次定义。当你多次调用函数的时候，mockito 会根据你定义的先后顺序来返回返回值。mocks 还可以根据传入参数的不同来定义不同的返回值。譬如说你的函数可以将anystring 或者 anyint作为输入参数，然后定义其特定的放回值。\n\nimport static org.mockito.mockito.*;\nimport static org.junit.assert.*;\n\n@test\npublic void test1()  {\n        //  创建 mock\n        myclass test = mockito.mock(myclass.class);\n\n        // 自定义 getuniqueid() 的返回值\n        when(test.getuniqueid()).thenreturn(43);\n\n        // 在测试中使用mock对象\n        assertequals(test.getuniqueid(), 43);\n}\n\n// 返回多个值\n@test\npublic void testmorethanonereturnvalue()  {\n        iterator i= mock(iterator.class);\n        when(i.next()).thenreturn("mockito").thenreturn("rocks");\n        string result=i.next()+" "+i.next();\n        // 断言\n        assertequals("mockito rocks", result);\n}\n\n// 如何根据输入来返回值\n@test\npublic void testreturnvaluedependentonmethodparameter()  {\n        comparable c= mock(comparable.class);\n        when(c.compareto("mockito")).thenreturn(1);\n        when(c.compareto("eclipse")).thenreturn(2);\n        // 断言\n        assertequals(1,c.compareto("mockito"));\n}\n\n// 如何让返回值不依赖于输入\n@test\npublic void testreturnvalueindependentonmethodparameter()  {\n        comparable c= mock(comparable.class);\n        when(c.compareto(anyint())).thenreturn(-1);\n        // 断言\n        assertequals(-1 ,c.compareto(9));\n}\n\n// 根据参数类型来返回值\n@test\npublic void testreturnvalueindependentonmethodparameter()  {\n        comparable c= mock(comparable.class);\n        when(c.compareto(isa(todo.class))).thenreturn(0);\n        // 断言\n        todo todo = new todo(5);\n        assertequals(todo ,c.compareto(new todo(1)));\n}\n\n\n对于无返回值的函数，我们可以使用doreturn(…).when(…).methodcall来获得类似的效果。例如我们想在调用某些无返回值函数的时候抛出异常，那么可以使用dothrow 方法。如下面代码片段所示\n\nimport static org.mockito.mockito.*;\nimport static org.junit.assert.*;\n\n// 下面测试用例描述了如何使用dothrow()方法\n\n@test(expected=ioexception.class)\npublic void testforioexception() {\n        // 创建并配置 mock 对象\n        outputstream mockstream = mock(outputstream.class);\n        dothrow(new ioexception()).when(mockstream).close();\n\n        // 使用 mock\n        outputstreamwriter streamwriter= new outputstreamwriter(mockstream);\n        streamwriter.close();\n}\n\n\n\n# 验证 mock 对象方法是否被调用\n\nmockito 会跟踪 mock 对象里面所有的方法和变量。所以我们可以用来验证函数在传入特定参数的时候是否被调用。这种方式的测试称行为测试，行为测试并不会检查函数的返回值，而是检查在传入正确参数时候函数是否被调用。\n\nimport static org.mockito.mockito.*;\n\n@test\npublic void testverify()  {\n        // 创建并配置 mock 对象\n        myclass test = mockito.mock(myclass.class);\n        when(test.getuniqueid()).thenreturn(43);\n\n        // 调用mock对象里面的方法并传入参数为12\n        test.testing(12);\n        test.getuniqueid();\n        test.getuniqueid();\n\n        // 查看在传入参数为12的时候方法是否被调用\n        verify(test).testing(matchers.eq(12));\n\n        // 方法是否被调用两次\n        verify(test, times(2)).getuniqueid();\n\n        // 其他用来验证函数是否被调用的方法\n        verify(mock, never()).somemethod("never called");\n        verify(mock, atleastonce()).somemethod("called at least once");\n        verify(mock, atleast(2)).somemethod("called at least twice");\n        verify(mock, times(5)).somemethod("called five times");\n        verify(mock, atmost(3)).somemethod("called at most 3 times");\n}\n\n\n\n# 使用 spy 封装 java 对象\n\n@spy 或者spy()方法可以被用来封装 java 对象。被封装后，除非特殊声明（打桩 stub），否则都会真正的调用对象里面的每一个方法\n\nimport static org.mockito.mockito.*;\n\n// lets mock a linkedlist\nlist list = new linkedlist();\nlist spy = spy(list);\n\n// 可用 doreturn() 来打桩\ndoreturn("foo").when(spy).get(0);\n\n// 下面代码不生效\n// 真正的方法会被调用\n// 将会抛出 indexoutofboundsexception 的异常，因为 list 为空\nwhen(spy.get(0)).thenreturn("foo");\n\n\n方法verifynomoreinteractions()允许你检查没有其他的方法被调用了。\n\n\n# 使用 @injectmocks 在 mockito 中进行依赖注入\n\n我们也可以使用@injectmocks 注解来创建对象，它会根据类型来注入对象里面的成员方法和变量。假定我们有 articlemanager 类\n\npublic class articlemanager {\n    private user user;\n    private articledatabase database;\n\n    articlemanager(user user) {\n     this.user = user;\n    }\n\n    void setdatabase(articledatabase database) { }\n}\n\n\n这个类会被 mockito 构造，而类的成员方法和变量都会被 mock 对象所代替，正如下面的代码片段所示：\n\n@runwith(mockitojunitrunner.class)\npublic class articlemanagertest  {\n\n       @mock articlecalculator calculator;\n       @mock articledatabase database;\n       @most user user;\n\n       @spy private userprovider userprovider = new consumeruserprovider();\n\n       @injectmocks private articlemanager manager; (1)\n\n       @test public void shoulddosomething() {\n               // 假定 articlemanager 有一个叫 initialize() 的方法被调用了\n               // 使用 articlelistener 来调用 addlistener 方法\n               manager.initialize();\n\n               // 验证 addlistener 方法被调用\n               verify(database).addlistener(any(articlelistener.class));\n       }\n}\n\n\n 1. 创建 articlemanager 实例并注入 mock 对象\n\n更多的详情可以查看 http://docs.mockito.googlecode.com/hg/1.9.5/org/mockito/injectmocks.html\n\n\n# 捕捉参数\n\nargumentcaptor类允许我们在 verification 期间访问方法的参数。得到方法的参数后我们可以使用它进行测试。\n\nimport static org.hamcrest.matchers.hasitem;\nimport static org.junit.assert.assertthat;\nimport static org.mockito.mockito.mock;\nimport static org.mockito.mockito.verify;\n\nimport java.util.arrays;\nimport java.util.list;\n\nimport org.junit.rule;\nimport org.junit.test;\nimport org.mockito.argumentcaptor;\nimport org.mockito.captor;\nimport org.mockito.junit.mockitojunit;\nimport org.mockito.junit.mockitorule;\n\npublic class mockitotests {\n    @rule\n    public mockitorule rule = mockitojunit.rule();\n\n    @captor\n    private argumentcaptor<list<string>> captor;\n\n    @test\n    public final void shouldcontaincertainlistitem() {\n        list<string> aslist = arrays.aslist("someelement_test", "someelement");\n        final list<string> mockedlist = mock(list.class);\n        mockedlist.addall(aslist);\n\n        verify(mockedlist).addall(captor.capture());\n        final list<string> capturedargument = captor.getvalue();\n        assertthat(capturedargument, hasitem("someelement"));\n    }\n}\n\n\n\n# mockito 的限制\n\nmockito 当然也有一定的限制。而下面三种数据类型则不能够被测试\n\n * final classes\n * anonymous classes\n * primitive types\n\n\n# 在 android 中使用 mockito\n\n在 android 中的 gradle 构建文件中加入 mockito 依赖后就可以直接使用 mockito 了。若想使用 android instrumented tests 的话，还需要添加 dexmaker 和 dexmaker-mockito 依赖到 gradle 的构建文件中。（需要 mockito 1.9.5 版本以上）\n\ndependencies {\n    testcompile \'junit:junit:4.12\'\n    // mockito unit test 的依赖\n    testcompile \'org.mockito:mockito-core:1.+\'\n    // mockito android instrumentation tests 的依赖\n    androidtestcompile \'org.mockito:mockito-core:1.+\'\n    androidtestcompile "com.google.dexmaker:dexmaker:1.2"\n    androidtestcompile "com.google.dexmaker:dexmaker-mockito:1.2"\n}\n\n\n\n# 实例：使用 mockito 写一个 instrumented unit test\n\n\n# 创建一个测试的 android 应用\n\n创建一个包名为com.vogella.android.testing.mockito.contextmock的 android 应用，添加一个静态方法 ，方法里面创建一个包含参数的 intent，如下代码所示：\n\npublic static intent createquery(context context, string query, string value) {\n    // 简单起见，重用mainactivity\n    intent i = new intent(context, mainactivity.class);\n    i.putextra("query", query);\n    i.putextra("value", value);\n    return i;\n}\n\n\n\n# 在 app/build.gradle 文件中添加 mockito 依赖\n\ndependencies {\n    // mockito 和 junit 的依赖\n    // instrumentation unit tests on the jvm\n    androidtestcompile \'junit:junit:4.12\'\n    androidtestcompile \'org.mockito:mockito-core:2.0.57-beta\'\n    androidtestcompile \'com.android.support.test:runner:0.3\'\n    androidtestcompile "com.google.dexmaker:dexmaker:1.2"\n    androidtestcompile "com.google.dexmaker:dexmaker-mockito:1.2"\n\n    // mockito 和 junit 的依赖\n    // tests on the jvm\n    testcompile \'junit:junit:4.12\'\n    testcompile \'org.mockito:mockito-core:1.+\'\n\n}\n\n\n\n# 创建测试\n\n使用 mockito 创建一个单元测试来验证在传递正确 extra data 的情况下，intent 是否被触发。\n\n因此我们需要使用 mockito 来 mock 一个context对象，如下代码所示：\n\npackage com.vogella.android.testing.mockitocontextmock;\n\nimport android.content.context;\nimport android.content.intent;\nimport android.os.bundle;\n\nimport org.junit.test;\nimport org.junit.runner.runwith;\nimport org.mockito.mockito;\n\nimport static org.junit.assert.assertequals;\nimport static org.junit.assert.assertnotnull;\n\npublic class textintentcreation {\n\n    @test\n    public void testintentshouldbecreated() {\n        context context = mockito.mock(context.class);\n        intent intent = mainactivity.createquery(context, "query", "value");\n        assertnotnull(intent);\n        bundle extras = intent.getextras();\n        assertnotnull(extras);\n        assertequals("query", extras.getstring("query"));\n        assertequals("value", extras.getstring("value"));\n    }\n}\n\n\n\n# 实例：使用 mockito 创建一个 mock 对象\n\n\n# 目标\n\n创建一个 api，它可以被 mockito 来模拟并做一些工作\n\n\n# 创建一个 twitter api 的例子\n\n实现 twitterclient类，它内部使用到了 itweet 的实现。但是itweet实例很难得到，譬如说他需要启动一个很复杂的服务来得到。\n\npublic interface itweet {\n\n        string getmessage();\n}\n\n\npublic class twitterclient {\n\n        public void sendtweet(itweet tweet) {\n                string message = tweet.getmessage();\n\n                // send the message to twitter\n        }\n}\n\n\n\n# 模拟 itweet 的实例\n\n为了能够不启动复杂的服务来得到 itweet，我们可以使用 mockito 来模拟得到该实例。\n\n@test\npublic void testsendingtweet() {\n        twitterclient twitterclient = new twitterclient();\n\n        itweet itweet = mock(itweet.class);\n\n        when(itweet.getmessage()).thenreturn("using mockito is great");\n\n        twitterclient.sendtweet(itweet);\n}\n\n\n现在 twitterclient 可以使用 itweet 接口的实现，当调用 getmessage() 方法的时候将会打印 "using mockito is great" 信息。\n\n\n# 验证方法调用\n\n确保 getmessage() 方法至少调用一次。\n\n@test\npublic void testsendingtweet() {\n        twitterclient twitterclient = new twitterclient();\n\n        itweet itweet = mock(itweet.class);\n\n        when(itweet.getmessage()).thenreturn("using mockito is great");\n\n        twitterclient.sendtweet(itweet);\n\n        verify(itweet, atleastonce()).getmessage();\n}\n\n\n\n# 验证\n\n运行测试，查看代码是否测试通过。\n\n\n# 模拟静态方法\n\n\n# 使用 powermock 来模拟静态方法\n\n因为 mockito 不能够 mock 静态方法，因此我们可以使用 powermock。\n\nimport java.net.inetaddress;\nimport java.net.unknownhostexception;\n\npublic final class networkreader {\n    public static string getlocalhostname() {\n        string hostname = "";\n        try {\n            inetaddress addr = inetaddress.getlocalhost();\n            // get hostname\n            hostname = addr.gethostname();\n        } catch ( unknownhostexception e ) {\n        }\n        return hostname;\n    }\n}\n\n\n我们模拟了 networkreader 的依赖，如下代码所示：\n\nimport org.junit.runner.runwith;\nimport org.powermock.core.classloader.annotations.preparefortest;\n\n@runwith( powermockrunner.class )\n@preparefortest( networkreader.class )\npublic class mytest {\n\n// 测试代码\n\n @test\npublic void testsomething() {\n    mockstatic( networkutil.class );\n    when( networkreader.getlocalhostname() ).andreturn( "localhost" );\n\n    // 与 networkreader 协作的测试\n}\n\n\n\n# 用封装的方法代替 powermock\n\n有时候我们可以在静态方法周围包含非静态的方法来达到和 powermock 同样的效果。\n\nclass foowraper {\n      void somemethod() {\n           foo.somestaticmethod()\n       }\n}\n\n\n\n# 引用和引申\n\n * 官网\n * github\n * 使用强大的 mockito 测试框架来测试你的代码',charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Java 测试",frontmatter:{title:"Java 测试",date:"2022-02-17T22:34:30.000Z",categories:["Java","工具","测试"],tags:["Java","测试"],permalink:"/pages/2cecc3/",hidden:!0,index:!1},regularPath:"/01.Java/12.%E5%B7%A5%E5%85%B7/04.%E6%B5%8B%E8%AF%95/",relativePath:"01.Java/12.工具/04.测试/README.md",key:"v-1d1948c1",path:"/pages/2cecc3/",headers:[{level:2,title:"内容",slug:"内容",normalizedTitle:"内容",charIndex:14}],headersStr:"内容",content:"# Java 测试\n\n\n# 内容\n\n * Junit\n * Mockito\n * Jmeter\n * JMH",normalizedContent:"# java 测试\n\n\n# 内容\n\n * junit\n * mockito\n * jmeter\n * jmh",charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"JMeter 快速入门",frontmatter:{title:"JMeter 快速入门",date:"2022-02-17T22:34:30.000Z",order:3,categories:["Java","工具","测试"],tags:["Java","测试","JMeter"],permalink:"/pages/0e5ab1/"},regularPath:"/01.Java/12.%E5%B7%A5%E5%85%B7/04.%E6%B5%8B%E8%AF%95/03.Jmeter.html",relativePath:"01.Java/12.工具/04.测试/03.Jmeter.md",key:"v-7cf35edc",path:"/pages/0e5ab1/",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:79},{level:3,title:"特性",slug:"特性",normalizedTitle:"特性",charIndex:119},{level:3,title:"工作流",slug:"工作流",normalizedTitle:"工作流",charIndex:361},{level:3,title:"主要元素",slug:"主要元素",normalizedTitle:"主要元素",charIndex:436},{level:2,title:"安装",slug:"安装",normalizedTitle:"安装",charIndex:1331},{level:3,title:"环境要求",slug:"环境要求",normalizedTitle:"环境要求",charIndex:1338},{level:3,title:"下载",slug:"下载",normalizedTitle:"下载",charIndex:1444},{level:3,title:"启动",slug:"启动",normalizedTitle:"启动",charIndex:1541},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:93},{level:3,title:"创建测试计划",slug:"创建测试计划",normalizedTitle:"创建测试计划",charIndex:1626},{level:4,title:"创建线程组",slug:"创建线程组",normalizedTitle:"创建线程组",charIndex:1713},{level:4,title:"配置原件",slug:"配置原件",normalizedTitle:"配置原件",charIndex:1777},{level:4,title:"构造 HTTP 请求",slug:"构造-http-请求",normalizedTitle:"构造 http 请求",charIndex:1853},{level:4,title:"添加 HTTP 请求头",slug:"添加-http-请求头",normalizedTitle:"添加 http 请求头",charIndex:1985},{level:4,title:"添加断言",slug:"添加断言",normalizedTitle:"添加断言",charIndex:2108},{level:4,title:"添加察看结果树",slug:"添加察看结果树",normalizedTitle:"添加察看结果树",charIndex:2191},{level:4,title:"添加汇总报告",slug:"添加汇总报告",normalizedTitle:"添加汇总报告",charIndex:2259},{level:4,title:"保存测试计划",slug:"保存测试计划",normalizedTitle:"保存测试计划",charIndex:1664},{level:3,title:"执行测试计划",slug:"执行测试计划",normalizedTitle:"执行测试计划",charIndex:2333},{level:2,title:"问题",slug:"问题",normalizedTitle:"问题",charIndex:2607},{level:3,title:"如何读取本地 txt/csv 文件作为请求参数",slug:"如何读取本地-txt-csv-文件作为请求参数",normalizedTitle:"如何读取本地 txt/csv 文件作为请求参数",charIndex:2614},{level:3,title:"如何有序发送数据",slug:"如何有序发送数据",normalizedTitle:"如何有序发送数据",charIndex:2890},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:2931}],headersStr:"简介 特性 工作流 主要元素 安装 环境要求 下载 启动 使用 创建测试计划 创建线程组 配置原件 构造 HTTP 请求 添加 HTTP 请求头 添加断言 添加察看结果树 添加汇总报告 保存测试计划 执行测试计划 问题 如何读取本地 txt/csv 文件作为请求参数 如何有序发送数据 参考资料",content:'# JMeter 快速入门\n\n> Jmeter 是一款基于 Java 开发的功能和性能测试软件。\n> \n> 🎁 本文编辑时的最新版本为：5.1.1\n\n\n# 简介\n\nJmeter 是一款使用 Java 开发的功能和性能测试软件。\n\n\n# 特性\n\nJmeter 能够加载和性能测试许多不同的应用程序/服务器/协议类型：\n\n * 网络 - HTTP，HTTPS(Java，NodeJS，PHP，ASP.NET 等)\n * SOAP / REST Web 服务\n * FTP 文件\n * 通过 JDBC 的数据库\n * LDAP\n * 通过 JMS 的面向消息的中间件(MOM)\n * 邮件-SMTP(S)，POP3(S)和 IMAP(S)\n * 本机命令或 Shell 脚本\n * TCP 协议\n * Java 对象\n\n\n# 工作流\n\nJmeter 的工作原理是仿真用户向服务器发送请求，并收集服务器应答信息并计算统计信息。\n\nJmeter 的工作流如下图所示：\n\n\n\n\n# 主要元素\n\nJmeter 的主要元素如下：\n\n * 测试计划(Test Plan) - 可以将测试计划视为 JMeter 的测试脚本 。测试计划由测试元素组成，例如线程组，逻辑控制器，样本生成控制器，监听器，定时器，断言和配置元素。\n * 线程组(Thread Group) - 线程组的作用是：模拟大量用户负载的运行场景。\n   * 设置线程数\n   * 设置加速期\n   * 设置执行测试的次数\n * 控制器(Controllers) - 可以分为两大类：\n   * 采样器（Sampler） - 采样器的作用是模拟用户对目标服务器发送请求。 采样器是必须将组件添加到测试计划中的，因为它只能让 JMeter 知道需要将哪种类型的请求发送到服务器。 请求可以是 HTTP，HTTP(s)，FTP，TCP，SMTP，SOAP 等。\n   * 逻辑控制器 - 逻辑控制器的作用是：控制多个请求发送的循环次数及顺序等。\n * 监听器(Listeners) - 监听器的作用是：收集测试结果信息。如查看结果树、汇总报告等。\n * 计时器(Timers) - 计时器的作用是：控制多个请求发送的时间频次。\n * 配置元素(Configuration Elements) - 配置元素的工作与采样器的工作类似。但是，它不发送请求，而是提供预备的数据等，如 CSV、函数助手。\n * 预处理器元素(Pre-Processor Elements) - 预处理器元素在采样器发出请求之前执行，如果预处理器附加到采样器元素，那么它将在该采样器元素运行之前执行。预处理器元素用于在运行之前准备环境及参数。\n * 后处理器元素(Post-Processor Elements) - 后处理器元素是在发送采样器请求之后执行的元素，常用于处理响应数据。\n\n\n\n> 📌 提示：\n> \n> Jmeter 元素的数量关系大致如下：\n> \n>  1. 脚本中最多只能有一个测试计划。\n>  2. 测试计划中至少要有一个线程组。\n>  3. 线程组中至少要有一个取样器。\n>  4. 线程组中至少要有一个监听器。\n\n\n# 安装\n\n\n# 环境要求\n\n * 必要的。Jmeter 基于 JDK8 开发，所以必须运行在 JDK8 环境。\n   \n   * JDK8\n\n * 可选的。有些 jar 包不是 Jmeter 提供的，如果需要相应的功能，需要自行下载并置于 lib 目录。\n   \n   * JDBC\n   * JMS\n   * Bouncy Castle\n\n\n# 下载\n\n进入 Jmeter 官网下载地址 选择需要版本进行下载。\n\n\n# 启动\n\n解压 Jmeter 压缩包，进入 bin 目录\n\nUnix 类系统运行 jmeter ；Windows 系统运行 jmeter.bat\n\n\n\n\n# 使用\n\n\n# 创建测试计划\n\n> 🔔 注意：\n> \n>  * 在运行整个测试计划之前，应保存测试计划。\n> \n>  * JMeter 的测试计划以 .jmx 扩展文件的形式保存。\n\n# 创建线程组\n\n * 在“测试计划”上右键 【添加】=>【线程（用户）】=>【线程组】。\n\n * 设置线程数和循环次数\n\n\n\n# 配置原件\n\n * 在新建的线程组上右键 【添加】=>【配置元件】=>【HTTP 请求默认值】。\n\n * 填写协议、服务器名称或 IP、端口号\n\n\n\n# 构造 HTTP 请求\n\n * 在“线程组”上右键 【添加-】=>【取样器】=>【HTTP 请求】。\n\n * 填写协议、服务器名称或 IP、端口号（如果配置了 HTTP 请求默认值可以忽略）\n\n * 填写方法、路径\n\n * 填写参数、消息体数据、文件上传\n\n\n\n# 添加 HTTP 请求头\n\n * 在“线程组”上右键 【添加】=>【配置元件】=>【HTTP 信息头管理器】\n * 由于我的测试例中传输的数据为 json 形式，所以设置键值对 Content-Type：application/json\n\n\n\n# 添加断言\n\n * 在“线程组”上右键 【添加】=>【断言】=>【 响应断言 】\n * 在我的案例中，以 HTTP 应答状态码为 200 来判断请求是否成功\n\n\n\n# 添加察看结果树\n\n * 在“线程组”上右键 【添加】=>【监听器】=>【察看结果树】\n * 直接点击运行，就可以查看测试结果\n\n\n\n# 添加汇总报告\n\n * 在“线程组”上右键 【添加】=>【监听器】=>【汇总报告】\n * 直接点击运行，就可以查看测试结果\n\n\n\n# 保存测试计划\n\n执行测试计划前，GUI 会提示先保存配置为 jmx 文件。\n\n\n# 执行测试计划\n\n官方建议不要直接使用 GUI 来执行测试计划，这种模式指适用于创建测试计划和 debug。\n\n执行测试计划应该使用命令行模式，语法形式如下：\n\njmeter -n -t [jmx file] -l [results file] -e -o [Path to web report folder]\n\n\n执行测试计划后，在 -e -o 参数后指定的 web 报告目录下，可以找到测试报告内容。在浏览器中打开 index.html 文件，可以看到如下报告：\n\n\n\n\n# 问题\n\n\n# 如何读取本地 txt/csv 文件作为请求参数\n\n参考：Jmeter 读取本地 txt/csv 文件作为请求参数，实现接口自动化\n\n（1）依次点击【添加】=>【配置元件】=>【CSV 数据文件设置】\n\n配置如下所示：\n\n\n\n重要配置说明（其他配置根据实际情况填）：\n\n * 文件名：输入需要导入的数据文件位置。\n * 文件编码：设为 UTF-8，避免乱码。\n * 变量名称：使用 , 分隔输入变量列表。如截图中设置了两个变量 a 和 b\n\n（2）在 HTTP 请求的消息体数据中配置参数\n\n[{"a":"${a}","b":"${b}"}]\n\n\n\n# 如何有序发送数据\n\n依次点击【添加】=>【逻辑控制器】=>【事务控制器】\n\n\n# 参考资料\n\n * Jmeter 官网\n * Jmeter Github\n * Jmeter 性能测试入门\n * 易百教程 - Jmeter 教程\n * Jmeter 读取本地 txt/csv 文件作为请求参数，实现接口自动化',normalizedContent:'# jmeter 快速入门\n\n> jmeter 是一款基于 java 开发的功能和性能测试软件。\n> \n> 🎁 本文编辑时的最新版本为：5.1.1\n\n\n# 简介\n\njmeter 是一款使用 java 开发的功能和性能测试软件。\n\n\n# 特性\n\njmeter 能够加载和性能测试许多不同的应用程序/服务器/协议类型：\n\n * 网络 - http，https(java，nodejs，php，asp.net 等)\n * soap / rest web 服务\n * ftp 文件\n * 通过 jdbc 的数据库\n * ldap\n * 通过 jms 的面向消息的中间件(mom)\n * 邮件-smtp(s)，pop3(s)和 imap(s)\n * 本机命令或 shell 脚本\n * tcp 协议\n * java 对象\n\n\n# 工作流\n\njmeter 的工作原理是仿真用户向服务器发送请求，并收集服务器应答信息并计算统计信息。\n\njmeter 的工作流如下图所示：\n\n\n\n\n# 主要元素\n\njmeter 的主要元素如下：\n\n * 测试计划(test plan) - 可以将测试计划视为 jmeter 的测试脚本 。测试计划由测试元素组成，例如线程组，逻辑控制器，样本生成控制器，监听器，定时器，断言和配置元素。\n * 线程组(thread group) - 线程组的作用是：模拟大量用户负载的运行场景。\n   * 设置线程数\n   * 设置加速期\n   * 设置执行测试的次数\n * 控制器(controllers) - 可以分为两大类：\n   * 采样器（sampler） - 采样器的作用是模拟用户对目标服务器发送请求。 采样器是必须将组件添加到测试计划中的，因为它只能让 jmeter 知道需要将哪种类型的请求发送到服务器。 请求可以是 http，http(s)，ftp，tcp，smtp，soap 等。\n   * 逻辑控制器 - 逻辑控制器的作用是：控制多个请求发送的循环次数及顺序等。\n * 监听器(listeners) - 监听器的作用是：收集测试结果信息。如查看结果树、汇总报告等。\n * 计时器(timers) - 计时器的作用是：控制多个请求发送的时间频次。\n * 配置元素(configuration elements) - 配置元素的工作与采样器的工作类似。但是，它不发送请求，而是提供预备的数据等，如 csv、函数助手。\n * 预处理器元素(pre-processor elements) - 预处理器元素在采样器发出请求之前执行，如果预处理器附加到采样器元素，那么它将在该采样器元素运行之前执行。预处理器元素用于在运行之前准备环境及参数。\n * 后处理器元素(post-processor elements) - 后处理器元素是在发送采样器请求之后执行的元素，常用于处理响应数据。\n\n\n\n> 📌 提示：\n> \n> jmeter 元素的数量关系大致如下：\n> \n>  1. 脚本中最多只能有一个测试计划。\n>  2. 测试计划中至少要有一个线程组。\n>  3. 线程组中至少要有一个取样器。\n>  4. 线程组中至少要有一个监听器。\n\n\n# 安装\n\n\n# 环境要求\n\n * 必要的。jmeter 基于 jdk8 开发，所以必须运行在 jdk8 环境。\n   \n   * jdk8\n\n * 可选的。有些 jar 包不是 jmeter 提供的，如果需要相应的功能，需要自行下载并置于 lib 目录。\n   \n   * jdbc\n   * jms\n   * bouncy castle\n\n\n# 下载\n\n进入 jmeter 官网下载地址 选择需要版本进行下载。\n\n\n# 启动\n\n解压 jmeter 压缩包，进入 bin 目录\n\nunix 类系统运行 jmeter ；windows 系统运行 jmeter.bat\n\n\n\n\n# 使用\n\n\n# 创建测试计划\n\n> 🔔 注意：\n> \n>  * 在运行整个测试计划之前，应保存测试计划。\n> \n>  * jmeter 的测试计划以 .jmx 扩展文件的形式保存。\n\n# 创建线程组\n\n * 在“测试计划”上右键 【添加】=>【线程（用户）】=>【线程组】。\n\n * 设置线程数和循环次数\n\n\n\n# 配置原件\n\n * 在新建的线程组上右键 【添加】=>【配置元件】=>【http 请求默认值】。\n\n * 填写协议、服务器名称或 ip、端口号\n\n\n\n# 构造 http 请求\n\n * 在“线程组”上右键 【添加-】=>【取样器】=>【http 请求】。\n\n * 填写协议、服务器名称或 ip、端口号（如果配置了 http 请求默认值可以忽略）\n\n * 填写方法、路径\n\n * 填写参数、消息体数据、文件上传\n\n\n\n# 添加 http 请求头\n\n * 在“线程组”上右键 【添加】=>【配置元件】=>【http 信息头管理器】\n * 由于我的测试例中传输的数据为 json 形式，所以设置键值对 content-type：application/json\n\n\n\n# 添加断言\n\n * 在“线程组”上右键 【添加】=>【断言】=>【 响应断言 】\n * 在我的案例中，以 http 应答状态码为 200 来判断请求是否成功\n\n\n\n# 添加察看结果树\n\n * 在“线程组”上右键 【添加】=>【监听器】=>【察看结果树】\n * 直接点击运行，就可以查看测试结果\n\n\n\n# 添加汇总报告\n\n * 在“线程组”上右键 【添加】=>【监听器】=>【汇总报告】\n * 直接点击运行，就可以查看测试结果\n\n\n\n# 保存测试计划\n\n执行测试计划前，gui 会提示先保存配置为 jmx 文件。\n\n\n# 执行测试计划\n\n官方建议不要直接使用 gui 来执行测试计划，这种模式指适用于创建测试计划和 debug。\n\n执行测试计划应该使用命令行模式，语法形式如下：\n\njmeter -n -t [jmx file] -l [results file] -e -o [path to web report folder]\n\n\n执行测试计划后，在 -e -o 参数后指定的 web 报告目录下，可以找到测试报告内容。在浏览器中打开 index.html 文件，可以看到如下报告：\n\n\n\n\n# 问题\n\n\n# 如何读取本地 txt/csv 文件作为请求参数\n\n参考：jmeter 读取本地 txt/csv 文件作为请求参数，实现接口自动化\n\n（1）依次点击【添加】=>【配置元件】=>【csv 数据文件设置】\n\n配置如下所示：\n\n\n\n重要配置说明（其他配置根据实际情况填）：\n\n * 文件名：输入需要导入的数据文件位置。\n * 文件编码：设为 utf-8，避免乱码。\n * 变量名称：使用 , 分隔输入变量列表。如截图中设置了两个变量 a 和 b\n\n（2）在 http 请求的消息体数据中配置参数\n\n[{"a":"${a}","b":"${b}"}]\n\n\n\n# 如何有序发送数据\n\n依次点击【添加】=>【逻辑控制器】=>【事务控制器】\n\n\n# 参考资料\n\n * jmeter 官网\n * jmeter github\n * jmeter 性能测试入门\n * 易百教程 - jmeter 教程\n * jmeter 读取本地 txt/csv 文件作为请求参数，实现接口自动化',charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"JMH 快速入门",frontmatter:{title:"JMH 快速入门",date:"2022-02-17T22:34:30.000Z",order:4,categories:["Java","工具","测试"],tags:["Java","测试","JUnit"],permalink:"/pages/9c6402/"},regularPath:"/01.Java/12.%E5%B7%A5%E5%85%B7/04.%E6%B5%8B%E8%AF%95/04.JMH.html",relativePath:"01.Java/12.工具/04.测试/04.JMH.md",key:"v-fefff020",path:"/pages/9c6402/",headers:[{level:2,title:"基准测试简介",slug:"基准测试简介",normalizedTitle:"基准测试简介",charIndex:15},{level:3,title:"什么是基准测试",slug:"什么是基准测试",normalizedTitle:"什么是基准测试",charIndex:26},{level:3,title:"何时需要微基准测试",slug:"何时需要微基准测试",normalizedTitle:"何时需要微基准测试",charIndex:351},{level:2,title:"JMH 简介",slug:"jmh-简介",normalizedTitle:"jmh 简介",charIndex:466},{level:3,title:"为什么需要 JMH",slug:"为什么需要-jmh",normalizedTitle:"为什么需要 jmh",charIndex:699},{level:4,title:"死码消除",slug:"死码消除",normalizedTitle:"死码消除",charIndex:712},{level:4,title:"常量折叠与常量传播",slug:"常量折叠与常量传播",normalizedTitle:"常量折叠与常量传播",charIndex:757},{level:3,title:"JMH 的注意点",slug:"jmh-的注意点",normalizedTitle:"jmh 的注意点",charIndex:888},{level:3,title:"应用场景",slug:"应用场景",normalizedTitle:"应用场景",charIndex:952},{level:3,title:"JMH 概念",slug:"jmh-概念",normalizedTitle:"jmh 概念",charIndex:1126},{level:2,title:"JMH 快速入门",slug:"jmh-快速入门-2",normalizedTitle:"jmh 快速入门",charIndex:2},{level:3,title:"添加 maven 依赖",slug:"添加-maven-依赖",normalizedTitle:"添加 maven 依赖",charIndex:1452},{level:3,title:"测试代码",slug:"测试代码",normalizedTitle:"测试代码",charIndex:1798},{level:3,title:"执行 JMH",slug:"执行-jmh",normalizedTitle:"执行 jmh",charIndex:2846},{level:4,title:"命令行",slug:"命令行",normalizedTitle:"命令行",charIndex:2856},{level:4,title:"执行 main 方法",slug:"执行-main-方法",normalizedTitle:"执行 main 方法",charIndex:3246},{level:2,title:"JMH API",slug:"jmh-api",normalizedTitle:"jmh api",charIndex:7822},{level:3,title:"@BenchmarkMode",slug:"benchmarkmode",normalizedTitle:"@benchmarkmode",charIndex:1915},{level:3,title:"@Warmup",slug:"warmup",normalizedTitle:"@warmup",charIndex:1947},{level:3,title:"@Measurement",slug:"measurement",normalizedTitle:"@measurement",charIndex:1971},{level:3,title:"@Threads",slug:"threads",normalizedTitle:"@threads",charIndex:2040},{level:3,title:"@Fork",slug:"fork",normalizedTitle:"@fork",charIndex:2052},{level:3,title:"@OutputTimeUnit",slug:"outputtimeunit",normalizedTitle:"@outputtimeunit",charIndex:2061},{level:3,title:"@Benchmark",slug:"benchmark",normalizedTitle:"@benchmark",charIndex:1915},{level:3,title:"@Param",slug:"param",normalizedTitle:"@param",charIndex:8843},{level:3,title:"@Setup",slug:"setup",normalizedTitle:"@setup",charIndex:8913},{level:3,title:"@TearDown",slug:"teardown",normalizedTitle:"@teardown",charIndex:8974},{level:3,title:"@State",slug:"state",normalizedTitle:"@state",charIndex:9050},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:9352}],headersStr:"基准测试简介 什么是基准测试 何时需要微基准测试 JMH 简介 为什么需要 JMH 死码消除 常量折叠与常量传播 JMH 的注意点 应用场景 JMH 概念 JMH 快速入门 添加 maven 依赖 测试代码 执行 JMH 命令行 执行 main 方法 JMH API @BenchmarkMode @Warmup @Measurement @Threads @Fork @OutputTimeUnit @Benchmark @Param @Setup @TearDown @State 参考资料",content:'# JMH 快速入门\n\n\n# 基准测试简介\n\n\n# 什么是基准测试\n\n基准测试是指通过设计科学的测试方法、测试工具和测试系统，实现对一类测试对象的某项性能指标进行定量的和可对比的测试。\n\n现代软件常常都把高性能作为目标。那么，何为高性能，性能就是快，更快吗？显然，如果没有一个量化的标准，难以衡量性能的好坏。\n\n不同的基准测试其具体内容和范围也存在很大的不同。如果是专业的性能工程师，更加熟悉的可能是类似 SPEC 提供的工业标准的系统级测试；而对于大多数 Java 开发者，更熟悉的则是范围相对较小、关注点更加细节的微基准测试（Micro-Benchmark）。何谓 Micro Benchmark 呢？ 简单地说就是在 method 层面上的 benchmark，精度可以精确到 微秒级。\n\n\n# 何时需要微基准测试\n\n微基准测试大多是 API 级别的性能测试。\n\n微基准测试的适用场景：\n\n * 如果开发公共类库、中间件，会被其他模块经常调用的 API。\n * 对于性能，如响应延迟、吞吐量有严格要求的核心 API。\n\n\n# JMH 简介\n\nJMH(即 Java Microbenchmark Harness)，是目前主流的微基准测试框架。JMH 是由 Hotspot JVM 团队专家开发的，除了支持完整的基准测试过程，包括预热、运行、统计和报告等，还支持 Java 和其他 JVM 语言。更重要的是，它针对 Hotspot JVM 提供了各种特性，以保证基准测试的正确性，整体准确性大大优于其他框架，并且，JMH 还提供了用近乎白盒的方式进行 Profiling 等工作的能力。\n\n\n# 为什么需要 JMH\n\n# 死码消除\n\n所谓死码，是指注释的代码，不可达的代码块，可达但不被使用的代码等等 。\n\n# 常量折叠与常量传播\n\n常量折叠 (Constant folding) 是一个在编译时期简化常数的一个过程，常数在表示式中仅仅代表一个简单的数值，就像是整数 2，若是一个变数从未被修改也可作为常数，或者直接将一个变数被明确地被标注为常数，例如下面的描述：\n\n\n# JMH 的注意点\n\n * 测试前需要预热。\n * 防止无用代码进入测试方法中。\n * 并发测试。\n * 测试结果呈现。\n\n\n# 应用场景\n\n 1. 当你已经找出了热点函数，而需要对热点函数进行进一步的优化时，就可以使用 JMH 对优化的效果进行定量的分析。\n 2. 想定量地知道某个函数需要执行多长时间，以及执行时间和输入 n 的相关性\n 3. 一个函数有两种不同实现（例如 JSON 序列化/反序列化有 Jackson 和 Gson 实现），不知道哪种实现性能更好\n\n\n# JMH 概念\n\n * Iteration - iteration 是 JMH 进行测试的最小单位，包含一组 invocations。\n * Invocation - 一次 benchmark 方法调用。\n * Operation - benchmark 方法中，被测量操作的执行。如果被测试的操作在 benchmark 方法中循环执行，可以使用@OperationsPerInvocation表明循环次数，使测试结果为单次 operation 的性能。\n * Warmup - 在实际进行 benchmark 前先进行预热。因为某个函数被调用多次之后，JIT 会对其进行编译，通过预热可以使测量结果更加接近真实情况。\n\n\n# JMH 快速入门\n\n\n# 添加 maven 依赖\n\n<dependency>\n    <groupId>org.openjdk.jmh</groupId>\n    <artifactId>jmh-core</artifactId>\n    <version>${jmh.version}</version>\n</dependency>\n<dependency>\n    <groupId>org.openjdk.jmh</groupId>\n    <artifactId>jmh-generator-annprocess</artifactId>\n    <version>${jmh.version}</version>\n    <scope>provided</scope>\n</dependency>\n\n\n\n# 测试代码\n\nimport org.openjdk.jmh.annotations.*;\nimport org.openjdk.jmh.runner.*;\n\nimport java.util.concurrent.TimeUnit;\n\n@BenchmarkMode(Mode.Throughput)\n@Warmup(iterations = 3)\n@Measurement(iterations = 10, time = 5, timeUnit = TimeUnit.SECONDS)\n@Threads(8)\n@Fork(2)\n@OutputTimeUnit(TimeUnit.MILLISECONDS)\npublic class StringBuilderBenchmark {\n\n    @Benchmark\n    public void testStringAdd() {\n        String a = "";\n        for (int i = 0; i < 10; i++) {\n            a += i;\n        }\n        // System.out.println(a);\n    }\n\n    @Benchmark\n    public void testStringBuilderAdd() {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < 10; i++) {\n            sb.append(i);\n        }\n        // System.out.println(sb.toString());\n    }\n\n    public static void main(String[] args) throws RunnerException {\n        Options options = new OptionsBuilder()\n            .include(StringBuilderBenchmark.class.getSimpleName())\n            .output("d:/Benchmark.log")\n            .build();\n        new Runner(options).run();\n    }\n\n}\n\n\n\n# 执行 JMH\n\n# 命令行\n\n（1）初始化 benchmarking 工程\n\n$ mvn archetype:generate \\\n          -DinteractiveMode=false \\\n          -DarchetypeGroupId=org.openjdk.jmh \\\n          -DarchetypeArtifactId=jmh-java-benchmark-archetype \\\n          -DgroupId=org.sample \\\n          -DartifactId=test \\\n          -Dversion=1.0\n\n\n（2）构建 benchmark\n\ncd test/\nmvn clean install\n\n\n（3）运行 benchmark\n\njava -jar target/benchmarks.jar\n\n\n# 执行 main 方法\n\n执行 main 方法，耐心等待测试结果，最终会生成一个测试报告，内容大致如下；\n\n# JMH version: 1.22\n# VM version: JDK 1.8.0_181, Java HotSpot(TM) 64-Bit Server VM, 25.181-b13\n# VM invoker: C:\\Program Files\\Java\\jdk1.8.0_181\\jre\\bin\\java.exe\n# VM options: -javaagent:D:\\Program Files\\JetBrains\\IntelliJ IDEA 2019.2.3\\lib\\idea_rt.jar=58635:D:\\Program Files\\JetBrains\\IntelliJ IDEA 2019.2.3\\bin -Dfile.encoding=UTF-8\n# Warmup: 3 iterations, 10 s each\n# Measurement: 10 iterations, 5 s each\n# Timeout: 10 min per iteration\n# Threads: 8 threads, will synchronize iterations\n# Benchmark mode: Throughput, ops/time\n# Benchmark: io.github.dunwu.javatech.jmh.StringBuilderBenchmark.testStringAdd\n\n# Run progress: 0.00% complete, ETA 00:05:20\n# Fork: 1 of 2\n# Warmup Iteration   1: 21803.050 ops/ms\n# Warmup Iteration   2: 22501.860 ops/ms\n# Warmup Iteration   3: 20953.944 ops/ms\nIteration   1: 21627.645 ops/ms\nIteration   2: 21215.269 ops/ms\nIteration   3: 20863.282 ops/ms\nIteration   4: 21617.715 ops/ms\nIteration   5: 21695.645 ops/ms\nIteration   6: 21886.784 ops/ms\nIteration   7: 21986.899 ops/ms\nIteration   8: 22389.540 ops/ms\nIteration   9: 22507.313 ops/ms\nIteration  10: 22124.133 ops/ms\n\n# Run progress: 25.00% complete, ETA 00:04:02\n# Fork: 2 of 2\n# Warmup Iteration   1: 22262.108 ops/ms\n# Warmup Iteration   2: 21567.804 ops/ms\n# Warmup Iteration   3: 21787.002 ops/ms\nIteration   1: 21598.970 ops/ms\nIteration   2: 22486.133 ops/ms\nIteration   3: 22157.834 ops/ms\nIteration   4: 22321.827 ops/ms\nIteration   5: 22477.063 ops/ms\nIteration   6: 22154.760 ops/ms\nIteration   7: 21561.095 ops/ms\nIteration   8: 22194.863 ops/ms\nIteration   9: 22493.844 ops/ms\nIteration  10: 22568.078 ops/ms\n\n\nResult "io.github.dunwu.javatech.jmh.StringBuilderBenchmark.testStringAdd":\n  21996.435 ±(99.9%) 412.955 ops/ms [Average]\n  (min, avg, max) = (20863.282, 21996.435, 22568.078), stdev = 475.560\n  CI (99.9%): [21583.480, 22409.390] (assumes normal distribution)\n\n\n# JMH version: 1.22\n# VM version: JDK 1.8.0_181, Java HotSpot(TM) 64-Bit Server VM, 25.181-b13\n# VM invoker: C:\\Program Files\\Java\\jdk1.8.0_181\\jre\\bin\\java.exe\n# VM options: -javaagent:D:\\Program Files\\JetBrains\\IntelliJ IDEA 2019.2.3\\lib\\idea_rt.jar=58635:D:\\Program Files\\JetBrains\\IntelliJ IDEA 2019.2.3\\bin -Dfile.encoding=UTF-8\n# Warmup: 3 iterations, 10 s each\n# Measurement: 10 iterations, 5 s each\n# Timeout: 10 min per iteration\n# Threads: 8 threads, will synchronize iterations\n# Benchmark mode: Throughput, ops/time\n# Benchmark: io.github.dunwu.javatech.jmh.StringBuilderBenchmark.testStringBuilderAdd\n\n# Run progress: 50.00% complete, ETA 00:02:41\n# Fork: 1 of 2\n# Warmup Iteration   1: 241500.886 ops/ms\n# Warmup Iteration   2: 134206.032 ops/ms\n# Warmup Iteration   3: 86907.846 ops/ms\nIteration   1: 86143.339 ops/ms\nIteration   2: 74725.356 ops/ms\nIteration   3: 72316.121 ops/ms\nIteration   4: 77319.716 ops/ms\nIteration   5: 83469.256 ops/ms\nIteration   6: 87712.360 ops/ms\nIteration   7: 79421.899 ops/ms\nIteration   8: 80867.839 ops/ms\nIteration   9: 82619.163 ops/ms\nIteration  10: 87026.928 ops/ms\n\n# Run progress: 75.00% complete, ETA 00:01:20\n# Fork: 2 of 2\n# Warmup Iteration   1: 228342.337 ops/ms\n# Warmup Iteration   2: 124737.248 ops/ms\n# Warmup Iteration   3: 82598.851 ops/ms\nIteration   1: 86877.318 ops/ms\nIteration   2: 89388.624 ops/ms\nIteration   3: 88523.558 ops/ms\nIteration   4: 87547.332 ops/ms\nIteration   5: 88376.087 ops/ms\nIteration   6: 88848.837 ops/ms\nIteration   7: 85998.124 ops/ms\nIteration   8: 86796.998 ops/ms\nIteration   9: 87994.726 ops/ms\nIteration  10: 87784.453 ops/ms\n\n\nResult "io.github.dunwu.javatech.jmh.StringBuilderBenchmark.testStringBuilderAdd":\n  84487.902 ±(99.9%) 4355.525 ops/ms [Average]\n  (min, avg, max) = (72316.121, 84487.902, 89388.624), stdev = 5015.829\n  CI (99.9%): [80132.377, 88843.427] (assumes normal distribution)\n\n\n# Run complete. Total time: 00:05:23\n\nREMEMBER: The numbers below are just data. To gain reusable insights, you need to follow up on\nwhy the numbers are the way they are. Use profilers (see -prof, -lprof), design factorial\nexperiments, perform baseline and negative tests that provide experimental control, make sure\nthe benchmarking environment is safe on JVM/OS/HW level, ask for reviews from the domain experts.\nDo not assume the numbers tell you what you want them to tell.\n\nBenchmark                                     Mode  Cnt      Score      Error   Units\nStringBuilderBenchmark.testStringAdd         thrpt   20  21996.435 ±  412.955  ops/ms\nStringBuilderBenchmark.testStringBuilderAdd  thrpt   20  84487.902 ± 4355.525  ops/ms\n\n\n\n# JMH API\n\n下面来了解一下 jmh 常用 API\n\n\n# @BenchmarkMode\n\n基准测试类型。这里选择的是 Throughput 也就是吞吐量。根据源码点进去，每种类型后面都有对应的解释，比较好理解，吞吐量会得到单位时间内可以进行的操作数。\n\n * Throughput - 整体吞吐量，例如“1 秒内可以执行多少次调用”。\n * AverageTime - 调用的平均时间，例如“每次调用平均耗时 xxx 毫秒”。\n * SampleTime - 随机取样，最后输出取样结果的分布，例如“99%的调用在 xxx 毫秒以内，99.99%的调用在 xxx 毫秒以内”\n * SingleShotTime - 以上模式都是默认一次 iteration 是 1s，唯有 SingleShotTime 是只运行一次。往往同时把 warmup 次数设为 0，用于测试冷启动时的性能。\n * All - 所有模式\n\n\n# @Warmup\n\n上面我们提到了，进行基准测试前需要进行预热。一般我们前几次进行程序测试的时候都会比较慢， 所以要让程序进行几轮预热，保证测试的准确性。其中的参数 iterations 也就非常好理解了，就是预热轮数。\n\n为什么需要预热？因为 JVM 的 JIT 机制的存在，如果某个函数被调用多次之后，JVM 会尝试将其编译成为机器码从而提高执行速度。所以为了让 benchmark 的结果更加接近真实情况就需要进行预热。\n\n\n# @Measurement\n\n度量，其实就是一些基本的测试参数。\n\n * iterations - 进行测试的轮次\n * time - 每轮进行的时长\n * timeUnit - 时长单位\n\n都是一些基本的参数，可以根据具体情况调整。一般比较重的东西可以进行大量的测试，放到服务器上运行。\n\n\n# @Threads\n\n每个进程中的测试线程，这个非常好理解，根据具体情况选择，一般为 cpu 乘以 2。\n\n\n# @Fork\n\n进行 fork 的次数。如果 fork 数是 2 的话，则 JMH 会 fork 出两个进程来进行测试。\n\n\n# @OutputTimeUnit\n\n这个比较简单了，基准测试结果的时间类型。一般选择秒、毫秒、微秒。\n\n\n# @Benchmark\n\n方法级注解，表示该方法是需要进行 benchmark 的对象，用法和 JUnit 的 @Test 类似。\n\n\n# @Param\n\n属性级注解，@Param 可以用来指定某项参数的多种情况。特别适合用来测试一个函数在不同的参数输入的情况下的性能。\n\n\n# @Setup\n\n方法级注解，这个注解的作用就是我们需要在测试之前进行一些准备工作，比如对一些数据的初始化之类的。\n\n\n# @TearDown\n\n方法级注解，这个注解的作用就是我们需要在测试之后进行一些结束工作，比如关闭线程池，数据库连接等的，主要用于资源的回收等。\n\n\n# @State\n\n当使用 @Setup 参数的时候，必须在类上加这个参数，不然会提示无法运行。\n\nState 用于声明某个类是一个“状态”，然后接受一个 Scope 参数用来表示该状态的共享范围。 因为很多 benchmark 会需要一些表示状态的类，JMH 允许你把这些类以依赖注入的方式注入到 benchmark 函数里。Scope 主要分为三种。\n\n * Thread - 该状态为每个线程独享。\n * Group - 该状态为同一个组里面所有线程共享。\n * Benchmark - 该状态在所有线程间共享。\n\n关于 State 的用法，官方的 code sample 里有比较好的例子。\n\n\n# 参考资料\n\n * jmh 官方示例\n * Java 微基准测试框架 JMH\n * JAVA 拾遗 — JMH 与 8 个测试陷阱',normalizedContent:'# jmh 快速入门\n\n\n# 基准测试简介\n\n\n# 什么是基准测试\n\n基准测试是指通过设计科学的测试方法、测试工具和测试系统，实现对一类测试对象的某项性能指标进行定量的和可对比的测试。\n\n现代软件常常都把高性能作为目标。那么，何为高性能，性能就是快，更快吗？显然，如果没有一个量化的标准，难以衡量性能的好坏。\n\n不同的基准测试其具体内容和范围也存在很大的不同。如果是专业的性能工程师，更加熟悉的可能是类似 spec 提供的工业标准的系统级测试；而对于大多数 java 开发者，更熟悉的则是范围相对较小、关注点更加细节的微基准测试（micro-benchmark）。何谓 micro benchmark 呢？ 简单地说就是在 method 层面上的 benchmark，精度可以精确到 微秒级。\n\n\n# 何时需要微基准测试\n\n微基准测试大多是 api 级别的性能测试。\n\n微基准测试的适用场景：\n\n * 如果开发公共类库、中间件，会被其他模块经常调用的 api。\n * 对于性能，如响应延迟、吞吐量有严格要求的核心 api。\n\n\n# jmh 简介\n\njmh(即 java microbenchmark harness)，是目前主流的微基准测试框架。jmh 是由 hotspot jvm 团队专家开发的，除了支持完整的基准测试过程，包括预热、运行、统计和报告等，还支持 java 和其他 jvm 语言。更重要的是，它针对 hotspot jvm 提供了各种特性，以保证基准测试的正确性，整体准确性大大优于其他框架，并且，jmh 还提供了用近乎白盒的方式进行 profiling 等工作的能力。\n\n\n# 为什么需要 jmh\n\n# 死码消除\n\n所谓死码，是指注释的代码，不可达的代码块，可达但不被使用的代码等等 。\n\n# 常量折叠与常量传播\n\n常量折叠 (constant folding) 是一个在编译时期简化常数的一个过程，常数在表示式中仅仅代表一个简单的数值，就像是整数 2，若是一个变数从未被修改也可作为常数，或者直接将一个变数被明确地被标注为常数，例如下面的描述：\n\n\n# jmh 的注意点\n\n * 测试前需要预热。\n * 防止无用代码进入测试方法中。\n * 并发测试。\n * 测试结果呈现。\n\n\n# 应用场景\n\n 1. 当你已经找出了热点函数，而需要对热点函数进行进一步的优化时，就可以使用 jmh 对优化的效果进行定量的分析。\n 2. 想定量地知道某个函数需要执行多长时间，以及执行时间和输入 n 的相关性\n 3. 一个函数有两种不同实现（例如 json 序列化/反序列化有 jackson 和 gson 实现），不知道哪种实现性能更好\n\n\n# jmh 概念\n\n * iteration - iteration 是 jmh 进行测试的最小单位，包含一组 invocations。\n * invocation - 一次 benchmark 方法调用。\n * operation - benchmark 方法中，被测量操作的执行。如果被测试的操作在 benchmark 方法中循环执行，可以使用@operationsperinvocation表明循环次数，使测试结果为单次 operation 的性能。\n * warmup - 在实际进行 benchmark 前先进行预热。因为某个函数被调用多次之后，jit 会对其进行编译，通过预热可以使测量结果更加接近真实情况。\n\n\n# jmh 快速入门\n\n\n# 添加 maven 依赖\n\n<dependency>\n    <groupid>org.openjdk.jmh</groupid>\n    <artifactid>jmh-core</artifactid>\n    <version>${jmh.version}</version>\n</dependency>\n<dependency>\n    <groupid>org.openjdk.jmh</groupid>\n    <artifactid>jmh-generator-annprocess</artifactid>\n    <version>${jmh.version}</version>\n    <scope>provided</scope>\n</dependency>\n\n\n\n# 测试代码\n\nimport org.openjdk.jmh.annotations.*;\nimport org.openjdk.jmh.runner.*;\n\nimport java.util.concurrent.timeunit;\n\n@benchmarkmode(mode.throughput)\n@warmup(iterations = 3)\n@measurement(iterations = 10, time = 5, timeunit = timeunit.seconds)\n@threads(8)\n@fork(2)\n@outputtimeunit(timeunit.milliseconds)\npublic class stringbuilderbenchmark {\n\n    @benchmark\n    public void teststringadd() {\n        string a = "";\n        for (int i = 0; i < 10; i++) {\n            a += i;\n        }\n        // system.out.println(a);\n    }\n\n    @benchmark\n    public void teststringbuilderadd() {\n        stringbuilder sb = new stringbuilder();\n        for (int i = 0; i < 10; i++) {\n            sb.append(i);\n        }\n        // system.out.println(sb.tostring());\n    }\n\n    public static void main(string[] args) throws runnerexception {\n        options options = new optionsbuilder()\n            .include(stringbuilderbenchmark.class.getsimplename())\n            .output("d:/benchmark.log")\n            .build();\n        new runner(options).run();\n    }\n\n}\n\n\n\n# 执行 jmh\n\n# 命令行\n\n（1）初始化 benchmarking 工程\n\n$ mvn archetype:generate \\\n          -dinteractivemode=false \\\n          -darchetypegroupid=org.openjdk.jmh \\\n          -darchetypeartifactid=jmh-java-benchmark-archetype \\\n          -dgroupid=org.sample \\\n          -dartifactid=test \\\n          -dversion=1.0\n\n\n（2）构建 benchmark\n\ncd test/\nmvn clean install\n\n\n（3）运行 benchmark\n\njava -jar target/benchmarks.jar\n\n\n# 执行 main 方法\n\n执行 main 方法，耐心等待测试结果，最终会生成一个测试报告，内容大致如下；\n\n# jmh version: 1.22\n# vm version: jdk 1.8.0_181, java hotspot(tm) 64-bit server vm, 25.181-b13\n# vm invoker: c:\\program files\\java\\jdk1.8.0_181\\jre\\bin\\java.exe\n# vm options: -javaagent:d:\\program files\\jetbrains\\intellij idea 2019.2.3\\lib\\idea_rt.jar=58635:d:\\program files\\jetbrains\\intellij idea 2019.2.3\\bin -dfile.encoding=utf-8\n# warmup: 3 iterations, 10 s each\n# measurement: 10 iterations, 5 s each\n# timeout: 10 min per iteration\n# threads: 8 threads, will synchronize iterations\n# benchmark mode: throughput, ops/time\n# benchmark: io.github.dunwu.javatech.jmh.stringbuilderbenchmark.teststringadd\n\n# run progress: 0.00% complete, eta 00:05:20\n# fork: 1 of 2\n# warmup iteration   1: 21803.050 ops/ms\n# warmup iteration   2: 22501.860 ops/ms\n# warmup iteration   3: 20953.944 ops/ms\niteration   1: 21627.645 ops/ms\niteration   2: 21215.269 ops/ms\niteration   3: 20863.282 ops/ms\niteration   4: 21617.715 ops/ms\niteration   5: 21695.645 ops/ms\niteration   6: 21886.784 ops/ms\niteration   7: 21986.899 ops/ms\niteration   8: 22389.540 ops/ms\niteration   9: 22507.313 ops/ms\niteration  10: 22124.133 ops/ms\n\n# run progress: 25.00% complete, eta 00:04:02\n# fork: 2 of 2\n# warmup iteration   1: 22262.108 ops/ms\n# warmup iteration   2: 21567.804 ops/ms\n# warmup iteration   3: 21787.002 ops/ms\niteration   1: 21598.970 ops/ms\niteration   2: 22486.133 ops/ms\niteration   3: 22157.834 ops/ms\niteration   4: 22321.827 ops/ms\niteration   5: 22477.063 ops/ms\niteration   6: 22154.760 ops/ms\niteration   7: 21561.095 ops/ms\niteration   8: 22194.863 ops/ms\niteration   9: 22493.844 ops/ms\niteration  10: 22568.078 ops/ms\n\n\nresult "io.github.dunwu.javatech.jmh.stringbuilderbenchmark.teststringadd":\n  21996.435 ±(99.9%) 412.955 ops/ms [average]\n  (min, avg, max) = (20863.282, 21996.435, 22568.078), stdev = 475.560\n  ci (99.9%): [21583.480, 22409.390] (assumes normal distribution)\n\n\n# jmh version: 1.22\n# vm version: jdk 1.8.0_181, java hotspot(tm) 64-bit server vm, 25.181-b13\n# vm invoker: c:\\program files\\java\\jdk1.8.0_181\\jre\\bin\\java.exe\n# vm options: -javaagent:d:\\program files\\jetbrains\\intellij idea 2019.2.3\\lib\\idea_rt.jar=58635:d:\\program files\\jetbrains\\intellij idea 2019.2.3\\bin -dfile.encoding=utf-8\n# warmup: 3 iterations, 10 s each\n# measurement: 10 iterations, 5 s each\n# timeout: 10 min per iteration\n# threads: 8 threads, will synchronize iterations\n# benchmark mode: throughput, ops/time\n# benchmark: io.github.dunwu.javatech.jmh.stringbuilderbenchmark.teststringbuilderadd\n\n# run progress: 50.00% complete, eta 00:02:41\n# fork: 1 of 2\n# warmup iteration   1: 241500.886 ops/ms\n# warmup iteration   2: 134206.032 ops/ms\n# warmup iteration   3: 86907.846 ops/ms\niteration   1: 86143.339 ops/ms\niteration   2: 74725.356 ops/ms\niteration   3: 72316.121 ops/ms\niteration   4: 77319.716 ops/ms\niteration   5: 83469.256 ops/ms\niteration   6: 87712.360 ops/ms\niteration   7: 79421.899 ops/ms\niteration   8: 80867.839 ops/ms\niteration   9: 82619.163 ops/ms\niteration  10: 87026.928 ops/ms\n\n# run progress: 75.00% complete, eta 00:01:20\n# fork: 2 of 2\n# warmup iteration   1: 228342.337 ops/ms\n# warmup iteration   2: 124737.248 ops/ms\n# warmup iteration   3: 82598.851 ops/ms\niteration   1: 86877.318 ops/ms\niteration   2: 89388.624 ops/ms\niteration   3: 88523.558 ops/ms\niteration   4: 87547.332 ops/ms\niteration   5: 88376.087 ops/ms\niteration   6: 88848.837 ops/ms\niteration   7: 85998.124 ops/ms\niteration   8: 86796.998 ops/ms\niteration   9: 87994.726 ops/ms\niteration  10: 87784.453 ops/ms\n\n\nresult "io.github.dunwu.javatech.jmh.stringbuilderbenchmark.teststringbuilderadd":\n  84487.902 ±(99.9%) 4355.525 ops/ms [average]\n  (min, avg, max) = (72316.121, 84487.902, 89388.624), stdev = 5015.829\n  ci (99.9%): [80132.377, 88843.427] (assumes normal distribution)\n\n\n# run complete. total time: 00:05:23\n\nremember: the numbers below are just data. to gain reusable insights, you need to follow up on\nwhy the numbers are the way they are. use profilers (see -prof, -lprof), design factorial\nexperiments, perform baseline and negative tests that provide experimental control, make sure\nthe benchmarking environment is safe on jvm/os/hw level, ask for reviews from the domain experts.\ndo not assume the numbers tell you what you want them to tell.\n\nbenchmark                                     mode  cnt      score      error   units\nstringbuilderbenchmark.teststringadd         thrpt   20  21996.435 ±  412.955  ops/ms\nstringbuilderbenchmark.teststringbuilderadd  thrpt   20  84487.902 ± 4355.525  ops/ms\n\n\n\n# jmh api\n\n下面来了解一下 jmh 常用 api\n\n\n# @benchmarkmode\n\n基准测试类型。这里选择的是 throughput 也就是吞吐量。根据源码点进去，每种类型后面都有对应的解释，比较好理解，吞吐量会得到单位时间内可以进行的操作数。\n\n * throughput - 整体吞吐量，例如“1 秒内可以执行多少次调用”。\n * averagetime - 调用的平均时间，例如“每次调用平均耗时 xxx 毫秒”。\n * sampletime - 随机取样，最后输出取样结果的分布，例如“99%的调用在 xxx 毫秒以内，99.99%的调用在 xxx 毫秒以内”\n * singleshottime - 以上模式都是默认一次 iteration 是 1s，唯有 singleshottime 是只运行一次。往往同时把 warmup 次数设为 0，用于测试冷启动时的性能。\n * all - 所有模式\n\n\n# @warmup\n\n上面我们提到了，进行基准测试前需要进行预热。一般我们前几次进行程序测试的时候都会比较慢， 所以要让程序进行几轮预热，保证测试的准确性。其中的参数 iterations 也就非常好理解了，就是预热轮数。\n\n为什么需要预热？因为 jvm 的 jit 机制的存在，如果某个函数被调用多次之后，jvm 会尝试将其编译成为机器码从而提高执行速度。所以为了让 benchmark 的结果更加接近真实情况就需要进行预热。\n\n\n# @measurement\n\n度量，其实就是一些基本的测试参数。\n\n * iterations - 进行测试的轮次\n * time - 每轮进行的时长\n * timeunit - 时长单位\n\n都是一些基本的参数，可以根据具体情况调整。一般比较重的东西可以进行大量的测试，放到服务器上运行。\n\n\n# @threads\n\n每个进程中的测试线程，这个非常好理解，根据具体情况选择，一般为 cpu 乘以 2。\n\n\n# @fork\n\n进行 fork 的次数。如果 fork 数是 2 的话，则 jmh 会 fork 出两个进程来进行测试。\n\n\n# @outputtimeunit\n\n这个比较简单了，基准测试结果的时间类型。一般选择秒、毫秒、微秒。\n\n\n# @benchmark\n\n方法级注解，表示该方法是需要进行 benchmark 的对象，用法和 junit 的 @test 类似。\n\n\n# @param\n\n属性级注解，@param 可以用来指定某项参数的多种情况。特别适合用来测试一个函数在不同的参数输入的情况下的性能。\n\n\n# @setup\n\n方法级注解，这个注解的作用就是我们需要在测试之前进行一些准备工作，比如对一些数据的初始化之类的。\n\n\n# @teardown\n\n方法级注解，这个注解的作用就是我们需要在测试之后进行一些结束工作，比如关闭线程池，数据库连接等的，主要用于资源的回收等。\n\n\n# @state\n\n当使用 @setup 参数的时候，必须在类上加这个参数，不然会提示无法运行。\n\nstate 用于声明某个类是一个“状态”，然后接受一个 scope 参数用来表示该状态的共享范围。 因为很多 benchmark 会需要一些表示状态的类，jmh 允许你把这些类以依赖注入的方式注入到 benchmark 函数里。scope 主要分为三种。\n\n * thread - 该状态为每个线程独享。\n * group - 该状态为同一个组里面所有线程共享。\n * benchmark - 该状态在所有线程间共享。\n\n关于 state 的用法，官方的 code sample 里有比较好的例子。\n\n\n# 参考资料\n\n * jmh 官方示例\n * java 微基准测试框架 jmh\n * java 拾遗 — jmh 与 8 个测试陷阱',charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"javalib-log",frontmatter:{title:"javalib-log",date:"2022-02-17T22:34:30.000Z",order:1,categories:["Java","工具","其他"],tags:["Java","日志"],permalink:"/pages/fcc1c4/"},regularPath:"/01.Java/12.%E5%B7%A5%E5%85%B7/99.%E5%85%B6%E4%BB%96/01.Java%E6%97%A5%E5%BF%97.html",relativePath:"01.Java/12.工具/99.其他/01.Java日志.md",key:"v-e3a97658",path:"/pages/fcc1c4/",headers:[{level:2,title:"日志框架",slug:"日志框架",normalizedTitle:"日志框架",charIndex:125},{level:3,title:"java.util.logging (JUL)",slug:"java-util-logging-jul",normalizedTitle:"java.util.logging (jul)",charIndex:134},{level:3,title:"Log4j",slug:"log4j",normalizedTitle:"log4j",charIndex:218},{level:3,title:"Logback",slug:"logback",normalizedTitle:"logback",charIndex:555},{level:3,title:"Log4j2",slug:"log4j2",normalizedTitle:"log4j2",charIndex:902},{level:3,title:"Log4j vs Logback vs Log4j2",slug:"log4j-vs-logback-vs-log4j2",normalizedTitle:"log4j vs logback vs log4j2",charIndex:972},{level:2,title:"日志门面",slug:"日志门面",normalizedTitle:"日志门面",charIndex:1753},{level:3,title:"common-logging",slug:"common-logging",normalizedTitle:"common-logging",charIndex:1826},{level:3,title:"slf4j",slug:"slf4j",normalizedTitle:"slf4j",charIndex:2072},{level:3,title:"common-logging vs slf4j",slug:"common-logging-vs-slf4j",normalizedTitle:"common-logging vs slf4j",charIndex:2376},{level:3,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:2636},{level:2,title:"实施日志解决方案",slug:"实施日志解决方案",normalizedTitle:"实施日志解决方案",charIndex:2704},{level:3,title:"引入 jar 包",slug:"引入-jar-包",normalizedTitle:"引入 jar 包",charIndex:2736},{level:4,title:"slf4j 直接绑定日志组件",slug:"slf4j-直接绑定日志组件",normalizedTitle:"slf4j 直接绑定日志组件",charIndex:3130},{level:4,title:"slf4j 兼容非 slf4j 日志组件",slug:"slf4j-兼容非-slf4j-日志组件",normalizedTitle:"slf4j 兼容非 slf4j 日志组件",charIndex:3893},{level:4,title:"spring 集成 slf4j",slug:"spring-集成-slf4j",normalizedTitle:"spring 集成 slf4j",charIndex:4662},{level:4,title:"common-logging 绑定日志组件",slug:"common-logging-绑定日志组件",normalizedTitle:"common-logging 绑定日志组件",charIndex:5203},{level:3,title:"使用 API",slug:"使用-api",normalizedTitle:"使用 api",charIndex:2756},{level:4,title:"slf4j 用法",slug:"slf4j-用法",normalizedTitle:"slf4j 用法",charIndex:5532},{level:4,title:"common-logging 用法",slug:"common-logging-用法",normalizedTitle:"common-logging 用法",charIndex:6039},{level:2,title:"log4j2 配置",slug:"log4j2-配置",normalizedTitle:"log4j2 配置",charIndex:6649},{level:2,title:"logback 配置",slug:"logback-配置",normalizedTitle:"logback 配置",charIndex:8907},{level:3,title:"<configuration>",slug:"configuration",normalizedTitle:"<configuration>",charIndex:8922},{level:3,title:"<appender>",slug:"appender",normalizedTitle:"<appender>",charIndex:8995},{level:4,title:"<file>",slug:"file",normalizedTitle:"<file>",charIndex:9111},{level:4,title:"<filter>",slug:"filter",normalizedTitle:"<filter>",charIndex:9118},{level:4,title:"<layout>",slug:"layout",normalizedTitle:"<layout>",charIndex:9127},{level:4,title:"<encoder>",slug:"encoder",normalizedTitle:"<encoder>",charIndex:9136},{level:3,title:"<logger>",slug:"logger",normalizedTitle:"<logger>",charIndex:9006},{level:4,title:"<appender-ref>",slug:"appender-ref",normalizedTitle:"<appender-ref>",charIndex:9614},{level:3,title:"<root>",slug:"root",normalizedTitle:"<root>",charIndex:9015},{level:3,title:"完整的 logback.xml 参考示例",slug:"完整的-logback-xml-参考示例",normalizedTitle:"完整的 logback.xml 参考示例",charIndex:9815},{level:2,title:"log4j 配置",slug:"log4j-配置",normalizedTitle:"log4j 配置",charIndex:16371},{level:3,title:"完整的 log4j.xml 参考示例",slug:"完整的-log4j-xml-参考示例",normalizedTitle:"完整的 log4j.xml 参考示例",charIndex:16384},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:9831}],headersStr:"日志框架 java.util.logging (JUL) Log4j Logback Log4j2 Log4j vs Logback vs Log4j2 日志门面 common-logging slf4j common-logging vs slf4j 总结 实施日志解决方案 引入 jar 包 slf4j 直接绑定日志组件 slf4j 兼容非 slf4j 日志组件 spring 集成 slf4j common-logging 绑定日志组件 使用 API slf4j 用法 common-logging 用法 log4j2 配置 logback 配置 <configuration> <appender> <file> <filter> <layout> <encoder> <logger> <appender-ref> <root> 完整的 logback.xml 参考示例 log4j 配置 完整的 log4j.xml 参考示例 参考",content:'# 细说 Java 主流日志工具库\n\n> 在项目开发中，为了跟踪代码的运行情况，常常要使用日志来记录信息。\n> \n> 在 Java 世界，有很多的日志工具库来实现日志功能，避免了我们重复造轮子。\n> \n> 我们先来逐一了解一下主流日志工具。\n\n\n# 日志框架\n\n\n# java.util.logging (JUL)\n\nJDK1.4 开始，通过 java.util.logging 提供日志功能。\n\n它能满足基本的日志需要，但是功能没有 Log4j 强大，而且使用范围也没有 Log4j 广泛。\n\n\n# Log4j\n\nLog4j 是 apache 的一个开源项目，创始人 Ceki Gulcu。\n\nLog4j 应该说是 Java 领域资格最老，应用最广的日志工具。从诞生之日到现在一直广受业界欢迎。\n\nLog4j 是高度可配置的，并可通过在运行时的外部文件配置。它根据记录的优先级别，并提供机制，以指示记录信息到许多的目的地，诸如：数据库，文件，控制台，UNIX 系统日志等。\n\nLog4j 中有三个主要组成部分：\n\n * loggers - 负责捕获记录信息。\n * appenders - 负责发布日志信息，以不同的首选目的地。\n * layouts - 负责格式化不同风格的日志信息。\n\n官网地址\n\n\n# Logback\n\nLogback 是由 log4j 创始人 Ceki Gulcu 设计的又一个开源日记组件，目标是替代 log4j。\n\nlogback 当前分成三个模块：logback-core、logback-classic 和 logback-access。\n\n * logback-core - 是其它两个模块的基础模块。\n * logback-classic - 是 log4j 的一个 改良版本。此外 logback-classic 完整实现 SLF4J API 使你可以很方便地更换成其它日记系统如 log4j 或 JDK14 Logging。\n * logback-access - 访问模块与 Servlet 容器集成提供通过 Http 来访问日记的功能。\n\n官网地址\n\n\n# Log4j2\n\n官网地址\n\n按照官方的说法，Log4j2 是 Log4j 和 Logback 的替代。\n\nLog4j2 架构：\n\n\n\n\n# Log4j vs Logback vs Log4j2\n\n按照官方的说法，Log4j2 大大优于 Log4j 和 Logback。\n\n那么，Log4j2 相比于先问世的 Log4j 和 Logback，它具有哪些优势呢？\n\n 1.  Log4j2 旨在用作审计日志记录框架。 Log4j 1.x 和 Logback 都会在重新配置时丢失事件。 Log4j 2 不会。在 Logback 中，Appender 中的异常永远不会对应用程序可见。在 Log4j 中，可以将 Appender 配置为允许异常渗透到应用程序。\n 2.  Log4j2 在多线程场景中，异步 Loggers 的吞吐量比 Log4j 1.x 和 Logback 高 10 倍，延迟低几个数量级。\n 3.  Log4j2 对于独立应用程序是无垃圾的，对于稳定状态日志记录期间的 Web 应用程序来说是低垃圾。这减少了垃圾收集器的压力，并且可以提供更好的响应时间性能。\n 4.  Log4j2 使用插件系统，通过添加新的 Appender、Filter、Layout、Lookup 和 Pattern Converter，可以非常轻松地扩展框架，而无需对 Log4j 进行任何更改。\n 5.  由于插件系统配置更简单。配置中的条目不需要指定类名。\n 6.  支持自定义日志等级。\n 7.  支持 lambda 表达式。\n 8.  支持消息对象。\n 9.  Log4j 和 Logback 的 Layout 返回的是字符串，而 Log4j2 返回的是二进制数组，这使得它能被各种 Appender 使用。\n 10. Syslog Appender 支持 TCP 和 UDP 并且支持 BSD 系统日志。\n 11. Log4j2 利用 Java5 并发特性，尽量小粒度的使用锁，减少锁的开销。\n\n\n# 日志门面\n\n何谓日志门面？\n\n日志门面是对不同日志框架提供的一个 API 封装，可以在部署的时候不修改任何配置即可接入一种日志实现方案。\n\n\n# common-logging\n\ncommon-logging 是 apache 的一个开源项目。也称Jakarta Commons Logging，缩写 JCL。\n\ncommon-logging 的功能是提供日志功能的 API 接口，本身并不提供日志的具体实现（当然，common-logging 内部有一个 Simple logger 的简单实现，但是功能很弱，直接忽略），而是在运行时动态的绑定日志实现组件来工作（如 log4j、java.util.loggin）。\n\n官网地址\n\n\n# slf4j\n\n全称为 Simple Logging Facade for Java，即 java 简单日志门面。\n\n什么，作者又是 Ceki Gulcu！这位大神写了 Log4j、Logback 和 slf4j，专注日志组件开发五百年，一直只能超越自己。\n\n类似于 Common-Logging，slf4j 是对不同日志框架提供的一个 API 封装，可以在部署的时候不修改任何配置即可接入一种日志实现方案。但是，slf4j 在编译时静态绑定真正的 Log 库。使用 SLF4J 时，如果你需要使用某一种日志实现，那么你必须选择正确的 SLF4J 的 jar 包的集合（各种桥接包）。\n\n官网地址\n\n\n\n\n# common-logging vs slf4j\n\nslf4j 库类似于 Apache Common-Logging。但是，他在编译时静态绑定真正的日志库。这点似乎很麻烦，其实也不过是导入桥接 jar 包而已。\n\nslf4j 一大亮点是提供了更方便的日志记录方式：\n\n不需要使用logger.isDebugEnabled()来解决日志因为字符拼接产生的性能问题。slf4j 的方式是使用{}作为字符串替换符，形式如下：\n\nlogger.debug("id: {}, name: {} ", id, name);\n\n\n\n# 总结\n\n综上所述，使用 slf4j + Logback 可谓是目前最理想的日志解决方案了。\n\n接下来，就是如何在项目中实施了。\n\n\n# 实施日志解决方案\n\n使用日志解决方案基本可分为三步：\n\n 1. 引入 jar 包\n 2. 配置\n 3. 使用 API\n\n常见的各种日志解决方案的第 2 步和第 3 步基本一样，实施上的差别主要在第 1 步，也就是使用不同的库。\n\n\n# 引入 jar 包\n\n这里首选推荐使用 slf4j + logback 的组合。\n\n如果你习惯了 common-logging，可以选择 common-logging+log4j。\n\n强烈建议不要直接使用日志实现组件(logback、log4j、java.util.logging)，理由前面也说过，就是无法灵活替换日志库。\n\n还有一种情况：你的老项目使用了 common-logging，或是直接使用日志实现组件。如果修改老的代码，工作量太大，需要兼容处理。在下文，都将看到各种应对方法。\n\n注：据我所知，当前仍没有方法可以将 slf4j 桥接到 common-logging。如果我孤陋寡闻了，请不吝赐教。\n\n# slf4j 直接绑定日志组件\n\nslf4j + logback\n\n添加依赖到 pom.xml 中即可。\n\nlogback-classic-1.0.13.jar 会自动将 slf4j-api-1.7.21.jar 和 logback-core-1.0.13.jar 也添加到你的项目中。\n\n<dependency>\n  <groupId>ch.qos.logback</groupId>\n  <artifactId>logback-classic</artifactId>\n  <version>1.0.13</version>\n</dependency>\n\n\nslf4j + log4j\n\n添加依赖到 pom.xml 中即可。\n\nslf4j-log4j12-1.7.21.jar 会自动将 slf4j-api-1.7.21.jar 和 log4j-1.2.17.jar 也添加到你的项目中。\n\n<dependency>\n  <groupId>org.slf4j</groupId>\n  <artifactId>slf4j-log4j12</artifactId>\n  <version>1.7.21</version>\n</dependency>\n\n\nslf4j + java.util.logging\n\n添加依赖到 pom.xml 中即可。\n\nslf4j-jdk14-1.7.21.jar 会自动将 slf4j-api-1.7.21.jar 也添加到你的项目中。\n\n<dependency>\n  <groupId>org.slf4j</groupId>\n  <artifactId>slf4j-jdk14</artifactId>\n  <version>1.7.21</version>\n</dependency>\n\n\n# slf4j 兼容非 slf4j 日志组件\n\n在介绍解决方案前，先提一个概念——桥接\n\n什么是桥接呢\n\n假如你正在开发应用程序所调用的组件当中已经使用了 common-logging，这时你需要 jcl-over-slf4j.jar 把日志信息输出重定向到 slf4j-api，slf4j-api 再去调用 slf4j 实际依赖的日志组件。这个过程称为桥接。下图是官方的 slf4j 桥接策略图：\n\n\n\n从图中应该可以看出，无论你的老项目中使用的是 common-logging 或是直接使用 log4j、java.util.logging，都可以使用对应的桥接 jar 包来解决兼容问题。\n\nslf4j 兼容 common-logging\n\n<dependency>\n  <groupId>org.slf4j</groupId>\n  <artifactId>jcl-over-slf4j</artifactId>\n  <version>1.7.12</version>\n</dependency>\n\n\nslf4j 兼容 log4j\n\n<dependency>\n    <groupId>org.slf4j</groupId>\n    <artifactId>log4j-over-slf4j</artifactId>\n    <version>1.7.12</version>\n</dependency>\n\n\nslf4j 兼容 java.util.logging\n\n<dependency>\n    <groupId>org.slf4j</groupId>\n    <artifactId>jul-to-slf4j</artifactId>\n    <version>1.7.12</version>\n</dependency>\n\n\n# spring 集成 slf4j\n\n做 java web 开发，基本离不开 spring 框架。很遗憾，spring 使用的日志解决方案是 common-logging + log4j。\n\n所以，你需要一个桥接 jar 包：logback-ext-spring。\n\n<dependency>\n  <groupId>ch.qos.logback</groupId>\n  <artifactId>logback-classic</artifactId>\n  <version>1.1.3</version>\n</dependency>\n<dependency>\n  <groupId>org.logback-extensions</groupId>\n  <artifactId>logback-ext-spring</artifactId>\n  <version>0.1.2</version>\n</dependency>\n<dependency>\n  <groupId>org.slf4j</groupId>\n  <artifactId>jcl-over-slf4j</artifactId>\n  <version>1.7.12</version>\n</dependency>\n\n\n# common-logging 绑定日志组件\n\ncommon-logging + log4j\n\n添加依赖到 pom.xml 中即可。\n\n<dependency>\n  <groupId>commons-logging</groupId>\n  <artifactId>commons-logging</artifactId>\n  <version>1.2</version>\n</dependency>\n<dependency>\n  <groupId>log4j</groupId>\n  <artifactId>log4j</artifactId>\n  <version>1.2.17</version>\n</dependency>\n\n\n\n# 使用 API\n\n# slf4j 用法\n\n使用 slf4j 的 API 很简单。使用LoggerFactory初始化一个Logger实例，然后调用 Logger 对应的打印等级函数就行了。\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class App {\n    private static final Logger log = LoggerFactory.getLogger(App.class);\n    public static void main(String[] args) {\n        String msg = "print log, current level: {}";\n        log.trace(msg, "trace");\n        log.debug(msg, "debug");\n        log.info(msg, "info");\n        log.warn(msg, "warn");\n        log.error(msg, "error");\n    }\n}\n\n\n# common-logging 用法\n\ncommon-logging 用法和 slf4j 几乎一样，但是支持的打印等级多了一个更高级别的：fatal。\n\n此外，common-logging 不支持{}替换参数，你只能选择拼接字符串这种方式了。\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\n\npublic class JclTest {\n    private static final Log log = LogFactory.getLog(JclTest.class);\n\n    public static void main(String[] args) {\n        String msg = "print log, current level: ";\n        log.trace(msg + "trace");\n        log.debug(msg + "debug");\n        log.info(msg + "info");\n        log.warn(msg + "warn");\n        log.error(msg + "error");\n        log.fatal(msg + "fatal");\n    }\n}\n\n\n\n# log4j2 配置\n\nlog4j2 基本配置形式如下：\n\n<?xml version="1.0" encoding="UTF-8"?>;\n<Configuration>\n  <Properties>\n    <Property name="name1">value</property>\n    <Property name="name2" value="value2"/>\n  </Properties>\n  <Filter type="type" ... />\n  <Appenders>\n    <Appender type="type" name="name">\n      <Filter type="type" ... />\n    </Appender>\n    ...\n  </Appenders>\n  <Loggers>\n    <Logger name="name1">\n      <Filter type="type" ... />\n    </Logger>\n    ...\n    <Root level="level">\n      <AppenderRef ref="name"/>\n    </Root>\n  </Loggers>\n</Configuration>\n\n\n配置示例：\n\n<?xml version="1.0" encoding="UTF-8"?>\n<Configuration status="debug" strict="true" name="XMLConfigTest"\n               packages="org.apache.logging.log4j.test">\n  <Properties>\n    <Property name="filename">target/test.log</Property>\n  </Properties>\n  <Filter type="ThresholdFilter" level="trace"/>\n\n  <Appenders>\n    <Appender type="Console" name="STDOUT">\n      <Layout type="PatternLayout" pattern="%m MDC%X%n"/>\n      <Filters>\n        <Filter type="MarkerFilter" marker="FLOW" onMatch="DENY" onMismatch="NEUTRAL"/>\n        <Filter type="MarkerFilter" marker="EXCEPTION" onMatch="DENY" onMismatch="ACCEPT"/>\n      </Filters>\n    </Appender>\n    <Appender type="Console" name="FLOW">\n      <Layout type="PatternLayout" pattern="%C{1}.%M %m %ex%n"/>\x3c!-- class and line number --\x3e\n      <Filters>\n        <Filter type="MarkerFilter" marker="FLOW" onMatch="ACCEPT" onMismatch="NEUTRAL"/>\n        <Filter type="MarkerFilter" marker="EXCEPTION" onMatch="ACCEPT" onMismatch="DENY"/>\n      </Filters>\n    </Appender>\n    <Appender type="File" name="File" fileName="${filename}">\n      <Layout type="PatternLayout">\n        <Pattern>%d %p %C{1.} [%t] %m%n</Pattern>\n      </Layout>\n    </Appender>\n  </Appenders>\n\n  <Loggers>\n    <Logger name="org.apache.logging.log4j.test1" level="debug" additivity="false">\n      <Filter type="ThreadContextMapFilter">\n        <KeyValuePair key="test" value="123"/>\n      </Filter>\n      <AppenderRef ref="STDOUT"/>\n    </Logger>\n\n    <Logger name="org.apache.logging.log4j.test2" level="debug" additivity="false">\n      <AppenderRef ref="File"/>\n    </Logger>\n\n    <Root level="trace">\n      <AppenderRef ref="STDOUT"/>\n    </Root>\n  </Loggers>\n\n</Configuration>\n\n\n\n# logback 配置\n\n\n# <configuration>\n\n * 作用：<configuration> 是 logback 配置文件的根元素。\n * 要点\n   * 它有 <appender>、<logger>、<root> 三个子元素。\n\n\n\n\n# <appender>\n\n * 作用：将记录日志的任务委托给名为 appender 的组件。\n * 要点\n   * 可以配置零个或多个。\n   * 它有 <file>、<filter>、<layout>、<encoder> 四个子元素。\n * 属性\n   * name：设置 appender 名称。\n   * class：设置具体的实例化类。\n\n# <file>\n\n * 作用：设置日志文件路径。\n\n# <filter>\n\n * 作用：设置过滤器。\n * 要点\n   * 可以配置零个或多个。\n\n# <layout>\n\n * 作用：设置 appender。\n * 要点\n   * 可以配置零个或一个。\n * 属性\n   * class：设置具体的实例化类。\n\n# <encoder>\n\n * 作用：设置编码。\n * 要点\n   * 可以配置零个或多个。\n * 属性\n   * class：设置具体的实例化类。\n\n\n\n\n# <logger>\n\n * 作用：设置 logger。\n * 要点\n   * 可以配置零个或多个。\n * 属性\n   * name\n   * level：设置日志级别。不区分大小写。可选值：TRACE、DEBUG、INFO、WARN、ERROR、ALL、OFF。\n   * additivity：可选值：true 或 false。\n\n# <appender-ref>\n\n * 作用：appender 引用。\n * 要点\n   * 可以配置零个或多个。\n\n\n# <root>\n\n * 作用：设置根 logger。\n * 要点\n   * 只能配置一个。\n   * 除了 level，不支持任何属性。level 属性和 <logger> 中的相同。\n   * 有一个子元素 <appender-ref>，与 <logger> 中的相同。\n\n\n# 完整的 logback.xml 参考示例\n\n在下面的配置文件中，我为自己的项目代码（根目录：org.zp.notes.spring）设置了五种等级：\n\nTRACE、DEBUG、INFO、WARN、ERROR，优先级依次从低到高。\n\n因为关注 spring 框架本身的一些信息，我增加了专门打印 spring WARN 及以上等级的日志。\n\n<?xml version="1.0" encoding="UTF-8" ?>\n\n\x3c!-- logback中一共有5种有效级别，分别是TRACE、DEBUG、INFO、WARN、ERROR，优先级依次从低到高 --\x3e\n<configuration scan="true" scanPeriod="60 seconds" debug="false">\n\n  <property name="DIR_NAME" value="spring-helloworld"/>\n\n  \x3c!-- 将记录日志打印到控制台 --\x3e\n  <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">\n    <encoder>\n      <pattern>%d{HH:mm:ss.SSS} [%thread] [%-5p] %c{36}.%M - %m%n</pattern>\n    </encoder>\n  </appender>\n\n  \x3c!-- RollingFileAppender begin --\x3e\n  <appender name="ALL" class="ch.qos.logback.core.rolling.RollingFileAppender">\n    \x3c!-- 根据时间来制定滚动策略 --\x3e\n    <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">\n      <fileNamePattern>${user.dir}/logs/${DIR_NAME}/all.%d{yyyy-MM-dd}.log</fileNamePattern>\n      <maxHistory>30</maxHistory>\n    </rollingPolicy>\n\n    \x3c!-- 根据文件大小来制定滚动策略 --\x3e\n    <triggeringPolicy class="ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy">\n      <maxFileSize>30MB</maxFileSize>\n    </triggeringPolicy>\n\n    <encoder>\n      <pattern>%d{HH:mm:ss.SSS} [%thread] [%-5p] %c{36}.%M - %m%n</pattern>\n    </encoder>\n  </appender>\n\n  <appender name="ERROR" class="ch.qos.logback.core.rolling.RollingFileAppender">\n    \x3c!-- 根据时间来制定滚动策略 --\x3e\n    <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">\n      <fileNamePattern>${user.dir}/logs/${DIR_NAME}/error.%d{yyyy-MM-dd}.log</fileNamePattern>\n      <maxHistory>30</maxHistory>\n    </rollingPolicy>\n\n    \x3c!-- 根据文件大小来制定滚动策略 --\x3e\n    <triggeringPolicy class="ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy">\n      <maxFileSize>10MB</maxFileSize>\n    </triggeringPolicy>\n\n    <filter class="ch.qos.logback.classic.filter.LevelFilter">\n      <level>ERROR</level>\n      <onMatch>ACCEPT</onMatch>\n      <onMismatch>DENY</onMismatch>\n    </filter>\n\n    <encoder>\n      <pattern>%d{HH:mm:ss.SSS} [%thread] [%-5p] %c{36}.%M - %m%n</pattern>\n    </encoder>\n  </appender>\n\n  <appender name="WARN" class="ch.qos.logback.core.rolling.RollingFileAppender">\n    \x3c!-- 根据时间来制定滚动策略 --\x3e\n    <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">\n      <fileNamePattern>${user.dir}/logs/${DIR_NAME}/warn.%d{yyyy-MM-dd}.log</fileNamePattern>\n      <maxHistory>30</maxHistory>\n    </rollingPolicy>\n\n    \x3c!-- 根据文件大小来制定滚动策略 --\x3e\n    <triggeringPolicy class="ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy">\n      <maxFileSize>10MB</maxFileSize>\n    </triggeringPolicy>\n\n    <filter class="ch.qos.logback.classic.filter.LevelFilter">\n      <level>WARN</level>\n      <onMatch>ACCEPT</onMatch>\n      <onMismatch>DENY</onMismatch>\n    </filter>\n\n    <encoder>\n      <pattern>%d{HH:mm:ss.SSS} [%thread] [%-5p] %c{36}.%M - %m%n</pattern>\n    </encoder>\n  </appender>\n\n  <appender name="INFO" class="ch.qos.logback.core.rolling.RollingFileAppender">\n    \x3c!-- 根据时间来制定滚动策略 --\x3e\n    <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">\n      <fileNamePattern>${user.dir}/logs/${DIR_NAME}/info.%d{yyyy-MM-dd}.log</fileNamePattern>\n      <maxHistory>30</maxHistory>\n    </rollingPolicy>\n\n    \x3c!-- 根据文件大小来制定滚动策略 --\x3e\n    <triggeringPolicy class="ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy">\n      <maxFileSize>10MB</maxFileSize>\n    </triggeringPolicy>\n\n    <filter class="ch.qos.logback.classic.filter.LevelFilter">\n      <level>INFO</level>\n      <onMatch>ACCEPT</onMatch>\n      <onMismatch>DENY</onMismatch>\n    </filter>\n\n    <encoder>\n      <pattern>%d{HH:mm:ss.SSS} [%thread] [%-5p] %c{36}.%M - %m%n</pattern>\n    </encoder>\n  </appender>\n\n  <appender name="DEBUG" class="ch.qos.logback.core.rolling.RollingFileAppender">\n    \x3c!-- 根据时间来制定滚动策略 --\x3e\n    <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">\n      <fileNamePattern>${user.dir}/logs/${DIR_NAME}/debug.%d{yyyy-MM-dd}.log</fileNamePattern>\n      <maxHistory>30</maxHistory>\n    </rollingPolicy>\n\n    \x3c!-- 根据文件大小来制定滚动策略 --\x3e\n    <triggeringPolicy class="ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy">\n      <maxFileSize>10MB</maxFileSize>\n    </triggeringPolicy>\n\n    <filter class="ch.qos.logback.classic.filter.LevelFilter">\n      <level>DEBUG</level>\n      <onMatch>ACCEPT</onMatch>\n      <onMismatch>DENY</onMismatch>\n    </filter>\n\n    <encoder>\n      <pattern>%d{HH:mm:ss.SSS} [%thread] [%-5p] %c{36}.%M - %m%n</pattern>\n    </encoder>\n  </appender>\n\n  <appender name="TRACE" class="ch.qos.logback.core.rolling.RollingFileAppender">\n    \x3c!-- 根据时间来制定滚动策略 --\x3e\n    <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">\n      <fileNamePattern>${user.dir}/logs/${DIR_NAME}/trace.%d{yyyy-MM-dd}.log</fileNamePattern>\n      <maxHistory>30</maxHistory>\n    </rollingPolicy>\n\n    \x3c!-- 根据文件大小来制定滚动策略 --\x3e\n    <triggeringPolicy class="ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy">\n      <maxFileSize>10MB</maxFileSize>\n    </triggeringPolicy>\n\n    <filter class="ch.qos.logback.classic.filter.LevelFilter">\n      <level>TRACE</level>\n      <onMatch>ACCEPT</onMatch>\n      <onMismatch>DENY</onMismatch>\n    </filter>\n\n    <encoder>\n      <pattern>%d{HH:mm:ss.SSS} [%thread] [%-5p] %c{36}.%M - %m%n</pattern>\n    </encoder>\n  </appender>\n\n  <appender name="SPRING" class="ch.qos.logback.core.rolling.RollingFileAppender">\n    \x3c!-- 根据时间来制定滚动策略 --\x3e\n    <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">\n      <fileNamePattern>${user.dir}/logs/${DIR_NAME}/springframework.%d{yyyy-MM-dd}.log\n      </fileNamePattern>\n      <maxHistory>30</maxHistory>\n    </rollingPolicy>\n\n    \x3c!-- 根据文件大小来制定滚动策略 --\x3e\n    <triggeringPolicy class="ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy">\n      <maxFileSize>10MB</maxFileSize>\n    </triggeringPolicy>\n\n    <encoder>\n      <pattern>%d{HH:mm:ss.SSS} [%thread] [%-5p] %c{36}.%M - %m%n</pattern>\n    </encoder>\n  </appender>\n  \x3c!-- RollingFileAppender end --\x3e\n\n  \x3c!-- logger begin --\x3e\n  \x3c!-- 本项目的日志记录，分级打印 --\x3e\n  <logger name="org.zp.notes.spring" level="TRACE" additivity="false">\n    <appender-ref ref="STDOUT"/>\n    <appender-ref ref="ERROR"/>\n    <appender-ref ref="WARN"/>\n    <appender-ref ref="INFO"/>\n    <appender-ref ref="DEBUG"/>\n    <appender-ref ref="TRACE"/>\n  </logger>\n\n  \x3c!-- SPRING框架日志 --\x3e\n  <logger name="org.springframework" level="WARN" additivity="false">\n    <appender-ref ref="SPRING"/>\n  </logger>\n\n  <root level="TRACE">\n    <appender-ref ref="ALL"/>\n  </root>\n  \x3c!-- logger end --\x3e\n\n</configuration>\n\n\n\n# log4j 配置\n\n\n# 完整的 log4j.xml 参考示例\n\nlog4j 的配置文件一般有 xml 格式或 properties 格式。这里为了和 logback.xml 做个对比，就不介绍 properties 了，其实也没太大差别。\n\n<?xml version="1.0" encoding="UTF-8"?>\n<!DOCTYPE log4j:configuration SYSTEM "log4j.dtd">\n\n<log4j:configuration xmlns:log4j=\'http://jakarta.apache.org/log4j/\'>\n\n  <appender name="STDOUT" class="org.apache.log4j.ConsoleAppender">\n    <layout class="org.apache.log4j.PatternLayout">\n      <param name="ConversionPattern"\n             value="%d{yyyy-MM-dd HH:mm:ss,SSS\\} [%-5p] [%t] %c{36\\}.%M - %m%n"/>\n    </layout>\n\n    \x3c!--过滤器设置输出的级别--\x3e\n    <filter class="org.apache.log4j.varia.LevelRangeFilter">\n      <param name="levelMin" value="debug"/>\n      <param name="levelMax" value="fatal"/>\n      <param name="AcceptOnMatch" value="true"/>\n    </filter>\n  </appender>\n\n\n  <appender name="ALL" class="org.apache.log4j.DailyRollingFileAppender">\n    <param name="File" value="${user.dir}/logs/spring-common/jcl/all"/>\n    <param name="Append" value="true"/>\n    \x3c!-- 每天重新生成日志文件 --\x3e\n    <param name="DatePattern" value="\'-\'yyyy-MM-dd\'.log\'"/>\n    \x3c!-- 每小时重新生成日志文件 --\x3e\n    \x3c!--<param name="DatePattern" value="\'-\'yyyy-MM-dd-HH\'.log\'"/>--\x3e\n    <layout class="org.apache.log4j.PatternLayout">\n      <param name="ConversionPattern"\n             value="%d{yyyy-MM-dd HH:mm:ss,SSS\\} [%-5p] [%t] %c{36\\}.%M - %m%n"/>\n    </layout>\n  </appender>\n\n  \x3c!-- 指定logger的设置，additivity指示是否遵循缺省的继承机制--\x3e\n  <logger name="org.zp.notes.spring" additivity="false">\n    <level value="error"/>\n    <appender-ref ref="STDOUT"/>\n    <appender-ref ref="ALL"/>\n  </logger>\n\n  \x3c!-- 根logger的设置--\x3e\n  <root>\n    <level value="warn"/>\n    <appender-ref ref="STDOUT"/>\n  </root>\n</log4j:configuration>\n\n\n\n# 参考\n\n * slf4 官方文档\n * logback 官方文档\n * log4j 官方文档\n * commons-logging 官方文档\n * http://blog.csdn.net/yycdaizi/article/details/8276265',normalizedContent:'# 细说 java 主流日志工具库\n\n> 在项目开发中，为了跟踪代码的运行情况，常常要使用日志来记录信息。\n> \n> 在 java 世界，有很多的日志工具库来实现日志功能，避免了我们重复造轮子。\n> \n> 我们先来逐一了解一下主流日志工具。\n\n\n# 日志框架\n\n\n# java.util.logging (jul)\n\njdk1.4 开始，通过 java.util.logging 提供日志功能。\n\n它能满足基本的日志需要，但是功能没有 log4j 强大，而且使用范围也没有 log4j 广泛。\n\n\n# log4j\n\nlog4j 是 apache 的一个开源项目，创始人 ceki gulcu。\n\nlog4j 应该说是 java 领域资格最老，应用最广的日志工具。从诞生之日到现在一直广受业界欢迎。\n\nlog4j 是高度可配置的，并可通过在运行时的外部文件配置。它根据记录的优先级别，并提供机制，以指示记录信息到许多的目的地，诸如：数据库，文件，控制台，unix 系统日志等。\n\nlog4j 中有三个主要组成部分：\n\n * loggers - 负责捕获记录信息。\n * appenders - 负责发布日志信息，以不同的首选目的地。\n * layouts - 负责格式化不同风格的日志信息。\n\n官网地址\n\n\n# logback\n\nlogback 是由 log4j 创始人 ceki gulcu 设计的又一个开源日记组件，目标是替代 log4j。\n\nlogback 当前分成三个模块：logback-core、logback-classic 和 logback-access。\n\n * logback-core - 是其它两个模块的基础模块。\n * logback-classic - 是 log4j 的一个 改良版本。此外 logback-classic 完整实现 slf4j api 使你可以很方便地更换成其它日记系统如 log4j 或 jdk14 logging。\n * logback-access - 访问模块与 servlet 容器集成提供通过 http 来访问日记的功能。\n\n官网地址\n\n\n# log4j2\n\n官网地址\n\n按照官方的说法，log4j2 是 log4j 和 logback 的替代。\n\nlog4j2 架构：\n\n\n\n\n# log4j vs logback vs log4j2\n\n按照官方的说法，log4j2 大大优于 log4j 和 logback。\n\n那么，log4j2 相比于先问世的 log4j 和 logback，它具有哪些优势呢？\n\n 1.  log4j2 旨在用作审计日志记录框架。 log4j 1.x 和 logback 都会在重新配置时丢失事件。 log4j 2 不会。在 logback 中，appender 中的异常永远不会对应用程序可见。在 log4j 中，可以将 appender 配置为允许异常渗透到应用程序。\n 2.  log4j2 在多线程场景中，异步 loggers 的吞吐量比 log4j 1.x 和 logback 高 10 倍，延迟低几个数量级。\n 3.  log4j2 对于独立应用程序是无垃圾的，对于稳定状态日志记录期间的 web 应用程序来说是低垃圾。这减少了垃圾收集器的压力，并且可以提供更好的响应时间性能。\n 4.  log4j2 使用插件系统，通过添加新的 appender、filter、layout、lookup 和 pattern converter，可以非常轻松地扩展框架，而无需对 log4j 进行任何更改。\n 5.  由于插件系统配置更简单。配置中的条目不需要指定类名。\n 6.  支持自定义日志等级。\n 7.  支持 lambda 表达式。\n 8.  支持消息对象。\n 9.  log4j 和 logback 的 layout 返回的是字符串，而 log4j2 返回的是二进制数组，这使得它能被各种 appender 使用。\n 10. syslog appender 支持 tcp 和 udp 并且支持 bsd 系统日志。\n 11. log4j2 利用 java5 并发特性，尽量小粒度的使用锁，减少锁的开销。\n\n\n# 日志门面\n\n何谓日志门面？\n\n日志门面是对不同日志框架提供的一个 api 封装，可以在部署的时候不修改任何配置即可接入一种日志实现方案。\n\n\n# common-logging\n\ncommon-logging 是 apache 的一个开源项目。也称jakarta commons logging，缩写 jcl。\n\ncommon-logging 的功能是提供日志功能的 api 接口，本身并不提供日志的具体实现（当然，common-logging 内部有一个 simple logger 的简单实现，但是功能很弱，直接忽略），而是在运行时动态的绑定日志实现组件来工作（如 log4j、java.util.loggin）。\n\n官网地址\n\n\n# slf4j\n\n全称为 simple logging facade for java，即 java 简单日志门面。\n\n什么，作者又是 ceki gulcu！这位大神写了 log4j、logback 和 slf4j，专注日志组件开发五百年，一直只能超越自己。\n\n类似于 common-logging，slf4j 是对不同日志框架提供的一个 api 封装，可以在部署的时候不修改任何配置即可接入一种日志实现方案。但是，slf4j 在编译时静态绑定真正的 log 库。使用 slf4j 时，如果你需要使用某一种日志实现，那么你必须选择正确的 slf4j 的 jar 包的集合（各种桥接包）。\n\n官网地址\n\n\n\n\n# common-logging vs slf4j\n\nslf4j 库类似于 apache common-logging。但是，他在编译时静态绑定真正的日志库。这点似乎很麻烦，其实也不过是导入桥接 jar 包而已。\n\nslf4j 一大亮点是提供了更方便的日志记录方式：\n\n不需要使用logger.isdebugenabled()来解决日志因为字符拼接产生的性能问题。slf4j 的方式是使用{}作为字符串替换符，形式如下：\n\nlogger.debug("id: {}, name: {} ", id, name);\n\n\n\n# 总结\n\n综上所述，使用 slf4j + logback 可谓是目前最理想的日志解决方案了。\n\n接下来，就是如何在项目中实施了。\n\n\n# 实施日志解决方案\n\n使用日志解决方案基本可分为三步：\n\n 1. 引入 jar 包\n 2. 配置\n 3. 使用 api\n\n常见的各种日志解决方案的第 2 步和第 3 步基本一样，实施上的差别主要在第 1 步，也就是使用不同的库。\n\n\n# 引入 jar 包\n\n这里首选推荐使用 slf4j + logback 的组合。\n\n如果你习惯了 common-logging，可以选择 common-logging+log4j。\n\n强烈建议不要直接使用日志实现组件(logback、log4j、java.util.logging)，理由前面也说过，就是无法灵活替换日志库。\n\n还有一种情况：你的老项目使用了 common-logging，或是直接使用日志实现组件。如果修改老的代码，工作量太大，需要兼容处理。在下文，都将看到各种应对方法。\n\n注：据我所知，当前仍没有方法可以将 slf4j 桥接到 common-logging。如果我孤陋寡闻了，请不吝赐教。\n\n# slf4j 直接绑定日志组件\n\nslf4j + logback\n\n添加依赖到 pom.xml 中即可。\n\nlogback-classic-1.0.13.jar 会自动将 slf4j-api-1.7.21.jar 和 logback-core-1.0.13.jar 也添加到你的项目中。\n\n<dependency>\n  <groupid>ch.qos.logback</groupid>\n  <artifactid>logback-classic</artifactid>\n  <version>1.0.13</version>\n</dependency>\n\n\nslf4j + log4j\n\n添加依赖到 pom.xml 中即可。\n\nslf4j-log4j12-1.7.21.jar 会自动将 slf4j-api-1.7.21.jar 和 log4j-1.2.17.jar 也添加到你的项目中。\n\n<dependency>\n  <groupid>org.slf4j</groupid>\n  <artifactid>slf4j-log4j12</artifactid>\n  <version>1.7.21</version>\n</dependency>\n\n\nslf4j + java.util.logging\n\n添加依赖到 pom.xml 中即可。\n\nslf4j-jdk14-1.7.21.jar 会自动将 slf4j-api-1.7.21.jar 也添加到你的项目中。\n\n<dependency>\n  <groupid>org.slf4j</groupid>\n  <artifactid>slf4j-jdk14</artifactid>\n  <version>1.7.21</version>\n</dependency>\n\n\n# slf4j 兼容非 slf4j 日志组件\n\n在介绍解决方案前，先提一个概念——桥接\n\n什么是桥接呢\n\n假如你正在开发应用程序所调用的组件当中已经使用了 common-logging，这时你需要 jcl-over-slf4j.jar 把日志信息输出重定向到 slf4j-api，slf4j-api 再去调用 slf4j 实际依赖的日志组件。这个过程称为桥接。下图是官方的 slf4j 桥接策略图：\n\n\n\n从图中应该可以看出，无论你的老项目中使用的是 common-logging 或是直接使用 log4j、java.util.logging，都可以使用对应的桥接 jar 包来解决兼容问题。\n\nslf4j 兼容 common-logging\n\n<dependency>\n  <groupid>org.slf4j</groupid>\n  <artifactid>jcl-over-slf4j</artifactid>\n  <version>1.7.12</version>\n</dependency>\n\n\nslf4j 兼容 log4j\n\n<dependency>\n    <groupid>org.slf4j</groupid>\n    <artifactid>log4j-over-slf4j</artifactid>\n    <version>1.7.12</version>\n</dependency>\n\n\nslf4j 兼容 java.util.logging\n\n<dependency>\n    <groupid>org.slf4j</groupid>\n    <artifactid>jul-to-slf4j</artifactid>\n    <version>1.7.12</version>\n</dependency>\n\n\n# spring 集成 slf4j\n\n做 java web 开发，基本离不开 spring 框架。很遗憾，spring 使用的日志解决方案是 common-logging + log4j。\n\n所以，你需要一个桥接 jar 包：logback-ext-spring。\n\n<dependency>\n  <groupid>ch.qos.logback</groupid>\n  <artifactid>logback-classic</artifactid>\n  <version>1.1.3</version>\n</dependency>\n<dependency>\n  <groupid>org.logback-extensions</groupid>\n  <artifactid>logback-ext-spring</artifactid>\n  <version>0.1.2</version>\n</dependency>\n<dependency>\n  <groupid>org.slf4j</groupid>\n  <artifactid>jcl-over-slf4j</artifactid>\n  <version>1.7.12</version>\n</dependency>\n\n\n# common-logging 绑定日志组件\n\ncommon-logging + log4j\n\n添加依赖到 pom.xml 中即可。\n\n<dependency>\n  <groupid>commons-logging</groupid>\n  <artifactid>commons-logging</artifactid>\n  <version>1.2</version>\n</dependency>\n<dependency>\n  <groupid>log4j</groupid>\n  <artifactid>log4j</artifactid>\n  <version>1.2.17</version>\n</dependency>\n\n\n\n# 使用 api\n\n# slf4j 用法\n\n使用 slf4j 的 api 很简单。使用loggerfactory初始化一个logger实例，然后调用 logger 对应的打印等级函数就行了。\n\nimport org.slf4j.logger;\nimport org.slf4j.loggerfactory;\n\npublic class app {\n    private static final logger log = loggerfactory.getlogger(app.class);\n    public static void main(string[] args) {\n        string msg = "print log, current level: {}";\n        log.trace(msg, "trace");\n        log.debug(msg, "debug");\n        log.info(msg, "info");\n        log.warn(msg, "warn");\n        log.error(msg, "error");\n    }\n}\n\n\n# common-logging 用法\n\ncommon-logging 用法和 slf4j 几乎一样，但是支持的打印等级多了一个更高级别的：fatal。\n\n此外，common-logging 不支持{}替换参数，你只能选择拼接字符串这种方式了。\n\nimport org.apache.commons.logging.log;\nimport org.apache.commons.logging.logfactory;\n\npublic class jcltest {\n    private static final log log = logfactory.getlog(jcltest.class);\n\n    public static void main(string[] args) {\n        string msg = "print log, current level: ";\n        log.trace(msg + "trace");\n        log.debug(msg + "debug");\n        log.info(msg + "info");\n        log.warn(msg + "warn");\n        log.error(msg + "error");\n        log.fatal(msg + "fatal");\n    }\n}\n\n\n\n# log4j2 配置\n\nlog4j2 基本配置形式如下：\n\n<?xml version="1.0" encoding="utf-8"?>;\n<configuration>\n  <properties>\n    <property name="name1">value</property>\n    <property name="name2" value="value2"/>\n  </properties>\n  <filter type="type" ... />\n  <appenders>\n    <appender type="type" name="name">\n      <filter type="type" ... />\n    </appender>\n    ...\n  </appenders>\n  <loggers>\n    <logger name="name1">\n      <filter type="type" ... />\n    </logger>\n    ...\n    <root level="level">\n      <appenderref ref="name"/>\n    </root>\n  </loggers>\n</configuration>\n\n\n配置示例：\n\n<?xml version="1.0" encoding="utf-8"?>\n<configuration status="debug" strict="true" name="xmlconfigtest"\n               packages="org.apache.logging.log4j.test">\n  <properties>\n    <property name="filename">target/test.log</property>\n  </properties>\n  <filter type="thresholdfilter" level="trace"/>\n\n  <appenders>\n    <appender type="console" name="stdout">\n      <layout type="patternlayout" pattern="%m mdc%x%n"/>\n      <filters>\n        <filter type="markerfilter" marker="flow" onmatch="deny" onmismatch="neutral"/>\n        <filter type="markerfilter" marker="exception" onmatch="deny" onmismatch="accept"/>\n      </filters>\n    </appender>\n    <appender type="console" name="flow">\n      <layout type="patternlayout" pattern="%c{1}.%m %m %ex%n"/>\x3c!-- class and line number --\x3e\n      <filters>\n        <filter type="markerfilter" marker="flow" onmatch="accept" onmismatch="neutral"/>\n        <filter type="markerfilter" marker="exception" onmatch="accept" onmismatch="deny"/>\n      </filters>\n    </appender>\n    <appender type="file" name="file" filename="${filename}">\n      <layout type="patternlayout">\n        <pattern>%d %p %c{1.} [%t] %m%n</pattern>\n      </layout>\n    </appender>\n  </appenders>\n\n  <loggers>\n    <logger name="org.apache.logging.log4j.test1" level="debug" additivity="false">\n      <filter type="threadcontextmapfilter">\n        <keyvaluepair key="test" value="123"/>\n      </filter>\n      <appenderref ref="stdout"/>\n    </logger>\n\n    <logger name="org.apache.logging.log4j.test2" level="debug" additivity="false">\n      <appenderref ref="file"/>\n    </logger>\n\n    <root level="trace">\n      <appenderref ref="stdout"/>\n    </root>\n  </loggers>\n\n</configuration>\n\n\n\n# logback 配置\n\n\n# <configuration>\n\n * 作用：<configuration> 是 logback 配置文件的根元素。\n * 要点\n   * 它有 <appender>、<logger>、<root> 三个子元素。\n\n\n\n\n# <appender>\n\n * 作用：将记录日志的任务委托给名为 appender 的组件。\n * 要点\n   * 可以配置零个或多个。\n   * 它有 <file>、<filter>、<layout>、<encoder> 四个子元素。\n * 属性\n   * name：设置 appender 名称。\n   * class：设置具体的实例化类。\n\n# <file>\n\n * 作用：设置日志文件路径。\n\n# <filter>\n\n * 作用：设置过滤器。\n * 要点\n   * 可以配置零个或多个。\n\n# <layout>\n\n * 作用：设置 appender。\n * 要点\n   * 可以配置零个或一个。\n * 属性\n   * class：设置具体的实例化类。\n\n# <encoder>\n\n * 作用：设置编码。\n * 要点\n   * 可以配置零个或多个。\n * 属性\n   * class：设置具体的实例化类。\n\n\n\n\n# <logger>\n\n * 作用：设置 logger。\n * 要点\n   * 可以配置零个或多个。\n * 属性\n   * name\n   * level：设置日志级别。不区分大小写。可选值：trace、debug、info、warn、error、all、off。\n   * additivity：可选值：true 或 false。\n\n# <appender-ref>\n\n * 作用：appender 引用。\n * 要点\n   * 可以配置零个或多个。\n\n\n# <root>\n\n * 作用：设置根 logger。\n * 要点\n   * 只能配置一个。\n   * 除了 level，不支持任何属性。level 属性和 <logger> 中的相同。\n   * 有一个子元素 <appender-ref>，与 <logger> 中的相同。\n\n\n# 完整的 logback.xml 参考示例\n\n在下面的配置文件中，我为自己的项目代码（根目录：org.zp.notes.spring）设置了五种等级：\n\ntrace、debug、info、warn、error，优先级依次从低到高。\n\n因为关注 spring 框架本身的一些信息，我增加了专门打印 spring warn 及以上等级的日志。\n\n<?xml version="1.0" encoding="utf-8" ?>\n\n\x3c!-- logback中一共有5种有效级别，分别是trace、debug、info、warn、error，优先级依次从低到高 --\x3e\n<configuration scan="true" scanperiod="60 seconds" debug="false">\n\n  <property name="dir_name" value="spring-helloworld"/>\n\n  \x3c!-- 将记录日志打印到控制台 --\x3e\n  <appender name="stdout" class="ch.qos.logback.core.consoleappender">\n    <encoder>\n      <pattern>%d{hh:mm:ss.sss} [%thread] [%-5p] %c{36}.%m - %m%n</pattern>\n    </encoder>\n  </appender>\n\n  \x3c!-- rollingfileappender begin --\x3e\n  <appender name="all" class="ch.qos.logback.core.rolling.rollingfileappender">\n    \x3c!-- 根据时间来制定滚动策略 --\x3e\n    <rollingpolicy class="ch.qos.logback.core.rolling.timebasedrollingpolicy">\n      <filenamepattern>${user.dir}/logs/${dir_name}/all.%d{yyyy-mm-dd}.log</filenamepattern>\n      <maxhistory>30</maxhistory>\n    </rollingpolicy>\n\n    \x3c!-- 根据文件大小来制定滚动策略 --\x3e\n    <triggeringpolicy class="ch.qos.logback.core.rolling.sizebasedtriggeringpolicy">\n      <maxfilesize>30mb</maxfilesize>\n    </triggeringpolicy>\n\n    <encoder>\n      <pattern>%d{hh:mm:ss.sss} [%thread] [%-5p] %c{36}.%m - %m%n</pattern>\n    </encoder>\n  </appender>\n\n  <appender name="error" class="ch.qos.logback.core.rolling.rollingfileappender">\n    \x3c!-- 根据时间来制定滚动策略 --\x3e\n    <rollingpolicy class="ch.qos.logback.core.rolling.timebasedrollingpolicy">\n      <filenamepattern>${user.dir}/logs/${dir_name}/error.%d{yyyy-mm-dd}.log</filenamepattern>\n      <maxhistory>30</maxhistory>\n    </rollingpolicy>\n\n    \x3c!-- 根据文件大小来制定滚动策略 --\x3e\n    <triggeringpolicy class="ch.qos.logback.core.rolling.sizebasedtriggeringpolicy">\n      <maxfilesize>10mb</maxfilesize>\n    </triggeringpolicy>\n\n    <filter class="ch.qos.logback.classic.filter.levelfilter">\n      <level>error</level>\n      <onmatch>accept</onmatch>\n      <onmismatch>deny</onmismatch>\n    </filter>\n\n    <encoder>\n      <pattern>%d{hh:mm:ss.sss} [%thread] [%-5p] %c{36}.%m - %m%n</pattern>\n    </encoder>\n  </appender>\n\n  <appender name="warn" class="ch.qos.logback.core.rolling.rollingfileappender">\n    \x3c!-- 根据时间来制定滚动策略 --\x3e\n    <rollingpolicy class="ch.qos.logback.core.rolling.timebasedrollingpolicy">\n      <filenamepattern>${user.dir}/logs/${dir_name}/warn.%d{yyyy-mm-dd}.log</filenamepattern>\n      <maxhistory>30</maxhistory>\n    </rollingpolicy>\n\n    \x3c!-- 根据文件大小来制定滚动策略 --\x3e\n    <triggeringpolicy class="ch.qos.logback.core.rolling.sizebasedtriggeringpolicy">\n      <maxfilesize>10mb</maxfilesize>\n    </triggeringpolicy>\n\n    <filter class="ch.qos.logback.classic.filter.levelfilter">\n      <level>warn</level>\n      <onmatch>accept</onmatch>\n      <onmismatch>deny</onmismatch>\n    </filter>\n\n    <encoder>\n      <pattern>%d{hh:mm:ss.sss} [%thread] [%-5p] %c{36}.%m - %m%n</pattern>\n    </encoder>\n  </appender>\n\n  <appender name="info" class="ch.qos.logback.core.rolling.rollingfileappender">\n    \x3c!-- 根据时间来制定滚动策略 --\x3e\n    <rollingpolicy class="ch.qos.logback.core.rolling.timebasedrollingpolicy">\n      <filenamepattern>${user.dir}/logs/${dir_name}/info.%d{yyyy-mm-dd}.log</filenamepattern>\n      <maxhistory>30</maxhistory>\n    </rollingpolicy>\n\n    \x3c!-- 根据文件大小来制定滚动策略 --\x3e\n    <triggeringpolicy class="ch.qos.logback.core.rolling.sizebasedtriggeringpolicy">\n      <maxfilesize>10mb</maxfilesize>\n    </triggeringpolicy>\n\n    <filter class="ch.qos.logback.classic.filter.levelfilter">\n      <level>info</level>\n      <onmatch>accept</onmatch>\n      <onmismatch>deny</onmismatch>\n    </filter>\n\n    <encoder>\n      <pattern>%d{hh:mm:ss.sss} [%thread] [%-5p] %c{36}.%m - %m%n</pattern>\n    </encoder>\n  </appender>\n\n  <appender name="debug" class="ch.qos.logback.core.rolling.rollingfileappender">\n    \x3c!-- 根据时间来制定滚动策略 --\x3e\n    <rollingpolicy class="ch.qos.logback.core.rolling.timebasedrollingpolicy">\n      <filenamepattern>${user.dir}/logs/${dir_name}/debug.%d{yyyy-mm-dd}.log</filenamepattern>\n      <maxhistory>30</maxhistory>\n    </rollingpolicy>\n\n    \x3c!-- 根据文件大小来制定滚动策略 --\x3e\n    <triggeringpolicy class="ch.qos.logback.core.rolling.sizebasedtriggeringpolicy">\n      <maxfilesize>10mb</maxfilesize>\n    </triggeringpolicy>\n\n    <filter class="ch.qos.logback.classic.filter.levelfilter">\n      <level>debug</level>\n      <onmatch>accept</onmatch>\n      <onmismatch>deny</onmismatch>\n    </filter>\n\n    <encoder>\n      <pattern>%d{hh:mm:ss.sss} [%thread] [%-5p] %c{36}.%m - %m%n</pattern>\n    </encoder>\n  </appender>\n\n  <appender name="trace" class="ch.qos.logback.core.rolling.rollingfileappender">\n    \x3c!-- 根据时间来制定滚动策略 --\x3e\n    <rollingpolicy class="ch.qos.logback.core.rolling.timebasedrollingpolicy">\n      <filenamepattern>${user.dir}/logs/${dir_name}/trace.%d{yyyy-mm-dd}.log</filenamepattern>\n      <maxhistory>30</maxhistory>\n    </rollingpolicy>\n\n    \x3c!-- 根据文件大小来制定滚动策略 --\x3e\n    <triggeringpolicy class="ch.qos.logback.core.rolling.sizebasedtriggeringpolicy">\n      <maxfilesize>10mb</maxfilesize>\n    </triggeringpolicy>\n\n    <filter class="ch.qos.logback.classic.filter.levelfilter">\n      <level>trace</level>\n      <onmatch>accept</onmatch>\n      <onmismatch>deny</onmismatch>\n    </filter>\n\n    <encoder>\n      <pattern>%d{hh:mm:ss.sss} [%thread] [%-5p] %c{36}.%m - %m%n</pattern>\n    </encoder>\n  </appender>\n\n  <appender name="spring" class="ch.qos.logback.core.rolling.rollingfileappender">\n    \x3c!-- 根据时间来制定滚动策略 --\x3e\n    <rollingpolicy class="ch.qos.logback.core.rolling.timebasedrollingpolicy">\n      <filenamepattern>${user.dir}/logs/${dir_name}/springframework.%d{yyyy-mm-dd}.log\n      </filenamepattern>\n      <maxhistory>30</maxhistory>\n    </rollingpolicy>\n\n    \x3c!-- 根据文件大小来制定滚动策略 --\x3e\n    <triggeringpolicy class="ch.qos.logback.core.rolling.sizebasedtriggeringpolicy">\n      <maxfilesize>10mb</maxfilesize>\n    </triggeringpolicy>\n\n    <encoder>\n      <pattern>%d{hh:mm:ss.sss} [%thread] [%-5p] %c{36}.%m - %m%n</pattern>\n    </encoder>\n  </appender>\n  \x3c!-- rollingfileappender end --\x3e\n\n  \x3c!-- logger begin --\x3e\n  \x3c!-- 本项目的日志记录，分级打印 --\x3e\n  <logger name="org.zp.notes.spring" level="trace" additivity="false">\n    <appender-ref ref="stdout"/>\n    <appender-ref ref="error"/>\n    <appender-ref ref="warn"/>\n    <appender-ref ref="info"/>\n    <appender-ref ref="debug"/>\n    <appender-ref ref="trace"/>\n  </logger>\n\n  \x3c!-- spring框架日志 --\x3e\n  <logger name="org.springframework" level="warn" additivity="false">\n    <appender-ref ref="spring"/>\n  </logger>\n\n  <root level="trace">\n    <appender-ref ref="all"/>\n  </root>\n  \x3c!-- logger end --\x3e\n\n</configuration>\n\n\n\n# log4j 配置\n\n\n# 完整的 log4j.xml 参考示例\n\nlog4j 的配置文件一般有 xml 格式或 properties 格式。这里为了和 logback.xml 做个对比，就不介绍 properties 了，其实也没太大差别。\n\n<?xml version="1.0" encoding="utf-8"?>\n<!doctype log4j:configuration system "log4j.dtd">\n\n<log4j:configuration xmlns:log4j=\'http://jakarta.apache.org/log4j/\'>\n\n  <appender name="stdout" class="org.apache.log4j.consoleappender">\n    <layout class="org.apache.log4j.patternlayout">\n      <param name="conversionpattern"\n             value="%d{yyyy-mm-dd hh:mm:ss,sss\\} [%-5p] [%t] %c{36\\}.%m - %m%n"/>\n    </layout>\n\n    \x3c!--过滤器设置输出的级别--\x3e\n    <filter class="org.apache.log4j.varia.levelrangefilter">\n      <param name="levelmin" value="debug"/>\n      <param name="levelmax" value="fatal"/>\n      <param name="acceptonmatch" value="true"/>\n    </filter>\n  </appender>\n\n\n  <appender name="all" class="org.apache.log4j.dailyrollingfileappender">\n    <param name="file" value="${user.dir}/logs/spring-common/jcl/all"/>\n    <param name="append" value="true"/>\n    \x3c!-- 每天重新生成日志文件 --\x3e\n    <param name="datepattern" value="\'-\'yyyy-mm-dd\'.log\'"/>\n    \x3c!-- 每小时重新生成日志文件 --\x3e\n    \x3c!--<param name="datepattern" value="\'-\'yyyy-mm-dd-hh\'.log\'"/>--\x3e\n    <layout class="org.apache.log4j.patternlayout">\n      <param name="conversionpattern"\n             value="%d{yyyy-mm-dd hh:mm:ss,sss\\} [%-5p] [%t] %c{36\\}.%m - %m%n"/>\n    </layout>\n  </appender>\n\n  \x3c!-- 指定logger的设置，additivity指示是否遵循缺省的继承机制--\x3e\n  <logger name="org.zp.notes.spring" additivity="false">\n    <level value="error"/>\n    <appender-ref ref="stdout"/>\n    <appender-ref ref="all"/>\n  </logger>\n\n  \x3c!-- 根logger的设置--\x3e\n  <root>\n    <level value="warn"/>\n    <appender-ref ref="stdout"/>\n  </root>\n</log4j:configuration>\n\n\n\n# 参考\n\n * slf4 官方文档\n * logback 官方文档\n * log4j 官方文档\n * commons-logging 官方文档\n * http://blog.csdn.net/yycdaizi/article/details/8276265',charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"javalib-util",frontmatter:{title:"javalib-util",date:"2022-02-17T22:34:30.000Z",order:2,categories:["Java","工具","其他"],tags:["Java","工具包"],permalink:"/pages/27ad42/"},regularPath:"/01.Java/12.%E5%B7%A5%E5%85%B7/99.%E5%85%B6%E4%BB%96/02.Java%E5%B7%A5%E5%85%B7%E5%8C%85.html",relativePath:"01.Java/12.工具/99.其他/02.Java工具包.md",key:"v-377147a2",path:"/pages/27ad42/",headersStr:null,content:"# 细说 Java 主流工具包\n\n * apache.commons\n   * commons-lang\n   * commons-collections\n   * common-io\n * guava",normalizedContent:"# 细说 java 主流工具包\n\n * apache.commons\n   * commons-lang\n   * commons-collections\n   * common-io\n * guava",charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Reflections 快速入门",frontmatter:{title:"Reflections 快速入门",date:"2022-02-17T22:34:30.000Z",order:3,categories:["Java","工具","其他"],tags:["Java","反射","Reflections"],permalink:"/pages/ce6195/"},regularPath:"/01.Java/12.%E5%B7%A5%E5%85%B7/99.%E5%85%B6%E4%BB%96/03.Reflections.html",relativePath:"01.Java/12.工具/99.其他/03.Reflections.md",key:"v-38be25ad",path:"/pages/ce6195/",headers:[{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:403},{level:2,title:"ReflectionUtils",slug:"reflectionutils",normalizedTitle:"reflectionutils",charIndex:2194}],headersStr:"使用 ReflectionUtils",content:'# Reflections 快速入门\n\n引入 pom\n\n<dependency>\n    <groupId>org.reflections</groupId>\n    <artifactId>reflections</artifactId>\n    <version>0.9.11</version>\n</dependency>\n\n\n典型应用\n\nReflections reflections = new Reflections("my.project");\nSet<Class<? extends SomeType>> subTypes = reflections.getSubTypesOf(SomeType.class);\nSet<Class<?>> annotated = reflections.getTypesAnnotatedWith(SomeAnnotation.class);\n\n\n\n# 使用\n\n基本上，使用 Reflections 首先使用 urls 和 scanners 对其进行实例化\n\n//scan urls that contain \'my.package\', include inputs starting with \'my.package\', use the default scanners\nReflections reflections = new Reflections("my.package");\n\n//or using ConfigurationBuilder\nnew Reflections(new ConfigurationBuilder()\n     .setUrls(ClasspathHelper.forPackage("my.project.prefix"))\n     .setScanners(new SubTypesScanner(),\n                  new TypeAnnotationsScanner().filterResultsBy(optionalFilter), ...),\n     .filterInputsBy(new FilterBuilder().includePackage("my.project.prefix"))\n     ...);\n\n\n然后，使用方便的查询方法\n\n// 子类型扫描\nSet<Class<? extends Module>> modules =\n    reflections.getSubTypesOf(com.google.inject.Module.class);\n// 类型注解扫描\nSet<Class<?>> singletons =\n    reflections.getTypesAnnotatedWith(javax.inject.Singleton.class);\n// 资源扫描\nSet<String> properties =\n    reflections.getResources(Pattern.compile(".*\\\\.properties"));\n// 方法注解扫描\nSet<Method> resources =\n    reflections.getMethodsAnnotatedWith(javax.ws.rs.Path.class);\nSet<Constructor> injectables =\n    reflections.getConstructorsAnnotatedWith(javax.inject.Inject.class);\n// 字段注解扫描\nSet<Field> ids =\n    reflections.getFieldsAnnotatedWith(javax.persistence.Id.class);\n// 方法参数扫描\nSet<Method> someMethods =\n    reflections.getMethodsMatchParams(long.class, int.class);\nSet<Method> voidMethods =\n    reflections.getMethodsReturn(void.class);\nSet<Method> pathParamMethods =\n    reflections.getMethodsWithAnyParamAnnotated(PathParam.class);\n// 方法参数名扫描\nList<String> parameterNames =\n    reflections.getMethodParamNames(Method.class)\n// 方法使用扫描\nSet<Member> usages =\n    reflections.getMethodUsages(Method.class)\n\n\n说明：\n\n * 如果未配置扫描程序，则将使用默认值 - SubTypesScanner 和 TypeAnnotationsScanner。\n * 还可以配置类加载器，它将用于从名称中解析运行时类。\n * Reflection 默认情况下会扩展超类型。 这解决了传输 URL 不被扫描的一些问题。\n\n\n# ReflectionUtils\n\nimport static org.reflections.ReflectionUtils.*;\n\nSet<Method> getters = getAllMethods(someClass,\n  withModifier(Modifier.PUBLIC), withPrefix("get"), withParametersCount(0));\n\n//or\nSet<Method> listMethodsFromCollectionToBoolean =\n  getAllMethods(List.class,\n    withParametersAssignableTo(Collection.class), withReturnType(boolean.class));\n\nSet<Field> fields = getAllFields(SomeClass.class, withAnnotation(annotation), withTypeAssignableTo(type));\n',normalizedContent:'# reflections 快速入门\n\n引入 pom\n\n<dependency>\n    <groupid>org.reflections</groupid>\n    <artifactid>reflections</artifactid>\n    <version>0.9.11</version>\n</dependency>\n\n\n典型应用\n\nreflections reflections = new reflections("my.project");\nset<class<? extends sometype>> subtypes = reflections.getsubtypesof(sometype.class);\nset<class<?>> annotated = reflections.gettypesannotatedwith(someannotation.class);\n\n\n\n# 使用\n\n基本上，使用 reflections 首先使用 urls 和 scanners 对其进行实例化\n\n//scan urls that contain \'my.package\', include inputs starting with \'my.package\', use the default scanners\nreflections reflections = new reflections("my.package");\n\n//or using configurationbuilder\nnew reflections(new configurationbuilder()\n     .seturls(classpathhelper.forpackage("my.project.prefix"))\n     .setscanners(new subtypesscanner(),\n                  new typeannotationsscanner().filterresultsby(optionalfilter), ...),\n     .filterinputsby(new filterbuilder().includepackage("my.project.prefix"))\n     ...);\n\n\n然后，使用方便的查询方法\n\n// 子类型扫描\nset<class<? extends module>> modules =\n    reflections.getsubtypesof(com.google.inject.module.class);\n// 类型注解扫描\nset<class<?>> singletons =\n    reflections.gettypesannotatedwith(javax.inject.singleton.class);\n// 资源扫描\nset<string> properties =\n    reflections.getresources(pattern.compile(".*\\\\.properties"));\n// 方法注解扫描\nset<method> resources =\n    reflections.getmethodsannotatedwith(javax.ws.rs.path.class);\nset<constructor> injectables =\n    reflections.getconstructorsannotatedwith(javax.inject.inject.class);\n// 字段注解扫描\nset<field> ids =\n    reflections.getfieldsannotatedwith(javax.persistence.id.class);\n// 方法参数扫描\nset<method> somemethods =\n    reflections.getmethodsmatchparams(long.class, int.class);\nset<method> voidmethods =\n    reflections.getmethodsreturn(void.class);\nset<method> pathparammethods =\n    reflections.getmethodswithanyparamannotated(pathparam.class);\n// 方法参数名扫描\nlist<string> parameternames =\n    reflections.getmethodparamnames(method.class)\n// 方法使用扫描\nset<member> usages =\n    reflections.getmethodusages(method.class)\n\n\n说明：\n\n * 如果未配置扫描程序，则将使用默认值 - subtypesscanner 和 typeannotationsscanner。\n * 还可以配置类加载器，它将用于从名称中解析运行时类。\n * reflection 默认情况下会扩展超类型。 这解决了传输 url 不被扫描的一些问题。\n\n\n# reflectionutils\n\nimport static org.reflections.reflectionutils.*;\n\nset<method> getters = getallmethods(someclass,\n  withmodifier(modifier.public), withprefix("get"), withparameterscount(0));\n\n//or\nset<method> listmethodsfromcollectiontoboolean =\n  getallmethods(list.class,\n    withparametersassignableto(collection.class), withreturntype(boolean.class));\n\nset<field> fields = getallfields(someclass.class, withannotation(annotation), withtypeassignableto(type));\n',charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"JavaMail 快速入门",frontmatter:{title:"JavaMail 快速入门",date:"2022-02-17T22:34:30.000Z",order:4,categories:["Java","工具","其他"],tags:["Java","邮件"],permalink:"/pages/cd38ec/"},regularPath:"/01.Java/12.%E5%B7%A5%E5%85%B7/99.%E5%85%B6%E4%BB%96/04.JavaMail.html",relativePath:"01.Java/12.工具/99.其他/04.JavaMail.md",key:"v-16dd06c5",path:"/pages/cd38ec/",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:20},{level:3,title:"邮件相关的标准",slug:"邮件相关的标准",normalizedTitle:"邮件相关的标准",charIndex:27},{level:3,title:"JavaMail 简介",slug:"javamail-简介",normalizedTitle:"javamail 简介",charIndex:458},{level:3,title:"邮件传输过程",slug:"邮件传输过程",normalizedTitle:"邮件传输过程",charIndex:780},{level:3,title:"Message 结构",slug:"message-结构",normalizedTitle:"message 结构",charIndex:1016},{level:2,title:"JavaMail 的核心类",slug:"javamail-的核心类",normalizedTitle:"javamail 的核心类",charIndex:1144},{level:3,title:"java.util.Properties 类（属性对象）",slug:"java-util-properties-类-属性对象",normalizedTitle:"java.util.properties 类（属性对象）",charIndex:1232},{level:3,title:"javax.mail.Session 类（会话对象）",slug:"javax-mail-session-类-会话对象",normalizedTitle:"javax.mail.session 类（会话对象）",charIndex:2117},{level:3,title:"javax.mail.Transport 类（邮件传输）",slug:"javax-mail-transport-类-邮件传输",normalizedTitle:"javax.mail.transport 类（邮件传输）",charIndex:2597},{level:3,title:"javax.mail.Store 类（邮件存储 ）",slug:"javax-mail-store-类-邮件存储",normalizedTitle:"javax.mail.store 类（邮件存储 ）",charIndex:3011},{level:3,title:"javax.mail.Message 类（消息对象）",slug:"javax-mail-message-类-消息对象",normalizedTitle:"javax.mail.message 类（消息对象）",charIndex:3292},{level:3,title:"javax.mail.Address 类（地址）",slug:"javax-mail-address-类-地址",normalizedTitle:"javax.mail.address 类（地址）",charIndex:3840},{level:3,title:"Authenticator 类（认证者）",slug:"authenticator-类-认证者",normalizedTitle:"authenticator 类（认证者）",charIndex:4102},{level:2,title:"实例",slug:"实例",normalizedTitle:"实例",charIndex:2301},{level:3,title:"发送文本邮件",slug:"发送文本邮件",normalizedTitle:"发送文本邮件",charIndex:4759},{level:3,title:"发送 HTML 格式的邮件",slug:"发送-html-格式的邮件",normalizedTitle:"发送 html 格式的邮件",charIndex:5899},{level:3,title:"发送带附件的邮件",slug:"发送带附件的邮件",normalizedTitle:"发送带附件的邮件",charIndex:7594},{level:3,title:"获取邮箱中的邮件",slug:"获取邮箱中的邮件",normalizedTitle:"获取邮箱中的邮件",charIndex:9240},{level:3,title:"转发邮件",slug:"转发邮件",normalizedTitle:"转发邮件",charIndex:10289}],headersStr:"简介 邮件相关的标准 JavaMail 简介 邮件传输过程 Message 结构 JavaMail 的核心类 java.util.Properties 类（属性对象） javax.mail.Session 类（会话对象） javax.mail.Transport 类（邮件传输） javax.mail.Store 类（邮件存储 ） javax.mail.Message 类（消息对象） javax.mail.Address 类（地址） Authenticator 类（认证者） 实例 发送文本邮件 发送 HTML 格式的邮件 发送带附件的邮件 获取邮箱中的邮件 转发邮件",content:'# JavaMail 快速入门\n\n\n# 简介\n\n\n# 邮件相关的标准\n\n厂商所提供的 JavaMail 服务程序可以有选择地实现某些邮件协议，常见的邮件协议包括：\n\n * SMTP(Simple Mail Transfer Protocol) ：即简单邮件传输协议，它是一组用于由源地址到目的地址传送邮件的规则，由它来控制信件的中转方式。\n * POP3(Post Office Protocol - Version 3) ：即邮局协议版本 3 ，用于接收电子邮件的标准协议。\n * IMAP(Internet Mail Access Protocol) ：即 Internet 邮件访问协议。是 POP3 的替代协议。\n\n这三种协议都有对应 SSL 加密传输的协议，分别是 SMTPS， POP3S和 IMAPS。\n\nMIME(Multipurpose Internet Mail Extensions) ：即多用途因特网邮件扩展标准。它不是邮件传输协议。但对传输内容的消息、附件及其它的内容定义了格式。\n\n\n# JavaMail 简介\n\nJavaMail 是由 Sun 发布的用来处理 email 的 API 。它并没有包含在 Java SE 中，而是作为 Java EE 的一部分。\n\n * mail.jar ：此 JAR 文件包含 JavaMail API 和 Sun 提供的 SMTP 、 IMAP 和 POP3 服务提供程序；\n * activation.jar ：此 JAR 文件包含 JAF API 和 Sun 的实现。\n\nJavaMail 包中用于处理电子邮件的核心类是： Properties 、 Session 、 Message 、 Address 、 Authenticator 、 Transport 、 Store 等。\n\n\n# 邮件传输过程\n\n如上图，电子邮件的处理步骤如下：\n\n 1. 创建一个 Session 对象。\n 2. Session 对象创建一个 Transport 对象 /Store 对象，用来发送 / 保存邮件。\n 3. Transport 对象 /Store 对象连接邮件服务器。\n 4. Transport 对象 /Store 对象创建一个 Message 对象 ( 也就是邮件内容 ) 。\n 5. Transport 对象发送邮件； Store 对象获取邮箱的邮件。\n\n\n# Message 结构\n\n * MimeMessage 类：代表整封邮件。\n * MimeBodyPart 类：代表邮件的一个 MIME 信息。\n * MimeMultipart 类：代表一个由多个 MIME 信息组合成的组合 MIME 信息。\n\n\n\n\n# JavaMail 的核心类\n\nJavaMail 对收发邮件进行了高级的抽象，形成了一些关键的的接口和类，它们构成了程序的基础，下面我们分别来了解一下这些最常见的对象。\n\n\n# java.util.Properties 类（属性对象）\n\njava.util.Properties 类代表一组属性集合。\n\n它的每一个键和值都是 String 类型。\n\n由于 JavaMail 需要和邮件服务器进行通信，这就要求程序提供许多诸如服务器地址、端口、用户名、密码等信息， JavaMail 通过 Properties 对象封装这些属性信息。\n\n例： 如下面的代码封装了几个属性信息：\n\nProperties prop = new Properties();\nprop.setProperty("mail.debug", "true");\nprop.setProperty("mail.host", "[email protected]");\nprop.setProperty("mail.transport.protocol", "smtp");\nprop.setProperty("mail.smtp.auth", "true");\n\n\n针对不同的的邮件协议， JavaMail 规定了服务提供者必须支持一系列属性，\n\n下表是一些常见属性（属性值都以 String 类型进行设置，属性类型栏仅表示属性是如何被解析的）：\n\n关键词                       类型        描述\nmail.debug                boolean   debug 开关。\nmail.host                 String    指定发送、接收邮件的默认邮箱服务器。\nmail.store.protocol       String    指定接收邮件的协议。\nmail.transport.protocol   String    指定发送邮件的协议。\nmail.debug.auth           boolean   debug 输出中是否包含认证命令。默认是 false 。\n\n详情请参考官方 API 文档：\n\nhttps://javamail.java.net/nonav/docs/api/ 。\n\n\n# javax.mail.Session 类（会话对象）\n\nSession 表示一个邮件会话。\n\nSession 的主要作用包括两个方面：\n\n * 接收各种配置属性信息：通过 Properties 对象设置的属性信息；\n * 初始化 JavaMail 环境：根据 JavaMail 的配置文件，初始化 JavaMail 环境，以便通过 Session 对象创建其他重要类的实例。\n\nJavaMail 在 Jar 包的 META-INF 目录下，通过以下文件提供了基本配置信息，以便 session 能够根据这个配置文件加载提供者的实现类：\n\n * javamail.default.providers\n * javamail.default.address.map\n\n\n\n例：\n\nProperties props = new Properties();\nprops.setProperty("mail.transport.protocol", "smtp");\nSession session = Session.getInstance(props);\n\n\n\n# javax.mail.Transport 类（邮件传输）\n\n邮件操作只有发送或接收两种处理方式。\n\nJavaMail 将这两种不同操作描述为传输（ javax.mail.Transport ）和存储（ javax.mail.Store ），传输对应邮件的发送，而存储对应邮件的接收。\n\n * getTransport - Session 类中的 **getTransport()**有多个重载方法，可以用来创建 Transport 对象。\n * connect - 如果设置了认证命令—— mail.smtp.auth ，那么使用 Transport 类的 connect 方法连接服务器时，则必须加上用户名和密码。\n * sendMessage - Transport 类的 sendMessage 方法用来发送邮件消息。\n * close - Transport 类的 close 方法用来关闭和邮件服务器的连接。\n\n\n# javax.mail.Store 类（邮件存储 ）\n\n * getStore - Session 类中的 getStore () 有多个重载方法，可以用来创建 Store 对象。\n * connect - 如果设置了认证命令—— mail.smtp.auth ，那么使用 Store 类的 connect 方法连接服务器时，则必须加上用户名和密码。\n * getFolder - Store 类的 getFolder 方法可以 获取邮箱内的邮件夹 Folder 对象\n * close - Store 类的 close 方法用来关闭和邮件服务器的连接。\n\n\n# javax.mail.Message 类（消息对象）\n\n * javax.mail.Message - 是个抽象类，只能用子类去实例化，多数情况下为 javax.mail.internet.MimeMessage。\n * MimeMessage - 代表 MIME 类型的电子邮件消息。\n\n要创建一个 Message ，需要将 Session 对象传递给 MimeMessage 构造器：\n\nMimeMessage message = new MimeMessage(session);\n\n\n注意：还存在其它构造器，如用按 RFC822 格式的输入流来创建消息。\n\n * setFrom - 设置邮件的发件人\n * setRecipient - 设置邮件的发送人、抄送人、密送人\n\n三种预定义的地址类型是：\n\n * Message.RecipientType.TO - 收件人\n * Message.RecipientType.CC - 抄送人\n * Message.RecipientType.BCC - 密送人\n * setSubject - 设置邮件的主题\n * setContent - 设置邮件内容\n * setText - 如果邮件内容是纯文本，可以使用此接口设置文本内容。\n\n\n# javax.mail.Address 类（地址）\n\n一旦您创建了 Session 和 Message ，并将内容填入消息后，就可以用 Address 确定信件地址了。和 Message 一样， Address 也是个抽象类。您用的是 javax.mail.internet.InternetAddress 类。\n\n若创建的地址只包含电子邮件地址，只要传递电子邮件地址到构造器就行了。\n\n例：\n\nAddress address = new InternetAddress("[email protected]");\n\n\n\n# Authenticator 类（认证者）\n\n与 java.net 类一样， JavaMail API 也可以利用 Authenticator 通过用户名和密码访问受保护的资源。对于 JavaMail API 来说，这些资源就是邮件服务器。Authenticator 在 javax.mail 包中，而且它和 java.net 中同名的类 Authenticator 不同。两者并不共享同一个 Authenticator ，因为 JavaMail API 用于 Java 1.1 ，它没有 java.net 类别。\n\n要使用 Authenticator ，先创建一个抽象类的子类，并从 getPasswordAuthentication() 方法中返回 PasswordAuthentication 实例。创建完成后，您必需向 session 注册 Authenticator 。然后，在需要认证的时候，就会通知 Authenticator 。您可以弹出窗口，也可以从配置文件中（虽然没有加密是不安全的）读取用户名和密码，将它们作为 PasswordAuthentication 对象返回给调用程序。\n\n例：\n\nProperties props = new Properties();\nAuthenticator auth = new MyAuthenticator();\nSession session = Session.getDefaultInstance(props, auth);\n\n\n\n# 实例\n\n\n# 发送文本邮件\n\npublic static void main(String[] args) throws Exception {\n    Properties prop = new Properties();\n    prop.setProperty("mail.debug", "true");\n    prop.setProperty("mail.host", MAIL_SERVER_HOST);\n    prop.setProperty("mail.transport.protocol", "smtp");\n    prop.setProperty("mail.smtp.auth", "true");\n\n    // 1、创建session\n    Session session = Session.getInstance(prop);\n    Transport ts = null;\n\n    // 2、通过session得到transport对象\n    ts = session.getTransport();\n\n    // 3、连上邮件服务器\n    ts.connect(MAIL_SERVER_HOST, USER, PASSWORD);\n\n    // 4、创建邮件\n    MimeMessage message = new MimeMessage(session);\n\n    // 邮件消息头\n    message.setFrom(new InternetAddress(MAIL_FROM)); // 邮件的发件人\n    message.setRecipient(Message.RecipientType.TO, new InternetAddress(MAIL_TO)); // 邮件的收件人\n    message.setRecipient(Message.RecipientType.CC, new InternetAddress(MAIL_CC)); // 邮件的抄送人\n    message.setRecipient(Message.RecipientType.BCC, new InternetAddress(MAIL_BCC)); // 邮件的密送人\n    message.setSubject("测试文本邮件"); // 邮件的标题\n\n    // 邮件消息体\n    message.setText("天下无双。");\n\n    // 5、发送邮件\n    ts.sendMessage(message, message.getAllRecipients());\n    ts.close();\n}\n\n\n\n# 发送 HTML 格式的邮件\n\npublic static void main(String[] args) throws Exception {\n    Properties prop = new Properties();\n    prop.setProperty("mail.debug", "true");\n    prop.setProperty("mail.host", MAIL_SERVER_HOST);\n    prop.setProperty("mail.transport.protocol", "smtp");\n    prop.setProperty("mail.smtp.auth", "true");\n\n    // 1、创建session\n    Session session = Session.getInstance(prop);\n    Transport ts = null;\n\n    // 2、通过session得到transport对象\n    ts = session.getTransport();\n\n    // 3、连上邮件服务器\n    ts.connect(MAIL_SERVER_HOST, USER, PASSWORD);\n\n    // 4、创建邮件\n    MimeMessage message = new MimeMessage(session);\n\n    // 邮件消息头\n    message.setFrom(new InternetAddress(MAIL_FROM)); // 邮件的发件人\n    message.setRecipient(Message.RecipientType.TO, new InternetAddress(MAIL_TO)); // 邮件的收件人\n    message.setRecipient(Message.RecipientType.CC, new InternetAddress(MAIL_CC)); // 邮件的抄送人\n    message.setRecipient(Message.RecipientType.BCC, new InternetAddress(MAIL_BCC)); // 邮件的密送人\n    message.setSubject("测试HTML邮件"); // 邮件的标题\n\n    String htmlContent = "<h1>Hello</h1>" + "<p>显示图片<img src=\'cid:abc.jpg\'>1.jpg</p>";\n    MimeBodyPart text = new MimeBodyPart();\n    text.setContent(htmlContent, "text/html;charset=UTF-8");\n    MimeBodyPart image = new MimeBodyPart();\n    DataHandler dh = new DataHandler(new FileDataSource("D:\\\\05_Datas\\\\图库\\\\吉他少年背影.png"));\n    image.setDataHandler(dh);\n    image.setContentID("abc.jpg");\n\n    // 描述数据关系\n    MimeMultipart mm = new MimeMultipart();\n    mm.addBodyPart(text);\n    mm.addBodyPart(image);\n    mm.setSubType("related");\n    message.setContent(mm);\n    message.saveChanges();\n\n    // 5、发送邮件\n    ts.sendMessage(message, message.getAllRecipients());\n    ts.close();\n}\n\n\n\n# 发送带附件的邮件\n\npublic static void main(String[] args) throws Exception {\n    Properties prop = new Properties();\n    prop.setProperty("mail.debug", "true");\n    prop.setProperty("mail.host", MAIL_SERVER_HOST);\n    prop.setProperty("mail.transport.protocol", "smtp");\n    prop.setProperty("mail.smtp.auth", "true");\n\n    // 1、创建session\n    Session session = Session.getInstance(prop);\n\n    // 2、通过session得到transport对象\n    Transport ts = session.getTransport();\n\n    // 3、连上邮件服务器\n    ts.connect(MAIL_SERVER_HOST, USER, PASSWORD);\n\n    // 4、创建邮件\n    MimeMessage message = new MimeMessage(session);\n\n    // 邮件消息头\n    message.setFrom(new InternetAddress(MAIL_FROM)); // 邮件的发件人\n    message.setRecipient(Message.RecipientType.TO, new InternetAddress(MAIL_TO)); // 邮件的收件人\n    message.setRecipient(Message.RecipientType.CC, new InternetAddress(MAIL_CC)); // 邮件的抄送人\n    message.setRecipient(Message.RecipientType.BCC, new InternetAddress(MAIL_BCC)); // 邮件的密送人\n    message.setSubject("测试带附件邮件"); // 邮件的标题\n\n    MimeBodyPart text = new MimeBodyPart();\n    text.setContent("邮件中有两个附件。", "text/html;charset=UTF-8");\n\n    // 描述数据关系\n    MimeMultipart mm = new MimeMultipart();\n    mm.setSubType("related");\n    mm.addBodyPart(text);\n    String[] files = {\n            "D:\\\\00_Temp\\\\temp\\\\1.jpg", "D:\\\\00_Temp\\\\temp\\\\2.png"\n    };\n\n    // 添加邮件附件\n    for (String filename : files) {\n        MimeBodyPart attachPart = new MimeBodyPart();\n        attachPart.attachFile(filename);\n        mm.addBodyPart(attachPart);\n    }\n\n    message.setContent(mm);\n    message.saveChanges();\n\n    // 5、发送邮件\n    ts.sendMessage(message, message.getAllRecipients());\n    ts.close();\n}\n\n\n\n# 获取邮箱中的邮件\n\n public static void main(String[] args) throws Exception {\n\n    // 创建一个有具体连接信息的Properties对象\n    Properties prop = new Properties();\n    prop.setProperty("mail.debug", "true");\n    prop.setProperty("mail.store.protocol", "pop3");\n    prop.setProperty("mail.pop3.host", MAIL_SERVER_HOST);\n\n    // 1、创建session\n    Session session = Session.getInstance(prop);\n\n    // 2、通过session得到Store对象\n    Store store = session.getStore();\n\n    // 3、连上邮件服务器\n    store.connect(MAIL_SERVER_HOST, USER, PASSWORD);\n\n    // 4、获得邮箱内的邮件夹\n    Folder folder = store.getFolder("inbox");\n    folder.open(Folder.READ_ONLY);\n\n    // 获得邮件夹Folder内的所有邮件Message对象\n    Message[] messages = folder.getMessages();\n    for (int i = 0; i < messages.length; i++) {\n        String subject = messages[i].getSubject();\n        String from = (messages[i].getFrom()[0]).toString();\n        System.out.println("第 " + (i + 1) + "封邮件的主题：" + subject);\n        System.out.println("第 " + (i + 1) + "封邮件的发件人地址：" + from);\n    }\n\n    // 5、关闭\n    folder.close(false);\n    store.close();\n}\n\n\n\n# 转发邮件\n\n例：获取指定邮件夹下的第一封邮件并转发\n\n public static void main(String[] args) throws Exception {\n    Properties prop = new Properties();\n    prop.put("mail.store.protocol", "pop3");\n    prop.put("mail.pop3.host", MAIL_SERVER_POP3);\n    prop.put("mail.pop3.starttls.enable", "true");\n    prop.put("mail.smtp.auth", "true");\n    prop.put("mail.smtp.host", MAIL_SERVER_SMTP);\n\n    // 1、创建session\n    Session session = Session.getDefaultInstance(prop);\n\n    // 2、读取邮件夹\n    Store store = session.getStore("pop3");\n    store.connect(MAIL_SERVER_POP3, USER, PASSWORD);\n    Folder folder = store.getFolder("inbox");\n    folder.open(Folder.READ_ONLY);\n\n    // 获取邮件夹中第1封邮件信息\n    Message[] messages = folder.getMessages();\n    if (messages.length <= 0) {\n        return;\n    }\n    Message message = messages[0];\n\n    // 打印邮件关键信息\n    String from = InternetAddress.toString(message.getFrom());\n    if (from != null) {\n        System.out.println("From: " + from);\n    }\n\n    String replyTo = InternetAddress.toString(message.getReplyTo());\n    if (replyTo != null) {\n        System.out.println("Reply-to: " + replyTo);\n    }\n\n    String to = InternetAddress.toString(message.getRecipients(Message.RecipientType.TO));\n    if (to != null) {\n        System.out.println("To: " + to);\n    }\n\n    String subject = message.getSubject();\n    if (subject != null) {\n        System.out.println("Subject: " + subject);\n    }\n\n    Date sent = message.getSentDate();\n    if (sent != null) {\n        System.out.println("Sent: " + sent);\n    }\n\n    // 设置转发邮件信息头\n    Message forward = new MimeMessage(session);\n    forward.setFrom(new InternetAddress(MAIL_FROM));\n    forward.setRecipient(Message.RecipientType.TO, new InternetAddress(MAIL_TO));\n    forward.setSubject("Fwd: " + message.getSubject());\n\n    // 设置转发邮件内容\n    MimeBodyPart bodyPart = new MimeBodyPart();\n    bodyPart.setContent(message, "message/rfc822");\n\n    Multipart multipart = new MimeMultipart();\n    multipart.addBodyPart(bodyPart);\n    forward.setContent(multipart);\n    forward.saveChanges();\n\n    Transport ts = session.getTransport("smtp");\n    ts.connect(USER, PASSWORD);\n    ts.sendMessage(forward, forward.getAllRecipients());\n\n    folder.close(false);\n    store.close();\n    ts.close();\n    System.out.println("message forwarded successfully....");\n}\n',normalizedContent:'# javamail 快速入门\n\n\n# 简介\n\n\n# 邮件相关的标准\n\n厂商所提供的 javamail 服务程序可以有选择地实现某些邮件协议，常见的邮件协议包括：\n\n * smtp(simple mail transfer protocol) ：即简单邮件传输协议，它是一组用于由源地址到目的地址传送邮件的规则，由它来控制信件的中转方式。\n * pop3(post office protocol - version 3) ：即邮局协议版本 3 ，用于接收电子邮件的标准协议。\n * imap(internet mail access protocol) ：即 internet 邮件访问协议。是 pop3 的替代协议。\n\n这三种协议都有对应 ssl 加密传输的协议，分别是 smtps， pop3s和 imaps。\n\nmime(multipurpose internet mail extensions) ：即多用途因特网邮件扩展标准。它不是邮件传输协议。但对传输内容的消息、附件及其它的内容定义了格式。\n\n\n# javamail 简介\n\njavamail 是由 sun 发布的用来处理 email 的 api 。它并没有包含在 java se 中，而是作为 java ee 的一部分。\n\n * mail.jar ：此 jar 文件包含 javamail api 和 sun 提供的 smtp 、 imap 和 pop3 服务提供程序；\n * activation.jar ：此 jar 文件包含 jaf api 和 sun 的实现。\n\njavamail 包中用于处理电子邮件的核心类是： properties 、 session 、 message 、 address 、 authenticator 、 transport 、 store 等。\n\n\n# 邮件传输过程\n\n如上图，电子邮件的处理步骤如下：\n\n 1. 创建一个 session 对象。\n 2. session 对象创建一个 transport 对象 /store 对象，用来发送 / 保存邮件。\n 3. transport 对象 /store 对象连接邮件服务器。\n 4. transport 对象 /store 对象创建一个 message 对象 ( 也就是邮件内容 ) 。\n 5. transport 对象发送邮件； store 对象获取邮箱的邮件。\n\n\n# message 结构\n\n * mimemessage 类：代表整封邮件。\n * mimebodypart 类：代表邮件的一个 mime 信息。\n * mimemultipart 类：代表一个由多个 mime 信息组合成的组合 mime 信息。\n\n\n\n\n# javamail 的核心类\n\njavamail 对收发邮件进行了高级的抽象，形成了一些关键的的接口和类，它们构成了程序的基础，下面我们分别来了解一下这些最常见的对象。\n\n\n# java.util.properties 类（属性对象）\n\njava.util.properties 类代表一组属性集合。\n\n它的每一个键和值都是 string 类型。\n\n由于 javamail 需要和邮件服务器进行通信，这就要求程序提供许多诸如服务器地址、端口、用户名、密码等信息， javamail 通过 properties 对象封装这些属性信息。\n\n例： 如下面的代码封装了几个属性信息：\n\nproperties prop = new properties();\nprop.setproperty("mail.debug", "true");\nprop.setproperty("mail.host", "[email protected]");\nprop.setproperty("mail.transport.protocol", "smtp");\nprop.setproperty("mail.smtp.auth", "true");\n\n\n针对不同的的邮件协议， javamail 规定了服务提供者必须支持一系列属性，\n\n下表是一些常见属性（属性值都以 string 类型进行设置，属性类型栏仅表示属性是如何被解析的）：\n\n关键词                       类型        描述\nmail.debug                boolean   debug 开关。\nmail.host                 string    指定发送、接收邮件的默认邮箱服务器。\nmail.store.protocol       string    指定接收邮件的协议。\nmail.transport.protocol   string    指定发送邮件的协议。\nmail.debug.auth           boolean   debug 输出中是否包含认证命令。默认是 false 。\n\n详情请参考官方 api 文档：\n\nhttps://javamail.java.net/nonav/docs/api/ 。\n\n\n# javax.mail.session 类（会话对象）\n\nsession 表示一个邮件会话。\n\nsession 的主要作用包括两个方面：\n\n * 接收各种配置属性信息：通过 properties 对象设置的属性信息；\n * 初始化 javamail 环境：根据 javamail 的配置文件，初始化 javamail 环境，以便通过 session 对象创建其他重要类的实例。\n\njavamail 在 jar 包的 meta-inf 目录下，通过以下文件提供了基本配置信息，以便 session 能够根据这个配置文件加载提供者的实现类：\n\n * javamail.default.providers\n * javamail.default.address.map\n\n\n\n例：\n\nproperties props = new properties();\nprops.setproperty("mail.transport.protocol", "smtp");\nsession session = session.getinstance(props);\n\n\n\n# javax.mail.transport 类（邮件传输）\n\n邮件操作只有发送或接收两种处理方式。\n\njavamail 将这两种不同操作描述为传输（ javax.mail.transport ）和存储（ javax.mail.store ），传输对应邮件的发送，而存储对应邮件的接收。\n\n * gettransport - session 类中的 **gettransport()**有多个重载方法，可以用来创建 transport 对象。\n * connect - 如果设置了认证命令—— mail.smtp.auth ，那么使用 transport 类的 connect 方法连接服务器时，则必须加上用户名和密码。\n * sendmessage - transport 类的 sendmessage 方法用来发送邮件消息。\n * close - transport 类的 close 方法用来关闭和邮件服务器的连接。\n\n\n# javax.mail.store 类（邮件存储 ）\n\n * getstore - session 类中的 getstore () 有多个重载方法，可以用来创建 store 对象。\n * connect - 如果设置了认证命令—— mail.smtp.auth ，那么使用 store 类的 connect 方法连接服务器时，则必须加上用户名和密码。\n * getfolder - store 类的 getfolder 方法可以 获取邮箱内的邮件夹 folder 对象\n * close - store 类的 close 方法用来关闭和邮件服务器的连接。\n\n\n# javax.mail.message 类（消息对象）\n\n * javax.mail.message - 是个抽象类，只能用子类去实例化，多数情况下为 javax.mail.internet.mimemessage。\n * mimemessage - 代表 mime 类型的电子邮件消息。\n\n要创建一个 message ，需要将 session 对象传递给 mimemessage 构造器：\n\nmimemessage message = new mimemessage(session);\n\n\n注意：还存在其它构造器，如用按 rfc822 格式的输入流来创建消息。\n\n * setfrom - 设置邮件的发件人\n * setrecipient - 设置邮件的发送人、抄送人、密送人\n\n三种预定义的地址类型是：\n\n * message.recipienttype.to - 收件人\n * message.recipienttype.cc - 抄送人\n * message.recipienttype.bcc - 密送人\n * setsubject - 设置邮件的主题\n * setcontent - 设置邮件内容\n * settext - 如果邮件内容是纯文本，可以使用此接口设置文本内容。\n\n\n# javax.mail.address 类（地址）\n\n一旦您创建了 session 和 message ，并将内容填入消息后，就可以用 address 确定信件地址了。和 message 一样， address 也是个抽象类。您用的是 javax.mail.internet.internetaddress 类。\n\n若创建的地址只包含电子邮件地址，只要传递电子邮件地址到构造器就行了。\n\n例：\n\naddress address = new internetaddress("[email protected]");\n\n\n\n# authenticator 类（认证者）\n\n与 java.net 类一样， javamail api 也可以利用 authenticator 通过用户名和密码访问受保护的资源。对于 javamail api 来说，这些资源就是邮件服务器。authenticator 在 javax.mail 包中，而且它和 java.net 中同名的类 authenticator 不同。两者并不共享同一个 authenticator ，因为 javamail api 用于 java 1.1 ，它没有 java.net 类别。\n\n要使用 authenticator ，先创建一个抽象类的子类，并从 getpasswordauthentication() 方法中返回 passwordauthentication 实例。创建完成后，您必需向 session 注册 authenticator 。然后，在需要认证的时候，就会通知 authenticator 。您可以弹出窗口，也可以从配置文件中（虽然没有加密是不安全的）读取用户名和密码，将它们作为 passwordauthentication 对象返回给调用程序。\n\n例：\n\nproperties props = new properties();\nauthenticator auth = new myauthenticator();\nsession session = session.getdefaultinstance(props, auth);\n\n\n\n# 实例\n\n\n# 发送文本邮件\n\npublic static void main(string[] args) throws exception {\n    properties prop = new properties();\n    prop.setproperty("mail.debug", "true");\n    prop.setproperty("mail.host", mail_server_host);\n    prop.setproperty("mail.transport.protocol", "smtp");\n    prop.setproperty("mail.smtp.auth", "true");\n\n    // 1、创建session\n    session session = session.getinstance(prop);\n    transport ts = null;\n\n    // 2、通过session得到transport对象\n    ts = session.gettransport();\n\n    // 3、连上邮件服务器\n    ts.connect(mail_server_host, user, password);\n\n    // 4、创建邮件\n    mimemessage message = new mimemessage(session);\n\n    // 邮件消息头\n    message.setfrom(new internetaddress(mail_from)); // 邮件的发件人\n    message.setrecipient(message.recipienttype.to, new internetaddress(mail_to)); // 邮件的收件人\n    message.setrecipient(message.recipienttype.cc, new internetaddress(mail_cc)); // 邮件的抄送人\n    message.setrecipient(message.recipienttype.bcc, new internetaddress(mail_bcc)); // 邮件的密送人\n    message.setsubject("测试文本邮件"); // 邮件的标题\n\n    // 邮件消息体\n    message.settext("天下无双。");\n\n    // 5、发送邮件\n    ts.sendmessage(message, message.getallrecipients());\n    ts.close();\n}\n\n\n\n# 发送 html 格式的邮件\n\npublic static void main(string[] args) throws exception {\n    properties prop = new properties();\n    prop.setproperty("mail.debug", "true");\n    prop.setproperty("mail.host", mail_server_host);\n    prop.setproperty("mail.transport.protocol", "smtp");\n    prop.setproperty("mail.smtp.auth", "true");\n\n    // 1、创建session\n    session session = session.getinstance(prop);\n    transport ts = null;\n\n    // 2、通过session得到transport对象\n    ts = session.gettransport();\n\n    // 3、连上邮件服务器\n    ts.connect(mail_server_host, user, password);\n\n    // 4、创建邮件\n    mimemessage message = new mimemessage(session);\n\n    // 邮件消息头\n    message.setfrom(new internetaddress(mail_from)); // 邮件的发件人\n    message.setrecipient(message.recipienttype.to, new internetaddress(mail_to)); // 邮件的收件人\n    message.setrecipient(message.recipienttype.cc, new internetaddress(mail_cc)); // 邮件的抄送人\n    message.setrecipient(message.recipienttype.bcc, new internetaddress(mail_bcc)); // 邮件的密送人\n    message.setsubject("测试html邮件"); // 邮件的标题\n\n    string htmlcontent = "<h1>hello</h1>" + "<p>显示图片<img src=\'cid:abc.jpg\'>1.jpg</p>";\n    mimebodypart text = new mimebodypart();\n    text.setcontent(htmlcontent, "text/html;charset=utf-8");\n    mimebodypart image = new mimebodypart();\n    datahandler dh = new datahandler(new filedatasource("d:\\\\05_datas\\\\图库\\\\吉他少年背影.png"));\n    image.setdatahandler(dh);\n    image.setcontentid("abc.jpg");\n\n    // 描述数据关系\n    mimemultipart mm = new mimemultipart();\n    mm.addbodypart(text);\n    mm.addbodypart(image);\n    mm.setsubtype("related");\n    message.setcontent(mm);\n    message.savechanges();\n\n    // 5、发送邮件\n    ts.sendmessage(message, message.getallrecipients());\n    ts.close();\n}\n\n\n\n# 发送带附件的邮件\n\npublic static void main(string[] args) throws exception {\n    properties prop = new properties();\n    prop.setproperty("mail.debug", "true");\n    prop.setproperty("mail.host", mail_server_host);\n    prop.setproperty("mail.transport.protocol", "smtp");\n    prop.setproperty("mail.smtp.auth", "true");\n\n    // 1、创建session\n    session session = session.getinstance(prop);\n\n    // 2、通过session得到transport对象\n    transport ts = session.gettransport();\n\n    // 3、连上邮件服务器\n    ts.connect(mail_server_host, user, password);\n\n    // 4、创建邮件\n    mimemessage message = new mimemessage(session);\n\n    // 邮件消息头\n    message.setfrom(new internetaddress(mail_from)); // 邮件的发件人\n    message.setrecipient(message.recipienttype.to, new internetaddress(mail_to)); // 邮件的收件人\n    message.setrecipient(message.recipienttype.cc, new internetaddress(mail_cc)); // 邮件的抄送人\n    message.setrecipient(message.recipienttype.bcc, new internetaddress(mail_bcc)); // 邮件的密送人\n    message.setsubject("测试带附件邮件"); // 邮件的标题\n\n    mimebodypart text = new mimebodypart();\n    text.setcontent("邮件中有两个附件。", "text/html;charset=utf-8");\n\n    // 描述数据关系\n    mimemultipart mm = new mimemultipart();\n    mm.setsubtype("related");\n    mm.addbodypart(text);\n    string[] files = {\n            "d:\\\\00_temp\\\\temp\\\\1.jpg", "d:\\\\00_temp\\\\temp\\\\2.png"\n    };\n\n    // 添加邮件附件\n    for (string filename : files) {\n        mimebodypart attachpart = new mimebodypart();\n        attachpart.attachfile(filename);\n        mm.addbodypart(attachpart);\n    }\n\n    message.setcontent(mm);\n    message.savechanges();\n\n    // 5、发送邮件\n    ts.sendmessage(message, message.getallrecipients());\n    ts.close();\n}\n\n\n\n# 获取邮箱中的邮件\n\n public static void main(string[] args) throws exception {\n\n    // 创建一个有具体连接信息的properties对象\n    properties prop = new properties();\n    prop.setproperty("mail.debug", "true");\n    prop.setproperty("mail.store.protocol", "pop3");\n    prop.setproperty("mail.pop3.host", mail_server_host);\n\n    // 1、创建session\n    session session = session.getinstance(prop);\n\n    // 2、通过session得到store对象\n    store store = session.getstore();\n\n    // 3、连上邮件服务器\n    store.connect(mail_server_host, user, password);\n\n    // 4、获得邮箱内的邮件夹\n    folder folder = store.getfolder("inbox");\n    folder.open(folder.read_only);\n\n    // 获得邮件夹folder内的所有邮件message对象\n    message[] messages = folder.getmessages();\n    for (int i = 0; i < messages.length; i++) {\n        string subject = messages[i].getsubject();\n        string from = (messages[i].getfrom()[0]).tostring();\n        system.out.println("第 " + (i + 1) + "封邮件的主题：" + subject);\n        system.out.println("第 " + (i + 1) + "封邮件的发件人地址：" + from);\n    }\n\n    // 5、关闭\n    folder.close(false);\n    store.close();\n}\n\n\n\n# 转发邮件\n\n例：获取指定邮件夹下的第一封邮件并转发\n\n public static void main(string[] args) throws exception {\n    properties prop = new properties();\n    prop.put("mail.store.protocol", "pop3");\n    prop.put("mail.pop3.host", mail_server_pop3);\n    prop.put("mail.pop3.starttls.enable", "true");\n    prop.put("mail.smtp.auth", "true");\n    prop.put("mail.smtp.host", mail_server_smtp);\n\n    // 1、创建session\n    session session = session.getdefaultinstance(prop);\n\n    // 2、读取邮件夹\n    store store = session.getstore("pop3");\n    store.connect(mail_server_pop3, user, password);\n    folder folder = store.getfolder("inbox");\n    folder.open(folder.read_only);\n\n    // 获取邮件夹中第1封邮件信息\n    message[] messages = folder.getmessages();\n    if (messages.length <= 0) {\n        return;\n    }\n    message message = messages[0];\n\n    // 打印邮件关键信息\n    string from = internetaddress.tostring(message.getfrom());\n    if (from != null) {\n        system.out.println("from: " + from);\n    }\n\n    string replyto = internetaddress.tostring(message.getreplyto());\n    if (replyto != null) {\n        system.out.println("reply-to: " + replyto);\n    }\n\n    string to = internetaddress.tostring(message.getrecipients(message.recipienttype.to));\n    if (to != null) {\n        system.out.println("to: " + to);\n    }\n\n    string subject = message.getsubject();\n    if (subject != null) {\n        system.out.println("subject: " + subject);\n    }\n\n    date sent = message.getsentdate();\n    if (sent != null) {\n        system.out.println("sent: " + sent);\n    }\n\n    // 设置转发邮件信息头\n    message forward = new mimemessage(session);\n    forward.setfrom(new internetaddress(mail_from));\n    forward.setrecipient(message.recipienttype.to, new internetaddress(mail_to));\n    forward.setsubject("fwd: " + message.getsubject());\n\n    // 设置转发邮件内容\n    mimebodypart bodypart = new mimebodypart();\n    bodypart.setcontent(message, "message/rfc822");\n\n    multipart multipart = new mimemultipart();\n    multipart.addbodypart(bodypart);\n    forward.setcontent(multipart);\n    forward.savechanges();\n\n    transport ts = session.gettransport("smtp");\n    ts.connect(user, password);\n    ts.sendmessage(forward, forward.getallrecipients());\n\n    folder.close(false);\n    store.close();\n    ts.close();\n    system.out.println("message forwarded successfully....");\n}\n',charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Jsoup 快速入门",frontmatter:{title:"Jsoup 快速入门",date:"2022-02-17T22:34:30.000Z",order:5,categories:["Java","工具","其他"],tags:["Java","Html","Jsoup"],permalink:"/pages/5dd78d/"},regularPath:"/01.Java/12.%E5%B7%A5%E5%85%B7/99.%E5%85%B6%E4%BB%96/05.Jsoup.html",relativePath:"01.Java/12.工具/99.其他/05.Jsoup.md",key:"v-4feafdf7",path:"/pages/5dd78d/",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:17},{level:2,title:"加载",slug:"加载",normalizedTitle:"加载",charIndex:175},{level:3,title:"从 HTML 字符串加载一个文档",slug:"从-html-字符串加载一个文档",normalizedTitle:"从 html 字符串加载一个文档",charIndex:288},{level:3,title:"解析一个 body 片断",slug:"解析一个-body-片断",normalizedTitle:"解析一个 body 片断",charIndex:865},{level:4,title:"保证安全 Stay safe",slug:"保证安全-stay-safe",normalizedTitle:"保证安全 stay safe",charIndex:1408},{level:3,title:"从 URL 加载一个文档",slug:"从-url-加载一个文档",normalizedTitle:"从 url 加载一个文档",charIndex:1541},{level:3,title:"从一个文件加载一个文档",slug:"从一个文件加载一个文档",normalizedTitle:"从一个文件加载一个文档",charIndex:1967},{level:2,title:"解析",slug:"解析",normalizedTitle:"解析",charIndex:43},{level:3,title:"使用 DOM 方法来遍历一个文档",slug:"使用-dom-方法来遍历一个文档",normalizedTitle:"使用 dom 方法来遍历一个文档",charIndex:2456},{level:4,title:"查找元素",slug:"查找元素",normalizedTitle:"查找元素",charIndex:2919},{level:4,title:"元素数据",slug:"元素数据",normalizedTitle:"元素数据",charIndex:3296},{level:4,title:"操作 HTML 和文本",slug:"操作-html-和文本",normalizedTitle:"操作 html 和文本",charIndex:3605},{level:3,title:"使用选择器语法来查找元素",slug:"使用选择器语法来查找元素",normalizedTitle:"使用选择器语法来查找元素",charIndex:3807},{level:4,title:"Selector 选择器概述",slug:"selector-选择器概述",normalizedTitle:"selector 选择器概述",charIndex:4520},{level:4,title:"Selector 选择器组合使用",slug:"selector-选择器组合使用",normalizedTitle:"selector 选择器组合使用",charIndex:5007},{level:4,title:"伪选择器 selectors",slug:"伪选择器-selectors",normalizedTitle:"伪选择器 selectors",charIndex:5499},{level:3,title:"从元素抽取属性，文本和 HTML",slug:"从元素抽取属性-文本和-html",normalizedTitle:"从元素抽取属性，文本和 html",charIndex:6175},{level:3,title:"处理 URLs",slug:"处理-urls",normalizedTitle:"处理 urls",charIndex:7200},{level:2,title:"数据修改",slug:"数据修改",normalizedTitle:"数据修改",charIndex:7884},{level:3,title:"设置属性的值",slug:"设置属性的值",normalizedTitle:"设置属性的值",charIndex:7893},{level:3,title:"设置一个元素的 HTML 内容",slug:"设置一个元素的-html-内容",normalizedTitle:"设置一个元素的 html 内容",charIndex:8479},{level:3,title:"设置元素的文本内容",slug:"设置元素的文本内容",normalizedTitle:"设置元素的文本内容",charIndex:9372},{level:2,title:"HTML 清理",slug:"html-清理",normalizedTitle:"html 清理",charIndex:9877},{level:3,title:"消除不受信任的 HTML (来防止 XSS 攻击)",slug:"消除不受信任的-html-来防止-xss-攻击",normalizedTitle:"消除不受信任的 html (来防止 xss 攻击)",charIndex:9889},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:6159}],headersStr:"简介 加载 从 HTML 字符串加载一个文档 解析一个 body 片断 保证安全 Stay safe 从 URL 加载一个文档 从一个文件加载一个文档 解析 使用 DOM 方法来遍历一个文档 查找元素 元素数据 操作 HTML 和文本 使用选择器语法来查找元素 Selector 选择器概述 Selector 选择器组合使用 伪选择器 selectors 从元素抽取属性，文本和 HTML 处理 URLs 数据修改 设置属性的值 设置一个元素的 HTML 内容 设置元素的文本内容 HTML 清理 消除不受信任的 HTML (来防止 XSS 攻击) 参考",content:'# Jsoup 快速入门\n\n\n# 简介\n\njsoup 是一款 Java 的 HTML 解析器，可直接解析某个 URL 地址、HTML 文本内容。它提供了一套非常省力的 API，可通过 DOM，CSS 以及类似于 JQuery 的操作方法来取出和操作数据。\n\njsoup 工作的流程主要如下：\n\n 1. 从一个 URL，文件或字符串中解析 HTML，并加载为一个 Document 对象。\n 2. 使用 DOM 或 CSS 选择器来取出数据；\n 3. 可操作 HTML 元素、属性、文本。\n\njsoup 是基于 MIT 协议发布的，可放心使用于商业项目。\n\n\n# 加载\n\n\n# 从 HTML 字符串加载一个文档\n\n使用静态 Jsoup.parse(String html) 方法或 Jsoup.parse(String html, String baseUri) 示例代码：\n\nString html = "<html><head><title>First parse</title></head>"\n  + "<body><p>Parsed HTML into a doc.</p></body></html>";\nDocument doc = Jsoup.parse(html);\n\n\n> 说明\n> \n> parse(String html, String baseUri) 这方法能够将输入的 HTML 解析为一个新的文档 (Document），参数 baseUri 是用来将相对 URL 转成绝对 URL，并指定从哪个网站获取文档。如这个方法不适用，你可以使用 parse(String html) 方法来解析成 HTML 字符串如上面的示例。\n> \n> 只要解析的不是空字符串，就能返回一个结构合理的文档，其中包含(至少) 一个 head 和一个 body 元素。\n> \n> 一旦拥有了一个 Document，你就可以使用 Document 中适当的方法或它父类 Element和Node中的方法来取得相关数据。\n\n\n# 解析一个 body 片断\n\n问题\n\n假如你有一个 HTML 片断 (比如. 一个 div 包含一对 p 标签; 一个不完整的 HTML 文档) 想对它进行解析。这个 HTML 片断可以是用户提交的一条评论或在一个 CMS 页面中编辑 body 部分。\n\n办法\n\n使用Jsoup.parseBodyFragment(String html)方法.\n\nString html = "<div><p>Lorem ipsum.</p>";\nDocument doc = Jsoup.parseBodyFragment(html);\nElement body = doc.body();\n\n\n> 说明\n> \n> parseBodyFragment 方法创建一个空壳的文档，并插入解析过的 HTML 到body元素中。假如你使用正常的 Jsoup.parse(String html) 方法，通常你也可以得到相同的结果，但是明确将用户输入作为 body 片段处理，以确保用户所提供的任何糟糕的 HTML 都将被解析成 body 元素。\n> \n> Document.body() 方法能够取得文档 body 元素的所有子元素，与 doc.getElementsByTag("body")相同。\n\n# 保证安全 Stay safe\n\n假如你可以让用户输入 HTML 内容，那么要小心避免跨站脚本攻击。利用基于 Whitelist 的清除器和 clean(String bodyHtml, Whitelist whitelist)方法来清除用户输入的恶意内容。\n\n\n# 从 URL 加载一个文档\n\n使用 Jsoup.connect(String url)方法\n\nDocument doc = Jsoup.connect("http://example.com/").get();\n\n\n> 说明\n> \n> connect(String url) 方法创建一个新的 Connection, 和 get() 取得和解析一个 HTML 文件。如果从该 URL 获取 HTML 时发生错误，便会抛出 IOException，应适当处理。\n\nConnection 接口还提供一个方法链来解决特殊请求，具体如下：\n\nDocument doc = Jsoup.connect("http://example.com")\n  .data("query", "Java")\n  .userAgent("Mozilla")\n  .cookie("auth", "token")\n  .timeout(3000)\n  .post();\n\n\n\n# 从一个文件加载一个文档\n\n可以使用静态 Jsoup.parse(File in, String charsetName, String baseUri) 方法\n\nFile input = new File("/tmp/input.html");\nDocument doc = Jsoup.parse(input, "UTF-8", "http://example.com/");\n\n\n> 说明\n> \n> parse(File in, String charsetName, String baseUri) 这个方法用来加载和解析一个 HTML 文件。如在加载文件的时候发生错误，将抛出 IOException，应作适当处理。\n> \n> baseUri 参数用于解决文件中 URLs 是相对路径的问题。如果不需要可以传入一个空的字符串。\n> \n> 另外还有一个方法parse(File in, String charsetName) ，它使用文件的路径做为 baseUri。 这个方法适用于如果被解析文件位于网站的本地文件系统，且相关链接也指向该文件系统。\n\n\n# 解析\n\n\n# 使用 DOM 方法来遍历一个文档\n\n问题\n\n你有一个 HTML 文档要从中提取数据，并了解这个 HTML 文档的结构。\n\n方法\n\n将 HTML 解析成一个Document之后，就可以使用类似于 DOM 的方法进行操作。示例代码：\n\nFile input = new File("/tmp/input.html");\nDocument doc = Jsoup.parse(input, "UTF-8", "http://example.com/");\n\nElement content = doc.getElementById("content");\nElements links = content.getElementsByTag("a");\nfor (Element link : links) {\n  String linkHref = link.attr("href");\n  String linkText = link.text();\n}\n\n\n说明\n\nElements 这个对象提供了一系列类似于 DOM 的方法来查找元素，抽取并处理其中的数据。\n\n具体如下：\n\n# 查找元素\n\n * getElementById(String id)\n * getElementsByTag(String tag)\n * getElementsByClass(String className)\n * getElementsByAttribute(String key) (and related methods)\n * Element siblings: siblingElements(), firstElementSibling(), lastElementSibling();nextElementSibling(), previousElementSibling()\n * Graph: parent(), children(), child(int index)\n\n# 元素数据\n\n * attr(String key)获取属性attr(String key, String value)设置属性\n * attributes()获取所有属性\n * id(), className() and classNames()\n * text()获取文本内容text(String value) 设置文本内容\n * html()获取元素内 HTMLhtml(String value)设置元素内的 HTML 内容\n * outerHtml()获取元素外 HTML 内容\n * data()获取数据内容（例如：script 和 style 标签)\n * tag() and tagName()\n\n# 操作 HTML 和文本\n\n * append(String html), prepend(String html)\n * appendText(String text), prependText(String text)\n * appendElement(String tagName), prependElement(String tagName)\n * html(String value)\n\n\n# 使用选择器语法来查找元素\n\n问题\n\n你想使用类似于 CSS 或 jQuery 的语法来查找和操作元素。\n\n方法\n\n可以使用Element.select(String selector) 和 Elements.select(String selector) 方法实现：\n\nFile input = new File("/tmp/input.html");\nDocument doc = Jsoup.parse(input, "UTF-8", "http://example.com/");\n\nElements links = doc.select("a[href]"); //带有href属性的a元素\nElements pngs = doc.select("img[src$=.png]");\n  //扩展名为.png的图片\n\nElement masthead = doc.select("div.masthead").first();\n  //class等于masthead的div标签\n\nElements resultLinks = doc.select("h3.r > a"); //在h3元素之后的a元素\n\n\n> 说明\n> \n> jsoup elements 对象支持类似于CSS (或jquery)的选择器语法，来实现非常强大和灵活的查找功能。.\n> \n> 这个select 方法在Document, Element,或Elements对象中都可以使用。且是上下文相关的，因此可实现指定元素的过滤，或者链式选择访问。\n> \n> Select 方法将返回一个Elements集合，并提供一组方法来抽取和处理结果。\n\n# Selector 选择器概述\n\n * tagname: 通过标签查找元素，比如：a\n * ns|tag: 通过标签在命名空间查找元素，比如：可以用 fb|name 语法来查找 `` 元素\n * #id: 通过 ID 查找元素，比如：#logo\n * .class: 通过 class 名称查找元素，比如：.masthead\n * [attribute]: 利用属性查找元素，比如：[href]\n * [^attr]: 利用属性名前缀来查找元素，比如：可以用[^data-] 来查找带有 HTML5 Dataset 属性的元素\n * [attr=value]: 利用属性值来查找元素，比如：[width=500]\n * [attr^=value], [attr$=value], [attr*=value]: 利用匹配属性值开头、结尾或包含属性值来查找元素，比如：[href*=/path/]\n * [attr\\~=regex]: 利用属性值匹配正则表达式来查找元素，比如： img[src\\~=(?i)\\.(png|jpe?g)]\n * *: 这个符号将匹配所有元素\n\n# Selector 选择器组合使用\n\n * el##id: 元素+ID，比如： div##logo\n * el.class: 元素+class，比如： div.masthead\n * el[attr]: 元素+class，比如： a[href]\n * 任意组合，比如：a[href].highlight\n * ancestor child: 查找某个元素下子元素，比如：可以用.body p 查找在"body"元素下的所有p元素\n * parent > child: 查找某个父元素下的直接子元素，比如：可以用div.content > p 查找 p 元素，也可以用body > * 查找 body 标签下所有直接子元素\n * siblingA + siblingB: 查找在 A 元素之前第一个同级元素 B，比如：div.head + div\n * siblingA \\~ siblingX: 查找 A 元素之前的同级 X 元素，比如：h1 \\~ p\n * el, el, el:多个选择器组合，查找匹配任一选择器的唯一元素，例如：div.masthead, div.logo\n\n# 伪选择器 selectors\n\n * :lt(n): 查找哪些元素的同级索引值（它的位置在 DOM 树中是相对于它的父节点）小于 n，比如：td:lt(3) 表示小于三列的元素\n * :gt(n):查找哪些元素的同级索引值大于n``，比如： div p:gt(2)表示哪些 div 中有包含 2 个以上的 p 元素\n * :eq(n): 查找哪些元素的同级索引值与n相等，比如：form input:eq(1)表示包含一个 input 标签的 Form 元素\n * :has(seletor): 查找匹配选择器包含元素的元素，比如：div:has(p)表示哪些 div 包含了 p 元素\n * :not(selector): 查找与选择器不匹配的元素，比如： div:not(.logo) 表示不包含 class=logo 元素的所有 div 列表\n * :contains(text): 查找包含给定文本的元素，搜索不区分大不写，比如： p:contains(jsoup)\n * :containsOwn(text): 查找直接包含给定文本的元素\n * :matches(regex): 查找哪些元素的文本匹配指定的正则表达式，比如：div:matches((?i)login)\n * :matchesOwn(regex): 查找自身包含文本匹配指定正则表达式的元素\n * 注意：上述伪选择器索引是从 0 开始的，也就是说第一个元素索引值为 0，第二个元素 index 为 1 等\n\n可以查看Selector API 参考来了解更详细的内容\n\n\n# 从元素抽取属性，文本和 HTML\n\n问题\n\n在解析获得一个 Document 实例对象，并查找到一些元素之后，你希望取得在这些元素中的数据。\n\n方法\n\n * 要取得一个属性的值，可以使用Node.attr(String key) 方法\n * 对于一个元素中的文本，可以使用Element.text()方法\n * 对于要取得元素或属性中的 HTML 内容，可以使用Element.html(), 或 Node.outerHtml()方法\n\n示例：\n\nString html = "<p>An <a href=\'http://example.com/\'><b>example</b></a> link.</p>";\nDocument doc = Jsoup.parse(html);//解析HTML字符串返回一个Document实现\nElement link = doc.select("a").first();//查找第一个a元素\n\nString text = doc.body().text(); // "An example link"//取得字符串中的文本\nString linkHref = link.attr("href"); // "http://example.com/"//取得链接地址\nString linkText = link.text(); // "example""//取得链接地址中的文本\n\nString linkOuterH = link.outerHtml();\n    // "<a href="http://example.com"><b>example</b></a>"\nString linkInnerH = link.html(); // "<b>example</b>"//取得链接内的html内容\n\n\n> 说明\n> \n> 上述方法是元素数据访问的核心办法。此外还其它一些方法可以使用：\n> \n>  * Element.id()\n>  * Element.tagName()\n>  * Element.className() and Element.hasClass(String className)\n> \n> 这些访问器方法都有相应的 setter 方法来更改数据\n\n参见\n\n * Element和Elements集合类的参考文档\n * URLs 处理\n * 使用 CSS 选择器语法来查找元素\n\n\n# 处理 URLs\n\n问题\n\n你有一个包含相对 URLs 路径的 HTML 文档，需要将这些相对路径转换成绝对路径的 URLs。\n\n方法\n\n 1. 在你解析文档时确保有指定base URI，然后\n 2. 使用 abs: 属性前缀来取得包含base URI的绝对路径。代码如下：\n\nDocument doc = Jsoup.connect("http://www.open-open.com").get();\n\nElement link = doc.select("a").first();\nString relHref = link.attr("href"); // == "/"\nString absHref = link.attr("abs:href"); // "http://www.open-open.com/"\n\n\n\n> 说明\n> \n> 在 HTML 元素中，URLs 经常写成相对于文档位置的相对路径： <a href="/download">...</a>. 当你使用 Node.attr(String key) 方法来取得 a 元素的 href 属性时，它将直接返回在 HTML 源码中指定定的值。\n> \n> 假如你需要取得一个绝对路径，需要在属性名前加 abs: 前缀。这样就可以返回包含根路径的 URL 地址attr("abs:href")\n> \n> 因此，在解析 HTML 文档时，定义 base URI 非常重要。\n> \n> 如果你不想使用abs: 前缀，还有一个方法能够实现同样的功能 Node.absUrl(String key)。\n\n\n# 数据修改\n\n\n# 设置属性的值\n\n问题\n\n在你解析一个 Document 之后可能想修改其中的某些属性值，然后再保存到磁盘或都输出到前台页面。\n\n方法\n\n可以使用属性设置方法 Element.attr(String key, String value), 和 Elements.attr(String key, String value).\n\n假如你需要修改一个元素的 class 属性，可以使用 Element.addClass(String className) 和Element.removeClass(String className) 方法。\n\nElements 提供了批量操作元素属性和 class 的方法，比如：要为 div 中的每一个 a 元素都添加一个rel="nofollow" 可以使用如下方法：\n\ndoc.select("div.comments a").attr("rel", "nofollow");\n\n\n\n> 说明\n> \n> 与Element中的其它方法一样，attr 方法也是返回当 Element (或在使用选择器是返回 Elements集合)。这样能够很方便使用方法连用的书写方式。比如：\n> \n> doc.select("div.masthead").attr("title", "jsoup").addClass("round-box");\n\n\n# 设置一个元素的 HTML 内容\n\n问题\n\n你需要一个元素中的 HTML 内容\n\n方法\n\n可以使用Element中的 HTML 设置方法具体如下：\n\nElement div = doc.select("div").first(); // <div></div>\ndiv.html("<p>lorem ipsum</p>"); // <div><p>lorem ipsum</p></div>\ndiv.prepend("<p>First</p>");//在div前添加html内容\ndiv.append("<p>Last</p>");//在div之后添加html内容\n// 添完后的结果: <div><p>First</p><p>lorem ipsum</p><p>Last</p></div>\n\nElement span = doc.select("span").first(); // <span>One</span>\nspan.wrap("<li><a href=\'http://example.com/\'></a></li>");\n// 添完后的结果: <li><a href="http://example.com"><span>One</span></a></li>\n\n\n> 说明\n> \n>  * Element.html(String html) 这个方法将先清除元素中的 HTML 内容，然后用传入的 HTML 代替。\n>  * Element.prepend(String first) 和 Element.append(String last) 方法用于在分别在元素内部 HTML 的前面和后面添加 HTML 内容\n>  * Element.wrap(String around) 对元素包裹一个外部 HTML 内容。\n> \n> 参见\n> \n> 可以查看 API 参考文档中 Element.prependElement(String tag)和Element.appendElement(String tag) 方法来创建新的元素并作为文档的子元素插入其中。\n\n\n# 设置元素的文本内容\n\n问题\n\n你需要修改一个 HTML 文档中的文本内容\n\n方法\n\n可以使用Element的设置方法：:\n\nElement div = doc.select("div").first(); // <div></div>\ndiv.text("five > four"); // <div>five &gt; four</div>\ndiv.prepend("First ");\ndiv.append(" Last");\n// now: <div>First five &gt; four Last</div>\n\n\n> 说明\n> \n> 文本设置方法与 HTML setter 方法一样：\n> \n>  * Element.text(String text) 将清除一个元素中的内部 HTML 内容，然后提供的文本进行代替\n>  * Element.prepend(String first) 和 Element.append(String last) 将分别在元素的内部 html 前后添加文本节点。\n> \n> 对于传入的文本如果含有像 <, > 等这样的字符，将以文本处理，而非 HTML。\n\n\n# HTML 清理\n\n\n# 消除不受信任的 HTML (来防止 XSS 攻击)\n\n问题\n\n在做网站的时候，经常会提供用户评论的功能。有些不怀好意的用户，会搞一些脚本到评论内容中，而这些脚本可能会破坏整个页面的行为，更严重的是获取一些机要信息，此时需要清理该 HTML，以避免跨站脚本cross-site scripting攻击（XSS）。\n\n方法\n\n使用 jsoup HTML Cleaner 方法进行清除，但需要指定一个可配置的 Whitelist。\n\nString unsafe =\n  "<p><a href=\'http://example.com/\' onclick=\'stealCookies()\'>Link</a></p>";\nString safe = Jsoup.clean(unsafe, Whitelist.basic());\n// now: <p><a href="http://example.com/" rel="nofollow">Link</a></p>\n\n\n说明\n\nXSS 又叫 CSS (Cross Site Script) ，跨站脚本攻击。它指的是恶意攻击者往 Web 页面里插入恶意 html 代码，当用户浏览该页之时，嵌入其中 Web 里面的 html 代码会被执行，从而达到恶意攻击用户的特殊目的。XSS 属于被动式的攻击，因为其被动且不好利用，所以许多人常忽略其危害性。所以我们经常只让用户输入纯文本的内容，但这样用户体验就比较差了。\n\n一个更好的解决方法就是使用一个富文本编辑器 WYSIWYG 如 CKEditor 和 TinyMCE。这些可以输出 HTML 并能够让用户可视化编辑。虽然他们可以在客户端进行校验，但是这样还不够安全，需要在服务器端进行校验并清除有害的 HTML 代码，这样才能确保输入到你网站的 HTML 是安全的。否则，攻击者能够绕过客户端的 Javascript 验证，并注入不安全的 HMTL 直接进入您的网站。\n\njsoup 的 whitelist 清理器能够在服务器端对用户输入的 HTML 进行过滤，只输出一些安全的标签和属性。\n\njsoup 提供了一系列的 Whitelist 基本配置，能够满足大多数要求；但如有必要，也可以进行修改，不过要小心。\n\n这个 cleaner 非常好用不仅可以避免 XSS 攻击，还可以限制用户可以输入的标签范围。\n\n参见\n\n * 参阅XSS cheat sheet ，有一个例子可以了解为什么不能使用正则表达式，而采用安全的 whitelist parser-based 清理器才是正确的选择。\n * 参阅Cleaner ，了解如何返回一个 Document 对象，而不是字符串\n * 参阅Whitelist，了解如何创建一个自定义的 whitelist\n * nofollow 链接属性了解\n\n\n# 参考\n\n * jsoup github 托管代码\n * jsoup Cookbook\n * jsoup Cookbook(中文版)\n * 不错的 jsoup 学习笔记',normalizedContent:'# jsoup 快速入门\n\n\n# 简介\n\njsoup 是一款 java 的 html 解析器，可直接解析某个 url 地址、html 文本内容。它提供了一套非常省力的 api，可通过 dom，css 以及类似于 jquery 的操作方法来取出和操作数据。\n\njsoup 工作的流程主要如下：\n\n 1. 从一个 url，文件或字符串中解析 html，并加载为一个 document 对象。\n 2. 使用 dom 或 css 选择器来取出数据；\n 3. 可操作 html 元素、属性、文本。\n\njsoup 是基于 mit 协议发布的，可放心使用于商业项目。\n\n\n# 加载\n\n\n# 从 html 字符串加载一个文档\n\n使用静态 jsoup.parse(string html) 方法或 jsoup.parse(string html, string baseuri) 示例代码：\n\nstring html = "<html><head><title>first parse</title></head>"\n  + "<body><p>parsed html into a doc.</p></body></html>";\ndocument doc = jsoup.parse(html);\n\n\n> 说明\n> \n> parse(string html, string baseuri) 这方法能够将输入的 html 解析为一个新的文档 (document），参数 baseuri 是用来将相对 url 转成绝对 url，并指定从哪个网站获取文档。如这个方法不适用，你可以使用 parse(string html) 方法来解析成 html 字符串如上面的示例。\n> \n> 只要解析的不是空字符串，就能返回一个结构合理的文档，其中包含(至少) 一个 head 和一个 body 元素。\n> \n> 一旦拥有了一个 document，你就可以使用 document 中适当的方法或它父类 element和node中的方法来取得相关数据。\n\n\n# 解析一个 body 片断\n\n问题\n\n假如你有一个 html 片断 (比如. 一个 div 包含一对 p 标签; 一个不完整的 html 文档) 想对它进行解析。这个 html 片断可以是用户提交的一条评论或在一个 cms 页面中编辑 body 部分。\n\n办法\n\n使用jsoup.parsebodyfragment(string html)方法.\n\nstring html = "<div><p>lorem ipsum.</p>";\ndocument doc = jsoup.parsebodyfragment(html);\nelement body = doc.body();\n\n\n> 说明\n> \n> parsebodyfragment 方法创建一个空壳的文档，并插入解析过的 html 到body元素中。假如你使用正常的 jsoup.parse(string html) 方法，通常你也可以得到相同的结果，但是明确将用户输入作为 body 片段处理，以确保用户所提供的任何糟糕的 html 都将被解析成 body 元素。\n> \n> document.body() 方法能够取得文档 body 元素的所有子元素，与 doc.getelementsbytag("body")相同。\n\n# 保证安全 stay safe\n\n假如你可以让用户输入 html 内容，那么要小心避免跨站脚本攻击。利用基于 whitelist 的清除器和 clean(string bodyhtml, whitelist whitelist)方法来清除用户输入的恶意内容。\n\n\n# 从 url 加载一个文档\n\n使用 jsoup.connect(string url)方法\n\ndocument doc = jsoup.connect("http://example.com/").get();\n\n\n> 说明\n> \n> connect(string url) 方法创建一个新的 connection, 和 get() 取得和解析一个 html 文件。如果从该 url 获取 html 时发生错误，便会抛出 ioexception，应适当处理。\n\nconnection 接口还提供一个方法链来解决特殊请求，具体如下：\n\ndocument doc = jsoup.connect("http://example.com")\n  .data("query", "java")\n  .useragent("mozilla")\n  .cookie("auth", "token")\n  .timeout(3000)\n  .post();\n\n\n\n# 从一个文件加载一个文档\n\n可以使用静态 jsoup.parse(file in, string charsetname, string baseuri) 方法\n\nfile input = new file("/tmp/input.html");\ndocument doc = jsoup.parse(input, "utf-8", "http://example.com/");\n\n\n> 说明\n> \n> parse(file in, string charsetname, string baseuri) 这个方法用来加载和解析一个 html 文件。如在加载文件的时候发生错误，将抛出 ioexception，应作适当处理。\n> \n> baseuri 参数用于解决文件中 urls 是相对路径的问题。如果不需要可以传入一个空的字符串。\n> \n> 另外还有一个方法parse(file in, string charsetname) ，它使用文件的路径做为 baseuri。 这个方法适用于如果被解析文件位于网站的本地文件系统，且相关链接也指向该文件系统。\n\n\n# 解析\n\n\n# 使用 dom 方法来遍历一个文档\n\n问题\n\n你有一个 html 文档要从中提取数据，并了解这个 html 文档的结构。\n\n方法\n\n将 html 解析成一个document之后，就可以使用类似于 dom 的方法进行操作。示例代码：\n\nfile input = new file("/tmp/input.html");\ndocument doc = jsoup.parse(input, "utf-8", "http://example.com/");\n\nelement content = doc.getelementbyid("content");\nelements links = content.getelementsbytag("a");\nfor (element link : links) {\n  string linkhref = link.attr("href");\n  string linktext = link.text();\n}\n\n\n说明\n\nelements 这个对象提供了一系列类似于 dom 的方法来查找元素，抽取并处理其中的数据。\n\n具体如下：\n\n# 查找元素\n\n * getelementbyid(string id)\n * getelementsbytag(string tag)\n * getelementsbyclass(string classname)\n * getelementsbyattribute(string key) (and related methods)\n * element siblings: siblingelements(), firstelementsibling(), lastelementsibling();nextelementsibling(), previouselementsibling()\n * graph: parent(), children(), child(int index)\n\n# 元素数据\n\n * attr(string key)获取属性attr(string key, string value)设置属性\n * attributes()获取所有属性\n * id(), classname() and classnames()\n * text()获取文本内容text(string value) 设置文本内容\n * html()获取元素内 htmlhtml(string value)设置元素内的 html 内容\n * outerhtml()获取元素外 html 内容\n * data()获取数据内容（例如：script 和 style 标签)\n * tag() and tagname()\n\n# 操作 html 和文本\n\n * append(string html), prepend(string html)\n * appendtext(string text), prependtext(string text)\n * appendelement(string tagname), prependelement(string tagname)\n * html(string value)\n\n\n# 使用选择器语法来查找元素\n\n问题\n\n你想使用类似于 css 或 jquery 的语法来查找和操作元素。\n\n方法\n\n可以使用element.select(string selector) 和 elements.select(string selector) 方法实现：\n\nfile input = new file("/tmp/input.html");\ndocument doc = jsoup.parse(input, "utf-8", "http://example.com/");\n\nelements links = doc.select("a[href]"); //带有href属性的a元素\nelements pngs = doc.select("img[src$=.png]");\n  //扩展名为.png的图片\n\nelement masthead = doc.select("div.masthead").first();\n  //class等于masthead的div标签\n\nelements resultlinks = doc.select("h3.r > a"); //在h3元素之后的a元素\n\n\n> 说明\n> \n> jsoup elements 对象支持类似于css (或jquery)的选择器语法，来实现非常强大和灵活的查找功能。.\n> \n> 这个select 方法在document, element,或elements对象中都可以使用。且是上下文相关的，因此可实现指定元素的过滤，或者链式选择访问。\n> \n> select 方法将返回一个elements集合，并提供一组方法来抽取和处理结果。\n\n# selector 选择器概述\n\n * tagname: 通过标签查找元素，比如：a\n * ns|tag: 通过标签在命名空间查找元素，比如：可以用 fb|name 语法来查找 `` 元素\n * #id: 通过 id 查找元素，比如：#logo\n * .class: 通过 class 名称查找元素，比如：.masthead\n * [attribute]: 利用属性查找元素，比如：[href]\n * [^attr]: 利用属性名前缀来查找元素，比如：可以用[^data-] 来查找带有 html5 dataset 属性的元素\n * [attr=value]: 利用属性值来查找元素，比如：[width=500]\n * [attr^=value], [attr$=value], [attr*=value]: 利用匹配属性值开头、结尾或包含属性值来查找元素，比如：[href*=/path/]\n * [attr\\~=regex]: 利用属性值匹配正则表达式来查找元素，比如： img[src\\~=(?i)\\.(png|jpe?g)]\n * *: 这个符号将匹配所有元素\n\n# selector 选择器组合使用\n\n * el##id: 元素+id，比如： div##logo\n * el.class: 元素+class，比如： div.masthead\n * el[attr]: 元素+class，比如： a[href]\n * 任意组合，比如：a[href].highlight\n * ancestor child: 查找某个元素下子元素，比如：可以用.body p 查找在"body"元素下的所有p元素\n * parent > child: 查找某个父元素下的直接子元素，比如：可以用div.content > p 查找 p 元素，也可以用body > * 查找 body 标签下所有直接子元素\n * siblinga + siblingb: 查找在 a 元素之前第一个同级元素 b，比如：div.head + div\n * siblinga \\~ siblingx: 查找 a 元素之前的同级 x 元素，比如：h1 \\~ p\n * el, el, el:多个选择器组合，查找匹配任一选择器的唯一元素，例如：div.masthead, div.logo\n\n# 伪选择器 selectors\n\n * :lt(n): 查找哪些元素的同级索引值（它的位置在 dom 树中是相对于它的父节点）小于 n，比如：td:lt(3) 表示小于三列的元素\n * :gt(n):查找哪些元素的同级索引值大于n``，比如： div p:gt(2)表示哪些 div 中有包含 2 个以上的 p 元素\n * :eq(n): 查找哪些元素的同级索引值与n相等，比如：form input:eq(1)表示包含一个 input 标签的 form 元素\n * :has(seletor): 查找匹配选择器包含元素的元素，比如：div:has(p)表示哪些 div 包含了 p 元素\n * :not(selector): 查找与选择器不匹配的元素，比如： div:not(.logo) 表示不包含 class=logo 元素的所有 div 列表\n * :contains(text): 查找包含给定文本的元素，搜索不区分大不写，比如： p:contains(jsoup)\n * :containsown(text): 查找直接包含给定文本的元素\n * :matches(regex): 查找哪些元素的文本匹配指定的正则表达式，比如：div:matches((?i)login)\n * :matchesown(regex): 查找自身包含文本匹配指定正则表达式的元素\n * 注意：上述伪选择器索引是从 0 开始的，也就是说第一个元素索引值为 0，第二个元素 index 为 1 等\n\n可以查看selector api 参考来了解更详细的内容\n\n\n# 从元素抽取属性，文本和 html\n\n问题\n\n在解析获得一个 document 实例对象，并查找到一些元素之后，你希望取得在这些元素中的数据。\n\n方法\n\n * 要取得一个属性的值，可以使用node.attr(string key) 方法\n * 对于一个元素中的文本，可以使用element.text()方法\n * 对于要取得元素或属性中的 html 内容，可以使用element.html(), 或 node.outerhtml()方法\n\n示例：\n\nstring html = "<p>an <a href=\'http://example.com/\'><b>example</b></a> link.</p>";\ndocument doc = jsoup.parse(html);//解析html字符串返回一个document实现\nelement link = doc.select("a").first();//查找第一个a元素\n\nstring text = doc.body().text(); // "an example link"//取得字符串中的文本\nstring linkhref = link.attr("href"); // "http://example.com/"//取得链接地址\nstring linktext = link.text(); // "example""//取得链接地址中的文本\n\nstring linkouterh = link.outerhtml();\n    // "<a href="http://example.com"><b>example</b></a>"\nstring linkinnerh = link.html(); // "<b>example</b>"//取得链接内的html内容\n\n\n> 说明\n> \n> 上述方法是元素数据访问的核心办法。此外还其它一些方法可以使用：\n> \n>  * element.id()\n>  * element.tagname()\n>  * element.classname() and element.hasclass(string classname)\n> \n> 这些访问器方法都有相应的 setter 方法来更改数据\n\n参见\n\n * element和elements集合类的参考文档\n * urls 处理\n * 使用 css 选择器语法来查找元素\n\n\n# 处理 urls\n\n问题\n\n你有一个包含相对 urls 路径的 html 文档，需要将这些相对路径转换成绝对路径的 urls。\n\n方法\n\n 1. 在你解析文档时确保有指定base uri，然后\n 2. 使用 abs: 属性前缀来取得包含base uri的绝对路径。代码如下：\n\ndocument doc = jsoup.connect("http://www.open-open.com").get();\n\nelement link = doc.select("a").first();\nstring relhref = link.attr("href"); // == "/"\nstring abshref = link.attr("abs:href"); // "http://www.open-open.com/"\n\n\n\n> 说明\n> \n> 在 html 元素中，urls 经常写成相对于文档位置的相对路径： <a href="/download">...</a>. 当你使用 node.attr(string key) 方法来取得 a 元素的 href 属性时，它将直接返回在 html 源码中指定定的值。\n> \n> 假如你需要取得一个绝对路径，需要在属性名前加 abs: 前缀。这样就可以返回包含根路径的 url 地址attr("abs:href")\n> \n> 因此，在解析 html 文档时，定义 base uri 非常重要。\n> \n> 如果你不想使用abs: 前缀，还有一个方法能够实现同样的功能 node.absurl(string key)。\n\n\n# 数据修改\n\n\n# 设置属性的值\n\n问题\n\n在你解析一个 document 之后可能想修改其中的某些属性值，然后再保存到磁盘或都输出到前台页面。\n\n方法\n\n可以使用属性设置方法 element.attr(string key, string value), 和 elements.attr(string key, string value).\n\n假如你需要修改一个元素的 class 属性，可以使用 element.addclass(string classname) 和element.removeclass(string classname) 方法。\n\nelements 提供了批量操作元素属性和 class 的方法，比如：要为 div 中的每一个 a 元素都添加一个rel="nofollow" 可以使用如下方法：\n\ndoc.select("div.comments a").attr("rel", "nofollow");\n\n\n\n> 说明\n> \n> 与element中的其它方法一样，attr 方法也是返回当 element (或在使用选择器是返回 elements集合)。这样能够很方便使用方法连用的书写方式。比如：\n> \n> doc.select("div.masthead").attr("title", "jsoup").addclass("round-box");\n\n\n# 设置一个元素的 html 内容\n\n问题\n\n你需要一个元素中的 html 内容\n\n方法\n\n可以使用element中的 html 设置方法具体如下：\n\nelement div = doc.select("div").first(); // <div></div>\ndiv.html("<p>lorem ipsum</p>"); // <div><p>lorem ipsum</p></div>\ndiv.prepend("<p>first</p>");//在div前添加html内容\ndiv.append("<p>last</p>");//在div之后添加html内容\n// 添完后的结果: <div><p>first</p><p>lorem ipsum</p><p>last</p></div>\n\nelement span = doc.select("span").first(); // <span>one</span>\nspan.wrap("<li><a href=\'http://example.com/\'></a></li>");\n// 添完后的结果: <li><a href="http://example.com"><span>one</span></a></li>\n\n\n> 说明\n> \n>  * element.html(string html) 这个方法将先清除元素中的 html 内容，然后用传入的 html 代替。\n>  * element.prepend(string first) 和 element.append(string last) 方法用于在分别在元素内部 html 的前面和后面添加 html 内容\n>  * element.wrap(string around) 对元素包裹一个外部 html 内容。\n> \n> 参见\n> \n> 可以查看 api 参考文档中 element.prependelement(string tag)和element.appendelement(string tag) 方法来创建新的元素并作为文档的子元素插入其中。\n\n\n# 设置元素的文本内容\n\n问题\n\n你需要修改一个 html 文档中的文本内容\n\n方法\n\n可以使用element的设置方法：:\n\nelement div = doc.select("div").first(); // <div></div>\ndiv.text("five > four"); // <div>five &gt; four</div>\ndiv.prepend("first ");\ndiv.append(" last");\n// now: <div>first five &gt; four last</div>\n\n\n> 说明\n> \n> 文本设置方法与 html setter 方法一样：\n> \n>  * element.text(string text) 将清除一个元素中的内部 html 内容，然后提供的文本进行代替\n>  * element.prepend(string first) 和 element.append(string last) 将分别在元素的内部 html 前后添加文本节点。\n> \n> 对于传入的文本如果含有像 <, > 等这样的字符，将以文本处理，而非 html。\n\n\n# html 清理\n\n\n# 消除不受信任的 html (来防止 xss 攻击)\n\n问题\n\n在做网站的时候，经常会提供用户评论的功能。有些不怀好意的用户，会搞一些脚本到评论内容中，而这些脚本可能会破坏整个页面的行为，更严重的是获取一些机要信息，此时需要清理该 html，以避免跨站脚本cross-site scripting攻击（xss）。\n\n方法\n\n使用 jsoup html cleaner 方法进行清除，但需要指定一个可配置的 whitelist。\n\nstring unsafe =\n  "<p><a href=\'http://example.com/\' onclick=\'stealcookies()\'>link</a></p>";\nstring safe = jsoup.clean(unsafe, whitelist.basic());\n// now: <p><a href="http://example.com/" rel="nofollow">link</a></p>\n\n\n说明\n\nxss 又叫 css (cross site script) ，跨站脚本攻击。它指的是恶意攻击者往 web 页面里插入恶意 html 代码，当用户浏览该页之时，嵌入其中 web 里面的 html 代码会被执行，从而达到恶意攻击用户的特殊目的。xss 属于被动式的攻击，因为其被动且不好利用，所以许多人常忽略其危害性。所以我们经常只让用户输入纯文本的内容，但这样用户体验就比较差了。\n\n一个更好的解决方法就是使用一个富文本编辑器 wysiwyg 如 ckeditor 和 tinymce。这些可以输出 html 并能够让用户可视化编辑。虽然他们可以在客户端进行校验，但是这样还不够安全，需要在服务器端进行校验并清除有害的 html 代码，这样才能确保输入到你网站的 html 是安全的。否则，攻击者能够绕过客户端的 javascript 验证，并注入不安全的 hmtl 直接进入您的网站。\n\njsoup 的 whitelist 清理器能够在服务器端对用户输入的 html 进行过滤，只输出一些安全的标签和属性。\n\njsoup 提供了一系列的 whitelist 基本配置，能够满足大多数要求；但如有必要，也可以进行修改，不过要小心。\n\n这个 cleaner 非常好用不仅可以避免 xss 攻击，还可以限制用户可以输入的标签范围。\n\n参见\n\n * 参阅xss cheat sheet ，有一个例子可以了解为什么不能使用正则表达式，而采用安全的 whitelist parser-based 清理器才是正确的选择。\n * 参阅cleaner ，了解如何返回一个 document 对象，而不是字符串\n * 参阅whitelist，了解如何创建一个自定义的 whitelist\n * nofollow 链接属性了解\n\n\n# 参考\n\n * jsoup github 托管代码\n * jsoup cookbook\n * jsoup cookbook(中文版)\n * 不错的 jsoup 学习笔记',charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Thumbnailator 快速入门",frontmatter:{title:"Thumbnailator 快速入门",date:"2022-02-17T22:34:30.000Z",order:6,categories:["Java","工具","其他"],tags:["Java","图形处理","Thumbnailator"],permalink:"/pages/adacc5/"},regularPath:"/01.Java/12.%E5%B7%A5%E5%85%B7/99.%E5%85%B6%E4%BB%96/06.Thumbnailator.html",relativePath:"01.Java/12.工具/99.其他/06.Thumbnailator.md",key:"v-1b7ae99a",path:"/pages/adacc5/",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:25},{level:2,title:"核心 API",slug:"核心-api",normalizedTitle:"核心 api",charIndex:311},{level:3,title:"Thumbnails",slug:"thumbnails",normalizedTitle:"thumbnails",charIndex:124},{level:3,title:"Thumbnails.Builder",slug:"thumbnails-builder",normalizedTitle:"thumbnails.builder",charIndex:385},{level:4,title:"设置参数的函数",slug:"设置参数的函数",normalizedTitle:"设置参数的函数",charIndex:1500},{level:4,title:"输出函数",slug:"输出函数",normalizedTitle:"输出函数",charIndex:2140},{level:3,title:"工作流",slug:"工作流",normalizedTitle:"工作流",charIndex:3099},{level:2,title:"实战",slug:"实战",normalizedTitle:"实战",charIndex:3307},{level:3,title:"安装",slug:"安装",normalizedTitle:"安装",charIndex:3420},{level:3,title:"图片缩放",slug:"图片缩放",normalizedTitle:"图片缩放",charIndex:3578},{level:3,title:"图片旋转",slug:"图片旋转",normalizedTitle:"图片旋转",charIndex:3945},{level:3,title:"加水印",slug:"加水印",normalizedTitle:"加水印",charIndex:85},{level:3,title:"批量处理图片",slug:"批量处理图片",normalizedTitle:"批量处理图片",charIndex:4569},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:3274}],headersStr:"简介 核心 API Thumbnails Thumbnails.Builder 设置参数的函数 输出函数 工作流 实战 安装 图片缩放 图片旋转 加水印 批量处理图片 参考",content:'# Thumbnailator 快速入门\n\n\n# 简介\n\nThumbnailator 是一个开源的 Java 项目，它提供了非常简单的 API 来对图片进行缩放、旋转以及加水印的处理。\n\n有多简单呢？简单到一行代码就可以完成图片处理。形式如下：\n\nThumbnails.of(new File("path/to/directory").listFiles())\n    .size(640, 480)\n    .outputFormat("jpg")\n    .toFiles(Rename.PREFIX_DOT_THUMBNAIL);\n\n\n当然，Thumbnailator 还有一些使用细节，下面我会一一道来。\n\n\n# 核心 API\n\n\n# Thumbnails\n\nThumbnails 是使用 Thumbnailator 创建缩略图的主入口。\n\n它提供了一组初始化 Thumbnails.Builder 的接口。\n\n先看下这组接口的声明：\n\n// 可变长度参数列表\npublic static Builder<File> of(String... files) {...}\npublic static Builder<File> of(File... files) {...}\npublic static Builder<URL> of(URL... urls) {...}\npublic static Builder<? extends InputStream> of(InputStream... inputStreams) {...}\npublic static Builder<BufferedImage> of(BufferedImage... images) {...}\n// 迭代器（所有实现 Iterable 接口的 Java 对象都可以，当然也包括 List、Set）\npublic static Builder<File> fromFilenames(Iterable<String> files) {...}\npublic static Builder<File> fromFiles(Iterable<File> files) {...}\npublic static Builder<URL> fromURLs(Iterable<URL> urls) {...}\npublic static Builder<InputStream> fromInputStreams(Iterable<? extends InputStream> inputStreams) {...}\npublic static Builder<BufferedImage> fromImages(Iterable<BufferedImage> images) {...}\n\n\n很显然，Thumbnails 允许通过传入文件名、文件、网络图的 URL、图片流、图片缓存多种方式来初始化构造器。\n\n因此，你可以根据实际需求来灵活的选择图片的输入方式。\n\n需要注意一点：如果输入是多个对象（无论你是直接输入容器对象或使用可变参数方式传入多个对象），则输出也必须选用输出多个对象的方式，否则会报异常。\n\n\n# Thumbnails.Builder\n\nThumbnails.Builder 是 Thumbnails 的内部静态类。它用于设置生成缩略图任务的相关参数。\n\n注：Thumbnails.Builder 的构造函数是私有函数。所以，它只允许通过 Thumbnails 的实例化函数来进行初始化。\n\n# 设置参数的函数\n\nThumbnails.Builder 提供了一组函数链形式的接口来设置缩放图参数。\n\n以设置大小函数为例：\n\npublic Builder<T> size(int width, int height)\n{\n updateStatus(Properties.SIZE, Status.ALREADY_SET);\n updateStatus(Properties.SCALE, Status.CANNOT_SET);\n\n validateDimensions(width, height);\n this.width = width;\n this.height = height;\n\n return this;\n}\n\n\n通过返回 this 指针，使得设置参数函数可以以链式调用的方式来使用，形式如下：\n\nThumbnails.of(new File("original.jpg"))\n        .size(160, 160)\n        .rotate(90)\n        .watermark(Positions.BOTTOM_RIGHT, ImageIO.read(new File("watermark.png")), 0.5f)\n        .outputQuality(0.8)\n        .toFile(new File("image-with-watermark.jpg"));\n\n\n好处，不言自明：那就是大大简化了代码。\n\n# 输出函数\n\nThumbnails.Builder 提供了一组重载函数来输出生成的缩放图。\n\n函数声明如下：\n\n// 返回图片缓存\npublic List<BufferedImage> asBufferedImages() throws IOException {...}\npublic BufferedImage asBufferedImage() throws IOException {...}\n// 返回文件列表\npublic List<File> asFiles(Iterable<File> iterable) throws IOException {...}\npublic List<File> asFiles(Rename rename) throws IOException {...}\npublic List<File> asFiles(File destinationDir, Rename rename) throws IOException {...}\n// 创建文件\npublic void toFile(File outFile) throws IOException {...}\npublic void toFile(String outFilepath) throws IOException {...}\npublic void toFiles(Iterable<File> iterable) throws IOException {...}\npublic void toFiles(Rename rename) throws IOException {...}\npublic void toFiles(File destinationDir, Rename rename) throws IOException {...}\n// 创建输出流\npublic void toOutputStream(OutputStream os) throws IOException {...}\npublic void toOutputStreams(Iterable<? extends OutputStream> iterable) throws IOException {...}\n\n\n\n# 工作流\n\nThumbnailator 的工作步骤十分简单，可分为三步：\n\n 1. 输入：Thumbnails 根据输入初始化构造器—— Thumbnails.Builder 。\n\n 2. 设置：Thumbnails.Builder 设置缩放图片的参数。\n\n 3. 输出：Thumbnails.Builder 输出图片文件或图片流。\n\n> 更多详情可以参考： Thumbnailator 官网 javadoc\n\n\n# 实战\n\n前文介绍了 Thumbnailator 的核心 API，接下来我们就可以通过实战来看看 Thumbnailator 究竟可以做些什么。\n\nThumbnailator 生成什么样的图片，是根据设置参数来决定的。\n\n\n# 安装\n\nmaven 项目中引入依赖：\n\n<dependency>\n  <groupId>net.coobird</groupId>\n  <artifactId>thumbnailator</artifactId>\n  <version>[0.4, 0.5)</version>\n</dependency>\n\n\n\n# 图片缩放\n\nThumbnails.Builder 的 size 函数可以设置新图片精确的宽度和高度，也可以用 scale 函数设置缩放比例。\n\nThumbnails.of("oldFile.png")\n  .size(16, 16)\n  .toFile("newFile_16_16.png");\n\nThumbnails.of("oldFile.png")\n  .scale(2.0)\n  .toFile("newFile_scale_2.0.png");\n\nThumbnails.of("oldFile.png")\n  .scale(1.0, 0.5)\n  .toFile("newFile_scale_1.0_0.5.png");\n\n\noldFile.png\n\n\n\nnewFile_scale_1.0_0.5.png\n\n\n\n\n# 图片旋转\n\nThumbnails.Builder 的 size 函数可以设置新图片的旋转角度。\n\nThumbnails.of("oldFile.png")\n  .scale(0.8)\n  .rotate(90)\n  .toFile("newFile_rotate_90.png");\n\nThumbnails.of("oldFile.png")\n  .scale(0.8)\n  .rotate(180)\n  .toFile("newFile_rotate_180.png");\n\n\nnewFile_rotate_90.png\n\n\n\n\n# 加水印\n\nThumbnails.Builder 的 watermark 函数可以为图片添加水印图片。第一个参数是水印的位置；第二个参数是水印图片的缓存数据；第三个参数是透明度。\n\nBufferedImage watermarkImage = ImageIO.read(new File("wartermarkFile.png"));\nThumbnails.of("oldFile.png")\n  .scale(0.8)\n  .watermark(Positions.BOTTOM_LEFT, watermarkImage, 0.5f)\n  .toFile("newFile_watermark.png");\n\n\nwartermarkFile.png\n\n\n\nnewFile_watermark.png\n\n\n\n\n# 批量处理图片\n\n下面以批量给图片加水印来展示一下如何处理多个图片文件。\n\nBufferedImage watermarkImage = ImageIO.read(new File("wartermarkFile.png"));\n\nFile destinationDir = new File("D:\\\\watermark\\\\");\nThumbnails.of("oldFile.png", "oldFile2.png")\n  .scale(0.8)\n  .watermark(Positions.BOTTOM_LEFT, watermarkImage, 0.5f)\n  .toFiles(destinationDir, Rename.PREFIX_DOT_THUMBNAIL);\n\n\n> 需要参考完整测试例代码请 点击这里\n\n\n# 参考\n\nThumbnailator 官方示例文档',normalizedContent:'# thumbnailator 快速入门\n\n\n# 简介\n\nthumbnailator 是一个开源的 java 项目，它提供了非常简单的 api 来对图片进行缩放、旋转以及加水印的处理。\n\n有多简单呢？简单到一行代码就可以完成图片处理。形式如下：\n\nthumbnails.of(new file("path/to/directory").listfiles())\n    .size(640, 480)\n    .outputformat("jpg")\n    .tofiles(rename.prefix_dot_thumbnail);\n\n\n当然，thumbnailator 还有一些使用细节，下面我会一一道来。\n\n\n# 核心 api\n\n\n# thumbnails\n\nthumbnails 是使用 thumbnailator 创建缩略图的主入口。\n\n它提供了一组初始化 thumbnails.builder 的接口。\n\n先看下这组接口的声明：\n\n// 可变长度参数列表\npublic static builder<file> of(string... files) {...}\npublic static builder<file> of(file... files) {...}\npublic static builder<url> of(url... urls) {...}\npublic static builder<? extends inputstream> of(inputstream... inputstreams) {...}\npublic static builder<bufferedimage> of(bufferedimage... images) {...}\n// 迭代器（所有实现 iterable 接口的 java 对象都可以，当然也包括 list、set）\npublic static builder<file> fromfilenames(iterable<string> files) {...}\npublic static builder<file> fromfiles(iterable<file> files) {...}\npublic static builder<url> fromurls(iterable<url> urls) {...}\npublic static builder<inputstream> frominputstreams(iterable<? extends inputstream> inputstreams) {...}\npublic static builder<bufferedimage> fromimages(iterable<bufferedimage> images) {...}\n\n\n很显然，thumbnails 允许通过传入文件名、文件、网络图的 url、图片流、图片缓存多种方式来初始化构造器。\n\n因此，你可以根据实际需求来灵活的选择图片的输入方式。\n\n需要注意一点：如果输入是多个对象（无论你是直接输入容器对象或使用可变参数方式传入多个对象），则输出也必须选用输出多个对象的方式，否则会报异常。\n\n\n# thumbnails.builder\n\nthumbnails.builder 是 thumbnails 的内部静态类。它用于设置生成缩略图任务的相关参数。\n\n注：thumbnails.builder 的构造函数是私有函数。所以，它只允许通过 thumbnails 的实例化函数来进行初始化。\n\n# 设置参数的函数\n\nthumbnails.builder 提供了一组函数链形式的接口来设置缩放图参数。\n\n以设置大小函数为例：\n\npublic builder<t> size(int width, int height)\n{\n updatestatus(properties.size, status.already_set);\n updatestatus(properties.scale, status.cannot_set);\n\n validatedimensions(width, height);\n this.width = width;\n this.height = height;\n\n return this;\n}\n\n\n通过返回 this 指针，使得设置参数函数可以以链式调用的方式来使用，形式如下：\n\nthumbnails.of(new file("original.jpg"))\n        .size(160, 160)\n        .rotate(90)\n        .watermark(positions.bottom_right, imageio.read(new file("watermark.png")), 0.5f)\n        .outputquality(0.8)\n        .tofile(new file("image-with-watermark.jpg"));\n\n\n好处，不言自明：那就是大大简化了代码。\n\n# 输出函数\n\nthumbnails.builder 提供了一组重载函数来输出生成的缩放图。\n\n函数声明如下：\n\n// 返回图片缓存\npublic list<bufferedimage> asbufferedimages() throws ioexception {...}\npublic bufferedimage asbufferedimage() throws ioexception {...}\n// 返回文件列表\npublic list<file> asfiles(iterable<file> iterable) throws ioexception {...}\npublic list<file> asfiles(rename rename) throws ioexception {...}\npublic list<file> asfiles(file destinationdir, rename rename) throws ioexception {...}\n// 创建文件\npublic void tofile(file outfile) throws ioexception {...}\npublic void tofile(string outfilepath) throws ioexception {...}\npublic void tofiles(iterable<file> iterable) throws ioexception {...}\npublic void tofiles(rename rename) throws ioexception {...}\npublic void tofiles(file destinationdir, rename rename) throws ioexception {...}\n// 创建输出流\npublic void tooutputstream(outputstream os) throws ioexception {...}\npublic void tooutputstreams(iterable<? extends outputstream> iterable) throws ioexception {...}\n\n\n\n# 工作流\n\nthumbnailator 的工作步骤十分简单，可分为三步：\n\n 1. 输入：thumbnails 根据输入初始化构造器—— thumbnails.builder 。\n\n 2. 设置：thumbnails.builder 设置缩放图片的参数。\n\n 3. 输出：thumbnails.builder 输出图片文件或图片流。\n\n> 更多详情可以参考： thumbnailator 官网 javadoc\n\n\n# 实战\n\n前文介绍了 thumbnailator 的核心 api，接下来我们就可以通过实战来看看 thumbnailator 究竟可以做些什么。\n\nthumbnailator 生成什么样的图片，是根据设置参数来决定的。\n\n\n# 安装\n\nmaven 项目中引入依赖：\n\n<dependency>\n  <groupid>net.coobird</groupid>\n  <artifactid>thumbnailator</artifactid>\n  <version>[0.4, 0.5)</version>\n</dependency>\n\n\n\n# 图片缩放\n\nthumbnails.builder 的 size 函数可以设置新图片精确的宽度和高度，也可以用 scale 函数设置缩放比例。\n\nthumbnails.of("oldfile.png")\n  .size(16, 16)\n  .tofile("newfile_16_16.png");\n\nthumbnails.of("oldfile.png")\n  .scale(2.0)\n  .tofile("newfile_scale_2.0.png");\n\nthumbnails.of("oldfile.png")\n  .scale(1.0, 0.5)\n  .tofile("newfile_scale_1.0_0.5.png");\n\n\noldfile.png\n\n\n\nnewfile_scale_1.0_0.5.png\n\n\n\n\n# 图片旋转\n\nthumbnails.builder 的 size 函数可以设置新图片的旋转角度。\n\nthumbnails.of("oldfile.png")\n  .scale(0.8)\n  .rotate(90)\n  .tofile("newfile_rotate_90.png");\n\nthumbnails.of("oldfile.png")\n  .scale(0.8)\n  .rotate(180)\n  .tofile("newfile_rotate_180.png");\n\n\nnewfile_rotate_90.png\n\n\n\n\n# 加水印\n\nthumbnails.builder 的 watermark 函数可以为图片添加水印图片。第一个参数是水印的位置；第二个参数是水印图片的缓存数据；第三个参数是透明度。\n\nbufferedimage watermarkimage = imageio.read(new file("wartermarkfile.png"));\nthumbnails.of("oldfile.png")\n  .scale(0.8)\n  .watermark(positions.bottom_left, watermarkimage, 0.5f)\n  .tofile("newfile_watermark.png");\n\n\nwartermarkfile.png\n\n\n\nnewfile_watermark.png\n\n\n\n\n# 批量处理图片\n\n下面以批量给图片加水印来展示一下如何处理多个图片文件。\n\nbufferedimage watermarkimage = imageio.read(new file("wartermarkfile.png"));\n\nfile destinationdir = new file("d:\\\\watermark\\\\");\nthumbnails.of("oldfile.png", "oldfile2.png")\n  .scale(0.8)\n  .watermark(positions.bottom_left, watermarkimage, 0.5f)\n  .tofiles(destinationdir, rename.prefix_dot_thumbnail);\n\n\n> 需要参考完整测试例代码请 点击这里\n\n\n# 参考\n\nthumbnailator 官方示例文档',charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Java 工具",frontmatter:{title:"Java 工具",date:"2022-02-18T08:53:11.000Z",categories:["Java","工具"],tags:["Java","工具"],permalink:"/pages/1123e1/",hidden:!0,index:!1},regularPath:"/01.Java/12.%E5%B7%A5%E5%85%B7/",relativePath:"01.Java/12.工具/README.md",key:"v-78a970ba",path:"/pages/1123e1/",headers:[{level:2,title:"📖 内容",slug:"📖-内容",normalizedTitle:"📖 内容",charIndex:14},{level:3,title:"Java IO",slug:"java-io",normalizedTitle:"java io",charIndex:24},{level:3,title:"JavaBean 工具",slug:"javabean-工具",normalizedTitle:"javabean 工具",charIndex:118},{level:3,title:"Java 模板引擎",slug:"java-模板引擎",normalizedTitle:"java 模板引擎",charIndex:154},{level:3,title:"Java 测试工具",slug:"java-测试工具",normalizedTitle:"java 测试工具",charIndex:206},{level:3,title:"其他",slug:"其他",normalizedTitle:"其他",charIndex:258},{level:2,title:"📚 资料",slug:"📚-资料",normalizedTitle:"📚 资料",charIndex:351},{level:2,title:"🚪 传送",slug:"🚪-传送",normalizedTitle:"🚪 传送",charIndex:361}],headersStr:"📖 内容 Java IO JavaBean 工具 Java 模板引擎 Java 测试工具 其他 📚 资料 🚪 传送",content:"# Java 工具\n\n\n# 📖 内容\n\n\n# Java IO\n\n * JSON 序列化 - fastjson、Jackson、Gson\n * 二进制序列化 - Protobuf、Thrift、Hessian、Kryo、FST\n\n\n# JavaBean 工具\n\n * Lombok\n * Dozer\n\n\n# Java 模板引擎\n\n * Freemark\n * Velocity\n * Thymeleaf\n\n\n# Java 测试工具\n\n * Junit\n * Mockito\n * Jmeter\n * JMH\n\n\n# 其他\n\n * Java 日志\n * Java 工具包\n * Reflections\n * JavaMail\n * Jsoup\n * Thumbnailator\n * Zxing\n\n\n# 📚 资料\n\n\n# 🚪 传送\n\n◾ 💧 钝悟的 IT 知识图谱 ◾",normalizedContent:"# java 工具\n\n\n# 📖 内容\n\n\n# java io\n\n * json 序列化 - fastjson、jackson、gson\n * 二进制序列化 - protobuf、thrift、hessian、kryo、fst\n\n\n# javabean 工具\n\n * lombok\n * dozer\n\n\n# java 模板引擎\n\n * freemark\n * velocity\n * thymeleaf\n\n\n# java 测试工具\n\n * junit\n * mockito\n * jmeter\n * jmh\n\n\n# 其他\n\n * java 日志\n * java 工具包\n * reflections\n * javamail\n * jsoup\n * thumbnailator\n * zxing\n\n\n# 📚 资料\n\n\n# 🚪 传送\n\n◾ 💧 钝悟的 it 知识图谱 ◾",charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"ZXing 快速入门",frontmatter:{title:"ZXing 快速入门",date:"2022-02-17T22:34:30.000Z",order:7,categories:["Java","工具","其他"],tags:["Java","条形码","ZXing"],permalink:"/pages/b563af/"},regularPath:"/01.Java/12.%E5%B7%A5%E5%85%B7/99.%E5%85%B6%E4%BB%96/07.Zxing.html",relativePath:"01.Java/12.工具/99.其他/07.Zxing.md",key:"v-62f1222d",path:"/pages/b563af/",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:17},{level:2,title:"实战",slug:"实战",normalizedTitle:"实战",charIndex:164},{level:3,title:"安装",slug:"安装",normalizedTitle:"安装",charIndex:223},{level:3,title:"生成二维码图片",slug:"生成二维码图片",normalizedTitle:"生成二维码图片",charIndex:529},{level:3,title:"解析二维码图片",slug:"解析二维码图片",normalizedTitle:"解析二维码图片",charIndex:210},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:2066}],headersStr:"简介 实战 安装 生成二维码图片 解析二维码图片 参考",content:'# ZXing 快速入门\n\n\n# 简介\n\nZXing 是一个开源 Java 类库用于解析多种格式的 1D/2D 条形码。目标是能够对 QR 编码、Data Matrix、UPC 的 1D 条形码进行解码。 其提供了多种平台下的客户端包括：J2ME、J2SE 和 Android。\n\n官网：ZXing github 仓库\n\n\n# 实战\n\n本例演示如何在一个非 android 的 Java 项目中使用 ZXing 来生成、解析二维码图片。\n\n\n# 安装\n\nmaven 项目只需引入依赖：\n\n<dependency>\n  <groupId>com.google.zxing</groupId>\n  <artifactId>core</artifactId>\n  <version>3.3.0</version>\n</dependency>\n<dependency>\n  <groupId>com.google.zxing</groupId>\n  <artifactId>javase</artifactId>\n  <version>3.3.0</version>\n</dependency>\n\n\n如果非 maven 项目，就去官网下载发布版本：下载地址\n\n\n# 生成二维码图片\n\nZXing 生成二维码图片有以下步骤：\n\n 1. com.google.zxing.MultiFormatWriter 根据内容以及图像编码参数生成图像 2D 矩阵。\n 2. com.google.zxing.client.j2se.MatrixToImageWriter 根据图像矩阵生成图片文件或图片缓存 BufferedImage 。\n\npublic void encode(String content, String filepath) throws WriterException, IOException {\n int width = 100;\n int height = 100;\n Map<EncodeHintType, Object> encodeHints = new HashMap<EncodeHintType, Object>();\n encodeHints.put(EncodeHintType.CHARACTER_SET, "UTF-8");\n BitMatrix bitMatrix = new MultiFormatWriter().encode(content, BarcodeFormat.QR_CODE, width, height, encodeHints);\n Path path = FileSystems.getDefault().getPath(filepath);\n MatrixToImageWriter.writeToPath(bitMatrix, "png", path);\n}\n\n\n\n# 解析二维码图片\n\nZXing 解析二维码图片有以下步骤：\n\n 1. 使用 javax.imageio.ImageIO 读取图片文件，并存为一个 java.awt.image.BufferedImage 对象。\n\n 2. 将 java.awt.image.BufferedImage 转换为 ZXing 能识别的 com.google.zxing.BinaryBitmap 对象。\n\n 3. com.google.zxing.MultiFormatReader 根据图像解码参数来解析 com.google.zxing.BinaryBitmap 。\n\npublic String decode(String filepath) throws IOException, NotFoundException {\n BufferedImage bufferedImage = ImageIO.read(new FileInputStream(filepath));\n LuminanceSource source = new BufferedImageLuminanceSource(bufferedImage);\n Binarizer binarizer = new HybridBinarizer(source);\n BinaryBitmap bitmap = new BinaryBitmap(binarizer);\n HashMap<DecodeHintType, Object> decodeHints = new HashMap<DecodeHintType, Object>();\n decodeHints.put(DecodeHintType.CHARACTER_SET, "UTF-8");\n Result result = new MultiFormatReader().decode(bitmap, decodeHints);\n return result.getText();\n}\n\n\n完整参考示例：测试例代码\n\n以下是一个生成的二维码图片示例：\n\n\n\n\n# 参考\n\nZXing github 仓库',normalizedContent:'# zxing 快速入门\n\n\n# 简介\n\nzxing 是一个开源 java 类库用于解析多种格式的 1d/2d 条形码。目标是能够对 qr 编码、data matrix、upc 的 1d 条形码进行解码。 其提供了多种平台下的客户端包括：j2me、j2se 和 android。\n\n官网：zxing github 仓库\n\n\n# 实战\n\n本例演示如何在一个非 android 的 java 项目中使用 zxing 来生成、解析二维码图片。\n\n\n# 安装\n\nmaven 项目只需引入依赖：\n\n<dependency>\n  <groupid>com.google.zxing</groupid>\n  <artifactid>core</artifactid>\n  <version>3.3.0</version>\n</dependency>\n<dependency>\n  <groupid>com.google.zxing</groupid>\n  <artifactid>javase</artifactid>\n  <version>3.3.0</version>\n</dependency>\n\n\n如果非 maven 项目，就去官网下载发布版本：下载地址\n\n\n# 生成二维码图片\n\nzxing 生成二维码图片有以下步骤：\n\n 1. com.google.zxing.multiformatwriter 根据内容以及图像编码参数生成图像 2d 矩阵。\n 2. com.google.zxing.client.j2se.matrixtoimagewriter 根据图像矩阵生成图片文件或图片缓存 bufferedimage 。\n\npublic void encode(string content, string filepath) throws writerexception, ioexception {\n int width = 100;\n int height = 100;\n map<encodehinttype, object> encodehints = new hashmap<encodehinttype, object>();\n encodehints.put(encodehinttype.character_set, "utf-8");\n bitmatrix bitmatrix = new multiformatwriter().encode(content, barcodeformat.qr_code, width, height, encodehints);\n path path = filesystems.getdefault().getpath(filepath);\n matrixtoimagewriter.writetopath(bitmatrix, "png", path);\n}\n\n\n\n# 解析二维码图片\n\nzxing 解析二维码图片有以下步骤：\n\n 1. 使用 javax.imageio.imageio 读取图片文件，并存为一个 java.awt.image.bufferedimage 对象。\n\n 2. 将 java.awt.image.bufferedimage 转换为 zxing 能识别的 com.google.zxing.binarybitmap 对象。\n\n 3. com.google.zxing.multiformatreader 根据图像解码参数来解析 com.google.zxing.binarybitmap 。\n\npublic string decode(string filepath) throws ioexception, notfoundexception {\n bufferedimage bufferedimage = imageio.read(new fileinputstream(filepath));\n luminancesource source = new bufferedimageluminancesource(bufferedimage);\n binarizer binarizer = new hybridbinarizer(source);\n binarybitmap bitmap = new binarybitmap(binarizer);\n hashmap<decodehinttype, object> decodehints = new hashmap<decodehinttype, object>();\n decodehints.put(decodehinttype.character_set, "utf-8");\n result result = new multiformatreader().decode(bitmap, decodehints);\n return result.gettext();\n}\n\n\n完整参考示例：测试例代码\n\n以下是一个生成的二维码图片示例：\n\n\n\n\n# 参考\n\nzxing github 仓库',charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Spring Framework 综述",frontmatter:{title:"Spring Framework 综述",date:"2019-11-22T10:46:02.000Z",order:1,categories:["Java","框架","Spring","Spring综合"],tags:["Java","框架","Spring"],permalink:"/pages/9d3091/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/00.Spring%E7%BB%BC%E5%90%88/01.Spring%E6%A6%82%E8%BF%B0.html",relativePath:"01.Java/13.框架/01.Spring/00.Spring综合/01.Spring概述.md",key:"v-7d53b0b4",path:"/pages/9d3091/",headers:[{level:2,title:"Spring Framework 简介",slug:"spring-framework-简介",normalizedTitle:"spring framework 简介",charIndex:26},{level:2,title:"为什么使用 Spring",slug:"为什么使用-spring",normalizedTitle:"为什么使用 spring",charIndex:386},{level:2,title:"核心思想",slug:"核心思想",normalizedTitle:"核心思想",charIndex:1154},{level:3,title:"IoC",slug:"ioc",normalizedTitle:"ioc",charIndex:1179},{level:3,title:"Aop",slug:"aop",normalizedTitle:"aop",charIndex:1185},{level:2,title:"Spring 体系结构",slug:"spring-体系结构",normalizedTitle:"spring 体系结构",charIndex:2004},{level:3,title:"Core Container",slug:"core-container",normalizedTitle:"core container",charIndex:2138},{level:4,title:"BeanFactory",slug:"beanfactory",normalizedTitle:"beanfactory",charIndex:2167},{level:4,title:"ApplicationContext",slug:"applicationcontext",normalizedTitle:"applicationcontext",charIndex:2193},{level:3,title:"AOP and Instrumentation",slug:"aop-and-instrumentation",normalizedTitle:"aop and instrumentation",charIndex:2222},{level:3,title:"Messaging",slug:"messaging",normalizedTitle:"messaging",charIndex:2256},{level:3,title:"Data Access / Integaration",slug:"data-access-integaration",normalizedTitle:"data access / integaration",charIndex:2276},{level:3,title:"Web",slug:"web",normalizedTitle:"web",charIndex:2313},{level:3,title:"Test",slug:"test",normalizedTitle:"test",charIndex:2327},{level:2,title:"术语",slug:"术语",normalizedTitle:"术语",charIndex:2338}],headersStr:"Spring Framework 简介 为什么使用 Spring 核心思想 IoC Aop Spring 体系结构 Core Container BeanFactory ApplicationContext AOP and Instrumentation Messaging Data Access / Integaration Web Test 术语",content:'# Spring Framework 综述\n\n\n# Spring Framework 简介\n\nSpring Framework 是最受欢迎的企业级 Java 应用程序开发框架。用于构建企业级应用的轻量级、一站式解决方案。\n\n当谈论到大小和透明度时， Spring 是轻量级的。 Spring 框架的基础版本是在 2 MB 左右的。\n\nSpring 框架的核心特性可以用于开发任何 Java 应用程序，但是在 Java EE 平台上构建 web 应用程序是需要扩展的。 Spring 框架的目标是使 J2EE 开发变得更容易使用，通过启用基于 POJO 编程模型来促进良好的编程实践。\n\nSpring Framework 设计理念如下：\n\n * 力争让选择无处不在\n * 体现海纳百川的精神\n * 保持后向兼容性\n * 专注 API 设计\n * 追求严苛的代码质量\n\n\n# 为什么使用 Spring\n\n下面列出的是使用 Spring 框架主要的好处：\n\n * Spring 可以使开发人员使用 POJOs 开发企业级的应用程序。只使用 POJOs 的好处是你不需要一个 EJB 容器产品，比如一个应用程序服务器，但是你可以选择使用一个健壮的 servlet 容器，比如 Tomcat 或者一些商业产品。\n * Spring 在一个单元模式中是有组织的。即使包和类的数量非常大，你只需要选择你需要的部分，而忽略剩余的那部分。\n * Spring 不会让你白费力气做重复工作，它真正的利用了一些现有的技术，像几个 ORM 框架、日志框架、JEE、Quartz 和 JDK 计时器，其他视图技术。\n * 测试一个用 Spring 编写的应用程序很容易，因为 environment-dependent 代码被放进了这个框架中。此外，通过使用 JavaBean-style POJOs，它在使用依赖注入注入测试数据时变得更容易。\n * Spring 的 web 框架是一个设计良好的 web MVC 框架，它为 web 框架，比如 Structs 或者其他工程上的或者很少受欢迎的 web 框架，提供了一个很好的供替代的选择。\n * 为将特定技术的异常（例如，由 JDBC、Hibernate，或者 JDO 抛出的异常）翻译成一致的， Spring 提供了一个方便的 API，而这些都是未经检验的异常。\n * 轻量级的 IOC 容器往往是轻量级的，例如，特别是当与 EJB 容器相比的时候。这有利于在内存和 CPU 资源有限的计算机上开发和部署应用程序。\n * Spring 提供了一个一致的事务管理界面，该界面可以缩小成一个本地事务（例如，使用一个单一的数据库）和扩展成一个全局事务（例如，使用 JTA）。\n\n\n# 核心思想\n\nSpring 最核心的两个技术思想是：IoC 和 Aop\n\n\n# IoC\n\nIoC 即 Inversion of Control ，意为控制反转。\n\nSpring 最认同的技术是控制反转的**依赖注入（DI）**模式。控制反转（IoC）是一个通用的概念，它可以用许多不同的方式去表达，依赖注入仅仅是控制反转的一个具体的例子。\n\n当编写一个复杂的 Java 应用程序时，应用程序类应该尽可能的独立于其他的 Java 类来增加这些类可重用可能性，当进行单元测试时，可以使它们独立于其他类进行测试。依赖注入（或者有时被称为配线）有助于将这些类粘合在一起，并且在同一时间让它们保持独立。\n\n到底什么是依赖注入？让我们将这两个词分开来看一看。这里将依赖关系部分转化为两个类之间的关联。例如，类 A 依赖于类 B。现在，让我们看一看第二部分，注入。所有这一切都意味着类 B 将通过 IoC 被注入到类 A 中。\n\n依赖注入可以以向构造函数传递参数的方式发生，或者通过使用 setter 方法 post-construction。由于依赖注入是 Spring 框架的核心部分，所以我将在一个单独的章节中利用很好的例子去解释这一概念。\n\n\n# Aop\n\nSpring 框架的一个关键组件是面向方面的程序设计（AOP）框架。一个程序中跨越多个点的功能被称为横切关注点，这些横切关注点在概念上独立于应用程序的业务逻辑。有各种各样常见的很好的关于方面的例子，比如日志记录、声明性事务、安全性，和缓存等等。\n\n在 OOP 中模块化的关键单元是类，而在 AOP 中模块化的关键单元是方面。AOP 帮助你将横切关注点从它们所影响的对象中分离出来，然而依赖注入帮助你将你的应用程序对象从彼此中分离出来。\n\nSpring 框架的 AOP 模块提供了面向方面的程序设计实现，允许你定义拦截器方法和切入点，可以实现将应该被分开的代码干净的分开功能。我将在一个独立的章节中讨论更多关于 Spring AOP 的概念。\n\n\n# Spring 体系结构\n\nSpring 当前框架有20个 jar 包，大致可以分为6大模块:\n\n * 1. 为什么使用 Spring\n * 2. 核心思想\n   * 2.1. IoC\n   * 2.2. Aop\n * 3. Spring 体系结构\n   * 3.1. Core Container\n     * 3.1.1. BeanFactory\n     * 3.1.2. ApplicationContext\n   * 3.2. AOP and Instrumentation\n   * 3.3. Messaging\n   * 3.4. Data Access / Integaration\n   * 3.5. Web\n   * 3.6. Test\n * 4. 术语\n\nSpring 框架提供了非常丰富的功能，因此整个架构也很庞大。 在我们实际的应用开发中，并不一定要使用所有的功能，而是可以根据需要选择合适的 Spring 模块。\n\n\n\n\n# Core Container\n\nIoC 容器是 Spring 框架的核心。spring 容器使用依赖注入管理构成应用的组件，它会创建相互协作的组件之间的关联。毫无疑问，这些对象更简单干净，更容易理解，也更容易重用和测试。 Spring 自带了几种容器的实现，可归纳为两种类型：\n\n# BeanFactory\n\n由 org.springframework.beans.factory.BeanFactory 接口定义。 它是最简单的容器，提供基本的 DI 支持。\n\n# ApplicationContext\n\n由 org.springframework.context.ApplicationContext 接口定义。 它是基于 BeanFactory 之上构建，并提供面向应用的服务，例如从属性文件解析文本信息的能力，以及发布应用事件给感兴趣的事件监听者的能力。 注：Bean 工厂对于大多数应用来说往往太低级了，所以应用上下文使用更广泛。推荐在开发中使用应用上下文容器。\n\nSpring 自带了多种应用上下文，最可能遇到的有以下几种： ClassPathXmlApplicationContext：从类路径下的 XML 配置文件中加载上下文定义，把应用上下文定义文件当做类资源。 FileSystemXmlApplicationContext：读取文件系统下的 XML 配置文件并加载上下文定义。 XmlWebApplicationContext：读取 Web 应用下的 XML 配置文件并装载上下文定义。\n\n范例\n\nApplicationContext context = new FileSystemXmlApplicationContext("D:\\Temp\\build.xml");\nApplicationContext context2 = new ClassPathXmlApplicationContext("build.xml");\n\n\n可以看到，加载 FileSystemXmlApplicationContext 和 ClassPathXmlApplicationContext 十分相似。 差异在于：前者在指定文件系统路径下查找 build.xml 文件；而后在所有类路径（包含 JAR 文件）下查找 build.xml 文件。 通过引用应用上下文，可以很方便的调用 getBean() 方法从 Spring 容器中获取 Bean。\n\n相关 jar 包\n\n * spring-core, spring-beans, 提供框架的基础部分，包括 IoC 和依赖注入特性。\n\n * spring-context, 在spring-core, spring-beans基础上构建。它提供一种框架式的访问对象的方法。它也支持类似 Java EE 特性，例如：EJB，JMX 和基本 remoting。ApplicationContext 接口是它的聚焦点。\n\n * springcontext-support, 集成第三方库到 Spring application context。\n\n * spring-expression，提供一种强有力的表达语言在运行时来查询和操纵一个对象图。\n\n\n# AOP and Instrumentation\n\n相关 jar 包\n\n * spring-aop，提供了对面向切面编程的丰富支持。\n * spring-aspects，提供了对 AspectJ 的集成。\n * spring-instrument，提供了对类 instrumentation 的支持和类加载器。\n * spring-instrument-tomcat，包含了 Spring 对 Tomcat 的 instrumentation 代理。\n\n\n# Messaging\n\n相关 jar 包\n\n * spring-messaging，包含 spring 的消息处理功能，如 Message，MessageChannel，MessageHandler。\n\n\n# Data Access / Integaration\n\nData Access/Integration 层包含了 JDBC / ORM / OXM / JMS 和 Transaction 模块。\n\n相关 jar 包\n\n * spring-jdbc，提供了一个 JDBC 抽象层。\n\n * spring-tx，支持编程和声明式事务管理类。\n\n * spring-orm，提供了流行的对象关系型映射 API 集，如 JPA，JDO，Hibernate。\n\n * spring-oxm，提供了一个抽象层以支持对象/XML 映射的实现，如 JAXB，Castor，XMLBeans，JiBX 和 XStream.\n\n * spring-jms，包含了生产和消费消息的功能。\n\n\n# Web\n\n相关 jar 包\n\n * spring-web，提供了基本的面向 web 的功能，如多文件上传、使用 Servlet 监听器的 Ioc 容器的初始化。一个面向 web 的应用层上下文。\n\n * spring-webmvc，包括 MVC 和 REST web 服务实现。\n\n * spring-webmvc-portlet，提供在 Protlet 环境的 MVC 实现和spring-webmvc功能的镜像。\n\n\n# Test\n\n相关 jar 包\n\n * spring-test，以 Junit 和 TestNG 来支持 spring 组件的单元测试和集成测试。\n\n\n# 术语\n\n * 应用程序：是能完成我们所需要功能的成品，比如购物网站、OA 系统。\n * 框架：是能完成一定功能的半成品，比如我们可以使用框架进行购物网站开发；框架做一部分功能，我们自己做一部分功能，这样应用程序就创建出来了。而且框架规定了你在开发应用程序时的整体架构，提供了一些基础功能，还规定了类和对象的如何创建、如何协作等，从而简化我们开发，让我们专注于业务逻辑开发。\n * 非侵入式设计：从框架角度可以这样理解，无需继承框架提供的类，这种设计就可以看作是非侵入式设计，如果继承了这些框架类，就是侵入设计，如果以后想更换框架之前写过的代码几乎无法重用，如果非侵入式设计则之前写过的代码仍然可以继续使用。\n * 轻量级及重量级：轻量级是相对于重量级而言的，轻量级一般就是非入侵性的、所依赖的东西非常少、资源占用非常少、部署简单等等，其实就是比较容易使用，而重量级正好相反。\n * POJO：POJO（Plain Old Java Objects）简单的 Java 对象，它可以包含业务逻辑或持久化逻辑，但不担当任何特殊角色且不继承或不实现任何其它 Java 框架的类或接口。\n * 容器：在日常生活中容器就是一种盛放东西的器具，从程序设计角度看就是装对象的的对象，因为存在放入、拿出等操作，所以容器还要管理对象的生命周期。\n * **控制反转：**即 Inversion of Control，缩写为 IoC，控制反转还有一个名字叫做依赖注入（Dependency Injection），就是由容器控制程序之间的关系，而非传统实现中，由程序代码直接操控。\n * JavaBean：一般指容器管理对象，在 Spring 中指 Spring IoC 容器管理对象。',normalizedContent:'# spring framework 综述\n\n\n# spring framework 简介\n\nspring framework 是最受欢迎的企业级 java 应用程序开发框架。用于构建企业级应用的轻量级、一站式解决方案。\n\n当谈论到大小和透明度时， spring 是轻量级的。 spring 框架的基础版本是在 2 mb 左右的。\n\nspring 框架的核心特性可以用于开发任何 java 应用程序，但是在 java ee 平台上构建 web 应用程序是需要扩展的。 spring 框架的目标是使 j2ee 开发变得更容易使用，通过启用基于 pojo 编程模型来促进良好的编程实践。\n\nspring framework 设计理念如下：\n\n * 力争让选择无处不在\n * 体现海纳百川的精神\n * 保持后向兼容性\n * 专注 api 设计\n * 追求严苛的代码质量\n\n\n# 为什么使用 spring\n\n下面列出的是使用 spring 框架主要的好处：\n\n * spring 可以使开发人员使用 pojos 开发企业级的应用程序。只使用 pojos 的好处是你不需要一个 ejb 容器产品，比如一个应用程序服务器，但是你可以选择使用一个健壮的 servlet 容器，比如 tomcat 或者一些商业产品。\n * spring 在一个单元模式中是有组织的。即使包和类的数量非常大，你只需要选择你需要的部分，而忽略剩余的那部分。\n * spring 不会让你白费力气做重复工作，它真正的利用了一些现有的技术，像几个 orm 框架、日志框架、jee、quartz 和 jdk 计时器，其他视图技术。\n * 测试一个用 spring 编写的应用程序很容易，因为 environment-dependent 代码被放进了这个框架中。此外，通过使用 javabean-style pojos，它在使用依赖注入注入测试数据时变得更容易。\n * spring 的 web 框架是一个设计良好的 web mvc 框架，它为 web 框架，比如 structs 或者其他工程上的或者很少受欢迎的 web 框架，提供了一个很好的供替代的选择。\n * 为将特定技术的异常（例如，由 jdbc、hibernate，或者 jdo 抛出的异常）翻译成一致的， spring 提供了一个方便的 api，而这些都是未经检验的异常。\n * 轻量级的 ioc 容器往往是轻量级的，例如，特别是当与 ejb 容器相比的时候。这有利于在内存和 cpu 资源有限的计算机上开发和部署应用程序。\n * spring 提供了一个一致的事务管理界面，该界面可以缩小成一个本地事务（例如，使用一个单一的数据库）和扩展成一个全局事务（例如，使用 jta）。\n\n\n# 核心思想\n\nspring 最核心的两个技术思想是：ioc 和 aop\n\n\n# ioc\n\nioc 即 inversion of control ，意为控制反转。\n\nspring 最认同的技术是控制反转的**依赖注入（di）**模式。控制反转（ioc）是一个通用的概念，它可以用许多不同的方式去表达，依赖注入仅仅是控制反转的一个具体的例子。\n\n当编写一个复杂的 java 应用程序时，应用程序类应该尽可能的独立于其他的 java 类来增加这些类可重用可能性，当进行单元测试时，可以使它们独立于其他类进行测试。依赖注入（或者有时被称为配线）有助于将这些类粘合在一起，并且在同一时间让它们保持独立。\n\n到底什么是依赖注入？让我们将这两个词分开来看一看。这里将依赖关系部分转化为两个类之间的关联。例如，类 a 依赖于类 b。现在，让我们看一看第二部分，注入。所有这一切都意味着类 b 将通过 ioc 被注入到类 a 中。\n\n依赖注入可以以向构造函数传递参数的方式发生，或者通过使用 setter 方法 post-construction。由于依赖注入是 spring 框架的核心部分，所以我将在一个单独的章节中利用很好的例子去解释这一概念。\n\n\n# aop\n\nspring 框架的一个关键组件是面向方面的程序设计（aop）框架。一个程序中跨越多个点的功能被称为横切关注点，这些横切关注点在概念上独立于应用程序的业务逻辑。有各种各样常见的很好的关于方面的例子，比如日志记录、声明性事务、安全性，和缓存等等。\n\n在 oop 中模块化的关键单元是类，而在 aop 中模块化的关键单元是方面。aop 帮助你将横切关注点从它们所影响的对象中分离出来，然而依赖注入帮助你将你的应用程序对象从彼此中分离出来。\n\nspring 框架的 aop 模块提供了面向方面的程序设计实现，允许你定义拦截器方法和切入点，可以实现将应该被分开的代码干净的分开功能。我将在一个独立的章节中讨论更多关于 spring aop 的概念。\n\n\n# spring 体系结构\n\nspring 当前框架有20个 jar 包，大致可以分为6大模块:\n\n * 1. 为什么使用 spring\n * 2. 核心思想\n   * 2.1. ioc\n   * 2.2. aop\n * 3. spring 体系结构\n   * 3.1. core container\n     * 3.1.1. beanfactory\n     * 3.1.2. applicationcontext\n   * 3.2. aop and instrumentation\n   * 3.3. messaging\n   * 3.4. data access / integaration\n   * 3.5. web\n   * 3.6. test\n * 4. 术语\n\nspring 框架提供了非常丰富的功能，因此整个架构也很庞大。 在我们实际的应用开发中，并不一定要使用所有的功能，而是可以根据需要选择合适的 spring 模块。\n\n\n\n\n# core container\n\nioc 容器是 spring 框架的核心。spring 容器使用依赖注入管理构成应用的组件，它会创建相互协作的组件之间的关联。毫无疑问，这些对象更简单干净，更容易理解，也更容易重用和测试。 spring 自带了几种容器的实现，可归纳为两种类型：\n\n# beanfactory\n\n由 org.springframework.beans.factory.beanfactory 接口定义。 它是最简单的容器，提供基本的 di 支持。\n\n# applicationcontext\n\n由 org.springframework.context.applicationcontext 接口定义。 它是基于 beanfactory 之上构建，并提供面向应用的服务，例如从属性文件解析文本信息的能力，以及发布应用事件给感兴趣的事件监听者的能力。 注：bean 工厂对于大多数应用来说往往太低级了，所以应用上下文使用更广泛。推荐在开发中使用应用上下文容器。\n\nspring 自带了多种应用上下文，最可能遇到的有以下几种： classpathxmlapplicationcontext：从类路径下的 xml 配置文件中加载上下文定义，把应用上下文定义文件当做类资源。 filesystemxmlapplicationcontext：读取文件系统下的 xml 配置文件并加载上下文定义。 xmlwebapplicationcontext：读取 web 应用下的 xml 配置文件并装载上下文定义。\n\n范例\n\napplicationcontext context = new filesystemxmlapplicationcontext("d:\\temp\\build.xml");\napplicationcontext context2 = new classpathxmlapplicationcontext("build.xml");\n\n\n可以看到，加载 filesystemxmlapplicationcontext 和 classpathxmlapplicationcontext 十分相似。 差异在于：前者在指定文件系统路径下查找 build.xml 文件；而后在所有类路径（包含 jar 文件）下查找 build.xml 文件。 通过引用应用上下文，可以很方便的调用 getbean() 方法从 spring 容器中获取 bean。\n\n相关 jar 包\n\n * spring-core, spring-beans, 提供框架的基础部分，包括 ioc 和依赖注入特性。\n\n * spring-context, 在spring-core, spring-beans基础上构建。它提供一种框架式的访问对象的方法。它也支持类似 java ee 特性，例如：ejb，jmx 和基本 remoting。applicationcontext 接口是它的聚焦点。\n\n * springcontext-support, 集成第三方库到 spring application context。\n\n * spring-expression，提供一种强有力的表达语言在运行时来查询和操纵一个对象图。\n\n\n# aop and instrumentation\n\n相关 jar 包\n\n * spring-aop，提供了对面向切面编程的丰富支持。\n * spring-aspects，提供了对 aspectj 的集成。\n * spring-instrument，提供了对类 instrumentation 的支持和类加载器。\n * spring-instrument-tomcat，包含了 spring 对 tomcat 的 instrumentation 代理。\n\n\n# messaging\n\n相关 jar 包\n\n * spring-messaging，包含 spring 的消息处理功能，如 message，messagechannel，messagehandler。\n\n\n# data access / integaration\n\ndata access/integration 层包含了 jdbc / orm / oxm / jms 和 transaction 模块。\n\n相关 jar 包\n\n * spring-jdbc，提供了一个 jdbc 抽象层。\n\n * spring-tx，支持编程和声明式事务管理类。\n\n * spring-orm，提供了流行的对象关系型映射 api 集，如 jpa，jdo，hibernate。\n\n * spring-oxm，提供了一个抽象层以支持对象/xml 映射的实现，如 jaxb，castor，xmlbeans，jibx 和 xstream.\n\n * spring-jms，包含了生产和消费消息的功能。\n\n\n# web\n\n相关 jar 包\n\n * spring-web，提供了基本的面向 web 的功能，如多文件上传、使用 servlet 监听器的 ioc 容器的初始化。一个面向 web 的应用层上下文。\n\n * spring-webmvc，包括 mvc 和 rest web 服务实现。\n\n * spring-webmvc-portlet，提供在 protlet 环境的 mvc 实现和spring-webmvc功能的镜像。\n\n\n# test\n\n相关 jar 包\n\n * spring-test，以 junit 和 testng 来支持 spring 组件的单元测试和集成测试。\n\n\n# 术语\n\n * 应用程序：是能完成我们所需要功能的成品，比如购物网站、oa 系统。\n * 框架：是能完成一定功能的半成品，比如我们可以使用框架进行购物网站开发；框架做一部分功能，我们自己做一部分功能，这样应用程序就创建出来了。而且框架规定了你在开发应用程序时的整体架构，提供了一些基础功能，还规定了类和对象的如何创建、如何协作等，从而简化我们开发，让我们专注于业务逻辑开发。\n * 非侵入式设计：从框架角度可以这样理解，无需继承框架提供的类，这种设计就可以看作是非侵入式设计，如果继承了这些框架类，就是侵入设计，如果以后想更换框架之前写过的代码几乎无法重用，如果非侵入式设计则之前写过的代码仍然可以继续使用。\n * 轻量级及重量级：轻量级是相对于重量级而言的，轻量级一般就是非入侵性的、所依赖的东西非常少、资源占用非常少、部署简单等等，其实就是比较容易使用，而重量级正好相反。\n * pojo：pojo（plain old java objects）简单的 java 对象，它可以包含业务逻辑或持久化逻辑，但不担当任何特殊角色且不继承或不实现任何其它 java 框架的类或接口。\n * 容器：在日常生活中容器就是一种盛放东西的器具，从程序设计角度看就是装对象的的对象，因为存在放入、拿出等操作，所以容器还要管理对象的生命周期。\n * **控制反转：**即 inversion of control，缩写为 ioc，控制反转还有一个名字叫做依赖注入（dependency injection），就是由容器控制程序之间的关系，而非传统实现中，由程序代码直接操控。\n * javabean：一般指容器管理对象，在 spring 中指 spring ioc 容器管理对象。',charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"SpringBoot 知识图谱",frontmatter:{title:"SpringBoot 知识图谱",date:"2020-08-12T07:01:26.000Z",order:21,categories:["Java","框架","Spring","Spring综合"],tags:["Java","框架","Spring","SpringBoot"],permalink:"/pages/430f53/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/00.Spring%E7%BB%BC%E5%90%88/21.SpringBoot%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1.html",relativePath:"01.Java/13.框架/01.Spring/00.Spring综合/21.SpringBoot知识图谱.md",key:"v-aebe0138",path:"/pages/430f53/",headers:[{level:2,title:"一、抛砖引玉：探索 Spring IoC 容器",slug:"一、抛砖引玉-探索-spring-ioc-容器",normalizedTitle:"一、抛砖引玉：探索 spring ioc 容器",charIndex:722},{level:3,title:"1.1、Spring IoC 容器",slug:"_1-1、spring-ioc-容器",normalizedTitle:"1.1、spring ioc 容器",charIndex:911},{level:3,title:"1.2、Spring 容器扩展机制",slug:"_1-2、spring-容器扩展机制",normalizedTitle:"1.2、spring 容器扩展机制",charIndex:4067},{level:2,title:"二、夯实基础：JavaConfig 与常见 Annotation",slug:"二、夯实基础-javaconfig-与常见-annotation",normalizedTitle:"二、夯实基础：javaconfig 与常见 annotation",charIndex:6857},{level:3,title:"2.1、JavaConfig",slug:"_2-1、javaconfig",normalizedTitle:"2.1、javaconfig",charIndex:6894},{level:3,title:"2.2、@ComponentScan",slug:"_2-2、-componentscan",normalizedTitle:"2.2、@componentscan",charIndex:8790},{level:3,title:"2.3、@Import",slug:"_2-3、-import",normalizedTitle:"2.3、@import",charIndex:9028},{level:3,title:"2.4、@Conditional",slug:"_2-4、-conditional",normalizedTitle:"2.4、@conditional",charIndex:9693},{level:3,title:"2.5、@ConfigurationProperties 与@EnableConfigurationProperties",slug:"_2-5、-configurationproperties-与-enableconfigurationproperties",normalizedTitle:"2.5、@configurationproperties 与@enableconfigurationproperties",charIndex:11433},{level:2,title:"三、削铁如泥：SpringFactoriesLoader 详解",slug:"三、削铁如泥-springfactoriesloader-详解",normalizedTitle:"三、削铁如泥：springfactoriesloader 详解",charIndex:14026},{level:2,title:"四、另一件武器：Spring 容器的事件监听机制",slug:"四、另一件武器-spring-容器的事件监听机制",normalizedTitle:"四、另一件武器：spring 容器的事件监听机制",charIndex:19858},{level:4,title:"Spring 容器内的事件监听机制",slug:"spring-容器内的事件监听机制",normalizedTitle:"spring 容器内的事件监听机制",charIndex:23057},{level:2,title:"五、出神入化：揭秘自动配置原理",slug:"五、出神入化-揭秘自动配置原理",normalizedTitle:"五、出神入化：揭秘自动配置原理",charIndex:24228},{level:2,title:"六、启动引导：Spring Boot 应用启动的秘密",slug:"六、启动引导-spring-boot-应用启动的秘密",normalizedTitle:"六、启动引导：spring boot 应用启动的秘密",charIndex:28598},{level:3,title:"6.1 SpringApplication 初始化",slug:"_6-1-springapplication-初始化",normalizedTitle:"6.1 springapplication 初始化",charIndex:28629},{level:3,title:"6.2 Spring Boot 启动流程",slug:"_6-2-spring-boot-启动流程",normalizedTitle:"6.2 spring boot 启动流程",charIndex:30395},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:36499}],headersStr:"一、抛砖引玉：探索 Spring IoC 容器 1.1、Spring IoC 容器 1.2、Spring 容器扩展机制 二、夯实基础：JavaConfig 与常见 Annotation 2.1、JavaConfig 2.2、@ComponentScan 2.3、@Import 2.4、@Conditional 2.5、@ConfigurationProperties 与@EnableConfigurationProperties 三、削铁如泥：SpringFactoriesLoader 详解 四、另一件武器：Spring 容器的事件监听机制 Spring 容器内的事件监听机制 五、出神入化：揭秘自动配置原理 六、启动引导：Spring Boot 应用启动的秘密 6.1 SpringApplication 初始化 6.2 Spring Boot 启动流程 参考资料",content:'# SpringBoot 知识图谱\n\n>  1. 预警：本文非常长，建议先 mark 后看，也许是最后一次写这么长的文章\n>  2. 说明：前面有 4 个小节关于 Spring 的基础知识，分别是：IOC 容器、JavaConfig、事件监听、SpringFactoriesLoader 详解，它们占据了本文的大部分内容，虽然它们之间可能没有太多的联系，但这些知识对于理解 Spring Boot 的核心原理至关重要，如果你对 Spring 框架烂熟于心，完全可以跳过这 4 个小节。正是因为这个系列的文章是由这些看似不相关的知识点组成，因此取名知识清单。\n\n在过去两三年的 Spring 生态圈，最让人兴奋的莫过于 Spring Boot 框架。或许从命名上就能看出这个框架的设计初衷：快速的启动 Spring 应用。因而 Spring Boot 应用本质上就是一个基于 Spring 框架的应用，它是 Spring 对“约定优先于配置”理念的最佳实践产物，它能够帮助开发者更快速高效地构建基于 Spring 生态圈的应用。\n\n那 Spring Boot 有何魔法？自动配置、起步依赖、Actuator、命令行界面(CLI) 是 Spring Boot 最重要的 4 大核心特性，其中 CLI 是 Spring Boot 的可选特性，虽然它功能强大，但也引入了一套不太常规的开发模型，因而这个系列的文章仅关注其它 3 种特性。如文章标题，本文是这个系列的第一部分，将为你打开 Spring Boot 的大门，重点为你剖析其启动流程以及自动配置实现原理。要掌握这部分核心内容，理解一些 Spring 框架的基础知识，将会让你事半功倍。\n\n\n# 一、抛砖引玉：探索 Spring IoC 容器\n\n如果有看过SpringApplication.run()方法的源码，Spring Boot 冗长无比的启动流程一定会让你抓狂，透过现象看本质，SpringApplication 只是将一个典型的 Spring 应用的启动流程进行了扩展，因此，透彻理解 Spring 容器是打开 Spring Boot 大门的一把钥匙。\n\n\n# 1.1、Spring IoC 容器\n\n可以把 Spring IoC 容器比作一间餐馆，当你来到餐馆，通常会直接招呼服务员：点菜！至于菜的原料是什么？如何用原料把菜做出来？可能你根本就不关心。IoC 容器也是一样，你只需要告诉它需要某个 bean，它就把对应的实例（instance）扔给你，至于这个 bean 是否依赖其他组件，怎样完成它的初始化，根本就不需要你关心。\n\n作为餐馆，想要做出菜肴，得知道菜的原料和菜谱，同样地，IoC 容器想要管理各个业务对象以及它们之间的依赖关系，需要通过某种途径来记录和管理这些信息。BeanDefinition对象就承担了这个责任：容器中的每一个 bean 都会有一个对应的 BeanDefinition 实例，该实例负责保存 bean 对象的所有必要信息，包括 bean 对象的 class 类型、是否是抽象类、构造方法和参数、其它属性等等。当客户端向容器请求相应对象时，容器就会通过这些信息为客户端返回一个完整可用的 bean 实例。\n\n原材料已经准备好（把 BeanDefinition 看着原料），开始做菜吧，等等，你还需要一份菜谱，BeanDefinitionRegistry和BeanFactory就是这份菜谱，BeanDefinitionRegistry 抽象出 bean 的注册逻辑，而 BeanFactory 则抽象出了 bean 的管理逻辑，而各个 BeanFactory 的实现类就具体承担了 bean 的注册以及管理工作。它们之间的关系就如下图：\n\nBeanFactory、BeanDefinitionRegistry 关系图（来自：Spring 揭秘）\n\nDefaultListableBeanFactory作为一个比较通用的 BeanFactory 实现，它同时也实现了 BeanDefinitionRegistry 接口，因此它就承担了 Bean 的注册管理工作。从图中也可以看出，BeanFactory 接口中主要包含 getBean、containBean、getType、getAliases 等管理 bean 的方法，而 BeanDefinitionRegistry 接口则包含 registerBeanDefinition、removeBeanDefinition、getBeanDefinition 等注册管理 BeanDefinition 的方法。\n\n下面通过一段简单的代码来模拟 BeanFactory 底层是如何工作的：\n\n// 默认容器实现\nDefaultListableBeanFactory beanRegistry = new DefaultListableBeanFactory();\n// 根据业务对象构造相应的BeanDefinition\nAbstractBeanDefinition definition = new RootBeanDefinition(Business.class,true);\n// 将bean定义注册到容器中\nbeanRegistry.registerBeanDefinition("beanName",definition);\n// 如果有多个bean，还可以指定各个bean之间的依赖关系\n// ........\n\n// 然后可以从容器中获取这个bean的实例\n// 注意：这里的beanRegistry其实实现了BeanFactory接口，所以可以强转，\n// 单纯的BeanDefinitionRegistry是无法强制转换到BeanFactory类型的\nBeanFactory container = (BeanFactory)beanRegistry;\nBusiness business = (Business)container.getBean("beanName");\n\n\n这段代码仅为了说明 BeanFactory 底层的大致工作流程，实际情况会更加复杂，比如 bean 之间的依赖关系可能定义在外部配置文件(XML/Properties)中、也可能是注解方式。Spring IoC 容器的整个工作流程大致可以分为两个阶段：\n\n①、容器启动阶段\n\n容器启动时，会通过某种途径加载Configuration MetaData。除了代码方式比较直接外，在大部分情况下，容器需要依赖某些工具类，比如：BeanDefinitionReader，BeanDefinitionReader 会对加载的Configuration MetaData进行解析和分析，并将分析后的信息组装为相应的 BeanDefinition，最后把这些保存了 bean 定义的 BeanDefinition，注册到相应的 BeanDefinitionRegistry，这样容器的启动工作就完成了。这个阶段主要完成一些准备性工作，更侧重于 bean 对象管理信息的收集，当然一些验证性或者辅助性的工作也在这一阶段完成。\n\n来看一个简单的例子吧，过往，所有的 bean 都定义在 XML 配置文件中，下面的代码将模拟 BeanFactory 如何从配置文件中加载 bean 的定义以及依赖关系：\n\n// 通常为BeanDefinitionRegistry的实现类，这里以DeFaultListabeBeanFactory为例\nBeanDefinitionRegistry beanRegistry = new DefaultListableBeanFactory();\n// XmlBeanDefinitionReader实现了BeanDefinitionReader接口，用于解析XML文件\nXmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReaderImpl(beanRegistry);\n// 加载配置文件\nbeanDefinitionReader.loadBeanDefinitions("classpath:spring-bean.xml");\n\n// 从容器中获取bean实例\nBeanFactory container = (BeanFactory)beanRegistry;\nBusiness business = (Business)container.getBean("beanName");\n\n\n②、Bean 的实例化阶段\n\n经过第一阶段，所有 bean 定义都通过 BeanDefinition 的方式注册到 BeanDefinitionRegistry 中，当某个请求通过容器的 getBean 方法请求某个对象，或者因为依赖关系容器需要隐式的调用 getBean 时，就会触发第二阶段的活动：容器会首先检查所请求的对象之前是否已经实例化完成。如果没有，则会根据注册的 BeanDefinition 所提供的信息实例化被请求对象，并为其注入依赖。当该对象装配完毕后，容器会立即将其返回给请求方法使用。\n\nBeanFactory 只是 Spring IoC 容器的一种实现，如果没有特殊指定，它采用采用延迟初始化策略：只有当访问容器中的某个对象时，才对该对象进行初始化和依赖注入操作。而在实际场景下，我们更多的使用另外一种类型的容器：ApplicationContext，它构建在 BeanFactory 之上，属于更高级的容器，除了具有 BeanFactory 的所有能力之外，还提供对事件监听机制以及国际化的支持等。它管理的 bean，在容器启动时全部完成初始化和依赖注入操作。\n\n\n# 1.2、Spring 容器扩展机制\n\nIoC 容器负责管理容器中所有 bean 的生命周期，而在 bean 生命周期的不同阶段，Spring 提供了不同的扩展点来改变 bean 的命运。在容器的启动阶段，BeanFactoryPostProcessor允许我们在容器实例化相应对象之前，对注册到容器的 BeanDefinition 所保存的信息做一些额外的操作，比如修改 bean 定义的某些属性或者增加其他信息等。\n\n如果要自定义扩展类，通常需要实现org.springframework.beans.factory.config.BeanFactoryPostProcessor接口，与此同时，因为容器中可能有多个 BeanFactoryPostProcessor，可能还需要实现org.springframework.core.Ordered接口，以保证 BeanFactoryPostProcessor 按照顺序执行。Spring 提供了为数不多的 BeanFactoryPostProcessor 实现，我们以PropertyPlaceholderConfigurer来说明其大致的工作流程。\n\n在 Spring 项目的 XML 配置文件中，经常可以看到许多配置项的值使用占位符，而将占位符所代表的值单独配置到独立的 properties 文件，这样可以将散落在不同 XML 文件中的配置集中管理，而且也方便运维根据不同的环境进行配置不同的值。这个非常实用的功能就是由 PropertyPlaceholderConfigurer 负责实现的。\n\n根据前文，当 BeanFactory 在第一阶段加载完所有配置信息时，BeanFactory 中保存的对象的属性还是以占位符方式存在的，比如${jdbc.mysql.url}。当 PropertyPlaceholderConfigurer 作为 BeanFactoryPostProcessor 被应用时，它会使用 properties 配置文件中的值来替换相应的 BeanDefinition 中占位符所表示的属性值。当需要实例化 bean 时，bean 定义中的属性值就已经被替换成我们配置的值。当然其实现比上面描述的要复杂一些，这里仅说明其大致工作原理，更详细的实现可以参考其源码。\n\n与之相似的，还有BeanPostProcessor，其存在于对象实例化阶段。跟 BeanFactoryPostProcessor 类似，它会处理容器内所有符合条件并且已经实例化后的对象。简单的对比，BeanFactoryPostProcessor 处理 bean 的定义，而 BeanPostProcessor 则处理 bean 完成实例化后的对象。BeanPostProcessor 定义了两个接口：\n\npublic interface BeanPostProcessor {\n    // 前置处理\n    Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException;\n    // 后置处理\n    Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException;\n}\n\n\n为了理解这两个方法执行的时机，简单的了解下 bean 的整个生命周期：\n\npostProcessBeforeInitialization()方法与postProcessAfterInitialization()分别对应图中前置处理和后置处理两个步骤将执行的方法。这两个方法中都传入了 bean 对象实例的引用，为扩展容器的对象实例化过程提供了很大便利，在这儿几乎可以对传入的实例执行任何操作。注解、AOP 等功能的实现均大量使用了BeanPostProcessor，比如有一个自定义注解，你完全可以实现 BeanPostProcessor 的接口，在其中判断 bean 对象的脑袋上是否有该注解，如果有，你可以对这个 bean 实例执行任何操作，想想是不是非常的简单？\n\n再来看一个更常见的例子，在 Spring 中经常能够看到各种各样的 Aware 接口，其作用就是在对象实例化完成以后将 Aware 接口定义中规定的依赖注入到当前实例中。比如最常见的ApplicationContextAware接口，实现了这个接口的类都可以获取到一个 ApplicationContext 对象。当容器中每个对象的实例化过程走到 BeanPostProcessor 前置处理这一步时，容器会检测到之前注册到容器的 ApplicationContextAwareProcessor，然后就会调用其 postProcessBeforeInitialization()方法，检查并设置 Aware 相关依赖。看看代码吧，是不是很简单：\n\n// 代码来自：org.springframework.context.support.ApplicationContextAwareProcessor\n// 其postProcessBeforeInitialization方法调用了invokeAwareInterfaces方法\nprivate void invokeAwareInterfaces(Object bean) {\n    if (bean instanceof EnvironmentAware) {\n        ((EnvironmentAware) bean).setEnvironment(this.applicationContext.getEnvironment());\n    }\n    if (bean instanceof ApplicationContextAware) {\n        ((ApplicationContextAware) bean).setApplicationContext(this.applicationContext);\n    }\n    // ......\n}\n\n\n最后总结一下，本小节内容和你一起回顾了 Spring 容器的部分核心内容，限于篇幅不能写更多，但理解这部分内容，足以让您轻松理解 Spring Boot 的启动原理，如果在后续的学习过程中遇到一些晦涩难懂的知识，再回过头来看看 Spring 的核心知识，也许有意想不到的效果。也许 Spring Boot 的中文资料很少，但 Spring 的中文资料和书籍有太多太多，总有东西能给你启发。\n\n\n# 二、夯实基础：JavaConfig 与常见 Annotation\n\n\n# 2.1、JavaConfig\n\n我们知道bean是 Spring IOC 中非常核心的概念，Spring 容器负责 bean 的生命周期的管理。在最初，Spring 使用 XML 配置文件的方式来描述 bean 的定义以及相互间的依赖关系，但随着 Spring 的发展，越来越多的人对这种方式表示不满，因为 Spring 项目的所有业务类均以 bean 的形式配置在 XML 文件中，造成了大量的 XML 文件，使项目变得复杂且难以管理。\n\n后来，基于纯 Java Annotation 依赖注入框架Guice出世，其性能明显优于采用 XML 方式的 Spring，甚至有部分人认为，Guice可以完全取代 Spring（Guice仅是一个轻量级 IOC 框架，取代 Spring 还差的挺远）。正是这样的危机感，促使 Spring 及社区推出并持续完善了JavaConfig子项目，它基于 Java 代码和 Annotation 注解来描述 bean 之间的依赖绑定关系。比如，下面是使用 XML 配置方式来描述 bean 的定义：\n\n<bean id="bookService" class="cn.moondev.service.BookServiceImpl"></bean>\n\n\n而基于 JavaConfig 的配置形式是这样的：\n\n@Configuration\npublic class MoonBookConfiguration {\n\n    // 任何标志了@Bean的方法，其返回值将作为一个bean注册到Spring的IOC容器中\n    // 方法名默认成为该bean定义的id\n    @Bean\n    public BookService bookService() {\n        return new BookServiceImpl();\n    }\n}\n\n\n如果两个 bean 之间有依赖关系的话，在 XML 配置中应该是这样：\n\n<bean id="bookService" class="cn.moondev.service.BookServiceImpl">\n    <property name="dependencyService" ref="dependencyService"/>\n</bean>\n\n<bean id="otherService" class="cn.moondev.service.OtherServiceImpl">\n    <property name="dependencyService" ref="dependencyService"/>\n</bean>\n\n<bean id="dependencyService" class="DependencyServiceImpl"/>\n\n\n而在 JavaConfig 中则是这样：\n\n@Configuration\npublic class MoonBookConfiguration {\n\n    // 如果一个bean依赖另一个bean，则直接调用对应JavaConfig类中依赖bean的创建方法即可\n    // 这里直接调用dependencyService()\n    @Bean\n    public BookService bookService() {\n        return new BookServiceImpl(dependencyService());\n    }\n\n    @Bean\n    public OtherService otherService() {\n        return new OtherServiceImpl(dependencyService());\n    }\n\n    @Bean\n    public DependencyService dependencyService() {\n        return new DependencyServiceImpl();\n    }\n}\n\n\n你可能注意到这个示例中，有两个 bean 都依赖于 dependencyService，也就是说当初始化 bookService 时会调用dependencyService()，在初始化 otherService 时也会调用dependencyService()，那么问题来了？这时候 IOC 容器中是有一个 dependencyService 实例还是两个？这个问题留着大家思考吧，这里不再赘述。\n\n\n# 2.2、@ComponentScan\n\n@ComponentScan注解对应 XML 配置形式中的``元素，表示启用组件扫描，Spring 会自动扫描所有通过注解配置的 bean，然后将其注册到 IOC 容器中。我们可以通过basePackages等属性来指定@ComponentScan自动扫描的范围，如果不指定，默认从声明@ComponentScan所在类的package进行扫描。正因为如此，SpringBoot 的启动类都默认在src/main/java下。\n\n\n# 2.3、@Import\n\n@Import注解用于导入配置类，举个简单的例子：\n\n@Configuration\npublic class MoonBookConfiguration {\n    @Bean\n    public BookService bookService() {\n        return new BookServiceImpl();\n    }\n}\n\n\n现在有另外一个配置类，比如：MoonUserConfiguration，这个配置类中有一个 bean 依赖于MoonBookConfiguration中的 bookService，如何将这两个 bean 组合在一起？借助@Import即可：\n\n@Configuration\n// 可以同时导入多个配置类，比如：@Import({A.class,B.class})\n@Import(MoonBookConfiguration.class)\npublic class MoonUserConfiguration {\n    @Bean\n    public UserService userService(BookService bookService) {\n        return new BookServiceImpl(bookService);\n    }\n}\n\n\n需要注意的是，在 4.2 之前，@Import注解只支持导入配置类，但是在 4.2 之后，它支持导入普通类，并将这个类作为一个 bean 的定义注册到 IOC 容器中。\n\n\n# 2.4、@Conditional\n\n@Conditional注解表示在满足某种条件后才初始化一个 bean 或者启用某些配置。它一般用在由@Component、@Service、@Configuration等注解标识的类上面，或者由@Bean标记的方法上。如果一个@Configuration类标记了@Conditional，则该类中所有标识了@Bean的方法和@Import注解导入的相关类将遵从这些条件。\n\n在 Spring 里可以很方便的编写你自己的条件类，所要做的就是实现Condition接口，并覆盖它的matches()方法。举个例子，下面的简单条件类表示只有在Classpath里存在JdbcTemplate类时才生效：\n\npublic class JdbcTemplateCondition implements Condition {\n\n    @Override\n    public boolean matches(ConditionContext conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata) {\n        try {\n        conditionContext.getClassLoader().loadClass("org.springframework.jdbc.core.JdbcTemplate");\n            return true;\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n        return false;\n    }\n}\n\n\n当你用 Java 来声明 bean 的时候，可以使用这个自定义条件类：\n\n@Conditional(JdbcTemplateCondition.class)\n@Service\npublic MyService service() {\n    ......\n}\n\n\n这个例子中只有当JdbcTemplateCondition类的条件成立时才会创建 MyService 这个 bean。也就是说 MyService 这 bean 的创建条件是classpath里面包含JdbcTemplate，否则这个 bean 的声明就会被忽略掉。\n\nSpring Boot定义了很多有趣的条件，并把他们运用到了配置类上，这些配置类构成了Spring Boot的自动配置的基础。Spring Boot运用条件化配置的方法是：定义多个特殊的条件化注解，并将它们用到配置类上。下面列出了Spring Boot提供的部分条件化注解：\n\n条件化注解                             配置生效条件\n@ConditionalOnBean                配置了某个特定 bean\n@ConditionalOnMissingBean         没有配置特定的 bean\n@ConditionalOnClass               Classpath 里有指定的类\n@ConditionalOnMissingClass        Classpath 里没有指定的类\n@ConditionalOnExpression          给定的 Spring Expression Language 表达式计算结果为 true\n@ConditionalOnJava                Java 的版本匹配特定指或者一个范围值\n@ConditionalOnProperty            指定的配置属性要有一个明确的值\n@ConditionalOnResource            Classpath 里有指定的资源\n@ConditionalOnWebApplication      这是一个 Web 应用程序\n@ConditionalOnNotWebApplication   这不是一个 Web 应用程序\n\n\n# 2.5、@ConfigurationProperties 与@EnableConfigurationProperties\n\n当某些属性的值需要配置的时候，我们一般会在application.properties文件中新建配置项，然后在 bean 中使用@Value注解来获取配置的值，比如下面配置数据源的代码。\n\n// jdbc config\njdbc.mysql.url=jdbc:mysql://localhost:3306/sampledb\njdbc.mysql.username=root\njdbc.mysql.password=123456\n......\n\n// 配置数据源\n@Configuration\npublic class HikariDataSourceConfiguration {\n\n    @Value("jdbc.mysql.url")\n    public String url;\n    @Value("jdbc.mysql.username")\n    public String user;\n    @Value("jdbc.mysql.password")\n    public String password;\n\n    @Bean\n    public HikariDataSource dataSource() {\n        HikariConfig hikariConfig = new HikariConfig();\n        hikariConfig.setJdbcUrl(url);\n        hikariConfig.setUsername(user);\n        hikariConfig.setPassword(password);\n        // 省略部分代码\n        return new HikariDataSource(hikariConfig);\n    }\n}\n\n\n使用@Value注解注入的属性通常都比较简单，如果同一个配置在多个地方使用，也存在不方便维护的问题（考虑下，如果有几十个地方在使用某个配置，而现在你想改下名字，你改怎么做？）。对于更为复杂的配置，Spring Boot 提供了更优雅的实现方式，那就是@ConfigurationProperties注解。我们可以通过下面的方式来改写上面的代码：\n\n@Component\n//  还可以通过@PropertySource("classpath:jdbc.properties")来指定配置文件\n@ConfigurationProperties("jdbc.mysql")\n// 前缀=jdbc.mysql，会在配置文件中寻找jdbc.mysql.*的配置项\npulic class JdbcConfig {\n    public String url;\n    public String username;\n    public String password;\n}\n\n@Configuration\npublic class HikariDataSourceConfiguration {\n\n    @AutoWired\n    public JdbcConfig config;\n\n    @Bean\n    public HikariDataSource dataSource() {\n        HikariConfig hikariConfig = new HikariConfig();\n        hikariConfig.setJdbcUrl(config.url);\n        hikariConfig.setUsername(config.username);\n        hikariConfig.setPassword(config.password);\n        // 省略部分代码\n        return new HikariDataSource(hikariConfig);\n    }\n}\n\n\n@ConfigurationProperties对于更为复杂的配置，处理起来也是得心应手，比如有如下配置文件：\n\n#App\napp.menus[0].title=Home\napp.menus[0].name=Home\napp.menus[0].path=/\napp.menus[1].title=Login\napp.menus[1].name=Login\napp.menus[1].path=/login\n\napp.compiler.timeout=5\napp.compiler.output-folder=/temp/\n\napp.error=/error/\n\n\n可以定义如下配置类来接收这些属性\n\n@Component\n@ConfigurationProperties("app")\npublic class AppProperties {\n\n    public String error;\n    public List<Menu> menus = new ArrayList<>();\n    public Compiler compiler = new Compiler();\n\n    public static class Menu {\n        public String name;\n        public String path;\n        public String title;\n    }\n\n    public static class Compiler {\n        public String timeout;\n        public String outputFolder;\n    }\n}\n\n\n@EnableConfigurationProperties注解表示对@ConfigurationProperties的内嵌支持，默认会将对应 Properties Class 作为 bean 注入的 IOC 容器中，即在相应的 Properties 类上不用加@Component注解。\n\n\n# 三、削铁如泥：SpringFactoriesLoader 详解\n\nJVM 提供了 3 种类加载器：BootstrapClassLoader、ExtClassLoader、AppClassLoader分别加载 Java 核心类库、扩展类库以及应用的类路径(CLASSPATH)下的类库。JVM 通过双亲委派模型进行类的加载，我们也可以通过继承java.lang.classloader实现自己的类加载器。\n\n何为双亲委派模型？当一个类加载器收到类加载任务时，会先交给自己的父加载器去完成，因此最终加载任务都会传递到最顶层的 BootstrapClassLoader，只有当父加载器无法完成加载任务时，才会尝试自己来加载。\n\n采用双亲委派模型的一个好处是保证使用不同类加载器最终得到的都是同一个对象，这样就可以保证 Java 核心库的类型安全，比如，加载位于 rt.jar 包中的java.lang.Object类，不管是哪个加载器加载这个类，最终都是委托给顶层的 BootstrapClassLoader 来加载的，这样就可以保证任何的类加载器最终得到的都是同样一个 Object 对象。查看 ClassLoader 的源码，对双亲委派模型会有更直观的认识：\n\nprotected Class<?> loadClass(String name, boolean resolve) {\n    synchronized (getClassLoadingLock(name)) {\n    // 首先，检查该类是否已经被加载，如果从JVM缓存中找到该类，则直接返回\n    Class<?> c = findLoadedClass(name);\n    if (c == null) {\n        try {\n            // 遵循双亲委派的模型，首先会通过递归从父加载器开始找，\n            // 直到父类加载器是BootstrapClassLoader为止\n            if (parent != null) {\n                c = parent.loadClass(name, false);\n            } else {\n                c = findBootstrapClassOrNull(name);\n            }\n        } catch (ClassNotFoundException e) {}\n        if (c == null) {\n            // 如果还找不到，尝试通过findClass方法去寻找\n            // findClass是留给开发者自己实现的，也就是说\n            // 自定义类加载器时，重写此方法即可\n           c = findClass(name);\n        }\n    }\n    if (resolve) {\n        resolveClass(c);\n    }\n    return c;\n    }\n}\n\n\n但双亲委派模型并不能解决所有的类加载器问题，比如，Java 提供了很多服务提供者接口(Service Provider Interface，SPI)，允许第三方为这些接口提供实现。常见的 SPI 有 JDBC、JNDI、JAXP 等，这些 SPI 的接口由核心类库提供，却由第三方实现，这样就存在一个问题：SPI 的接口是 Java 核心库的一部分，是由 BootstrapClassLoader 加载的；SPI 实现的 Java 类一般是由 AppClassLoader 来加载的。BootstrapClassLoader 是无法找到 SPI 的实现类的，因为它只加载 Java 的核心库。它也不能代理给 AppClassLoader，因为它是最顶层的类加载器。也就是说，双亲委派模型并不能解决这个问题。\n\n线程上下文类加载器(ContextClassLoader)正好解决了这个问题。从名称上看，可能会误解为它是一种新的类加载器，实际上，它仅仅是 Thread 类的一个变量而已，可以通过setContextClassLoader(ClassLoader cl)和getContextClassLoader()来设置和获取该对象。如果不做任何的设置，Java 应用的线程的上下文类加载器默认就是 AppClassLoader。在核心类库使用 SPI 接口时，传递的类加载器使用线程上下文类加载器，就可以成功的加载到 SPI 实现的类。线程上下文类加载器在很多 SPI 的实现中都会用到。但在 JDBC 中，你可能会看到一种更直接的实现方式，比如，JDBC 驱动管理java.sql.Driver中的loadInitialDrivers()方法中，你可以直接看到 JDK 是如何加载驱动的：\n\nfor (String aDriver : driversList) {\n    try {\n        // 直接使用AppClassLoader\n        Class.forName(aDriver, true, ClassLoader.getSystemClassLoader());\n    } catch (Exception ex) {\n        println("DriverManager.Initialize: load failed: " + ex);\n    }\n}\n\n\n其实讲解线程上下文类加载器，最主要是让大家在看到Thread.currentThread().getClassLoader()和Thread.currentThread().getContextClassLoader()时不会一脸懵逼，这两者除了在许多底层框架中取得的 ClassLoader 可能会有所不同外，其他大多数业务场景下都是一样的，大家只要知道它是为了解决什么问题而存在的即可。\n\n类加载器除了加载 class 外，还有一个非常重要功能，就是加载资源，它可以从 jar 包中读取任何资源文件，比如，ClassLoader.getResources(String name)方法就是用于读取 jar 包中的资源文件，其代码如下：\n\npublic Enumeration<URL> getResources(String name) throws IOException {\n    Enumeration<URL>[] tmp = (Enumeration<URL>[]) new Enumeration<?>[2];\n    if (parent != null) {\n        tmp[0] = parent.getResources(name);\n    } else {\n        tmp[0] = getBootstrapResources(name);\n    }\n    tmp[1] = findResources(name);\n    return new CompoundEnumeration<>(tmp);\n}\n\n\n是不是觉得有点眼熟，不错，它的逻辑其实跟类加载的逻辑是一样的，首先判断父类加载器是否为空，不为空则委托父类加载器执行资源查找任务，直到 BootstrapClassLoader，最后才轮到自己查找。而不同的类加载器负责扫描不同路径下的 jar 包，就如同加载 class 一样，最后会扫描所有的 jar 包，找到符合条件的资源文件。\n\n类加载器的findResources(name)方法会遍历其负责加载的所有 jar 包，找到 jar 包中名称为 name 的资源文件，这里的资源可以是任何文件，甚至是.class 文件，比如下面的示例，用于查找 Array.class 文件：\n\n// 寻找Array.class文件\npublic static void main(String[] args) throws Exception{\n    // Array.class的完整路径\n    String name = "java/sql/Array.class";\n    Enumeration<URL> urls = Thread.currentThread().getContextClassLoader().getResources(name);\n    while (urls.hasMoreElements()) {\n        URL url = urls.nextElement();\n        System.out.println(url.toString());\n    }\n}\n\n\n运行后可以得到如下结果：\n\n$JAVA_HOME/jre/lib/rt.jar!/java/sql/Array.class\n\n\n根据资源文件的 URL，可以构造相应的文件来读取资源内容。\n\n看到这里，你可能会感到挺奇怪的，你不是要详解SpringFactoriesLoader吗？上来讲了一堆 ClassLoader 是几个意思？看下它的源码你就知道了：\n\npublic static final String FACTORIES_RESOURCE_LOCATION = "META-INF/spring.factories";\n// spring.factories文件的格式为：key=value1,value2,value3\n// 从所有的jar包中找到META-INF/spring.factories文件\n// 然后从文件中解析出key=factoryClass类名称的所有value值\npublic static List<String> loadFactoryNames(Class<?> factoryClass, ClassLoader classLoader) {\n    String factoryClassName = factoryClass.getName();\n    // 取得资源文件的URL\n    Enumeration<URL> urls = (classLoader != null ? classLoader.getResources(FACTORIES_RESOURCE_LOCATION) : ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));\n    List<String> result = new ArrayList<String>();\n    // 遍历所有的URL\n    while (urls.hasMoreElements()) {\n        URL url = urls.nextElement();\n        // 根据资源文件URL解析properties文件\n        Properties properties = PropertiesLoaderUtils.loadProperties(new UrlResource(url));\n        String factoryClassNames = properties.getProperty(factoryClassName);\n        // 组装数据，并返回\n        result.addAll(Arrays.asList(StringUtils.commaDelimitedListToStringArray(factoryClassNames)));\n    }\n    return result;\n}\n\n\n有了前面关于 ClassLoader 的知识，再来理解这段代码，是不是感觉豁然开朗：从CLASSPATH下的每个 Jar 包中搜寻所有META-INF/spring.factories配置文件，然后将解析 properties 文件，找到指定名称的配置后返回。需要注意的是，其实这里不仅仅是会去 ClassPath 路径下查找，会扫描所有路径下的 Jar 包，只不过这个文件只会在 Classpath 下的 jar 包中。来简单看下spring.factories文件的内容吧：\n\n// 来自 org.springframework.boot.autoconfigure下的META-INF/spring.factories\n// EnableAutoConfiguration后文会讲到，它用于开启Spring Boot自动配置功能\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\norg.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\\norg.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\\norg.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration\\\n\n\n执行loadFactoryNames(EnableAutoConfiguration.class, classLoader)后，得到对应的一组@Configuration类， 我们就可以通过反射实例化这些类然后注入到 IOC 容器中，最后容器里就有了一系列标注了@Configuration的 JavaConfig 形式的配置类。\n\n这就是SpringFactoriesLoader，它本质上属于 Spring 框架私有的一种扩展方案，类似于 SPI，Spring Boot 在 Spring 基础上的很多核心功能都是基于此，希望大家可以理解。\n\n\n# 四、另一件武器：Spring 容器的事件监听机制\n\n过去，事件监听机制多用于图形界面编程，比如：点击按钮、在文本框输入内容等操作被称为事件，而当事件触发时，应用程序作出一定的响应则表示应用监听了这个事件，而在服务器端，事件的监听机制更多的用于异步通知以及监控和异常处理。Java 提供了实现事件监听机制的两个基础类：自定义事件类型扩展自java.util.EventObject、事件的监听器扩展自java.util.EventListener。来看一个简单的实例：简单的监控一个方法的耗时。\n\n首先定义事件类型，通常的做法是扩展 EventObject，随着事件的发生，相应的状态通常都封装在此类中：\n\npublic class MethodMonitorEvent extends EventObject {\n    // 时间戳，用于记录方法开始执行的时间\n    public long timestamp;\n\n    public MethodMonitorEvent(Object source) {\n        super(source);\n    }\n}\n\n\n事件发布之后，相应的监听器即可对该类型的事件进行处理，我们可以在方法开始执行之前发布一个 begin 事件，在方法执行结束之后发布一个 end 事件，相应地，事件监听器需要提供方法对这两种情况下接收到的事件进行处理：\n\n// 1、定义事件监听接口\npublic interface MethodMonitorEventListener extends EventListener {\n    // 处理方法执行之前发布的事件\n    public void onMethodBegin(MethodMonitorEvent event);\n    // 处理方法结束时发布的事件\n    public void onMethodEnd(MethodMonitorEvent event);\n}\n// 2、事件监听接口的实现：如何处理\npublic class AbstractMethodMonitorEventListener implements MethodMonitorEventListener {\n\n    @Override\n    public void onMethodBegin(MethodMonitorEvent event) {\n        // 记录方法开始执行时的时间\n        event.timestamp = System.currentTimeMillis();\n    }\n\n    @Override\n    public void onMethodEnd(MethodMonitorEvent event) {\n        // 计算方法耗时\n        long duration = System.currentTimeMillis() - event.timestamp;\n        System.out.println("耗时：" + duration);\n    }\n}\n\n\n事件监听器接口针对不同的事件发布实际提供相应的处理方法定义，最重要的是，其方法只接收 MethodMonitorEvent 参数，说明这个监听器类只负责监听器对应的事件并进行处理。有了事件和监听器，剩下的就是发布事件，然后让相应的监听器监听并处理。通常情况，我们会有一个事件发布者，它本身作为事件源，在合适的时机，将相应的事件发布给对应的事件监听器：\n\npublic class MethodMonitorEventPublisher {\n\n    private List<MethodMonitorEventListener> listeners = new ArrayList<MethodMonitorEventListener>();\n\n    public void methodMonitor() {\n        MethodMonitorEvent eventObject = new MethodMonitorEvent(this);\n        publishEvent("begin",eventObject);\n        // 模拟方法执行：休眠5秒钟\n        TimeUnit.SECONDS.sleep(5);\n        publishEvent("end",eventObject);\n\n    }\n\n    private void publishEvent(String status,MethodMonitorEvent event) {\n        // 避免在事件处理期间，监听器被移除，这里为了安全做一个复制操作\n        List<MethodMonitorEventListener> copyListeners = ➥ new ArrayList<MethodMonitorEventListener>(listeners);\n        for (MethodMonitorEventListener listener : copyListeners) {\n            if ("begin".equals(status)) {\n                listener.onMethodBegin(event);\n            } else {\n                listener.onMethodEnd(event);\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        MethodMonitorEventPublisher publisher = new MethodMonitorEventPublisher();\n        publisher.addEventListener(new AbstractMethodMonitorEventListener());\n        publisher.methodMonitor();\n    }\n    // 省略实现\n    public void addEventListener(MethodMonitorEventListener listener) {}\n    public void removeEventListener(MethodMonitorEventListener listener) {}\n    public void removeAllListeners() {}\n\n\n对于事件发布者（事件源）通常需要关注两点：\n\n 1. 在合适的时机发布事件。此例中的 methodMonitor()方法是事件发布的源头，其在方法执行之前和结束之后两个时间点发布 MethodMonitorEvent 事件，每个时间点发布的事件都会传给相应的监听器进行处理。在具体实现时需要注意的是，事件发布是顺序执行，为了不影响处理性能，事件监听器的处理逻辑应尽量简单。\n 2. 事件监听器的管理。publisher 类中提供了事件监听器的注册与移除方法，这样客户端可以根据实际情况决定是否需要注册新的监听器或者移除某个监听器。如果这里没有提供 remove 方法，那么注册的监听器示例将一直被 MethodMonitorEventPublisher 引用，即使已经废弃不用了，也依然在发布者的监听器列表中，这会导致隐性的内存泄漏。\n\n# Spring 容器内的事件监听机制\n\nSpring 的 ApplicationContext 容器内部中的所有事件类型均继承自org.springframework.context.ApplicationEvent，容器中的所有监听器都实现org.springframework.context.ApplicationListener接口，并且以 bean 的形式注册在容器中。一旦在容器内发布 ApplicationEvent 及其子类型的事件，注册到容器的 ApplicationListener 就会对这些事件进行处理。\n\n你应该已经猜到是怎么回事了。\n\nApplicationEvent 继承自 EventObject，Spring 提供了一些默认的实现，比如：ContextClosedEvent表示容器在即将关闭时发布的事件类型，ContextRefreshedEvent表示容器在初始化或者刷新的时候发布的事件类型......\n\n容器内部使用 ApplicationListener 作为事件监听器接口定义，它继承自 EventListener。ApplicationContext 容器在启动时，会自动识别并加载 EventListener 类型的 bean，一旦容器内有事件发布，将通知这些注册到容器的 EventListener。\n\nApplicationContext 接口继承了 ApplicationEventPublisher 接口，该接口提供了void publishEvent(ApplicationEvent event)方法定义，不难看出，ApplicationContext 容器担当的就是事件发布者的角色。如果有兴趣可以查看AbstractApplicationContext.publishEvent(ApplicationEvent event)方法的源码：ApplicationContext 将事件的发布以及监听器的管理工作委托给ApplicationEventMulticaster接口的实现类。在容器启动时，会检查容器内是否存在名为 applicationEventMulticaster 的 ApplicationEventMulticaster 对象实例。如果有就使用其提供的实现，没有就默认初始化一个 SimpleApplicationEventMulticaster 作为实现。\n\n最后，如果我们业务需要在容器内部发布事件，只需要为其注入 ApplicationEventPublisher 依赖即可：实现 ApplicationEventPublisherAware 接口或者 ApplicationContextAware 接口(Aware 接口相关内容请回顾上文)。\n\n\n# 五、出神入化：揭秘自动配置原理\n\n典型的 Spring Boot 应用的启动类一般均位于src/main/java根路径下，比如MoonApplication类：\n\n@SpringBootApplication\npublic class MoonApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(MoonApplication.class, args);\n    }\n}\n\n\n其中@SpringBootApplication开启组件扫描和自动配置，而SpringApplication.run则负责启动引导应用程序。@SpringBootApplication是一个复合Annotation，它将三个有用的注解组合在一起：\n\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@SpringBootConfiguration\n@EnableAutoConfiguration\n@ComponentScan(excludeFilters = {\n        @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),\n        @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })\npublic @interface SpringBootApplication {\n    // ......\n}\n\n\n@SpringBootConfiguration就是@Configuration，它是 Spring 框架的注解，标明该类是一个JavaConfig配置类。而@ComponentScan启用组件扫描，前文已经详细讲解过，这里着重关注@EnableAutoConfiguration。\n\n@EnableAutoConfiguration注解表示开启 Spring Boot 自动配置功能，Spring Boot 会根据应用的依赖、自定义的 bean、classpath 下有没有某个类 等等因素来猜测你需要的 bean，然后注册到 IOC 容器中。那@EnableAutoConfiguration是如何推算出你的需求？首先看下它的定义：\n\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@AutoConfigurationPackage\n@Import(EnableAutoConfigurationImportSelector.class)\npublic @interface EnableAutoConfiguration {\n    // ......\n}\n\n\n你的关注点应该在@Import(EnableAutoConfigurationImportSelector.class)上了，前文说过，@Import注解用于导入类，并将这个类作为一个 bean 的定义注册到容器中，这里它将把EnableAutoConfigurationImportSelector作为 bean 注入到容器中，而这个类会将所有符合条件的@Configuration 配置都加载到容器中，看看它的代码：\n\npublic String[] selectImports(AnnotationMetadata annotationMetadata) {\n    // 省略了大部分代码，保留一句核心代码\n    // 注意：SpringBoot最近版本中，这句代码被封装在一个单独的方法中\n    // SpringFactoriesLoader相关知识请参考前文\n    List<String> factories = new ArrayList<String>(new LinkedHashSet<String>(\n        SpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class, this.beanClassLoader)));\n}\n\n\n这个类会扫描所有的 jar 包，将所有符合条件的@Configuration 配置类注入的容器中，何为符合条件，看看META-INF/spring.factories的文件内容：\n\n// 来自 org.springframework.boot.autoconfigure下的META-INF/spring.factories\n// 配置的key = EnableAutoConfiguration，与代码中一致\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\norg.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\\\norg.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\\norg.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration\\\n.....\n\n\n以DataSourceAutoConfiguration为例，看看 Spring Boot 是如何自动配置的：\n\n@Configuration\n@ConditionalOnClass({ DataSource.class, EmbeddedDatabaseType.class })\n@EnableConfigurationProperties(DataSourceProperties.class)\n@Import({ Registrar.class, DataSourcePoolMetadataProvidersConfiguration.class })\npublic class DataSourceAutoConfiguration {\n}\n\n\n分别说一说：\n\n * @ConditionalOnClass({ DataSource.class, EmbeddedDatabaseType.class })：当 Classpath 中存在 DataSource 或者 EmbeddedDatabaseType 类时才启用这个配置，否则这个配置将被忽略。\n * @EnableConfigurationProperties(DataSourceProperties.class)：将 DataSource 的默认配置类注入到 IOC 容器中，DataSourceproperties 定义为：\n\n// 提供对datasource配置信息的支持，所有的配置前缀为：spring.datasource\n@ConfigurationProperties(prefix = "spring.datasource")\npublic class DataSourceProperties  {\n    private ClassLoader classLoader;\n    private Environment environment;\n    private String name = "testdb";\n    ......\n}\n\n\n * @Import({ Registrar.class, DataSourcePoolMetadataProvidersConfiguration.class })：导入其他额外的配置，就以DataSourcePoolMetadataProvidersConfiguration为例吧。\n\n@Configuration\npublic class DataSourcePoolMetadataProvidersConfiguration {\n\n    @Configuration\n    @ConditionalOnClass(org.apache.tomcat.jdbc.pool.DataSource.class)\n    static class TomcatDataSourcePoolMetadataProviderConfiguration {\n        @Bean\n        public DataSourcePoolMetadataProvider tomcatPoolDataSourceMetadataProvider() {\n            .....\n        }\n    }\n  ......\n}\n\n\nDataSourcePoolMetadataProvidersConfiguration 是数据库连接池提供者的一个配置类，即 Classpath 中存在org.apache.tomcat.jdbc.pool.DataSource.class，则使用 tomcat-jdbc 连接池，如果 Classpath 中存在HikariDataSource.class则使用 Hikari 连接池。\n\n这里仅描述了 DataSourceAutoConfiguration 的冰山一角，但足以说明 Spring Boot 如何利用条件话配置来实现自动配置的。回顾一下，@EnableAutoConfiguration中导入了 EnableAutoConfigurationImportSelector 类，而这个类的selectImports()通过 SpringFactoriesLoader 得到了大量的配置类，而每一个配置类则根据条件化配置来做出决策，以实现自动配置。\n\n整个流程很清晰，但漏了一个大问题：EnableAutoConfigurationImportSelector.selectImports()是何时执行的？其实这个方法会在容器启动过程中执行：AbstractApplicationContext.refresh()，更多的细节在下一小节中说明。\n\n\n# 六、启动引导：Spring Boot 应用启动的秘密\n\n\n# 6.1 SpringApplication 初始化\n\nSpringBoot 整个启动流程分为两个步骤：初始化一个 SpringApplication 对象、执行该对象的 run 方法。看下 SpringApplication 的初始化流程，SpringApplication 的构造方法中调用 initialize(Object[] sources)方法，其代码如下：\n\nprivate void initialize(Object[] sources) {\n     if (sources != null && sources.length > 0) {\n         this.sources.addAll(Arrays.asList(sources));\n     }\n     // 判断是否是Web项目\n     this.webEnvironment = deduceWebEnvironment();\n     setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));\n     setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));\n     // 找到入口类\n     this.mainApplicationClass = deduceMainApplicationClass();\n}\n\n\n初始化流程中最重要的就是通过 SpringFactoriesLoader 找到spring.factories文件中配置的ApplicationContextInitializer和ApplicationListener两个接口的实现类名称，以便后期构造相应的实例。ApplicationContextInitializer的主要目的是在ConfigurableApplicationContext做 refresh 之前，对 ConfigurableApplicationContext 实例做进一步的设置或处理。ConfigurableApplicationContext 继承自 ApplicationContext，其主要提供了对 ApplicationContext 进行设置的能力。\n\n实现一个 ApplicationContextInitializer 非常简单，因为它只有一个方法，但大多数情况下我们没有必要自定义一个 ApplicationContextInitializer，即便是 Spring Boot 框架，它默认也只是注册了两个实现，毕竟 Spring 的容器已经非常成熟和稳定，你没有必要来改变它。\n\n而ApplicationListener的目的就没什么好说的了，它是 Spring 框架对 Java 事件监听机制的一种框架实现，具体内容在前文 Spring 事件监听机制这个小节有详细讲解。这里主要说说，如果你想为 Spring Boot 应用添加监听器，该如何实现？\n\nSpring Boot 提供两种方式来添加自定义监听器：\n\n * 通过SpringApplication.addListeners(ApplicationListener... listeners)或者SpringApplication.setListeners(Collection> listeners)两个方法来添加一个或者多个自定义监听器\n * 既然 SpringApplication 的初始化流程中已经从spring.factories中获取到ApplicationListener的实现类，那么我们直接在自己的 jar 包的META-INF/spring.factories文件中新增配置即可：\n\norg.springframework.context.ApplicationListener=\\\ncn.moondev.listeners.xxxxListener\\\n\n\n关于 SpringApplication 的初始化，我们就说这么多。\n\n\n# 6.2 Spring Boot 启动流程\n\nSpring Boot 应用的整个启动流程都封装在 SpringApplication.run 方法中，其整个流程真的是太长太长了，但本质上就是在 Spring 容器启动的基础上做了大量的扩展，按照这个思路来看看源码：\n\npublic ConfigurableApplicationContext run(String... args) {\n        StopWatch stopWatch = new StopWatch();\n        stopWatch.start();\n        ConfigurableApplicationContext context = null;\n        FailureAnalyzers analyzers = null;\n        configureHeadlessProperty();\n        // ①\n        SpringApplicationRunListeners listeners = getRunListeners(args);\n        listeners.starting();\n        try {\n            // ②\n            ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);\n            ConfigurableEnvironment environment = prepareEnvironment(listeners,applicationArguments);\n            // ③\n            Banner printedBanner = printBanner(environment);\n            // ④\n            context = createApplicationContext();\n            // ⑤\n            analyzers = new FailureAnalyzers(context);\n            // ⑥\n            prepareContext(context, environment, listeners, applicationArguments,printedBanner);\n            // ⑦\n            refreshContext(context);\n            // ⑧\n            afterRefresh(context, applicationArguments);\n            // ⑨\n            listeners.finished(context, null);\n            stopWatch.stop();\n            return context;\n        }\n        catch (Throwable ex) {\n            handleRunFailure(context, listeners, analyzers, ex);\n            throw new IllegalStateException(ex);\n        }\n    }\n\n\n① 通过 SpringFactoriesLoader 查找并加载所有的SpringApplicationRunListeners，通过调用 starting()方法通知所有的 SpringApplicationRunListeners：应用开始启动了。SpringApplicationRunListeners 其本质上就是一个事件发布者，它在 SpringBoot 应用启动的不同时间点发布不同应用事件类型(ApplicationEvent)，如果有哪些事件监听者(ApplicationListener)对这些事件感兴趣，则可以接收并且处理。还记得初始化流程中，SpringApplication 加载了一系列 ApplicationListener 吗？这个启动流程中没有发现有发布事件的代码，其实都已经在 SpringApplicationRunListeners 这儿实现了。\n\n简单的分析一下其实现流程，首先看下 SpringApplicationRunListener 的源码：\n\npublic interface SpringApplicationRunListener {\n\n    // 运行run方法时立即调用此方法，可以用户非常早期的初始化工作\n    void starting();\n\n    // Environment准备好后，并且ApplicationContext创建之前调用\n    void environmentPrepared(ConfigurableEnvironment environment);\n\n    // ApplicationContext创建好后立即调用\n    void contextPrepared(ConfigurableApplicationContext context);\n\n    // ApplicationContext加载完成，在refresh之前调用\n    void contextLoaded(ConfigurableApplicationContext context);\n\n    // 当run方法结束之前调用\n    void finished(ConfigurableApplicationContext context, Throwable exception);\n\n}\n\n\nSpringApplicationRunListener 只有一个实现类：EventPublishingRunListener。① 处的代码只会获取到一个 EventPublishingRunListener 的实例，我们来看看 starting()方法的内容：\n\npublic void starting() {\n    // 发布一个ApplicationStartedEvent\n    this.initialMulticaster.multicastEvent(new ApplicationStartedEvent(this.application, this.args));\n}\n\n\n顺着这个逻辑，你可以在 ② 处的prepareEnvironment()方法的源码中找到listeners.environmentPrepared(environment);即 SpringApplicationRunListener 接口的第二个方法，那不出你所料，environmentPrepared()又发布了另外一个事件ApplicationEnvironmentPreparedEvent。接下来会发生什么，就不用我多说了吧。\n\n② 创建并配置当前应用将要使用的Environment，Environment 用于描述应用程序当前的运行环境，其抽象了两个方面的内容：配置文件(profile)和属性(properties)，开发经验丰富的同学对这两个东西一定不会陌生：不同的环境(eg：生产环境、预发布环境)可以使用不同的配置文件，而属性则可以从配置文件、环境变量、命令行参数等来源获取。因此，当 Environment 准备好后，在整个应用的任何时候，都可以从 Environment 中获取资源。\n\n总结起来，② 处的两句代码，主要完成以下几件事：\n\n * 判断 Environment 是否存在，不存在就创建（如果是 web 项目就创建StandardServletEnvironment，否则创建StandardEnvironment）\n * 配置 Environment：配置 profile 以及 properties\n * 调用 SpringApplicationRunListener 的environmentPrepared()方法，通知事件监听者：应用的 Environment 已经准备好\n\n③、SpringBoot 应用在启动时会输出这样的东西：\n\n  .   ____          _            __ _ _\n /\\\\ / ___\'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\\n( ( )\\___ | \'_ | \'_| | \'_ \\/ _` | \\ \\ \\ \\\n \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )\n  \'  |____| .__|_| |_|_| |_\\__, | / / / /\n =========|_|==============|___/=/_/_/_/\n :: Spring Boot ::        (v1.5.6.RELEASE)\n\n\n如果想把这个东西改成自己的涂鸦，你可以研究以下 Banner 的实现，这个任务就留给你们吧。\n\n④、根据是否是 web 项目，来创建不同的 ApplicationContext 容器。\n\n⑤、创建一系列FailureAnalyzer，创建流程依然是通过 SpringFactoriesLoader 获取到所有实现 FailureAnalyzer 接口的 class，然后在创建对应的实例。FailureAnalyzer 用于分析故障并提供相关诊断信息。\n\n⑥、初始化 ApplicationContext，主要完成以下工作：\n\n * 将准备好的 Environment 设置给 ApplicationContext\n * 遍历调用所有的 ApplicationContextInitializer 的initialize()方法来对已经创建好的 ApplicationContext 进行进一步的处理\n * 调用 SpringApplicationRunListener 的contextPrepared()方法，通知所有的监听者：ApplicationContext 已经准备完毕\n * 将所有的 bean 加载到容器中\n * 调用 SpringApplicationRunListener 的contextLoaded()方法，通知所有的监听者：ApplicationContext 已经装载完毕\n\n⑦、调用 ApplicationContext 的refresh()方法，完成 IoC 容器可用的最后一道工序。从名字上理解为刷新容器，那何为刷新？就是插手容器的启动，联系一下第一小节的内容。那如何刷新呢？且看下面代码：\n\n// 摘自refresh()方法中一句代码\ninvokeBeanFactoryPostProcessors(beanFactory);\n\n\n看看这个方法的实现：\n\nprotected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {\n    PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());\n    ......\n}\n\n\n获取到所有的BeanFactoryPostProcessor来对容器做一些额外的操作。BeanFactoryPostProcessor 允许我们在容器实例化相应对象之前，对注册到容器的 BeanDefinition 所保存的信息做一些额外的操作。这里的 getBeanFactoryPostProcessors()方法可以获取到 3 个 Processor：\n\nConfigurationWarningsApplicationContextInitializer$ConfigurationWarningsPostProcessor\nSharedMetadataReaderFactoryContextInitializer$CachingMetadataReaderFactoryPostProcessor\nConfigFileApplicationListener$PropertySourceOrderingPostProcessor\n\n\n不是有那么多 BeanFactoryPostProcessor 的实现类，为什么这儿只有这 3 个？因为在初始化流程获取到的各种 ApplicationContextInitializer 和 ApplicationListener 中，只有上文 3 个做了类似于如下操作：\n\npublic void initialize(ConfigurableApplicationContext context) {\n    context.addBeanFactoryPostProcessor(new ConfigurationWarningsPostProcessor(getChecks()));\n}\n\n\n然后你就可以进入到PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors()方法了，这个方法除了会遍历上面的 3 个 BeanFactoryPostProcessor 处理外，还会获取类型为BeanDefinitionRegistryPostProcessor的 bean：org.springframework.context.annotation.internalConfigurationAnnotationProcessor，对应的 Class 为ConfigurationClassPostProcessor。ConfigurationClassPostProcessor用于解析处理各种注解，包括：@Configuration、@ComponentScan、@Import、@PropertySource、@ImportResource、@Bean。当处理@import注解的时候，就会调用自动配置这一小节中的EnableAutoConfigurationImportSelector.selectImports()来完成自动配置功能。其他的这里不再多讲，如果你有兴趣，可以查阅参考资料 6。\n\n⑧、查找当前 context 中是否注册有 CommandLineRunner 和 ApplicationRunner，如果有则遍历执行它们。\n\n⑨、执行所有 SpringApplicationRunListener 的 finished()方法。\n\n这就是 Spring Boot 的整个启动流程，其核心就是在 Spring 容器初始化并启动的基础上加入各种扩展点，这些扩展点包括：ApplicationContextInitializer、ApplicationListener 以及各种 BeanFactoryPostProcessor 等等。你对整个流程的细节不必太过关注，甚至没弄明白也没有关系，你只要理解这些扩展点是在何时如何工作的，能让它们为你所用即可。\n\n整个启动流程确实非常复杂，可以查询参考资料中的部分章节和内容，对照着源码，多看看，我想最终你都能弄清楚的。言而总之，Spring 才是核心，理解清楚 Spring 容器的启动流程，那 Spring Boot 启动流程就不在话下了。\n\n\n# 参考资料\n\n[1]王福强 著；springboot 揭秘：快速构建微服务体系; 机械工业出版社, 2016 [2]王福强 著；spring 揭秘; 人民邮件出版社, 2009 [3]craig walls 著；丁雪丰 译；spring boot 实战；中国工信出版集团 人民邮电出版社，2016 [4]深入探讨 java 类加载器 : www.ibm.com/developerwo… [5]spring boot 实战：自动配置原理分析 : blog.csdn.net/liaokailin/… [6]spring boot实战：spring boot bean加载源码分析： blog.csdn.net/liaokailin/…',normalizedContent:'# springboot 知识图谱\n\n>  1. 预警：本文非常长，建议先 mark 后看，也许是最后一次写这么长的文章\n>  2. 说明：前面有 4 个小节关于 spring 的基础知识，分别是：ioc 容器、javaconfig、事件监听、springfactoriesloader 详解，它们占据了本文的大部分内容，虽然它们之间可能没有太多的联系，但这些知识对于理解 spring boot 的核心原理至关重要，如果你对 spring 框架烂熟于心，完全可以跳过这 4 个小节。正是因为这个系列的文章是由这些看似不相关的知识点组成，因此取名知识清单。\n\n在过去两三年的 spring 生态圈，最让人兴奋的莫过于 spring boot 框架。或许从命名上就能看出这个框架的设计初衷：快速的启动 spring 应用。因而 spring boot 应用本质上就是一个基于 spring 框架的应用，它是 spring 对“约定优先于配置”理念的最佳实践产物，它能够帮助开发者更快速高效地构建基于 spring 生态圈的应用。\n\n那 spring boot 有何魔法？自动配置、起步依赖、actuator、命令行界面(cli) 是 spring boot 最重要的 4 大核心特性，其中 cli 是 spring boot 的可选特性，虽然它功能强大，但也引入了一套不太常规的开发模型，因而这个系列的文章仅关注其它 3 种特性。如文章标题，本文是这个系列的第一部分，将为你打开 spring boot 的大门，重点为你剖析其启动流程以及自动配置实现原理。要掌握这部分核心内容，理解一些 spring 框架的基础知识，将会让你事半功倍。\n\n\n# 一、抛砖引玉：探索 spring ioc 容器\n\n如果有看过springapplication.run()方法的源码，spring boot 冗长无比的启动流程一定会让你抓狂，透过现象看本质，springapplication 只是将一个典型的 spring 应用的启动流程进行了扩展，因此，透彻理解 spring 容器是打开 spring boot 大门的一把钥匙。\n\n\n# 1.1、spring ioc 容器\n\n可以把 spring ioc 容器比作一间餐馆，当你来到餐馆，通常会直接招呼服务员：点菜！至于菜的原料是什么？如何用原料把菜做出来？可能你根本就不关心。ioc 容器也是一样，你只需要告诉它需要某个 bean，它就把对应的实例（instance）扔给你，至于这个 bean 是否依赖其他组件，怎样完成它的初始化，根本就不需要你关心。\n\n作为餐馆，想要做出菜肴，得知道菜的原料和菜谱，同样地，ioc 容器想要管理各个业务对象以及它们之间的依赖关系，需要通过某种途径来记录和管理这些信息。beandefinition对象就承担了这个责任：容器中的每一个 bean 都会有一个对应的 beandefinition 实例，该实例负责保存 bean 对象的所有必要信息，包括 bean 对象的 class 类型、是否是抽象类、构造方法和参数、其它属性等等。当客户端向容器请求相应对象时，容器就会通过这些信息为客户端返回一个完整可用的 bean 实例。\n\n原材料已经准备好（把 beandefinition 看着原料），开始做菜吧，等等，你还需要一份菜谱，beandefinitionregistry和beanfactory就是这份菜谱，beandefinitionregistry 抽象出 bean 的注册逻辑，而 beanfactory 则抽象出了 bean 的管理逻辑，而各个 beanfactory 的实现类就具体承担了 bean 的注册以及管理工作。它们之间的关系就如下图：\n\nbeanfactory、beandefinitionregistry 关系图（来自：spring 揭秘）\n\ndefaultlistablebeanfactory作为一个比较通用的 beanfactory 实现，它同时也实现了 beandefinitionregistry 接口，因此它就承担了 bean 的注册管理工作。从图中也可以看出，beanfactory 接口中主要包含 getbean、containbean、gettype、getaliases 等管理 bean 的方法，而 beandefinitionregistry 接口则包含 registerbeandefinition、removebeandefinition、getbeandefinition 等注册管理 beandefinition 的方法。\n\n下面通过一段简单的代码来模拟 beanfactory 底层是如何工作的：\n\n// 默认容器实现\ndefaultlistablebeanfactory beanregistry = new defaultlistablebeanfactory();\n// 根据业务对象构造相应的beandefinition\nabstractbeandefinition definition = new rootbeandefinition(business.class,true);\n// 将bean定义注册到容器中\nbeanregistry.registerbeandefinition("beanname",definition);\n// 如果有多个bean，还可以指定各个bean之间的依赖关系\n// ........\n\n// 然后可以从容器中获取这个bean的实例\n// 注意：这里的beanregistry其实实现了beanfactory接口，所以可以强转，\n// 单纯的beandefinitionregistry是无法强制转换到beanfactory类型的\nbeanfactory container = (beanfactory)beanregistry;\nbusiness business = (business)container.getbean("beanname");\n\n\n这段代码仅为了说明 beanfactory 底层的大致工作流程，实际情况会更加复杂，比如 bean 之间的依赖关系可能定义在外部配置文件(xml/properties)中、也可能是注解方式。spring ioc 容器的整个工作流程大致可以分为两个阶段：\n\n①、容器启动阶段\n\n容器启动时，会通过某种途径加载configuration metadata。除了代码方式比较直接外，在大部分情况下，容器需要依赖某些工具类，比如：beandefinitionreader，beandefinitionreader 会对加载的configuration metadata进行解析和分析，并将分析后的信息组装为相应的 beandefinition，最后把这些保存了 bean 定义的 beandefinition，注册到相应的 beandefinitionregistry，这样容器的启动工作就完成了。这个阶段主要完成一些准备性工作，更侧重于 bean 对象管理信息的收集，当然一些验证性或者辅助性的工作也在这一阶段完成。\n\n来看一个简单的例子吧，过往，所有的 bean 都定义在 xml 配置文件中，下面的代码将模拟 beanfactory 如何从配置文件中加载 bean 的定义以及依赖关系：\n\n// 通常为beandefinitionregistry的实现类，这里以defaultlistabebeanfactory为例\nbeandefinitionregistry beanregistry = new defaultlistablebeanfactory();\n// xmlbeandefinitionreader实现了beandefinitionreader接口，用于解析xml文件\nxmlbeandefinitionreader beandefinitionreader = new xmlbeandefinitionreaderimpl(beanregistry);\n// 加载配置文件\nbeandefinitionreader.loadbeandefinitions("classpath:spring-bean.xml");\n\n// 从容器中获取bean实例\nbeanfactory container = (beanfactory)beanregistry;\nbusiness business = (business)container.getbean("beanname");\n\n\n②、bean 的实例化阶段\n\n经过第一阶段，所有 bean 定义都通过 beandefinition 的方式注册到 beandefinitionregistry 中，当某个请求通过容器的 getbean 方法请求某个对象，或者因为依赖关系容器需要隐式的调用 getbean 时，就会触发第二阶段的活动：容器会首先检查所请求的对象之前是否已经实例化完成。如果没有，则会根据注册的 beandefinition 所提供的信息实例化被请求对象，并为其注入依赖。当该对象装配完毕后，容器会立即将其返回给请求方法使用。\n\nbeanfactory 只是 spring ioc 容器的一种实现，如果没有特殊指定，它采用采用延迟初始化策略：只有当访问容器中的某个对象时，才对该对象进行初始化和依赖注入操作。而在实际场景下，我们更多的使用另外一种类型的容器：applicationcontext，它构建在 beanfactory 之上，属于更高级的容器，除了具有 beanfactory 的所有能力之外，还提供对事件监听机制以及国际化的支持等。它管理的 bean，在容器启动时全部完成初始化和依赖注入操作。\n\n\n# 1.2、spring 容器扩展机制\n\nioc 容器负责管理容器中所有 bean 的生命周期，而在 bean 生命周期的不同阶段，spring 提供了不同的扩展点来改变 bean 的命运。在容器的启动阶段，beanfactorypostprocessor允许我们在容器实例化相应对象之前，对注册到容器的 beandefinition 所保存的信息做一些额外的操作，比如修改 bean 定义的某些属性或者增加其他信息等。\n\n如果要自定义扩展类，通常需要实现org.springframework.beans.factory.config.beanfactorypostprocessor接口，与此同时，因为容器中可能有多个 beanfactorypostprocessor，可能还需要实现org.springframework.core.ordered接口，以保证 beanfactorypostprocessor 按照顺序执行。spring 提供了为数不多的 beanfactorypostprocessor 实现，我们以propertyplaceholderconfigurer来说明其大致的工作流程。\n\n在 spring 项目的 xml 配置文件中，经常可以看到许多配置项的值使用占位符，而将占位符所代表的值单独配置到独立的 properties 文件，这样可以将散落在不同 xml 文件中的配置集中管理，而且也方便运维根据不同的环境进行配置不同的值。这个非常实用的功能就是由 propertyplaceholderconfigurer 负责实现的。\n\n根据前文，当 beanfactory 在第一阶段加载完所有配置信息时，beanfactory 中保存的对象的属性还是以占位符方式存在的，比如${jdbc.mysql.url}。当 propertyplaceholderconfigurer 作为 beanfactorypostprocessor 被应用时，它会使用 properties 配置文件中的值来替换相应的 beandefinition 中占位符所表示的属性值。当需要实例化 bean 时，bean 定义中的属性值就已经被替换成我们配置的值。当然其实现比上面描述的要复杂一些，这里仅说明其大致工作原理，更详细的实现可以参考其源码。\n\n与之相似的，还有beanpostprocessor，其存在于对象实例化阶段。跟 beanfactorypostprocessor 类似，它会处理容器内所有符合条件并且已经实例化后的对象。简单的对比，beanfactorypostprocessor 处理 bean 的定义，而 beanpostprocessor 则处理 bean 完成实例化后的对象。beanpostprocessor 定义了两个接口：\n\npublic interface beanpostprocessor {\n    // 前置处理\n    object postprocessbeforeinitialization(object bean, string beanname) throws beansexception;\n    // 后置处理\n    object postprocessafterinitialization(object bean, string beanname) throws beansexception;\n}\n\n\n为了理解这两个方法执行的时机，简单的了解下 bean 的整个生命周期：\n\npostprocessbeforeinitialization()方法与postprocessafterinitialization()分别对应图中前置处理和后置处理两个步骤将执行的方法。这两个方法中都传入了 bean 对象实例的引用，为扩展容器的对象实例化过程提供了很大便利，在这儿几乎可以对传入的实例执行任何操作。注解、aop 等功能的实现均大量使用了beanpostprocessor，比如有一个自定义注解，你完全可以实现 beanpostprocessor 的接口，在其中判断 bean 对象的脑袋上是否有该注解，如果有，你可以对这个 bean 实例执行任何操作，想想是不是非常的简单？\n\n再来看一个更常见的例子，在 spring 中经常能够看到各种各样的 aware 接口，其作用就是在对象实例化完成以后将 aware 接口定义中规定的依赖注入到当前实例中。比如最常见的applicationcontextaware接口，实现了这个接口的类都可以获取到一个 applicationcontext 对象。当容器中每个对象的实例化过程走到 beanpostprocessor 前置处理这一步时，容器会检测到之前注册到容器的 applicationcontextawareprocessor，然后就会调用其 postprocessbeforeinitialization()方法，检查并设置 aware 相关依赖。看看代码吧，是不是很简单：\n\n// 代码来自：org.springframework.context.support.applicationcontextawareprocessor\n// 其postprocessbeforeinitialization方法调用了invokeawareinterfaces方法\nprivate void invokeawareinterfaces(object bean) {\n    if (bean instanceof environmentaware) {\n        ((environmentaware) bean).setenvironment(this.applicationcontext.getenvironment());\n    }\n    if (bean instanceof applicationcontextaware) {\n        ((applicationcontextaware) bean).setapplicationcontext(this.applicationcontext);\n    }\n    // ......\n}\n\n\n最后总结一下，本小节内容和你一起回顾了 spring 容器的部分核心内容，限于篇幅不能写更多，但理解这部分内容，足以让您轻松理解 spring boot 的启动原理，如果在后续的学习过程中遇到一些晦涩难懂的知识，再回过头来看看 spring 的核心知识，也许有意想不到的效果。也许 spring boot 的中文资料很少，但 spring 的中文资料和书籍有太多太多，总有东西能给你启发。\n\n\n# 二、夯实基础：javaconfig 与常见 annotation\n\n\n# 2.1、javaconfig\n\n我们知道bean是 spring ioc 中非常核心的概念，spring 容器负责 bean 的生命周期的管理。在最初，spring 使用 xml 配置文件的方式来描述 bean 的定义以及相互间的依赖关系，但随着 spring 的发展，越来越多的人对这种方式表示不满，因为 spring 项目的所有业务类均以 bean 的形式配置在 xml 文件中，造成了大量的 xml 文件，使项目变得复杂且难以管理。\n\n后来，基于纯 java annotation 依赖注入框架guice出世，其性能明显优于采用 xml 方式的 spring，甚至有部分人认为，guice可以完全取代 spring（guice仅是一个轻量级 ioc 框架，取代 spring 还差的挺远）。正是这样的危机感，促使 spring 及社区推出并持续完善了javaconfig子项目，它基于 java 代码和 annotation 注解来描述 bean 之间的依赖绑定关系。比如，下面是使用 xml 配置方式来描述 bean 的定义：\n\n<bean id="bookservice" class="cn.moondev.service.bookserviceimpl"></bean>\n\n\n而基于 javaconfig 的配置形式是这样的：\n\n@configuration\npublic class moonbookconfiguration {\n\n    // 任何标志了@bean的方法，其返回值将作为一个bean注册到spring的ioc容器中\n    // 方法名默认成为该bean定义的id\n    @bean\n    public bookservice bookservice() {\n        return new bookserviceimpl();\n    }\n}\n\n\n如果两个 bean 之间有依赖关系的话，在 xml 配置中应该是这样：\n\n<bean id="bookservice" class="cn.moondev.service.bookserviceimpl">\n    <property name="dependencyservice" ref="dependencyservice"/>\n</bean>\n\n<bean id="otherservice" class="cn.moondev.service.otherserviceimpl">\n    <property name="dependencyservice" ref="dependencyservice"/>\n</bean>\n\n<bean id="dependencyservice" class="dependencyserviceimpl"/>\n\n\n而在 javaconfig 中则是这样：\n\n@configuration\npublic class moonbookconfiguration {\n\n    // 如果一个bean依赖另一个bean，则直接调用对应javaconfig类中依赖bean的创建方法即可\n    // 这里直接调用dependencyservice()\n    @bean\n    public bookservice bookservice() {\n        return new bookserviceimpl(dependencyservice());\n    }\n\n    @bean\n    public otherservice otherservice() {\n        return new otherserviceimpl(dependencyservice());\n    }\n\n    @bean\n    public dependencyservice dependencyservice() {\n        return new dependencyserviceimpl();\n    }\n}\n\n\n你可能注意到这个示例中，有两个 bean 都依赖于 dependencyservice，也就是说当初始化 bookservice 时会调用dependencyservice()，在初始化 otherservice 时也会调用dependencyservice()，那么问题来了？这时候 ioc 容器中是有一个 dependencyservice 实例还是两个？这个问题留着大家思考吧，这里不再赘述。\n\n\n# 2.2、@componentscan\n\n@componentscan注解对应 xml 配置形式中的``元素，表示启用组件扫描，spring 会自动扫描所有通过注解配置的 bean，然后将其注册到 ioc 容器中。我们可以通过basepackages等属性来指定@componentscan自动扫描的范围，如果不指定，默认从声明@componentscan所在类的package进行扫描。正因为如此，springboot 的启动类都默认在src/main/java下。\n\n\n# 2.3、@import\n\n@import注解用于导入配置类，举个简单的例子：\n\n@configuration\npublic class moonbookconfiguration {\n    @bean\n    public bookservice bookservice() {\n        return new bookserviceimpl();\n    }\n}\n\n\n现在有另外一个配置类，比如：moonuserconfiguration，这个配置类中有一个 bean 依赖于moonbookconfiguration中的 bookservice，如何将这两个 bean 组合在一起？借助@import即可：\n\n@configuration\n// 可以同时导入多个配置类，比如：@import({a.class,b.class})\n@import(moonbookconfiguration.class)\npublic class moonuserconfiguration {\n    @bean\n    public userservice userservice(bookservice bookservice) {\n        return new bookserviceimpl(bookservice);\n    }\n}\n\n\n需要注意的是，在 4.2 之前，@import注解只支持导入配置类，但是在 4.2 之后，它支持导入普通类，并将这个类作为一个 bean 的定义注册到 ioc 容器中。\n\n\n# 2.4、@conditional\n\n@conditional注解表示在满足某种条件后才初始化一个 bean 或者启用某些配置。它一般用在由@component、@service、@configuration等注解标识的类上面，或者由@bean标记的方法上。如果一个@configuration类标记了@conditional，则该类中所有标识了@bean的方法和@import注解导入的相关类将遵从这些条件。\n\n在 spring 里可以很方便的编写你自己的条件类，所要做的就是实现condition接口，并覆盖它的matches()方法。举个例子，下面的简单条件类表示只有在classpath里存在jdbctemplate类时才生效：\n\npublic class jdbctemplatecondition implements condition {\n\n    @override\n    public boolean matches(conditioncontext conditioncontext, annotatedtypemetadata annotatedtypemetadata) {\n        try {\n        conditioncontext.getclassloader().loadclass("org.springframework.jdbc.core.jdbctemplate");\n            return true;\n        } catch (classnotfoundexception e) {\n            e.printstacktrace();\n        }\n        return false;\n    }\n}\n\n\n当你用 java 来声明 bean 的时候，可以使用这个自定义条件类：\n\n@conditional(jdbctemplatecondition.class)\n@service\npublic myservice service() {\n    ......\n}\n\n\n这个例子中只有当jdbctemplatecondition类的条件成立时才会创建 myservice 这个 bean。也就是说 myservice 这 bean 的创建条件是classpath里面包含jdbctemplate，否则这个 bean 的声明就会被忽略掉。\n\nspring boot定义了很多有趣的条件，并把他们运用到了配置类上，这些配置类构成了spring boot的自动配置的基础。spring boot运用条件化配置的方法是：定义多个特殊的条件化注解，并将它们用到配置类上。下面列出了spring boot提供的部分条件化注解：\n\n条件化注解                             配置生效条件\n@conditionalonbean                配置了某个特定 bean\n@conditionalonmissingbean         没有配置特定的 bean\n@conditionalonclass               classpath 里有指定的类\n@conditionalonmissingclass        classpath 里没有指定的类\n@conditionalonexpression          给定的 spring expression language 表达式计算结果为 true\n@conditionalonjava                java 的版本匹配特定指或者一个范围值\n@conditionalonproperty            指定的配置属性要有一个明确的值\n@conditionalonresource            classpath 里有指定的资源\n@conditionalonwebapplication      这是一个 web 应用程序\n@conditionalonnotwebapplication   这不是一个 web 应用程序\n\n\n# 2.5、@configurationproperties 与@enableconfigurationproperties\n\n当某些属性的值需要配置的时候，我们一般会在application.properties文件中新建配置项，然后在 bean 中使用@value注解来获取配置的值，比如下面配置数据源的代码。\n\n// jdbc config\njdbc.mysql.url=jdbc:mysql://localhost:3306/sampledb\njdbc.mysql.username=root\njdbc.mysql.password=123456\n......\n\n// 配置数据源\n@configuration\npublic class hikaridatasourceconfiguration {\n\n    @value("jdbc.mysql.url")\n    public string url;\n    @value("jdbc.mysql.username")\n    public string user;\n    @value("jdbc.mysql.password")\n    public string password;\n\n    @bean\n    public hikaridatasource datasource() {\n        hikariconfig hikariconfig = new hikariconfig();\n        hikariconfig.setjdbcurl(url);\n        hikariconfig.setusername(user);\n        hikariconfig.setpassword(password);\n        // 省略部分代码\n        return new hikaridatasource(hikariconfig);\n    }\n}\n\n\n使用@value注解注入的属性通常都比较简单，如果同一个配置在多个地方使用，也存在不方便维护的问题（考虑下，如果有几十个地方在使用某个配置，而现在你想改下名字，你改怎么做？）。对于更为复杂的配置，spring boot 提供了更优雅的实现方式，那就是@configurationproperties注解。我们可以通过下面的方式来改写上面的代码：\n\n@component\n//  还可以通过@propertysource("classpath:jdbc.properties")来指定配置文件\n@configurationproperties("jdbc.mysql")\n// 前缀=jdbc.mysql，会在配置文件中寻找jdbc.mysql.*的配置项\npulic class jdbcconfig {\n    public string url;\n    public string username;\n    public string password;\n}\n\n@configuration\npublic class hikaridatasourceconfiguration {\n\n    @autowired\n    public jdbcconfig config;\n\n    @bean\n    public hikaridatasource datasource() {\n        hikariconfig hikariconfig = new hikariconfig();\n        hikariconfig.setjdbcurl(config.url);\n        hikariconfig.setusername(config.username);\n        hikariconfig.setpassword(config.password);\n        // 省略部分代码\n        return new hikaridatasource(hikariconfig);\n    }\n}\n\n\n@configurationproperties对于更为复杂的配置，处理起来也是得心应手，比如有如下配置文件：\n\n#app\napp.menus[0].title=home\napp.menus[0].name=home\napp.menus[0].path=/\napp.menus[1].title=login\napp.menus[1].name=login\napp.menus[1].path=/login\n\napp.compiler.timeout=5\napp.compiler.output-folder=/temp/\n\napp.error=/error/\n\n\n可以定义如下配置类来接收这些属性\n\n@component\n@configurationproperties("app")\npublic class appproperties {\n\n    public string error;\n    public list<menu> menus = new arraylist<>();\n    public compiler compiler = new compiler();\n\n    public static class menu {\n        public string name;\n        public string path;\n        public string title;\n    }\n\n    public static class compiler {\n        public string timeout;\n        public string outputfolder;\n    }\n}\n\n\n@enableconfigurationproperties注解表示对@configurationproperties的内嵌支持，默认会将对应 properties class 作为 bean 注入的 ioc 容器中，即在相应的 properties 类上不用加@component注解。\n\n\n# 三、削铁如泥：springfactoriesloader 详解\n\njvm 提供了 3 种类加载器：bootstrapclassloader、extclassloader、appclassloader分别加载 java 核心类库、扩展类库以及应用的类路径(classpath)下的类库。jvm 通过双亲委派模型进行类的加载，我们也可以通过继承java.lang.classloader实现自己的类加载器。\n\n何为双亲委派模型？当一个类加载器收到类加载任务时，会先交给自己的父加载器去完成，因此最终加载任务都会传递到最顶层的 bootstrapclassloader，只有当父加载器无法完成加载任务时，才会尝试自己来加载。\n\n采用双亲委派模型的一个好处是保证使用不同类加载器最终得到的都是同一个对象，这样就可以保证 java 核心库的类型安全，比如，加载位于 rt.jar 包中的java.lang.object类，不管是哪个加载器加载这个类，最终都是委托给顶层的 bootstrapclassloader 来加载的，这样就可以保证任何的类加载器最终得到的都是同样一个 object 对象。查看 classloader 的源码，对双亲委派模型会有更直观的认识：\n\nprotected class<?> loadclass(string name, boolean resolve) {\n    synchronized (getclassloadinglock(name)) {\n    // 首先，检查该类是否已经被加载，如果从jvm缓存中找到该类，则直接返回\n    class<?> c = findloadedclass(name);\n    if (c == null) {\n        try {\n            // 遵循双亲委派的模型，首先会通过递归从父加载器开始找，\n            // 直到父类加载器是bootstrapclassloader为止\n            if (parent != null) {\n                c = parent.loadclass(name, false);\n            } else {\n                c = findbootstrapclassornull(name);\n            }\n        } catch (classnotfoundexception e) {}\n        if (c == null) {\n            // 如果还找不到，尝试通过findclass方法去寻找\n            // findclass是留给开发者自己实现的，也就是说\n            // 自定义类加载器时，重写此方法即可\n           c = findclass(name);\n        }\n    }\n    if (resolve) {\n        resolveclass(c);\n    }\n    return c;\n    }\n}\n\n\n但双亲委派模型并不能解决所有的类加载器问题，比如，java 提供了很多服务提供者接口(service provider interface，spi)，允许第三方为这些接口提供实现。常见的 spi 有 jdbc、jndi、jaxp 等，这些 spi 的接口由核心类库提供，却由第三方实现，这样就存在一个问题：spi 的接口是 java 核心库的一部分，是由 bootstrapclassloader 加载的；spi 实现的 java 类一般是由 appclassloader 来加载的。bootstrapclassloader 是无法找到 spi 的实现类的，因为它只加载 java 的核心库。它也不能代理给 appclassloader，因为它是最顶层的类加载器。也就是说，双亲委派模型并不能解决这个问题。\n\n线程上下文类加载器(contextclassloader)正好解决了这个问题。从名称上看，可能会误解为它是一种新的类加载器，实际上，它仅仅是 thread 类的一个变量而已，可以通过setcontextclassloader(classloader cl)和getcontextclassloader()来设置和获取该对象。如果不做任何的设置，java 应用的线程的上下文类加载器默认就是 appclassloader。在核心类库使用 spi 接口时，传递的类加载器使用线程上下文类加载器，就可以成功的加载到 spi 实现的类。线程上下文类加载器在很多 spi 的实现中都会用到。但在 jdbc 中，你可能会看到一种更直接的实现方式，比如，jdbc 驱动管理java.sql.driver中的loadinitialdrivers()方法中，你可以直接看到 jdk 是如何加载驱动的：\n\nfor (string adriver : driverslist) {\n    try {\n        // 直接使用appclassloader\n        class.forname(adriver, true, classloader.getsystemclassloader());\n    } catch (exception ex) {\n        println("drivermanager.initialize: load failed: " + ex);\n    }\n}\n\n\n其实讲解线程上下文类加载器，最主要是让大家在看到thread.currentthread().getclassloader()和thread.currentthread().getcontextclassloader()时不会一脸懵逼，这两者除了在许多底层框架中取得的 classloader 可能会有所不同外，其他大多数业务场景下都是一样的，大家只要知道它是为了解决什么问题而存在的即可。\n\n类加载器除了加载 class 外，还有一个非常重要功能，就是加载资源，它可以从 jar 包中读取任何资源文件，比如，classloader.getresources(string name)方法就是用于读取 jar 包中的资源文件，其代码如下：\n\npublic enumeration<url> getresources(string name) throws ioexception {\n    enumeration<url>[] tmp = (enumeration<url>[]) new enumeration<?>[2];\n    if (parent != null) {\n        tmp[0] = parent.getresources(name);\n    } else {\n        tmp[0] = getbootstrapresources(name);\n    }\n    tmp[1] = findresources(name);\n    return new compoundenumeration<>(tmp);\n}\n\n\n是不是觉得有点眼熟，不错，它的逻辑其实跟类加载的逻辑是一样的，首先判断父类加载器是否为空，不为空则委托父类加载器执行资源查找任务，直到 bootstrapclassloader，最后才轮到自己查找。而不同的类加载器负责扫描不同路径下的 jar 包，就如同加载 class 一样，最后会扫描所有的 jar 包，找到符合条件的资源文件。\n\n类加载器的findresources(name)方法会遍历其负责加载的所有 jar 包，找到 jar 包中名称为 name 的资源文件，这里的资源可以是任何文件，甚至是.class 文件，比如下面的示例，用于查找 array.class 文件：\n\n// 寻找array.class文件\npublic static void main(string[] args) throws exception{\n    // array.class的完整路径\n    string name = "java/sql/array.class";\n    enumeration<url> urls = thread.currentthread().getcontextclassloader().getresources(name);\n    while (urls.hasmoreelements()) {\n        url url = urls.nextelement();\n        system.out.println(url.tostring());\n    }\n}\n\n\n运行后可以得到如下结果：\n\n$java_home/jre/lib/rt.jar!/java/sql/array.class\n\n\n根据资源文件的 url，可以构造相应的文件来读取资源内容。\n\n看到这里，你可能会感到挺奇怪的，你不是要详解springfactoriesloader吗？上来讲了一堆 classloader 是几个意思？看下它的源码你就知道了：\n\npublic static final string factories_resource_location = "meta-inf/spring.factories";\n// spring.factories文件的格式为：key=value1,value2,value3\n// 从所有的jar包中找到meta-inf/spring.factories文件\n// 然后从文件中解析出key=factoryclass类名称的所有value值\npublic static list<string> loadfactorynames(class<?> factoryclass, classloader classloader) {\n    string factoryclassname = factoryclass.getname();\n    // 取得资源文件的url\n    enumeration<url> urls = (classloader != null ? classloader.getresources(factories_resource_location) : classloader.getsystemresources(factories_resource_location));\n    list<string> result = new arraylist<string>();\n    // 遍历所有的url\n    while (urls.hasmoreelements()) {\n        url url = urls.nextelement();\n        // 根据资源文件url解析properties文件\n        properties properties = propertiesloaderutils.loadproperties(new urlresource(url));\n        string factoryclassnames = properties.getproperty(factoryclassname);\n        // 组装数据，并返回\n        result.addall(arrays.aslist(stringutils.commadelimitedlisttostringarray(factoryclassnames)));\n    }\n    return result;\n}\n\n\n有了前面关于 classloader 的知识，再来理解这段代码，是不是感觉豁然开朗：从classpath下的每个 jar 包中搜寻所有meta-inf/spring.factories配置文件，然后将解析 properties 文件，找到指定名称的配置后返回。需要注意的是，其实这里不仅仅是会去 classpath 路径下查找，会扫描所有路径下的 jar 包，只不过这个文件只会在 classpath 下的 jar 包中。来简单看下spring.factories文件的内容吧：\n\n// 来自 org.springframework.boot.autoconfigure下的meta-inf/spring.factories\n// enableautoconfiguration后文会讲到，它用于开启spring boot自动配置功能\norg.springframework.boot.autoconfigure.enableautoconfiguration=\\\norg.springframework.boot.autoconfigure.admin.springapplicationadminjmxautoconfiguration,\\\norg.springframework.boot.autoconfigure.aop.aopautoconfiguration,\\\norg.springframework.boot.autoconfigure.amqp.rabbitautoconfiguration\\\n\n\n执行loadfactorynames(enableautoconfiguration.class, classloader)后，得到对应的一组@configuration类， 我们就可以通过反射实例化这些类然后注入到 ioc 容器中，最后容器里就有了一系列标注了@configuration的 javaconfig 形式的配置类。\n\n这就是springfactoriesloader，它本质上属于 spring 框架私有的一种扩展方案，类似于 spi，spring boot 在 spring 基础上的很多核心功能都是基于此，希望大家可以理解。\n\n\n# 四、另一件武器：spring 容器的事件监听机制\n\n过去，事件监听机制多用于图形界面编程，比如：点击按钮、在文本框输入内容等操作被称为事件，而当事件触发时，应用程序作出一定的响应则表示应用监听了这个事件，而在服务器端，事件的监听机制更多的用于异步通知以及监控和异常处理。java 提供了实现事件监听机制的两个基础类：自定义事件类型扩展自java.util.eventobject、事件的监听器扩展自java.util.eventlistener。来看一个简单的实例：简单的监控一个方法的耗时。\n\n首先定义事件类型，通常的做法是扩展 eventobject，随着事件的发生，相应的状态通常都封装在此类中：\n\npublic class methodmonitorevent extends eventobject {\n    // 时间戳，用于记录方法开始执行的时间\n    public long timestamp;\n\n    public methodmonitorevent(object source) {\n        super(source);\n    }\n}\n\n\n事件发布之后，相应的监听器即可对该类型的事件进行处理，我们可以在方法开始执行之前发布一个 begin 事件，在方法执行结束之后发布一个 end 事件，相应地，事件监听器需要提供方法对这两种情况下接收到的事件进行处理：\n\n// 1、定义事件监听接口\npublic interface methodmonitoreventlistener extends eventlistener {\n    // 处理方法执行之前发布的事件\n    public void onmethodbegin(methodmonitorevent event);\n    // 处理方法结束时发布的事件\n    public void onmethodend(methodmonitorevent event);\n}\n// 2、事件监听接口的实现：如何处理\npublic class abstractmethodmonitoreventlistener implements methodmonitoreventlistener {\n\n    @override\n    public void onmethodbegin(methodmonitorevent event) {\n        // 记录方法开始执行时的时间\n        event.timestamp = system.currenttimemillis();\n    }\n\n    @override\n    public void onmethodend(methodmonitorevent event) {\n        // 计算方法耗时\n        long duration = system.currenttimemillis() - event.timestamp;\n        system.out.println("耗时：" + duration);\n    }\n}\n\n\n事件监听器接口针对不同的事件发布实际提供相应的处理方法定义，最重要的是，其方法只接收 methodmonitorevent 参数，说明这个监听器类只负责监听器对应的事件并进行处理。有了事件和监听器，剩下的就是发布事件，然后让相应的监听器监听并处理。通常情况，我们会有一个事件发布者，它本身作为事件源，在合适的时机，将相应的事件发布给对应的事件监听器：\n\npublic class methodmonitoreventpublisher {\n\n    private list<methodmonitoreventlistener> listeners = new arraylist<methodmonitoreventlistener>();\n\n    public void methodmonitor() {\n        methodmonitorevent eventobject = new methodmonitorevent(this);\n        publishevent("begin",eventobject);\n        // 模拟方法执行：休眠5秒钟\n        timeunit.seconds.sleep(5);\n        publishevent("end",eventobject);\n\n    }\n\n    private void publishevent(string status,methodmonitorevent event) {\n        // 避免在事件处理期间，监听器被移除，这里为了安全做一个复制操作\n        list<methodmonitoreventlistener> copylisteners = ➥ new arraylist<methodmonitoreventlistener>(listeners);\n        for (methodmonitoreventlistener listener : copylisteners) {\n            if ("begin".equals(status)) {\n                listener.onmethodbegin(event);\n            } else {\n                listener.onmethodend(event);\n            }\n        }\n    }\n\n    public static void main(string[] args) {\n        methodmonitoreventpublisher publisher = new methodmonitoreventpublisher();\n        publisher.addeventlistener(new abstractmethodmonitoreventlistener());\n        publisher.methodmonitor();\n    }\n    // 省略实现\n    public void addeventlistener(methodmonitoreventlistener listener) {}\n    public void removeeventlistener(methodmonitoreventlistener listener) {}\n    public void removealllisteners() {}\n\n\n对于事件发布者（事件源）通常需要关注两点：\n\n 1. 在合适的时机发布事件。此例中的 methodmonitor()方法是事件发布的源头，其在方法执行之前和结束之后两个时间点发布 methodmonitorevent 事件，每个时间点发布的事件都会传给相应的监听器进行处理。在具体实现时需要注意的是，事件发布是顺序执行，为了不影响处理性能，事件监听器的处理逻辑应尽量简单。\n 2. 事件监听器的管理。publisher 类中提供了事件监听器的注册与移除方法，这样客户端可以根据实际情况决定是否需要注册新的监听器或者移除某个监听器。如果这里没有提供 remove 方法，那么注册的监听器示例将一直被 methodmonitoreventpublisher 引用，即使已经废弃不用了，也依然在发布者的监听器列表中，这会导致隐性的内存泄漏。\n\n# spring 容器内的事件监听机制\n\nspring 的 applicationcontext 容器内部中的所有事件类型均继承自org.springframework.context.applicationevent，容器中的所有监听器都实现org.springframework.context.applicationlistener接口，并且以 bean 的形式注册在容器中。一旦在容器内发布 applicationevent 及其子类型的事件，注册到容器的 applicationlistener 就会对这些事件进行处理。\n\n你应该已经猜到是怎么回事了。\n\napplicationevent 继承自 eventobject，spring 提供了一些默认的实现，比如：contextclosedevent表示容器在即将关闭时发布的事件类型，contextrefreshedevent表示容器在初始化或者刷新的时候发布的事件类型......\n\n容器内部使用 applicationlistener 作为事件监听器接口定义，它继承自 eventlistener。applicationcontext 容器在启动时，会自动识别并加载 eventlistener 类型的 bean，一旦容器内有事件发布，将通知这些注册到容器的 eventlistener。\n\napplicationcontext 接口继承了 applicationeventpublisher 接口，该接口提供了void publishevent(applicationevent event)方法定义，不难看出，applicationcontext 容器担当的就是事件发布者的角色。如果有兴趣可以查看abstractapplicationcontext.publishevent(applicationevent event)方法的源码：applicationcontext 将事件的发布以及监听器的管理工作委托给applicationeventmulticaster接口的实现类。在容器启动时，会检查容器内是否存在名为 applicationeventmulticaster 的 applicationeventmulticaster 对象实例。如果有就使用其提供的实现，没有就默认初始化一个 simpleapplicationeventmulticaster 作为实现。\n\n最后，如果我们业务需要在容器内部发布事件，只需要为其注入 applicationeventpublisher 依赖即可：实现 applicationeventpublisheraware 接口或者 applicationcontextaware 接口(aware 接口相关内容请回顾上文)。\n\n\n# 五、出神入化：揭秘自动配置原理\n\n典型的 spring boot 应用的启动类一般均位于src/main/java根路径下，比如moonapplication类：\n\n@springbootapplication\npublic class moonapplication {\n\n    public static void main(string[] args) {\n        springapplication.run(moonapplication.class, args);\n    }\n}\n\n\n其中@springbootapplication开启组件扫描和自动配置，而springapplication.run则负责启动引导应用程序。@springbootapplication是一个复合annotation，它将三个有用的注解组合在一起：\n\n@target(elementtype.type)\n@retention(retentionpolicy.runtime)\n@documented\n@inherited\n@springbootconfiguration\n@enableautoconfiguration\n@componentscan(excludefilters = {\n        @filter(type = filtertype.custom, classes = typeexcludefilter.class),\n        @filter(type = filtertype.custom, classes = autoconfigurationexcludefilter.class) })\npublic @interface springbootapplication {\n    // ......\n}\n\n\n@springbootconfiguration就是@configuration，它是 spring 框架的注解，标明该类是一个javaconfig配置类。而@componentscan启用组件扫描，前文已经详细讲解过，这里着重关注@enableautoconfiguration。\n\n@enableautoconfiguration注解表示开启 spring boot 自动配置功能，spring boot 会根据应用的依赖、自定义的 bean、classpath 下有没有某个类 等等因素来猜测你需要的 bean，然后注册到 ioc 容器中。那@enableautoconfiguration是如何推算出你的需求？首先看下它的定义：\n\n@target(elementtype.type)\n@retention(retentionpolicy.runtime)\n@documented\n@inherited\n@autoconfigurationpackage\n@import(enableautoconfigurationimportselector.class)\npublic @interface enableautoconfiguration {\n    // ......\n}\n\n\n你的关注点应该在@import(enableautoconfigurationimportselector.class)上了，前文说过，@import注解用于导入类，并将这个类作为一个 bean 的定义注册到容器中，这里它将把enableautoconfigurationimportselector作为 bean 注入到容器中，而这个类会将所有符合条件的@configuration 配置都加载到容器中，看看它的代码：\n\npublic string[] selectimports(annotationmetadata annotationmetadata) {\n    // 省略了大部分代码，保留一句核心代码\n    // 注意：springboot最近版本中，这句代码被封装在一个单独的方法中\n    // springfactoriesloader相关知识请参考前文\n    list<string> factories = new arraylist<string>(new linkedhashset<string>(\n        springfactoriesloader.loadfactorynames(enableautoconfiguration.class, this.beanclassloader)));\n}\n\n\n这个类会扫描所有的 jar 包，将所有符合条件的@configuration 配置类注入的容器中，何为符合条件，看看meta-inf/spring.factories的文件内容：\n\n// 来自 org.springframework.boot.autoconfigure下的meta-inf/spring.factories\n// 配置的key = enableautoconfiguration，与代码中一致\norg.springframework.boot.autoconfigure.enableautoconfiguration=\\\norg.springframework.boot.autoconfigure.jdbc.datasourceautoconfiguration,\\\norg.springframework.boot.autoconfigure.aop.aopautoconfiguration,\\\norg.springframework.boot.autoconfigure.amqp.rabbitautoconfiguration\\\n.....\n\n\n以datasourceautoconfiguration为例，看看 spring boot 是如何自动配置的：\n\n@configuration\n@conditionalonclass({ datasource.class, embeddeddatabasetype.class })\n@enableconfigurationproperties(datasourceproperties.class)\n@import({ registrar.class, datasourcepoolmetadataprovidersconfiguration.class })\npublic class datasourceautoconfiguration {\n}\n\n\n分别说一说：\n\n * @conditionalonclass({ datasource.class, embeddeddatabasetype.class })：当 classpath 中存在 datasource 或者 embeddeddatabasetype 类时才启用这个配置，否则这个配置将被忽略。\n * @enableconfigurationproperties(datasourceproperties.class)：将 datasource 的默认配置类注入到 ioc 容器中，datasourceproperties 定义为：\n\n// 提供对datasource配置信息的支持，所有的配置前缀为：spring.datasource\n@configurationproperties(prefix = "spring.datasource")\npublic class datasourceproperties  {\n    private classloader classloader;\n    private environment environment;\n    private string name = "testdb";\n    ......\n}\n\n\n * @import({ registrar.class, datasourcepoolmetadataprovidersconfiguration.class })：导入其他额外的配置，就以datasourcepoolmetadataprovidersconfiguration为例吧。\n\n@configuration\npublic class datasourcepoolmetadataprovidersconfiguration {\n\n    @configuration\n    @conditionalonclass(org.apache.tomcat.jdbc.pool.datasource.class)\n    static class tomcatdatasourcepoolmetadataproviderconfiguration {\n        @bean\n        public datasourcepoolmetadataprovider tomcatpooldatasourcemetadataprovider() {\n            .....\n        }\n    }\n  ......\n}\n\n\ndatasourcepoolmetadataprovidersconfiguration 是数据库连接池提供者的一个配置类，即 classpath 中存在org.apache.tomcat.jdbc.pool.datasource.class，则使用 tomcat-jdbc 连接池，如果 classpath 中存在hikaridatasource.class则使用 hikari 连接池。\n\n这里仅描述了 datasourceautoconfiguration 的冰山一角，但足以说明 spring boot 如何利用条件话配置来实现自动配置的。回顾一下，@enableautoconfiguration中导入了 enableautoconfigurationimportselector 类，而这个类的selectimports()通过 springfactoriesloader 得到了大量的配置类，而每一个配置类则根据条件化配置来做出决策，以实现自动配置。\n\n整个流程很清晰，但漏了一个大问题：enableautoconfigurationimportselector.selectimports()是何时执行的？其实这个方法会在容器启动过程中执行：abstractapplicationcontext.refresh()，更多的细节在下一小节中说明。\n\n\n# 六、启动引导：spring boot 应用启动的秘密\n\n\n# 6.1 springapplication 初始化\n\nspringboot 整个启动流程分为两个步骤：初始化一个 springapplication 对象、执行该对象的 run 方法。看下 springapplication 的初始化流程，springapplication 的构造方法中调用 initialize(object[] sources)方法，其代码如下：\n\nprivate void initialize(object[] sources) {\n     if (sources != null && sources.length > 0) {\n         this.sources.addall(arrays.aslist(sources));\n     }\n     // 判断是否是web项目\n     this.webenvironment = deducewebenvironment();\n     setinitializers((collection) getspringfactoriesinstances(applicationcontextinitializer.class));\n     setlisteners((collection) getspringfactoriesinstances(applicationlistener.class));\n     // 找到入口类\n     this.mainapplicationclass = deducemainapplicationclass();\n}\n\n\n初始化流程中最重要的就是通过 springfactoriesloader 找到spring.factories文件中配置的applicationcontextinitializer和applicationlistener两个接口的实现类名称，以便后期构造相应的实例。applicationcontextinitializer的主要目的是在configurableapplicationcontext做 refresh 之前，对 configurableapplicationcontext 实例做进一步的设置或处理。configurableapplicationcontext 继承自 applicationcontext，其主要提供了对 applicationcontext 进行设置的能力。\n\n实现一个 applicationcontextinitializer 非常简单，因为它只有一个方法，但大多数情况下我们没有必要自定义一个 applicationcontextinitializer，即便是 spring boot 框架，它默认也只是注册了两个实现，毕竟 spring 的容器已经非常成熟和稳定，你没有必要来改变它。\n\n而applicationlistener的目的就没什么好说的了，它是 spring 框架对 java 事件监听机制的一种框架实现，具体内容在前文 spring 事件监听机制这个小节有详细讲解。这里主要说说，如果你想为 spring boot 应用添加监听器，该如何实现？\n\nspring boot 提供两种方式来添加自定义监听器：\n\n * 通过springapplication.addlisteners(applicationlistener... listeners)或者springapplication.setlisteners(collection> listeners)两个方法来添加一个或者多个自定义监听器\n * 既然 springapplication 的初始化流程中已经从spring.factories中获取到applicationlistener的实现类，那么我们直接在自己的 jar 包的meta-inf/spring.factories文件中新增配置即可：\n\norg.springframework.context.applicationlistener=\\\ncn.moondev.listeners.xxxxlistener\\\n\n\n关于 springapplication 的初始化，我们就说这么多。\n\n\n# 6.2 spring boot 启动流程\n\nspring boot 应用的整个启动流程都封装在 springapplication.run 方法中，其整个流程真的是太长太长了，但本质上就是在 spring 容器启动的基础上做了大量的扩展，按照这个思路来看看源码：\n\npublic configurableapplicationcontext run(string... args) {\n        stopwatch stopwatch = new stopwatch();\n        stopwatch.start();\n        configurableapplicationcontext context = null;\n        failureanalyzers analyzers = null;\n        configureheadlessproperty();\n        // ①\n        springapplicationrunlisteners listeners = getrunlisteners(args);\n        listeners.starting();\n        try {\n            // ②\n            applicationarguments applicationarguments = new defaultapplicationarguments(args);\n            configurableenvironment environment = prepareenvironment(listeners,applicationarguments);\n            // ③\n            banner printedbanner = printbanner(environment);\n            // ④\n            context = createapplicationcontext();\n            // ⑤\n            analyzers = new failureanalyzers(context);\n            // ⑥\n            preparecontext(context, environment, listeners, applicationarguments,printedbanner);\n            // ⑦\n            refreshcontext(context);\n            // ⑧\n            afterrefresh(context, applicationarguments);\n            // ⑨\n            listeners.finished(context, null);\n            stopwatch.stop();\n            return context;\n        }\n        catch (throwable ex) {\n            handlerunfailure(context, listeners, analyzers, ex);\n            throw new illegalstateexception(ex);\n        }\n    }\n\n\n① 通过 springfactoriesloader 查找并加载所有的springapplicationrunlisteners，通过调用 starting()方法通知所有的 springapplicationrunlisteners：应用开始启动了。springapplicationrunlisteners 其本质上就是一个事件发布者，它在 springboot 应用启动的不同时间点发布不同应用事件类型(applicationevent)，如果有哪些事件监听者(applicationlistener)对这些事件感兴趣，则可以接收并且处理。还记得初始化流程中，springapplication 加载了一系列 applicationlistener 吗？这个启动流程中没有发现有发布事件的代码，其实都已经在 springapplicationrunlisteners 这儿实现了。\n\n简单的分析一下其实现流程，首先看下 springapplicationrunlistener 的源码：\n\npublic interface springapplicationrunlistener {\n\n    // 运行run方法时立即调用此方法，可以用户非常早期的初始化工作\n    void starting();\n\n    // environment准备好后，并且applicationcontext创建之前调用\n    void environmentprepared(configurableenvironment environment);\n\n    // applicationcontext创建好后立即调用\n    void contextprepared(configurableapplicationcontext context);\n\n    // applicationcontext加载完成，在refresh之前调用\n    void contextloaded(configurableapplicationcontext context);\n\n    // 当run方法结束之前调用\n    void finished(configurableapplicationcontext context, throwable exception);\n\n}\n\n\nspringapplicationrunlistener 只有一个实现类：eventpublishingrunlistener。① 处的代码只会获取到一个 eventpublishingrunlistener 的实例，我们来看看 starting()方法的内容：\n\npublic void starting() {\n    // 发布一个applicationstartedevent\n    this.initialmulticaster.multicastevent(new applicationstartedevent(this.application, this.args));\n}\n\n\n顺着这个逻辑，你可以在 ② 处的prepareenvironment()方法的源码中找到listeners.environmentprepared(environment);即 springapplicationrunlistener 接口的第二个方法，那不出你所料，environmentprepared()又发布了另外一个事件applicationenvironmentpreparedevent。接下来会发生什么，就不用我多说了吧。\n\n② 创建并配置当前应用将要使用的environment，environment 用于描述应用程序当前的运行环境，其抽象了两个方面的内容：配置文件(profile)和属性(properties)，开发经验丰富的同学对这两个东西一定不会陌生：不同的环境(eg：生产环境、预发布环境)可以使用不同的配置文件，而属性则可以从配置文件、环境变量、命令行参数等来源获取。因此，当 environment 准备好后，在整个应用的任何时候，都可以从 environment 中获取资源。\n\n总结起来，② 处的两句代码，主要完成以下几件事：\n\n * 判断 environment 是否存在，不存在就创建（如果是 web 项目就创建standardservletenvironment，否则创建standardenvironment）\n * 配置 environment：配置 profile 以及 properties\n * 调用 springapplicationrunlistener 的environmentprepared()方法，通知事件监听者：应用的 environment 已经准备好\n\n③、springboot 应用在启动时会输出这样的东西：\n\n  .   ____          _            __ _ _\n /\\\\ / ___\'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\\n( ( )\\___ | \'_ | \'_| | \'_ \\/ _` | \\ \\ \\ \\\n \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )\n  \'  |____| .__|_| |_|_| |_\\__, | / / / /\n =========|_|==============|___/=/_/_/_/\n :: spring boot ::        (v1.5.6.release)\n\n\n如果想把这个东西改成自己的涂鸦，你可以研究以下 banner 的实现，这个任务就留给你们吧。\n\n④、根据是否是 web 项目，来创建不同的 applicationcontext 容器。\n\n⑤、创建一系列failureanalyzer，创建流程依然是通过 springfactoriesloader 获取到所有实现 failureanalyzer 接口的 class，然后在创建对应的实例。failureanalyzer 用于分析故障并提供相关诊断信息。\n\n⑥、初始化 applicationcontext，主要完成以下工作：\n\n * 将准备好的 environment 设置给 applicationcontext\n * 遍历调用所有的 applicationcontextinitializer 的initialize()方法来对已经创建好的 applicationcontext 进行进一步的处理\n * 调用 springapplicationrunlistener 的contextprepared()方法，通知所有的监听者：applicationcontext 已经准备完毕\n * 将所有的 bean 加载到容器中\n * 调用 springapplicationrunlistener 的contextloaded()方法，通知所有的监听者：applicationcontext 已经装载完毕\n\n⑦、调用 applicationcontext 的refresh()方法，完成 ioc 容器可用的最后一道工序。从名字上理解为刷新容器，那何为刷新？就是插手容器的启动，联系一下第一小节的内容。那如何刷新呢？且看下面代码：\n\n// 摘自refresh()方法中一句代码\ninvokebeanfactorypostprocessors(beanfactory);\n\n\n看看这个方法的实现：\n\nprotected void invokebeanfactorypostprocessors(configurablelistablebeanfactory beanfactory) {\n    postprocessorregistrationdelegate.invokebeanfactorypostprocessors(beanfactory, getbeanfactorypostprocessors());\n    ......\n}\n\n\n获取到所有的beanfactorypostprocessor来对容器做一些额外的操作。beanfactorypostprocessor 允许我们在容器实例化相应对象之前，对注册到容器的 beandefinition 所保存的信息做一些额外的操作。这里的 getbeanfactorypostprocessors()方法可以获取到 3 个 processor：\n\nconfigurationwarningsapplicationcontextinitializer$configurationwarningspostprocessor\nsharedmetadatareaderfactorycontextinitializer$cachingmetadatareaderfactorypostprocessor\nconfigfileapplicationlistener$propertysourceorderingpostprocessor\n\n\n不是有那么多 beanfactorypostprocessor 的实现类，为什么这儿只有这 3 个？因为在初始化流程获取到的各种 applicationcontextinitializer 和 applicationlistener 中，只有上文 3 个做了类似于如下操作：\n\npublic void initialize(configurableapplicationcontext context) {\n    context.addbeanfactorypostprocessor(new configurationwarningspostprocessor(getchecks()));\n}\n\n\n然后你就可以进入到postprocessorregistrationdelegate.invokebeanfactorypostprocessors()方法了，这个方法除了会遍历上面的 3 个 beanfactorypostprocessor 处理外，还会获取类型为beandefinitionregistrypostprocessor的 bean：org.springframework.context.annotation.internalconfigurationannotationprocessor，对应的 class 为configurationclasspostprocessor。configurationclasspostprocessor用于解析处理各种注解，包括：@configuration、@componentscan、@import、@propertysource、@importresource、@bean。当处理@import注解的时候，就会调用自动配置这一小节中的enableautoconfigurationimportselector.selectimports()来完成自动配置功能。其他的这里不再多讲，如果你有兴趣，可以查阅参考资料 6。\n\n⑧、查找当前 context 中是否注册有 commandlinerunner 和 applicationrunner，如果有则遍历执行它们。\n\n⑨、执行所有 springapplicationrunlistener 的 finished()方法。\n\n这就是 spring boot 的整个启动流程，其核心就是在 spring 容器初始化并启动的基础上加入各种扩展点，这些扩展点包括：applicationcontextinitializer、applicationlistener 以及各种 beanfactorypostprocessor 等等。你对整个流程的细节不必太过关注，甚至没弄明白也没有关系，你只要理解这些扩展点是在何时如何工作的，能让它们为你所用即可。\n\n整个启动流程确实非常复杂，可以查询参考资料中的部分章节和内容，对照着源码，多看看，我想最终你都能弄清楚的。言而总之，spring 才是核心，理解清楚 spring 容器的启动流程，那 spring boot 启动流程就不在话下了。\n\n\n# 参考资料\n\n[1]王福强 著；springboot 揭秘：快速构建微服务体系; 机械工业出版社, 2016 [2]王福强 著；spring 揭秘; 人民邮件出版社, 2009 [3]craig walls 著；丁雪丰 译；spring boot 实战；中国工信出版集团 人民邮电出版社，2016 [4]深入探讨 java 类加载器 : www.ibm.com/developerwo… [5]spring boot 实战：自动配置原理分析 : blog.csdn.net/liaokailin/… [6]spring boot实战：spring boot bean加载源码分析： blog.csdn.net/liaokailin/…',charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"SpringBoot 基本原理",frontmatter:{title:"SpringBoot 基本原理",date:"2020-08-12T07:01:26.000Z",order:22,categories:["Java","框架","Spring","Spring综合"],tags:["Java","框架","Spring","SpringBoot"],permalink:"/pages/dbf521/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/00.Spring%E7%BB%BC%E5%90%88/22.SpringBoot%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.html",relativePath:"01.Java/13.框架/01.Spring/00.Spring综合/22.SpringBoot基本原理.md",key:"v-59088176",path:"/pages/dbf521/",headers:[{level:2,title:"SpringBootApplication 背后的秘密",slug:"springbootapplication-背后的秘密",normalizedTitle:"springbootapplication 背后的秘密",charIndex:429},{level:2,title:"@Configuration",slug:"configuration",normalizedTitle:"@configuration",charIndex:1202},{level:2,title:"@ComponentScan",slug:"componentscan",normalizedTitle:"@componentscan",charIndex:870},{level:2,title:"@EnableAutoConfiguration",slug:"enableautoconfiguration",normalizedTitle:"@enableautoconfiguration",charIndex:780},{level:4,title:"AutoConfigurationPackage 注解：",slug:"autoconfigurationpackage-注解",normalizedTitle:"autoconfigurationpackage 注解：",charIndex:4561},{level:4,title:"Import(AutoConfigurationImportSelector.class)注解：",slug:"import-autoconfigurationimportselector-class-注解",normalizedTitle:"import(autoconfigurationimportselector.class)注解：",charIndex:5179},{level:3,title:"自动配置幕后英雄：SpringFactoriesLoader 详解",slug:"自动配置幕后英雄-springfactoriesloader-详解",normalizedTitle:"自动配置幕后英雄：springfactoriesloader 详解",charIndex:6686},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:7738}],headersStr:"SpringBootApplication 背后的秘密 @Configuration @ComponentScan @EnableAutoConfiguration AutoConfigurationPackage 注解： Import(AutoConfigurationImportSelector.class)注解： 自动配置幕后英雄：SpringFactoriesLoader 详解 参考资料",content:'# SpringBoot 基本原理\n\nSpringBoot 为我们做的自动配置，确实方便快捷，但一直搞不明白它的内部启动原理，这次就来一步步解开 SpringBoot 的神秘面纱，让它不再神秘。\n\n\n\n----------------------------------------\n\n@SpringBootApplication\npublic class Application {\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n}\n\n\n从上面代码可以看出，**Annotation 定义（@SpringBootApplication）和类定义（SpringApplication.run）**最为耀眼，所以要揭开 SpringBoot 的神秘面纱，我们要从这两位开始就可以了。\n\n\n# SpringBootApplication 背后的秘密\n\n@Target(ElementType.TYPE)            // 注解的适用范围，其中TYPE用于描述类、接口（包括包注解类型）或enum声明\n@Retention(RetentionPolicy.RUNTIME)  // 注解的生命周期，保留到class文件中（三个生命周期）\n@Documented                          // 表明这个注解应该被javadoc记录\n@Inherited                           // 子类可以继承该注解\n@SpringBootConfiguration             // 继承了Configuration，表示当前是注解类\n@EnableAutoConfiguration             // 开启springboot的注解功能，springboot的四大神器之一，其借助@import的帮助\n@ComponentScan(excludeFilters = {    // 扫描路径设置（具体使用待确认）\n        @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),\n        @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })\npublic @interface SpringBootApplication {\n...\n}\n\n\n虽然定义使用了多个 Annotation 进行了原信息标注，但实际上重要的只有三个 Annotation：\n\n@Configuration（@SpringBootConfiguration 点开查看发现里面还是应用了@Configuration） @EnableAutoConfiguration @ComponentScan 所以，如果我们使用如下的 SpringBoot 启动类，整个 SpringBoot 应用依然可以与之前的启动类功能对等：\n\n@Configuration\n@EnableAutoConfiguration\n@ComponentScan\npublic class Application {\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n}\n\n\n每次写这 3 个比较累，所以写一个@SpringBootApplication 方便点。接下来分别介绍这 3 个 Annotation。\n\n\n# @Configuration\n\n这里的@Configuration 对我们来说不陌生，它就是 JavaConfig 形式的 Spring Ioc 容器的配置类使用的那个@Configuration，SpringBoot 社区推荐使用基于 JavaConfig 的配置形式，所以，这里的启动类标注了@Configuration 之后，本身其实也是一个 IoC 容器的配置类。 举几个简单例子回顾下，XML 跟 config 配置方式的区别：\n\n表达形式层面 基于 XML 配置的方式是这样：\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"\n       default-lazy-init="true">\n    \x3c!--bean定义--\x3e\n</beans>\n\n\n而基于 JavaConfig 的配置方式是这样：\n\n@Configuration\npublic class MockConfiguration{\n    //bean定义\n}\n\n\n任何一个标注了@Configuration 的 Java 类定义都是一个 JavaConfig 配置类。\n\n注册 bean 定义层面 基于 XML 的配置形式是这样：\n\n<bean id="mockService" class="..MockServiceImpl">\n    ...\n</bean>\n\n\n而基于 JavaConfig 的配置形式是这样的：\n\n@Configuration\npublic class MockConfiguration{\n    @Bean\n    public MockService mockService(){\n        return new MockServiceImpl();\n    }\n}\n\n\n任何一个标注了@Bean 的方法，其返回值将作为一个 bean 定义注册到 Spring 的 IoC 容器，方法名将默认成该 bean 定义的 id。\n\n表达依赖注入关系层面 为了表达 bean 与 bean 之间的依赖关系，在 XML 形式中一般是这样：\n\n<bean id="mockService" class="..MockServiceImpl">\n    <propery name ="dependencyService" ref="dependencyService" />\n</bean>\n\n<bean id="dependencyService" class="DependencyServiceImpl"></bean>\n\n\n而基于 JavaConfig 的配置形式是这样的：\n\n@Configuration\npublic class MockConfiguration{\n    @Bean\n    public MockService mockService(){\n        return new MockServiceImpl(dependencyService());\n    }\n\n    @Bean\n    public DependencyService dependencyService(){\n        return new DependencyServiceImpl();\n    }\n}\n\n\n如果一个 bean 的定义依赖其他 bean,则直接调用对应的 JavaConfig 类中依赖 bean 的创建方法就可以了。\n\n\n# @ComponentScan\n\n@ComponentScan 这个注解在 Spring 中很重要，它对应 XML 配置中的元素，@ComponentScan 的功能其实就是自动扫描并加载符合条件的组件（比如@Component 和@Repository 等）或者 bean 定义，最终将这些 bean 定义加载到 IoC 容器中。\n\n我们可以通过 basePackages 等属性来细粒度的定制@ComponentScan 自动扫描的范围，如果不指定，则默认 Spring 框架实现会从声明@ComponentScan 所在类的 package 进行扫描。\n\n> 注：所以 SpringBoot 的启动类最好是放在 root package 下，因为默认不指定 basePackages。\n\n\n# @EnableAutoConfiguration\n\n个人感觉**@EnableAutoConfiguration 这个 Annotation 最为重要**，所以放在最后来解读，大家是否还记得 Spring 框架提供的各种名字为@Enable 开头的 Annotation 定义？比如@EnableScheduling、@EnableCaching、@EnableMBeanExport 等，@EnableAutoConfiguration 的理念和做事方式其实一脉相承，简单概括一下就是，借助@Import 的支持，收集和注册特定场景相关的 bean 定义。\n\n@EnableScheduling是通过@Import 将 Spring 调度框架相关的 bean 定义都加载到 IoC 容器。 @EnableMBeanExport是通过@Import 将 JMX 相关的 bean 定义加载到 IoC 容器。 而**@EnableAutoConfiguration**也是借助@Import 的帮助，将所有符合自动配置条件的 bean 定义加载到 IoC 容器，仅此而已！\n\n@EnableAutoConfiguration 作为一个复合 Annotation,其自身定义关键信息如下：\n\n@SuppressWarnings("deprecation")\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@AutoConfigurationPackage\n@Import(EnableAutoConfigurationImportSelector.class)\npublic @interface EnableAutoConfiguration {\n    ...\n}\n\n\n两个比较重要的注解：\n\n@AutoConfigurationPackage：自动配置包\n\n@Import: 导入自动配置的组件\n\n# AutoConfigurationPackage 注解：\n\nstatic class Registrar implements ImportBeanDefinitionRegistrar, DeterminableImports {\n\n        @Override\n        public void registerBeanDefinitions(AnnotationMetadata metadata,\n                BeanDefinitionRegistry registry) {\n            register(registry, new PackageImport(metadata).getPackageName());\n        }\n\n\n它其实是注册了一个 Bean 的定义。\n\nnew PackageImport(metadata).getPackageName()，它其实返回了当前主程序类的 同级以及子级 的包组件。\n\n\n\n以上图为例，DemoApplication 是和 demo 包同级，但是 demo2 这个类是 DemoApplication 的父级，和 example 包同级\n\n也就是说，DemoApplication 启动加载的 Bean 中，并不会加载 demo2，这也就是为什么，我们要把 DemoApplication 放在项目的最高级中。\n\n# Import(AutoConfigurationImportSelector.class)注解：\n\n\n\n可以从图中看出 AutoConfigurationImportSelector 继承了 DeferredImportSelector 继承了 ImportSelector\n\nImportSelector 有一个方法为：selectImports。\n\n@Override\n    public String[] selectImports(AnnotationMetadata annotationMetadata) {\n        if (!isEnabled(annotationMetadata)) {\n            return NO_IMPORTS;\n        }\n        AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader\n                .loadMetadata(this.beanClassLoader);\n        AnnotationAttributes attributes = getAttributes(annotationMetadata);\n        List<String> configurations = getCandidateConfigurations(annotationMetadata,\n                attributes);\n        configurations = removeDuplicates(configurations);\n        Set<String> exclusions = getExclusions(annotationMetadata, attributes);\n        checkExcludedClasses(configurations, exclusions);\n        configurations.removeAll(exclusions);\n        configurations = filter(configurations, autoConfigurationMetadata);\n        fireAutoConfigurationImportEvents(configurations, exclusions);\n        return StringUtils.toStringArray(configurations);\n    }\n\n\n可以看到第九行，它其实是去加载 public static final String FACTORIES_RESOURCE_LOCATION = "META-INF/spring.factories";外部文件。这个外部文件，有很多自动配置的类。如下：\n\n\n\nimage\n\n其中，最关键的要属**@Import(EnableAutoConfigurationImportSelector.class)，借助EnableAutoConfigurationImportSelector**，@EnableAutoConfiguration可以帮助 SpringBoot 应用将所有符合条件的**@Configuration**配置都加载到当前 SpringBoot 创建并使用的 IoC 容器。就像一只“八爪鱼”一样。\n\n\n\n\n# 自动配置幕后英雄：SpringFactoriesLoader 详解\n\n借助于 Spring 框架原有的一个工具类：SpringFactoriesLoader 的支持，@EnableAutoConfiguration 可以智能的自动配置功效才得以大功告成！\n\nSpringFactoriesLoader 属于 Spring 框架私有的一种扩展方案，其主要功能就是从指定的配置文件 META-INF/spring.factories 加载配置。\n\npublic abstract class SpringFactoriesLoader {\n    //...\n    public static <T> List<T> loadFactories(Class<T> factoryClass, ClassLoader classLoader) {\n        ...\n    }\n\n\n    public static List<String> loadFactoryNames(Class<?> factoryClass, ClassLoader classLoader) {\n        ....\n    }\n}\n\n\n配合**@EnableAutoConfiguration使用的话，它更多是提供一种配置查找的功能支持，即根据@EnableAutoConfiguration 的完整类名 org.springframework.boot.autoconfigure.EnableAutoConfiguration 作为查找的 Key,获取对应的一组@Configuration**类\n\n\n\n上图就是从 SpringBoot 的 autoconfigure 依赖包中的 META-INF/spring.factories 配置文件中摘录的一段内容，可以很好地说明问题。\n\n所以，@EnableAutoConfiguration 自动配置的魔法骑士就变成了：从 classpath 中搜寻所有的 META-INF/spring.factories 配置文件，并将其中 org.springframework.boot.autoconfigure.EnableutoConfiguration 对应的配置项通过反射（Java Refletion）实例化为对应的标注了@Configuration 的 JavaConfig 形式的 IoC 容器配置类，然后汇总为一个并加载到 IoC 容器。\n\n\n\n\n# 参考资料\n\n * 一文搞懂 springboot 启动原理',normalizedContent:'# springboot 基本原理\n\nspringboot 为我们做的自动配置，确实方便快捷，但一直搞不明白它的内部启动原理，这次就来一步步解开 springboot 的神秘面纱，让它不再神秘。\n\n\n\n----------------------------------------\n\n@springbootapplication\npublic class application {\n    public static void main(string[] args) {\n        springapplication.run(application.class, args);\n    }\n}\n\n\n从上面代码可以看出，**annotation 定义（@springbootapplication）和类定义（springapplication.run）**最为耀眼，所以要揭开 springboot 的神秘面纱，我们要从这两位开始就可以了。\n\n\n# springbootapplication 背后的秘密\n\n@target(elementtype.type)            // 注解的适用范围，其中type用于描述类、接口（包括包注解类型）或enum声明\n@retention(retentionpolicy.runtime)  // 注解的生命周期，保留到class文件中（三个生命周期）\n@documented                          // 表明这个注解应该被javadoc记录\n@inherited                           // 子类可以继承该注解\n@springbootconfiguration             // 继承了configuration，表示当前是注解类\n@enableautoconfiguration             // 开启springboot的注解功能，springboot的四大神器之一，其借助@import的帮助\n@componentscan(excludefilters = {    // 扫描路径设置（具体使用待确认）\n        @filter(type = filtertype.custom, classes = typeexcludefilter.class),\n        @filter(type = filtertype.custom, classes = autoconfigurationexcludefilter.class) })\npublic @interface springbootapplication {\n...\n}\n\n\n虽然定义使用了多个 annotation 进行了原信息标注，但实际上重要的只有三个 annotation：\n\n@configuration（@springbootconfiguration 点开查看发现里面还是应用了@configuration） @enableautoconfiguration @componentscan 所以，如果我们使用如下的 springboot 启动类，整个 springboot 应用依然可以与之前的启动类功能对等：\n\n@configuration\n@enableautoconfiguration\n@componentscan\npublic class application {\n    public static void main(string[] args) {\n        springapplication.run(application.class, args);\n    }\n}\n\n\n每次写这 3 个比较累，所以写一个@springbootapplication 方便点。接下来分别介绍这 3 个 annotation。\n\n\n# @configuration\n\n这里的@configuration 对我们来说不陌生，它就是 javaconfig 形式的 spring ioc 容器的配置类使用的那个@configuration，springboot 社区推荐使用基于 javaconfig 的配置形式，所以，这里的启动类标注了@configuration 之后，本身其实也是一个 ioc 容器的配置类。 举几个简单例子回顾下，xml 跟 config 配置方式的区别：\n\n表达形式层面 基于 xml 配置的方式是这样：\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n       xsi:schemalocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"\n       default-lazy-init="true">\n    \x3c!--bean定义--\x3e\n</beans>\n\n\n而基于 javaconfig 的配置方式是这样：\n\n@configuration\npublic class mockconfiguration{\n    //bean定义\n}\n\n\n任何一个标注了@configuration 的 java 类定义都是一个 javaconfig 配置类。\n\n注册 bean 定义层面 基于 xml 的配置形式是这样：\n\n<bean id="mockservice" class="..mockserviceimpl">\n    ...\n</bean>\n\n\n而基于 javaconfig 的配置形式是这样的：\n\n@configuration\npublic class mockconfiguration{\n    @bean\n    public mockservice mockservice(){\n        return new mockserviceimpl();\n    }\n}\n\n\n任何一个标注了@bean 的方法，其返回值将作为一个 bean 定义注册到 spring 的 ioc 容器，方法名将默认成该 bean 定义的 id。\n\n表达依赖注入关系层面 为了表达 bean 与 bean 之间的依赖关系，在 xml 形式中一般是这样：\n\n<bean id="mockservice" class="..mockserviceimpl">\n    <propery name ="dependencyservice" ref="dependencyservice" />\n</bean>\n\n<bean id="dependencyservice" class="dependencyserviceimpl"></bean>\n\n\n而基于 javaconfig 的配置形式是这样的：\n\n@configuration\npublic class mockconfiguration{\n    @bean\n    public mockservice mockservice(){\n        return new mockserviceimpl(dependencyservice());\n    }\n\n    @bean\n    public dependencyservice dependencyservice(){\n        return new dependencyserviceimpl();\n    }\n}\n\n\n如果一个 bean 的定义依赖其他 bean,则直接调用对应的 javaconfig 类中依赖 bean 的创建方法就可以了。\n\n\n# @componentscan\n\n@componentscan 这个注解在 spring 中很重要，它对应 xml 配置中的元素，@componentscan 的功能其实就是自动扫描并加载符合条件的组件（比如@component 和@repository 等）或者 bean 定义，最终将这些 bean 定义加载到 ioc 容器中。\n\n我们可以通过 basepackages 等属性来细粒度的定制@componentscan 自动扫描的范围，如果不指定，则默认 spring 框架实现会从声明@componentscan 所在类的 package 进行扫描。\n\n> 注：所以 springboot 的启动类最好是放在 root package 下，因为默认不指定 basepackages。\n\n\n# @enableautoconfiguration\n\n个人感觉**@enableautoconfiguration 这个 annotation 最为重要**，所以放在最后来解读，大家是否还记得 spring 框架提供的各种名字为@enable 开头的 annotation 定义？比如@enablescheduling、@enablecaching、@enablembeanexport 等，@enableautoconfiguration 的理念和做事方式其实一脉相承，简单概括一下就是，借助@import 的支持，收集和注册特定场景相关的 bean 定义。\n\n@enablescheduling是通过@import 将 spring 调度框架相关的 bean 定义都加载到 ioc 容器。 @enablembeanexport是通过@import 将 jmx 相关的 bean 定义加载到 ioc 容器。 而**@enableautoconfiguration**也是借助@import 的帮助，将所有符合自动配置条件的 bean 定义加载到 ioc 容器，仅此而已！\n\n@enableautoconfiguration 作为一个复合 annotation,其自身定义关键信息如下：\n\n@suppresswarnings("deprecation")\n@target(elementtype.type)\n@retention(retentionpolicy.runtime)\n@documented\n@inherited\n@autoconfigurationpackage\n@import(enableautoconfigurationimportselector.class)\npublic @interface enableautoconfiguration {\n    ...\n}\n\n\n两个比较重要的注解：\n\n@autoconfigurationpackage：自动配置包\n\n@import: 导入自动配置的组件\n\n# autoconfigurationpackage 注解：\n\nstatic class registrar implements importbeandefinitionregistrar, determinableimports {\n\n        @override\n        public void registerbeandefinitions(annotationmetadata metadata,\n                beandefinitionregistry registry) {\n            register(registry, new packageimport(metadata).getpackagename());\n        }\n\n\n它其实是注册了一个 bean 的定义。\n\nnew packageimport(metadata).getpackagename()，它其实返回了当前主程序类的 同级以及子级 的包组件。\n\n\n\n以上图为例，demoapplication 是和 demo 包同级，但是 demo2 这个类是 demoapplication 的父级，和 example 包同级\n\n也就是说，demoapplication 启动加载的 bean 中，并不会加载 demo2，这也就是为什么，我们要把 demoapplication 放在项目的最高级中。\n\n# import(autoconfigurationimportselector.class)注解：\n\n\n\n可以从图中看出 autoconfigurationimportselector 继承了 deferredimportselector 继承了 importselector\n\nimportselector 有一个方法为：selectimports。\n\n@override\n    public string[] selectimports(annotationmetadata annotationmetadata) {\n        if (!isenabled(annotationmetadata)) {\n            return no_imports;\n        }\n        autoconfigurationmetadata autoconfigurationmetadata = autoconfigurationmetadataloader\n                .loadmetadata(this.beanclassloader);\n        annotationattributes attributes = getattributes(annotationmetadata);\n        list<string> configurations = getcandidateconfigurations(annotationmetadata,\n                attributes);\n        configurations = removeduplicates(configurations);\n        set<string> exclusions = getexclusions(annotationmetadata, attributes);\n        checkexcludedclasses(configurations, exclusions);\n        configurations.removeall(exclusions);\n        configurations = filter(configurations, autoconfigurationmetadata);\n        fireautoconfigurationimportevents(configurations, exclusions);\n        return stringutils.tostringarray(configurations);\n    }\n\n\n可以看到第九行，它其实是去加载 public static final string factories_resource_location = "meta-inf/spring.factories";外部文件。这个外部文件，有很多自动配置的类。如下：\n\n\n\nimage\n\n其中，最关键的要属**@import(enableautoconfigurationimportselector.class)，借助enableautoconfigurationimportselector**，@enableautoconfiguration可以帮助 springboot 应用将所有符合条件的**@configuration**配置都加载到当前 springboot 创建并使用的 ioc 容器。就像一只“八爪鱼”一样。\n\n\n\n\n# 自动配置幕后英雄：springfactoriesloader 详解\n\n借助于 spring 框架原有的一个工具类：springfactoriesloader 的支持，@enableautoconfiguration 可以智能的自动配置功效才得以大功告成！\n\nspringfactoriesloader 属于 spring 框架私有的一种扩展方案，其主要功能就是从指定的配置文件 meta-inf/spring.factories 加载配置。\n\npublic abstract class springfactoriesloader {\n    //...\n    public static <t> list<t> loadfactories(class<t> factoryclass, classloader classloader) {\n        ...\n    }\n\n\n    public static list<string> loadfactorynames(class<?> factoryclass, classloader classloader) {\n        ....\n    }\n}\n\n\n配合**@enableautoconfiguration使用的话，它更多是提供一种配置查找的功能支持，即根据@enableautoconfiguration 的完整类名 org.springframework.boot.autoconfigure.enableautoconfiguration 作为查找的 key,获取对应的一组@configuration**类\n\n\n\n上图就是从 springboot 的 autoconfigure 依赖包中的 meta-inf/spring.factories 配置文件中摘录的一段内容，可以很好地说明问题。\n\n所以，@enableautoconfiguration 自动配置的魔法骑士就变成了：从 classpath 中搜寻所有的 meta-inf/spring.factories 配置文件，并将其中 org.springframework.boot.autoconfigure.enableutoconfiguration 对应的配置项通过反射（java refletion）实例化为对应的标注了@configuration 的 javaconfig 形式的 ioc 容器配置类，然后汇总为一个并加载到 ioc 容器。\n\n\n\n\n# 参考资料\n\n * 一文搞懂 springboot 启动原理',charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Spring 综述",frontmatter:{title:"Spring 综述",date:"2020-02-26T23:48:06.000Z",categories:["Java","框架","Spring","Spring综合"],tags:["Java","框架","Spring","SpringBoot"],permalink:"/pages/9e0b67/",hidden:!0,index:!1},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/00.Spring%E7%BB%BC%E5%90%88/",relativePath:"01.Java/13.框架/01.Spring/00.Spring综合/README.md",key:"v-372d1374",path:"/pages/9e0b67/",headers:[{level:2,title:"📖 内容",slug:"📖-内容",normalizedTitle:"📖 内容",charIndex:16},{level:2,title:"📚 资料",slug:"📚-资料",normalizedTitle:"📚 资料",charIndex:91},{level:2,title:"🚪 传送",slug:"🚪-传送",normalizedTitle:"🚪 传送",charIndex:270}],headersStr:"📖 内容 📚 资料 🚪 传送",content:"# Spring 综述\n\n\n# 📖 内容\n\n * Spring 概述\n * SpringBoot 知识图谱\n * SpringBoot 基本原理\n * Spring 面试\n\n\n# 📚 资料\n\n * 官方\n   * Spring 官网\n   * Spring Framework 官方文档\n   * Spring Github\n * 书籍\n   * 《Spring In Action》\n * 教程\n   * 《小马哥讲 Spring 核心编程思想》\n   * geekbang-lessons\n   * 跟我学 Spring3\n\n\n# 🚪 传送\n\n◾ 💧 钝悟的 IT 知识图谱 ◾",normalizedContent:"# spring 综述\n\n\n# 📖 内容\n\n * spring 概述\n * springboot 知识图谱\n * springboot 基本原理\n * spring 面试\n\n\n# 📚 资料\n\n * 官方\n   * spring 官网\n   * spring framework 官方文档\n   * spring github\n * 书籍\n   * 《spring in action》\n * 教程\n   * 《小马哥讲 spring 核心编程思想》\n   * geekbang-lessons\n   * 跟我学 spring3\n\n\n# 🚪 传送\n\n◾ 💧 钝悟的 it 知识图谱 ◾",charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Spring 面试",frontmatter:{title:"Spring 面试",date:"2018-08-02T17:33:32.000Z",order:99,categories:["Java","框架","Spring","Spring综合"],tags:["Java","框架","Spring","面试"],permalink:"/pages/db33b0/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/00.Spring%E7%BB%BC%E5%90%88/99.Spring%E9%9D%A2%E8%AF%95.html",relativePath:"01.Java/13.框架/01.Spring/00.Spring综合/99.Spring面试.md",key:"v-4e3a5110",path:"/pages/db33b0/",headers:[{level:2,title:"综合篇",slug:"综合篇",normalizedTitle:"综合篇",charIndex:16},{level:3,title:"不同版本的 Spring Framework 有哪些主要功能？",slug:"不同版本的-spring-framework-有哪些主要功能",normalizedTitle:"不同版本的 spring framework 有哪些主要功能？",charIndex:24},{level:3,title:"什么是 Spring Framework？",slug:"什么是-spring-framework",normalizedTitle:"什么是 spring framework？",charIndex:222},{level:3,title:"列举 Spring Framework 的优点。",slug:"列举-spring-framework-的优点。",normalizedTitle:"列举 spring framework 的优点。",charIndex:404},{level:3,title:"Spring Framework 有哪些不同的功能？",slug:"spring-framework-有哪些不同的功能",normalizedTitle:"spring framework 有哪些不同的功能？",charIndex:588},{level:3,title:"Spring Framework 中有多少个模块，它们分别是什么？",slug:"spring-framework-中有多少个模块-它们分别是什么",normalizedTitle:"spring framework 中有多少个模块，它们分别是什么？",charIndex:891},{level:3,title:"什么是 Spring 配置文件？",slug:"什么是-spring-配置文件",normalizedTitle:"什么是 spring 配置文件？",charIndex:1605},{level:3,title:"Spring 应用程序有哪些不同组件？",slug:"spring-应用程序有哪些不同组件",normalizedTitle:"spring 应用程序有哪些不同组件？",charIndex:1726},{level:3,title:"使用 Spring 有哪些方式？",slug:"使用-spring-有哪些方式",normalizedTitle:"使用 spring 有哪些方式？",charIndex:1911},{level:2,title:"核心篇",slug:"核心篇",normalizedTitle:"核心篇",charIndex:2090},{level:3,title:"IoC",slug:"ioc",normalizedTitle:"ioc",charIndex:2098},{level:4,title:"什么是 IoC？什么是依赖注入？什么是 Spring IoC？",slug:"什么是-ioc-什么是依赖注入-什么是-spring-ioc",normalizedTitle:"什么是 ioc？什么是依赖注入？什么是 spring ioc？",charIndex:2105},{level:4,title:"依赖注入有哪些实现方式？",slug:"依赖注入有哪些实现方式",normalizedTitle:"依赖注入有哪些实现方式？",charIndex:2489},{level:4,title:"构造器注入 VS. setter 注入",slug:"构造器注入-vs-setter-注入",normalizedTitle:"构造器注入 vs. setter 注入",charIndex:2814},{level:4,title:"BeanFactory VS. ApplicationContext",slug:"beanfactory-vs-applicationcontext",normalizedTitle:"beanfactory vs. applicationcontext",charIndex:2991},{level:4,title:"BeanFactory VS. FactoryBean",slug:"beanfactory-vs-factorybean",normalizedTitle:"beanfactory vs. factorybean",charIndex:3371},{level:4,title:"Spring IoC 启动时做了哪些准备",slug:"spring-ioc-启动时做了哪些准备",normalizedTitle:"spring ioc 启动时做了哪些准备",charIndex:3477},{level:4,title:"Spring IoC 的实现机制是什么",slug:"spring-ioc-的实现机制是什么",normalizedTitle:"spring ioc 的实现机制是什么",charIndex:3553},{level:3,title:"Bean",slug:"bean",normalizedTitle:"bean",charIndex:727},{level:4,title:"什么是 Spring Bean",slug:"什么是-spring-bean",normalizedTitle:"什么是 spring bean",charIndex:4334},{level:4,title:"如何注册 Spring Bean",slug:"如何注册-spring-bean",normalizedTitle:"如何注册 spring bean",charIndex:4726},{level:4,title:"spring 提供了哪些配置方式？",slug:"spring-提供了哪些配置方式",normalizedTitle:"spring 提供了哪些配置方式？",charIndex:4777},{level:4,title:"spring 支持集中 bean scope？",slug:"spring-支持集中-bean-scope",normalizedTitle:"spring 支持集中 bean scope？",charIndex:5548},{level:4,title:"Spring Bean 的生命周期",slug:"spring-bean-的生命周期",normalizedTitle:"spring bean 的生命周期",charIndex:6126},{level:4,title:"什么是 spring 的内部 bean？",slug:"什么是-spring-的内部-bean",normalizedTitle:"什么是 spring 的内部 bean？",charIndex:7479},{level:4,title:"什么是 spring 装配",slug:"什么是-spring-装配",normalizedTitle:"什么是 spring 装配",charIndex:8264},{level:4,title:"自动装配有哪些方式？",slug:"自动装配有哪些方式",normalizedTitle:"自动装配有哪些方式？",charIndex:8387},{level:4,title:"自动装配有什么局限？",slug:"自动装配有什么局限",normalizedTitle:"自动装配有什么局限？",charIndex:8762},{level:3,title:"AOP",slug:"aop",normalizedTitle:"aop",charIndex:665},{level:4,title:"什么是 AOP？",slug:"什么是-aop",normalizedTitle:"什么是 aop？",charIndex:8930},{level:4,title:"AOP 中的 Aspect、Advice、Pointcut、JointPoint 和 Advice 参数分别是什么？",slug:"aop-中的-aspect、advice、pointcut、jointpoint-和-advice-参数分别是什么",normalizedTitle:"aop 中的 aspect、advice、pointcut、jointpoint 和 advice 参数分别是什么？",charIndex:9117},{level:4,title:"什么是通知（Advice）？",slug:"什么是通知-advice",normalizedTitle:"什么是通知（advice）？",charIndex:9829},{level:4,title:"有哪些类型的通知（Advice）？",slug:"有哪些类型的通知-advice",normalizedTitle:"有哪些类型的通知（advice）？",charIndex:9943},{level:4,title:"指出在 spring aop 中 concern 和 cross-cutting concern 的不同之处。",slug:"指出在-spring-aop-中-concern-和-cross-cutting-concern-的不同之处。",normalizedTitle:"指出在 spring aop 中 concern 和 cross-cutting concern 的不同之处。",charIndex:10335},{level:4,title:"AOP 有哪些实现方式？",slug:"aop-有哪些实现方式",normalizedTitle:"aop 有哪些实现方式？",charIndex:10539},{level:4,title:"Spring AOP and AspectJ AOP 有什么区别？",slug:"spring-aop-and-aspectj-aop-有什么区别",normalizedTitle:"spring aop and aspectj aop 有什么区别？",charIndex:10756},{level:4,title:"如何理解 Spring 中的代理？",slug:"如何理解-spring-中的代理",normalizedTitle:"如何理解 spring 中的代理？",charIndex:10899},{level:4,title:"什么是编织（Weaving）？",slug:"什么是编织-weaving",normalizedTitle:"什么是编织（weaving）？",charIndex:11007},{level:2,title:"注解",slug:"注解",normalizedTitle:"注解",charIndex:109},{level:3,title:"你用过哪些重要的 Spring 注解？",slug:"你用过哪些重要的-spring-注解",normalizedTitle:"你用过哪些重要的 spring 注解？",charIndex:11122},{level:3,title:"如何在 spring 中启动注解装配？",slug:"如何在-spring-中启动注解装配",normalizedTitle:"如何在 spring 中启动注解装配？",charIndex:11611},{level:3,title:"@Component, @Controller, @Repository, @Service 有何区别？",slug:"component-controller-repository-service-有何区别",normalizedTitle:"@component, @controller, @repository, @service 有何区别？",charIndex:11732},{level:3,title:"@Required 注解有什么用？",slug:"required-注解有什么用",normalizedTitle:"@required 注解有什么用？",charIndex:12178},{level:3,title:"@Autowired 注解有什么用？",slug:"autowired-注解有什么用",normalizedTitle:"@autowired 注解有什么用？",charIndex:12535},{level:3,title:"@Qualifier 注解有什么用？",slug:"qualifier-注解有什么用",normalizedTitle:"@qualifier 注解有什么用？",charIndex:12853},{level:3,title:"@RequestMapping 注解有什么用？",slug:"requestmapping-注解有什么用",normalizedTitle:"@requestmapping 注解有什么用？",charIndex:13478},{level:2,title:"数据篇",slug:"数据篇",normalizedTitle:"数据篇",charIndex:13622},{level:3,title:"spring DAO 有什么用？",slug:"spring-dao-有什么用",normalizedTitle:"spring dao 有什么用？",charIndex:13630},{level:3,title:"列举 Spring DAO 抛出的异常。",slug:"列举-spring-dao-抛出的异常。",normalizedTitle:"列举 spring dao 抛出的异常。",charIndex:13757},{level:3,title:"spring JDBC API 中存在哪些类？",slug:"spring-jdbc-api-中存在哪些类",normalizedTitle:"spring jdbc api 中存在哪些类？",charIndex:13784},{level:3,title:"使用 Spring 访问 Hibernate 的方法有哪些？",slug:"使用-spring-访问-hibernate-的方法有哪些",normalizedTitle:"使用 spring 访问 hibernate 的方法有哪些？",charIndex:13919},{level:3,title:"列举 spring 支持的事务管理类型",slug:"列举-spring-支持的事务管理类型",normalizedTitle:"列举 spring 支持的事务管理类型",charIndex:14060},{level:3,title:"spring 支持哪些 ORM 框架",slug:"spring-支持哪些-orm-框架",normalizedTitle:"spring 支持哪些 orm 框架",charIndex:14209},{level:2,title:"MVC",slug:"mvc",normalizedTitle:"mvc",charIndex:745},{level:3,title:"Spring MVC 框架有什么用？",slug:"spring-mvc-框架有什么用",normalizedTitle:"spring mvc 框架有什么用？",charIndex:14285},{level:3,title:"描述一下 DispatcherServlet 的工作流程",slug:"描述一下-dispatcherservlet-的工作流程",normalizedTitle:"描述一下 dispatcherservlet 的工作流程",charIndex:14431},{level:3,title:"介绍一下 WebApplicationContext",slug:"介绍一下-webapplicationcontext",normalizedTitle:"介绍一下 webapplicationcontext",charIndex:15427},{level:2,title:"资料",slug:"资料",normalizedTitle:"资料",charIndex:15682}],headersStr:"综合篇 不同版本的 Spring Framework 有哪些主要功能？ 什么是 Spring Framework？ 列举 Spring Framework 的优点。 Spring Framework 有哪些不同的功能？ Spring Framework 中有多少个模块，它们分别是什么？ 什么是 Spring 配置文件？ Spring 应用程序有哪些不同组件？ 使用 Spring 有哪些方式？ 核心篇 IoC 什么是 IoC？什么是依赖注入？什么是 Spring IoC？ 依赖注入有哪些实现方式？ 构造器注入 VS. setter 注入 BeanFactory VS. ApplicationContext BeanFactory VS. FactoryBean Spring IoC 启动时做了哪些准备 Spring IoC 的实现机制是什么 Bean 什么是 Spring Bean 如何注册 Spring Bean spring 提供了哪些配置方式？ spring 支持集中 bean scope？ Spring Bean 的生命周期 什么是 spring 的内部 bean？ 什么是 spring 装配 自动装配有哪些方式？ 自动装配有什么局限？ AOP 什么是 AOP？ AOP 中的 Aspect、Advice、Pointcut、JointPoint 和 Advice 参数分别是什么？ 什么是通知（Advice）？ 有哪些类型的通知（Advice）？ 指出在 spring aop 中 concern 和 cross-cutting concern 的不同之处。 AOP 有哪些实现方式？ Spring AOP and AspectJ AOP 有什么区别？ 如何理解 Spring 中的代理？ 什么是编织（Weaving）？ 注解 你用过哪些重要的 Spring 注解？ 如何在 spring 中启动注解装配？ @Component, @Controller, @Repository, @Service 有何区别？ @Required 注解有什么用？ @Autowired 注解有什么用？ @Qualifier 注解有什么用？ @RequestMapping 注解有什么用？ 数据篇 spring DAO 有什么用？ 列举 Spring DAO 抛出的异常。 spring JDBC API 中存在哪些类？ 使用 Spring 访问 Hibernate 的方法有哪些？ 列举 spring 支持的事务管理类型 spring 支持哪些 ORM 框架 MVC Spring MVC 框架有什么用？ 描述一下 DispatcherServlet 的工作流程 介绍一下 WebApplicationContext 资料",content:'# Spring 面试\n\n\n# 综合篇\n\n\n# 不同版本的 Spring Framework 有哪些主要功能？\n\nVERSION      FEATURE\nSpring 2.5   发布于 2007 年。这是第一个支持注解的版本。\nSpring 3.0   发布于 2009 年。它完全利用了 Java5 中的改进，并为 JEE6 提供了支持。\nSpring 4.0   发布于 2013 年。这是第一个完全支持 JAVA8 的版本。\n\n\n# 什么是 Spring Framework？\n\n * Spring 是一个开源应用框架，旨在降低应用程序开发的复杂度。\n * 它是轻量级、松散耦合的。\n * 它具有分层体系结构，允许用户选择组件，同时还为 J2EE 应用程序开发提供了一个有凝聚力的框架。\n * 它可以集成其他框架，如 Structs、Hibernate、EJB 等，所以又称为框架的框架。\n\n\n# 列举 Spring Framework 的优点。\n\n * 由于 Spring Frameworks 的分层架构，用户可以自由选择自己需要的组件。\n * Spring Framework 支持 POJO(Plain Old Java Object) 编程，从而具备持续集成和可测试性。\n * 由于依赖注入和控制反转，JDBC 得以简化。\n * 它是开源免费的。\n\n\n# Spring Framework 有哪些不同的功能？\n\n * 轻量级 - Spring 在代码量和透明度方面都很轻便。\n * IOC - 控制反转\n * AOP - 面向切面编程可以将应用业务逻辑和系统服务分离，以实现高内聚。\n * 容器 - Spring 负责创建和管理对象（Bean）的生命周期和配置。\n * MVC - 对 web 应用提供了高度可配置性，其他框架的集成也十分方便。\n * 事务管理 - 提供了用于事务管理的通用抽象层。Spring 的事务支持也可用于容器较少的环境。\n * JDBC 异常 - Spring 的 JDBC 抽象层提供了一个异常层次结构，简化了错误处理策略。\n\n\n# Spring Framework 中有多少个模块，它们分别是什么？\n\n\n\n * Spring 核心容器 – 该层基本上是 Spring Framework 的核心。它包含以下模块：\n   * Spring Core\n   * Spring Bean\n   * SpEL (Spring Expression Language)\n   * Spring Context\n * 数据访问/集成 – 该层提供与数据库交互的支持。它包含以下模块：\n   * JDBC (Java DataBase Connectivity)\n   * ORM (Object Relational Mapping)\n   * OXM (Object XML Mappers)\n   * JMS (Java Messaging Service)\n   * Transaction\n * Web – 该层提供了创建 Web 应用程序的支持。它包含以下模块：\n   * Web\n   * Web – Servlet\n   * Web – Socket\n   * Web – Portlet\n * AOP – 该层支持面向切面编程\n * Instrumentation – 该层为类检测和类加载器实现提供支持。\n * Test – 该层为使用 JUnit 和 TestNG 进行测试提供支持。\n * 几个杂项模块:\n   * Messaging – 该模块为 STOMP 提供支持。它还支持注解编程模型，该模型用于从 WebSocket 客户端路由和处理 STOMP 消息。\n   * Aspects – 该模块为与 AspectJ 的集成提供支持。\n\n\n# 什么是 Spring 配置文件？\n\nSpring 配置文件是 XML 文件。该文件主要包含类信息。它描述了这些类是如何配置以及相互引入的。但是，XML 配置文件冗长且更加干净。如果没有正确规划和编写，那么在大项目中管理变得非常困难。\n\n\n# Spring 应用程序有哪些不同组件？\n\nSpring 应用一般有以下组件：\n\n * 接口 - 定义功能。\n * Bean 类 - 它包含属性，setter 和 getter 方法，函数等。\n * Spring 面向切面编程（AOP） - 提供面向切面编程的功能。\n * Bean 配置文件 - 包含类的信息以及如何配置它们。\n * 用户程序 - 它使用接口。\n\n\n# 使用 Spring 有哪些方式？\n\n使用 Spring 有以下方式：\n\n * 作为一个成熟的 Spring Web 应用程序。\n * 作为第三方 Web 框架，使用 Spring Frameworks 中间层。\n * 用于远程使用。\n * 作为企业级 Java Bean，它可以包装现有的 POJO（Plain Old Java Objects）。\n\n\n# 核心篇\n\n\n# IoC\n\n# 什么是 IoC？什么是依赖注入？什么是 Spring IoC？\n\nIoC 即控制反转（Inversion of Control，缩写为 IoC）。IoC 又称为依赖倒置原则（设计模式六大原则之一），它的要点在于：程序要依赖于抽象接口，不要依赖于具体实现。它的作用就是用于降低代码间的耦合度。\n\nIoC 的实现方式有两种：\n\n * 依赖注入（Dependency Injection，简称 DI）：不通过 new() 的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造器、函数参数等方式传递（或注入）给类使用。\n * 依赖查找（Dependency Lookup）：容器中的受控对象通过容器的 API 来查找自己所依赖的资源和协作对象。\n\nSpring IoC 是 IoC 的一种实现。DI 是 Spring IoC 的主要实现原则。\n\n\n\n# 依赖注入有哪些实现方式？\n\n依赖注入有如下方式：\n\n依赖注入方式        配置元数据举例\nSetter 方法注入   <proeprty name="user" ref="userBean"/>\n构造器注入         <constructor-arg name="user" ref="userBean" />\n字段注入          @Autowired User user;\n方法注入          @Autowired public void user(User user) { ... }\n接口回调注入        class MyBean implements BeanFactoryAware { ... }\n\n# 构造器注入 VS. setter 注入\n\n构造器注入            SETTER 注入\n没有部分注入           有部分注入\n不会覆盖 setter 属性   会覆盖 setter 属性\n任意修改都会创建一个新实例    任意修改不会创建一个新实例\n适用于设置很多属性        适用于设置少量属性\n\n官方推荐使用构造器注入。\n\n# BeanFactory VS. ApplicationContext\n\n在 Spring 中，有两种 IoC 容器：BeanFactory 和 ApplicationContext。\n\n * BeanFactory：BeanFactory 是 Spring 基础 IoC 容器。BeanFactory 提供了 Spring 容器的配置框架和基本功能。\n * ApplicationContext：ApplicationContext 是具备应用特性的 BeanFactory 的子接口。它还扩展了其他一些接口，以支持更丰富的功能，如：国际化、访问资源、事件机制、更方便的支持 AOP、在 web 应用中指定应用层上下文等。\n\n实际开发中，更推荐使用 ApplicationContext 作为 IoC 容器，因为它的功能远多于 BeanFactory。\n\n# BeanFactory VS. FactoryBean\n\nBeanFactory 是 Spring 基础 IoC 容器。\n\nFactoryBean 是创建 Bean 的一种方式，帮助实现复杂的初始化逻辑。\n\n# Spring IoC 启动时做了哪些准备\n\nIoC 配置元信息读取和解析\n\nIoC 容器生命周期管理\n\nSpring 事件发布\n\n国际化\n\n等等\n\n# Spring IoC 的实现机制是什么\n\nSpring 中的 IoC 的实现原理就是工厂模式加反射机制。\n\n示例：\n\ninterface Fruit {\n     public abstract void eat();\n}\nclass Apple implements Fruit {\n    public void eat(){\n        System.out.println("Apple");\n    }\n}\nclass Orange implements Fruit {\n    public void eat(){\n        System.out.println("Orange");\n    }\n}\nclass Factory {\n    public static Fruit getInstance(String ClassName) {\n        Fruit f=null;\n        try {\n            f=(Fruit)Class.forName(ClassName).newInstance();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return f;\n    }\n}\nclass Client {\n    public static void main(String[] a) {\n        Fruit f=Factory.getInstance("io.github.dunwu.spring.Apple");\n        if(f!=null){\n            f.eat();\n        }\n    }\n}\n\n\n\n# Bean\n\n# 什么是 Spring Bean\n\n在 Spring 中，构成应用程序主体由 Spring IoC 容器管理的对象称为 Bean。Bean 是由 Spring IoC 容器实例化、装配和管理的对象。 Bean 以及它们之间的依赖关系反映在容器使用的配置元数据中。\n\nSpring IoC 容器本身，并不能识别配置的元数据。为此，要将这些配置信息转为 Spring 能识别的格式——BeanDefinition 对象。\n\nBeanDefinition 是 Spring 中定义 Bean 的配置元信息接口，它包含：\n\n * Bean 类名\n * Bean 行为配置元素，如：作用域、自动绑定的模式、生命周期回调等\n * 其他 Bean 引用，也可称为合作者（Collaborators）或依赖（Dependencies）\n * 配置设置，如 Bean 属性（Properties）\n\n# 如何注册 Spring Bean\n\n通过 BeanDefinition 和外部单例对象来注册。\n\n# spring 提供了哪些配置方式？\n\n * 基于 xml 配置\n\nbean 所需的依赖项和服务在 XML 格式的配置文件中指定。这些配置文件通常包含许多 bean 定义和特定于应用程序的配置选项。它们通常以 bean 标签开头。例如：\n\n<bean id="studentbean" class="org.edureka.firstSpring.StudentBean">\n <property name="name" value="Edureka"></property>\n</bean>\n\n\n * 基于注解配置\n\n您可以通过在相关的类，方法或字段声明上使用注解，将 bean 配置为组件类本身，而不是使用 XML 来描述 bean 装配。默认情况下，Spring 容器中未打开注解装配。因此，您需要在使用它之前在 Spring 配置文件中启用它。例如：\n\n<beans>\n<context:annotation-config/>\n\x3c!-- bean definitions go here --\x3e\n</beans>\n\n\n * 基于 Java API 配置\n\nSpring 的 Java 配置是通过使用 @Bean 和 @Configuration 来实现。\n\n 1. @Bean 注解扮演与 <bean /> 元素相同的角色。\n 2. @Configuration 类允许通过简单地调用同一个类中的其他 @Bean 方法来定义 bean 间依赖关系。\n\n例如：\n\n@Configuration\npublic class StudentConfig {\n    @Bean\n    public StudentBean myStudent() {\n        return new StudentBean();\n    }\n}\n\n\n# spring 支持集中 bean scope？\n\nSpring bean 支持 5 种 scope：\n\n * Singleton - 每个 Spring IoC 容器仅有一个单实例。\n * Prototype - 每次请求都会产生一个新的实例。\n * Request - 每一次 HTTP 请求都会产生一个新的实例，并且该 bean 仅在当前 HTTP 请求内有效。\n * Session - 每一次 HTTP 请求都会产生一个新的 bean，同时该 bean 仅在当前 HTTP session 内有效。\n * Global-session - 类似于标准的 HTTP Session 作用域，不过它仅仅在基于 portlet 的 web 应用中才有意义。Portlet 规范定义了全局 Session 的概念，它被所有构成某个 portlet web 应用的各种不同的 portlet 所共享。在 global session 作用域中定义的 bean 被限定于全局 portlet Session 的生命周期范围内。如果你在 web 中使用 global session 作用域来标识 bean，那么 web 会自动当成 session 类型来使用。\n\n仅当用户使用支持 Web 的 ApplicationContext 时，最后三个才可用。\n\n# Spring Bean 的生命周期\n\n\n\nspring bean 容器的生命周期如下：\n\n 1.  Spring 对 Bean 进行实例化（相当于 new XXX()）\n\n 2.  Spring 将值和引用注入到 Bean 对应的属性中\n\n 3.  如果 Bean 实现了 BeanNameAware 接口，Spring 将 Bean 的 ID 传递给 setBeanName 方法\n     \n     * 作用是通过 Bean 的引用来获得 Bean ID，一般业务中是很少有用到 Bean 的 ID 的\n\n 4.  如果 Bean 实现了 BeanFactoryAware 接口，Spring 将调用 setBeanDactory 方法，并把 BeanFactory 容器实例作为参数传入。\n     \n     * 作用是获取 Spring 容器，如 Bean 通过 Spring 容器发布事件等\n\n 5.  如果 Bean 实现了 ApplicationContextAware 接口，Spring 容器将调用 setApplicationContext 方法，把应用上下文作为参数传入\n     \n     * 作用与 BeanFactory 类似都是为了获取 Spring 容器，不同的是 Spring 容器在调用 setApplicationContext 方法时会把它自己作为 setApplicationContext 的参数传入，而 Spring 容器在调用 setBeanFactory 前需要使用者自己指定（注入）setBeanFactory 里的参数 BeanFactory\n\n 6.  如果 Bean 实现了 BeanPostProcess 接口，Spring 将调用 postProcessBeforeInitialization 方法\n     \n     * 作用是在 Bean 实例创建成功后对其进行增强处理，如对 Bean 进行修改，增加某个功能\n\n 7.  如果 Bean 实现了 InitializingBean 接口，Spring 将调用 afterPropertiesSet 方法，作用与在配置文件中对 Bean 使用 init-method 声明初始化的作用一样，都是在 Bean 的全部属性设置成功后执行的初始化方法。\n\n 8.  如果 Bean 实现了 BeanPostProcess 接口，Spring 将调用 postProcessAfterInitialization 方法\n     \n     * postProcessBeforeInitialization 是在 Bean 初始化前执行的，而 postProcessAfterInitialization 是在 Bean 初始化后执行的\n\n 9.  经过以上的工作后，Bean 将一直驻留在应用上下文中给应用使用，直到应用上下文被销毁\n\n 10. 如果 Bean 实现了 DispostbleBean 接口，Spring 将调用它的 destory 方法，作用与在配置文件中对 Bean 使用 destory-method 属性的作用一样，都是在 Bean 实例销毁前执行的方法。\n\n# 什么是 spring 的内部 bean？\n\n只有将 bean 用作另一个 bean 的属性时，才能将 bean 声明为内部 bean。为了定义 bean，Spring 的基于 XML 的配置元数据在 <property> 或 <constructor-arg> 中提供了 <bean> 元素的使用。内部 bean 总是匿名的，它们总是作为原型。\n\n例如，假设我们有一个 Student 类，其中引用了 Person 类。这里我们将只创建一个 Person 类实例并在 Student 中使用它。\n\nStudent.java\n\npublic class Student {\n    private Person person;\n    //Setters and Getters\n}\npublic class Person {\n    private String name;\n    private String address;\n    //Setters and Getters\n}\n\n\nbean.xml\n\n<bean id=“StudentBean" class="com.edureka.Student">\n    <property name="person">\n        \x3c!--This is inner bean --\x3e\n        <bean class="com.edureka.Person">\n            <property name="name" value=“Scott"></property>\n            <property name="address" value=“Bangalore"></property>\n        </bean>\n    </property>\n</bean>\n\n\n# 什么是 spring 装配\n\n当 bean 在 Spring 容器中组合在一起时，它被称为装配或 bean 装配。 Spring 容器需要知道需要什么 bean 以及容器应该如何使用依赖注入来将 bean 绑定在一起，同时装配 bean。\n\n# 自动装配有哪些方式？\n\nSpring 容器能够自动装配 bean。也就是说，可以通过检查 BeanFactory 的内容让 Spring 自动解析 bean 的协作者。\n\n自动装配的不同模式：\n\n * no - 这是默认设置，表示没有自动装配。应使用显式 bean 引用进行装配。\n * byName - 它根据 bean 的名称注入对象依赖项。它匹配并装配其属性与 XML 文件中由相同名称定义的 bean。\n * byType - 它根据类型注入对象依赖项。如果属性的类型与 XML 文件中的一个 bean 名称匹配，则匹配并装配属性。\n * 构造器 - 它通过调用类的构造器来注入依赖项。它有大量的参数。\n * autodetect - 首先容器尝试通过构造器使用 autowire 装配，如果不能，则尝试通过 byType 自动装配。\n\n# 自动装配有什么局限？\n\n * 覆盖的可能性 - 您始终可以使用 <constructor-arg> 和 <property> 设置指定依赖项，这将覆盖自动装配。\n * 基本元数据类型 - 简单属性（如原数据类型，字符串和类）无法自动装配。\n * 令人困惑的性质 - 总是喜欢使用明确的装配，因为自动装配不太精确。\n\n\n# AOP\n\n# 什么是 AOP？\n\nAOP(Aspect-Oriented Programming), 即 面向切面编程, 它与 OOP( Object-Oriented Programming, 面向对象编程) 相辅相成, 提供了与 OOP 不同的抽象软件结构的视角. 在 OOP 中, 我们以类(class)作为我们的基本单元, 而 AOP 中的基本单元是 Aspect(切面)\n\n# AOP 中的 Aspect、Advice、Pointcut、JointPoint 和 Advice 参数分别是什么？\n\n\n\n * Aspect - Aspect 是一个实现交叉问题的类，例如事务管理。方面可以是配置的普通类，然后在 Spring Bean 配置文件中配置，或者我们可以使用 Spring AspectJ 支持使用 @Aspect 注解将类声明为 Aspect。\n * Advice - Advice 是针对特定 JoinPoint 采取的操作。在编程方面，它们是在应用程序中达到具有匹配切入点的特定 JoinPoint 时执行的方法。您可以将 Advice 视为 Spring 拦截器（Interceptor）或 Servlet 过滤器（filter）。\n * Advice Arguments - 我们可以在 advice 方法中传递参数。我们可以在切入点中使用 args() 表达式来应用于与参数模式匹配的任何方法。如果我们使用它，那么我们需要在确定参数类型的 advice 方法中使用相同的名称。\n * Pointcut - Pointcut 是与 JoinPoint 匹配的正则表达式，用于确定是否需要执行 Advice。 Pointcut 使用与 JoinPoint 匹配的不同类型的表达式。Spring 框架使用 AspectJ Pointcut 表达式语言来确定将应用通知方法的 JoinPoint。\n * JoinPoint - JoinPoint 是应用程序中的特定点，例如方法执行，异常处理，更改对象变量值等。在 Spring AOP 中，JoinPoint 始终是方法的执行器。\n\n# 什么是通知（Advice）？\n\n特定 JoinPoint 处的 Aspect 所采取的动作称为 Advice。Spring AOP 使用一个 Advice 作为拦截器，在 JoinPoint “周围”维护一系列的拦截器。\n\n# 有哪些类型的通知（Advice）？\n\n * Before - 这些类型的 Advice 在 joinpoint 方法之前执行，并使用 @Before 注解标记进行配置。\n * After Returning - 这些类型的 Advice 在连接点方法正常执行后执行，并使用@AfterReturning 注解标记进行配置。\n * After Throwing - 这些类型的 Advice 仅在 joinpoint 方法通过抛出异常退出并使用 @AfterThrowing 注解标记配置时执行。\n * After (finally) - 这些类型的 Advice 在连接点方法之后执行，无论方法退出是正常还是异常返回，并使用 @After 注解标记进行配置。\n * Around - 这些类型的 Advice 在连接点之前和之后执行，并使用 @Around 注解标记进行配置。\n\n# 指出在 spring aop 中 concern 和 cross-cutting concern 的不同之处。\n\nconcern 是我们想要在应用程序的特定模块中定义的行为。它可以定义为我们想要实现的功能。\n\ncross-cutting concern 是一个适用于整个应用的行为，这会影响整个应用程序。例如，日志记录，安全性和数据传输是应用程序几乎每个模块都需要关注的问题，因此它们是跨领域的问题。\n\n# AOP 有哪些实现方式？\n\n实现 AOP 的技术，主要分为两大类：\n\n * 静态代理 - 指使用 AOP 框架提供的命令进行编译，从而在编译阶段就可生成 AOP 代理类，因此也称为编译时增强；\n   * 编译时编织（特殊编译器实现）\n   * 类加载时编织（特殊的类加载器实现）。\n * 动态代理 - 在运行时在内存中“临时”生成 AOP 动态代理类，因此也被称为运行时增强。\n   * JDK 动态代理\n   * CGLIB\n\n# Spring AOP and AspectJ AOP 有什么区别？\n\nSpring AOP 基于动态代理方式实现；AspectJ 基于静态代理方式实现。 Spring AOP 仅支持方法级别的 PointCut；提供了完全的 AOP 支持，它还支持属性级别的 PointCut。\n\n# 如何理解 Spring 中的代理？\n\n将 Advice 应用于目标对象后创建的对象称为代理。在客户端对象的情况下，目标对象和代理对象是相同的。\n\nAdvice + Target Object = Proxy\n\n\n# 什么是编织（Weaving）？\n\n为了创建一个 advice 对象而链接一个 aspect 和其它应用类型或对象，称为编织（Weaving）。在 Spring AOP 中，编织在运行时执行。请参考下图：\n\n\n\n\n# 注解\n\n\n# 你用过哪些重要的 Spring 注解？\n\n * @Controller - 用于 Spring MVC 项目中的控制器类。\n * @Service - 用于服务类。\n * @RequestMapping - 用于在控制器处理程序方法中配置 URI 映射。\n * @ResponseBody - 用于发送 Object 作为响应，通常用于发送 XML 或 JSON 数据作为响应。\n * @PathVariable - 用于将动态值从 URI 映射到处理程序方法参数。\n * @Autowired - 用于在 spring bean 中自动装配依赖项。\n * @Qualifier - 使用 @Autowired 注解，以避免在存在多个 bean 类型实例时出现混淆。\n * @Scope - 用于配置 spring bean 的范围。\n * @Configuration，@ComponentScan 和 @Bean - 用于基于 java 的配置。\n * @Aspect，@Before，@After，@Around，@Pointcut - 用于切面编程（AOP）。\n\n\n# 如何在 spring 中启动注解装配？\n\n默认情况下，Spring 容器中未打开注解装配。因此，要使用基于注解装配，我们必须通过配置<context：annotation-config /> 元素在 Spring 配置文件中启用它。\n\n\n# @Component, @Controller, @Repository, @Service 有何区别？\n\n * @Component：这将 java 类标记为 bean。它是任何 Spring 管理组件的通用构造型。spring 的组件扫描机制现在可以将其拾取并将其拉入应用程序环境中。\n * @Controller：这将一个类标记为 Spring Web MVC 控制器。标有它的 Bean 会自动导入到 IoC 容器中。\n * @Service：此注解是组件注解的特化。它不会对 @Component 注解提供任何其他行为。您可以在服务层类中使用 @Service 而不是 @Component，因为它以更好的方式指定了意图。\n * @Repository：这个注解是具有类似用途和功能的 @Component 注解的特化。它为 DAO 提供了额外的好处。它将 DAO 导入 IoC 容器，并使未经检查的异常有资格转换为 Spring DataAccessException。\n\n\n# @Required 注解有什么用？\n\n@Required 应用于 bean 属性 setter 方法。此注解仅指示必须在配置时使用 bean 定义中的显式属性值或使用自动装配填充受影响的 bean 属性。如果尚未填充受影响的 bean 属性，则容器将抛出 BeanInitializationException。\n\n示例：\n\npublic class Employee {\n    private String name;\n    @Required\n    public void setName(String name){\n        this.name=name;\n    }\n    public string getName(){\n        return name;\n    }\n}\n\n\n\n# @Autowired 注解有什么用？\n\n@Autowired 可以更准确地控制应该在何处以及如何进行自动装配。此注解用于在 setter 方法，构造器，具有任意名称或多个参数的属性或方法上自动装配 bean。默认情况下，它是类型驱动的注入。\n\npublic class Employee {\n    private String name;\n    @Autowired\n    public void setName(String name) {\n        this.name=name;\n    }\n    public string getName(){\n        return name;\n    }\n}\n\n\n\n# @Qualifier 注解有什么用？\n\n当您创建多个相同类型的 bean 并希望仅使用属性装配其中一个 bean 时，您可以使用@Qualifier 注解和 @Autowired 通过指定应该装配哪个确切的 bean 来消除歧义。\n\n例如，这里我们分别有两个类，Employee 和 EmpAccount。在 EmpAccount 中，使用@Qualifier 指定了必须装配 id 为 emp1 的 bean。\n\nEmployee.java\n\npublic class Employee {\n    private String name;\n    @Autowired\n    public void setName(String name) {\n        this.name=name;\n    }\n    public string getName() {\n        return name;\n    }\n}\n\n\nEmpAccount.java\n\npublic class EmpAccount {\n    private Employee emp;\n\n    @Autowired\n    @Qualifier(emp1)\n    public void showName() {\n        System.out.println(“Employee name : ”+emp.getName);\n    }\n}\n\n\n\n# @RequestMapping 注解有什么用？\n\n@RequestMapping 注解用于将特定 HTTP 请求方法映射到将处理相应请求的控制器中的特定类/方法。此注解可应用于两个级别：\n\n * 类级别：映射请求的 URL\n * 方法级别：映射 URL 以及 HTTP 请求方法\n\n\n# 数据篇\n\n\n# spring DAO 有什么用？\n\nSpring DAO 使得 JDBC，Hibernate 或 JDO 这样的数据访问技术更容易以一种统一的方式工作。这使得用户容易在持久性技术之间切换。它还允许您在编写代码时，无需考虑捕获每种技术不同的异常。\n\n\n# 列举 Spring DAO 抛出的异常。\n\n\n\n\n# spring JDBC API 中存在哪些类？\n\n * JdbcTemplate\n * SimpleJdbcTemplate\n * NamedParameterJdbcTemplate\n * SimpleJdbcInsert\n * SimpleJdbcCall\n\n\n# 使用 Spring 访问 Hibernate 的方法有哪些？\n\n我们可以通过两种方式使用 Spring 访问 Hibernate：\n\n 1. 使用 Hibernate 模板和回调进行控制反转\n 2. 扩展 HibernateDAOSupport 并应用 AOP 拦截器节点\n\n\n# 列举 spring 支持的事务管理类型\n\nSpring 支持两种类型的事务管理：\n\n 1. 程序化事务管理：在此过程中，在编程的帮助下管理事务。它为您提供极大的灵活性，但维护起来非常困难。\n 2. 声明式事务管理：在此，事务管理与业务代码分离。仅使用注解或基于 XML 的配置来管理事务。\n\n\n# spring 支持哪些 ORM 框架\n\n * Hibernate\n * iBatis\n * JPA\n * JDO\n * OJB\n\n\n# MVC\n\n\n# Spring MVC 框架有什么用？\n\nSpring Web MVC 框架提供 模型-视图-控制器 架构和随时可用的组件，用于开发灵活且松散耦合的 Web 应用程序。 MVC 模式有助于分离应用程序的不同方面，如输入逻辑，业务逻辑和 UI 逻辑，同时在所有这些元素之间提供松散耦合。\n\n\n# 描述一下 DispatcherServlet 的工作流程\n\nDispatcherServlet 的工作流程可以用一幅图来说明：\n\n\n\n 1. 向服务器发送 HTTP 请求，请求被前端控制器 DispatcherServlet 捕获。\n 2. DispatcherServlet 根据 <servlet-name>-servlet.xml 中的配置对请求的 URL 进行解析，得到请求资源标识符（URI）。然后根据该 URI，调用 HandlerMapping 获得该 Handler 配置的所有相关的对象（包括 Handler 对象以及 Handler 对象对应的拦截器），最后以HandlerExecutionChain 对象的形式返回。\n 3. DispatcherServlet 根据获得的Handler，选择一个合适的 HandlerAdapter。（附注：如果成功获得HandlerAdapter后，此时将开始执行拦截器的 preHandler(...)方法）。\n 4. 提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)。 在填充Handler的入参过程中，根据你的配置，Spring 将帮你做一些额外的工作：\n    * HttpMessageConveter： 将请求消息（如 Json、xml 等数据）转换成一个对象，将对象转换为指定的响应信息。\n    * 数据转换：对请求消息进行数据转换。如String转换成Integer、Double等。\n    * 数据根式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等。\n    * 数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中。\n 5. Handler(Controller)执行完成后，向 DispatcherServlet 返回一个 ModelAndView 对象；\n 6. 根据返回的ModelAndView，选择一个适合的 ViewResolver（必须是已经注册到 Spring 容器中的ViewResolver)返回给DispatcherServlet。\n 7. ViewResolver 结合Model和View，来渲染视图。\n 8. 视图负责将渲染结果返回给客户端。\n\n\n# 介绍一下 WebApplicationContext\n\nWebApplicationContext 是 ApplicationContext 的扩展。它具有 Web 应用程序所需的一些额外功能。它与普通的 ApplicationContext 在解析主题和决定与哪个 servlet 关联的能力方面有所不同。\n\n（完）\n\n----------------------------------------\n\n👉 想学习更多 Spring 内容可以访问我的 Spring 教程：spring-notes\n\n\n# 资料\n\n * Top 50 Spring Interview Questions You Must Prepare In 2018\n * Spring Interview Questions and Answers',normalizedContent:'# spring 面试\n\n\n# 综合篇\n\n\n# 不同版本的 spring framework 有哪些主要功能？\n\nversion      feature\nspring 2.5   发布于 2007 年。这是第一个支持注解的版本。\nspring 3.0   发布于 2009 年。它完全利用了 java5 中的改进，并为 jee6 提供了支持。\nspring 4.0   发布于 2013 年。这是第一个完全支持 java8 的版本。\n\n\n# 什么是 spring framework？\n\n * spring 是一个开源应用框架，旨在降低应用程序开发的复杂度。\n * 它是轻量级、松散耦合的。\n * 它具有分层体系结构，允许用户选择组件，同时还为 j2ee 应用程序开发提供了一个有凝聚力的框架。\n * 它可以集成其他框架，如 structs、hibernate、ejb 等，所以又称为框架的框架。\n\n\n# 列举 spring framework 的优点。\n\n * 由于 spring frameworks 的分层架构，用户可以自由选择自己需要的组件。\n * spring framework 支持 pojo(plain old java object) 编程，从而具备持续集成和可测试性。\n * 由于依赖注入和控制反转，jdbc 得以简化。\n * 它是开源免费的。\n\n\n# spring framework 有哪些不同的功能？\n\n * 轻量级 - spring 在代码量和透明度方面都很轻便。\n * ioc - 控制反转\n * aop - 面向切面编程可以将应用业务逻辑和系统服务分离，以实现高内聚。\n * 容器 - spring 负责创建和管理对象（bean）的生命周期和配置。\n * mvc - 对 web 应用提供了高度可配置性，其他框架的集成也十分方便。\n * 事务管理 - 提供了用于事务管理的通用抽象层。spring 的事务支持也可用于容器较少的环境。\n * jdbc 异常 - spring 的 jdbc 抽象层提供了一个异常层次结构，简化了错误处理策略。\n\n\n# spring framework 中有多少个模块，它们分别是什么？\n\n\n\n * spring 核心容器 – 该层基本上是 spring framework 的核心。它包含以下模块：\n   * spring core\n   * spring bean\n   * spel (spring expression language)\n   * spring context\n * 数据访问/集成 – 该层提供与数据库交互的支持。它包含以下模块：\n   * jdbc (java database connectivity)\n   * orm (object relational mapping)\n   * oxm (object xml mappers)\n   * jms (java messaging service)\n   * transaction\n * web – 该层提供了创建 web 应用程序的支持。它包含以下模块：\n   * web\n   * web – servlet\n   * web – socket\n   * web – portlet\n * aop – 该层支持面向切面编程\n * instrumentation – 该层为类检测和类加载器实现提供支持。\n * test – 该层为使用 junit 和 testng 进行测试提供支持。\n * 几个杂项模块:\n   * messaging – 该模块为 stomp 提供支持。它还支持注解编程模型，该模型用于从 websocket 客户端路由和处理 stomp 消息。\n   * aspects – 该模块为与 aspectj 的集成提供支持。\n\n\n# 什么是 spring 配置文件？\n\nspring 配置文件是 xml 文件。该文件主要包含类信息。它描述了这些类是如何配置以及相互引入的。但是，xml 配置文件冗长且更加干净。如果没有正确规划和编写，那么在大项目中管理变得非常困难。\n\n\n# spring 应用程序有哪些不同组件？\n\nspring 应用一般有以下组件：\n\n * 接口 - 定义功能。\n * bean 类 - 它包含属性，setter 和 getter 方法，函数等。\n * spring 面向切面编程（aop） - 提供面向切面编程的功能。\n * bean 配置文件 - 包含类的信息以及如何配置它们。\n * 用户程序 - 它使用接口。\n\n\n# 使用 spring 有哪些方式？\n\n使用 spring 有以下方式：\n\n * 作为一个成熟的 spring web 应用程序。\n * 作为第三方 web 框架，使用 spring frameworks 中间层。\n * 用于远程使用。\n * 作为企业级 java bean，它可以包装现有的 pojo（plain old java objects）。\n\n\n# 核心篇\n\n\n# ioc\n\n# 什么是 ioc？什么是依赖注入？什么是 spring ioc？\n\nioc 即控制反转（inversion of control，缩写为 ioc）。ioc 又称为依赖倒置原则（设计模式六大原则之一），它的要点在于：程序要依赖于抽象接口，不要依赖于具体实现。它的作用就是用于降低代码间的耦合度。\n\nioc 的实现方式有两种：\n\n * 依赖注入（dependency injection，简称 di）：不通过 new() 的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造器、函数参数等方式传递（或注入）给类使用。\n * 依赖查找（dependency lookup）：容器中的受控对象通过容器的 api 来查找自己所依赖的资源和协作对象。\n\nspring ioc 是 ioc 的一种实现。di 是 spring ioc 的主要实现原则。\n\n\n\n# 依赖注入有哪些实现方式？\n\n依赖注入有如下方式：\n\n依赖注入方式        配置元数据举例\nsetter 方法注入   <proeprty name="user" ref="userbean"/>\n构造器注入         <constructor-arg name="user" ref="userbean" />\n字段注入          @autowired user user;\n方法注入          @autowired public void user(user user) { ... }\n接口回调注入        class mybean implements beanfactoryaware { ... }\n\n# 构造器注入 vs. setter 注入\n\n构造器注入            setter 注入\n没有部分注入           有部分注入\n不会覆盖 setter 属性   会覆盖 setter 属性\n任意修改都会创建一个新实例    任意修改不会创建一个新实例\n适用于设置很多属性        适用于设置少量属性\n\n官方推荐使用构造器注入。\n\n# beanfactory vs. applicationcontext\n\n在 spring 中，有两种 ioc 容器：beanfactory 和 applicationcontext。\n\n * beanfactory：beanfactory 是 spring 基础 ioc 容器。beanfactory 提供了 spring 容器的配置框架和基本功能。\n * applicationcontext：applicationcontext 是具备应用特性的 beanfactory 的子接口。它还扩展了其他一些接口，以支持更丰富的功能，如：国际化、访问资源、事件机制、更方便的支持 aop、在 web 应用中指定应用层上下文等。\n\n实际开发中，更推荐使用 applicationcontext 作为 ioc 容器，因为它的功能远多于 beanfactory。\n\n# beanfactory vs. factorybean\n\nbeanfactory 是 spring 基础 ioc 容器。\n\nfactorybean 是创建 bean 的一种方式，帮助实现复杂的初始化逻辑。\n\n# spring ioc 启动时做了哪些准备\n\nioc 配置元信息读取和解析\n\nioc 容器生命周期管理\n\nspring 事件发布\n\n国际化\n\n等等\n\n# spring ioc 的实现机制是什么\n\nspring 中的 ioc 的实现原理就是工厂模式加反射机制。\n\n示例：\n\ninterface fruit {\n     public abstract void eat();\n}\nclass apple implements fruit {\n    public void eat(){\n        system.out.println("apple");\n    }\n}\nclass orange implements fruit {\n    public void eat(){\n        system.out.println("orange");\n    }\n}\nclass factory {\n    public static fruit getinstance(string classname) {\n        fruit f=null;\n        try {\n            f=(fruit)class.forname(classname).newinstance();\n        } catch (exception e) {\n            e.printstacktrace();\n        }\n        return f;\n    }\n}\nclass client {\n    public static void main(string[] a) {\n        fruit f=factory.getinstance("io.github.dunwu.spring.apple");\n        if(f!=null){\n            f.eat();\n        }\n    }\n}\n\n\n\n# bean\n\n# 什么是 spring bean\n\n在 spring 中，构成应用程序主体由 spring ioc 容器管理的对象称为 bean。bean 是由 spring ioc 容器实例化、装配和管理的对象。 bean 以及它们之间的依赖关系反映在容器使用的配置元数据中。\n\nspring ioc 容器本身，并不能识别配置的元数据。为此，要将这些配置信息转为 spring 能识别的格式——beandefinition 对象。\n\nbeandefinition 是 spring 中定义 bean 的配置元信息接口，它包含：\n\n * bean 类名\n * bean 行为配置元素，如：作用域、自动绑定的模式、生命周期回调等\n * 其他 bean 引用，也可称为合作者（collaborators）或依赖（dependencies）\n * 配置设置，如 bean 属性（properties）\n\n# 如何注册 spring bean\n\n通过 beandefinition 和外部单例对象来注册。\n\n# spring 提供了哪些配置方式？\n\n * 基于 xml 配置\n\nbean 所需的依赖项和服务在 xml 格式的配置文件中指定。这些配置文件通常包含许多 bean 定义和特定于应用程序的配置选项。它们通常以 bean 标签开头。例如：\n\n<bean id="studentbean" class="org.edureka.firstspring.studentbean">\n <property name="name" value="edureka"></property>\n</bean>\n\n\n * 基于注解配置\n\n您可以通过在相关的类，方法或字段声明上使用注解，将 bean 配置为组件类本身，而不是使用 xml 来描述 bean 装配。默认情况下，spring 容器中未打开注解装配。因此，您需要在使用它之前在 spring 配置文件中启用它。例如：\n\n<beans>\n<context:annotation-config/>\n\x3c!-- bean definitions go here --\x3e\n</beans>\n\n\n * 基于 java api 配置\n\nspring 的 java 配置是通过使用 @bean 和 @configuration 来实现。\n\n 1. @bean 注解扮演与 <bean /> 元素相同的角色。\n 2. @configuration 类允许通过简单地调用同一个类中的其他 @bean 方法来定义 bean 间依赖关系。\n\n例如：\n\n@configuration\npublic class studentconfig {\n    @bean\n    public studentbean mystudent() {\n        return new studentbean();\n    }\n}\n\n\n# spring 支持集中 bean scope？\n\nspring bean 支持 5 种 scope：\n\n * singleton - 每个 spring ioc 容器仅有一个单实例。\n * prototype - 每次请求都会产生一个新的实例。\n * request - 每一次 http 请求都会产生一个新的实例，并且该 bean 仅在当前 http 请求内有效。\n * session - 每一次 http 请求都会产生一个新的 bean，同时该 bean 仅在当前 http session 内有效。\n * global-session - 类似于标准的 http session 作用域，不过它仅仅在基于 portlet 的 web 应用中才有意义。portlet 规范定义了全局 session 的概念，它被所有构成某个 portlet web 应用的各种不同的 portlet 所共享。在 global session 作用域中定义的 bean 被限定于全局 portlet session 的生命周期范围内。如果你在 web 中使用 global session 作用域来标识 bean，那么 web 会自动当成 session 类型来使用。\n\n仅当用户使用支持 web 的 applicationcontext 时，最后三个才可用。\n\n# spring bean 的生命周期\n\n\n\nspring bean 容器的生命周期如下：\n\n 1.  spring 对 bean 进行实例化（相当于 new xxx()）\n\n 2.  spring 将值和引用注入到 bean 对应的属性中\n\n 3.  如果 bean 实现了 beannameaware 接口，spring 将 bean 的 id 传递给 setbeanname 方法\n     \n     * 作用是通过 bean 的引用来获得 bean id，一般业务中是很少有用到 bean 的 id 的\n\n 4.  如果 bean 实现了 beanfactoryaware 接口，spring 将调用 setbeandactory 方法，并把 beanfactory 容器实例作为参数传入。\n     \n     * 作用是获取 spring 容器，如 bean 通过 spring 容器发布事件等\n\n 5.  如果 bean 实现了 applicationcontextaware 接口，spring 容器将调用 setapplicationcontext 方法，把应用上下文作为参数传入\n     \n     * 作用与 beanfactory 类似都是为了获取 spring 容器，不同的是 spring 容器在调用 setapplicationcontext 方法时会把它自己作为 setapplicationcontext 的参数传入，而 spring 容器在调用 setbeanfactory 前需要使用者自己指定（注入）setbeanfactory 里的参数 beanfactory\n\n 6.  如果 bean 实现了 beanpostprocess 接口，spring 将调用 postprocessbeforeinitialization 方法\n     \n     * 作用是在 bean 实例创建成功后对其进行增强处理，如对 bean 进行修改，增加某个功能\n\n 7.  如果 bean 实现了 initializingbean 接口，spring 将调用 afterpropertiesset 方法，作用与在配置文件中对 bean 使用 init-method 声明初始化的作用一样，都是在 bean 的全部属性设置成功后执行的初始化方法。\n\n 8.  如果 bean 实现了 beanpostprocess 接口，spring 将调用 postprocessafterinitialization 方法\n     \n     * postprocessbeforeinitialization 是在 bean 初始化前执行的，而 postprocessafterinitialization 是在 bean 初始化后执行的\n\n 9.  经过以上的工作后，bean 将一直驻留在应用上下文中给应用使用，直到应用上下文被销毁\n\n 10. 如果 bean 实现了 dispostblebean 接口，spring 将调用它的 destory 方法，作用与在配置文件中对 bean 使用 destory-method 属性的作用一样，都是在 bean 实例销毁前执行的方法。\n\n# 什么是 spring 的内部 bean？\n\n只有将 bean 用作另一个 bean 的属性时，才能将 bean 声明为内部 bean。为了定义 bean，spring 的基于 xml 的配置元数据在 <property> 或 <constructor-arg> 中提供了 <bean> 元素的使用。内部 bean 总是匿名的，它们总是作为原型。\n\n例如，假设我们有一个 student 类，其中引用了 person 类。这里我们将只创建一个 person 类实例并在 student 中使用它。\n\nstudent.java\n\npublic class student {\n    private person person;\n    //setters and getters\n}\npublic class person {\n    private string name;\n    private string address;\n    //setters and getters\n}\n\n\nbean.xml\n\n<bean id=“studentbean" class="com.edureka.student">\n    <property name="person">\n        \x3c!--this is inner bean --\x3e\n        <bean class="com.edureka.person">\n            <property name="name" value=“scott"></property>\n            <property name="address" value=“bangalore"></property>\n        </bean>\n    </property>\n</bean>\n\n\n# 什么是 spring 装配\n\n当 bean 在 spring 容器中组合在一起时，它被称为装配或 bean 装配。 spring 容器需要知道需要什么 bean 以及容器应该如何使用依赖注入来将 bean 绑定在一起，同时装配 bean。\n\n# 自动装配有哪些方式？\n\nspring 容器能够自动装配 bean。也就是说，可以通过检查 beanfactory 的内容让 spring 自动解析 bean 的协作者。\n\n自动装配的不同模式：\n\n * no - 这是默认设置，表示没有自动装配。应使用显式 bean 引用进行装配。\n * byname - 它根据 bean 的名称注入对象依赖项。它匹配并装配其属性与 xml 文件中由相同名称定义的 bean。\n * bytype - 它根据类型注入对象依赖项。如果属性的类型与 xml 文件中的一个 bean 名称匹配，则匹配并装配属性。\n * 构造器 - 它通过调用类的构造器来注入依赖项。它有大量的参数。\n * autodetect - 首先容器尝试通过构造器使用 autowire 装配，如果不能，则尝试通过 bytype 自动装配。\n\n# 自动装配有什么局限？\n\n * 覆盖的可能性 - 您始终可以使用 <constructor-arg> 和 <property> 设置指定依赖项，这将覆盖自动装配。\n * 基本元数据类型 - 简单属性（如原数据类型，字符串和类）无法自动装配。\n * 令人困惑的性质 - 总是喜欢使用明确的装配，因为自动装配不太精确。\n\n\n# aop\n\n# 什么是 aop？\n\naop(aspect-oriented programming), 即 面向切面编程, 它与 oop( object-oriented programming, 面向对象编程) 相辅相成, 提供了与 oop 不同的抽象软件结构的视角. 在 oop 中, 我们以类(class)作为我们的基本单元, 而 aop 中的基本单元是 aspect(切面)\n\n# aop 中的 aspect、advice、pointcut、jointpoint 和 advice 参数分别是什么？\n\n\n\n * aspect - aspect 是一个实现交叉问题的类，例如事务管理。方面可以是配置的普通类，然后在 spring bean 配置文件中配置，或者我们可以使用 spring aspectj 支持使用 @aspect 注解将类声明为 aspect。\n * advice - advice 是针对特定 joinpoint 采取的操作。在编程方面，它们是在应用程序中达到具有匹配切入点的特定 joinpoint 时执行的方法。您可以将 advice 视为 spring 拦截器（interceptor）或 servlet 过滤器（filter）。\n * advice arguments - 我们可以在 advice 方法中传递参数。我们可以在切入点中使用 args() 表达式来应用于与参数模式匹配的任何方法。如果我们使用它，那么我们需要在确定参数类型的 advice 方法中使用相同的名称。\n * pointcut - pointcut 是与 joinpoint 匹配的正则表达式，用于确定是否需要执行 advice。 pointcut 使用与 joinpoint 匹配的不同类型的表达式。spring 框架使用 aspectj pointcut 表达式语言来确定将应用通知方法的 joinpoint。\n * joinpoint - joinpoint 是应用程序中的特定点，例如方法执行，异常处理，更改对象变量值等。在 spring aop 中，joinpoint 始终是方法的执行器。\n\n# 什么是通知（advice）？\n\n特定 joinpoint 处的 aspect 所采取的动作称为 advice。spring aop 使用一个 advice 作为拦截器，在 joinpoint “周围”维护一系列的拦截器。\n\n# 有哪些类型的通知（advice）？\n\n * before - 这些类型的 advice 在 joinpoint 方法之前执行，并使用 @before 注解标记进行配置。\n * after returning - 这些类型的 advice 在连接点方法正常执行后执行，并使用@afterreturning 注解标记进行配置。\n * after throwing - 这些类型的 advice 仅在 joinpoint 方法通过抛出异常退出并使用 @afterthrowing 注解标记配置时执行。\n * after (finally) - 这些类型的 advice 在连接点方法之后执行，无论方法退出是正常还是异常返回，并使用 @after 注解标记进行配置。\n * around - 这些类型的 advice 在连接点之前和之后执行，并使用 @around 注解标记进行配置。\n\n# 指出在 spring aop 中 concern 和 cross-cutting concern 的不同之处。\n\nconcern 是我们想要在应用程序的特定模块中定义的行为。它可以定义为我们想要实现的功能。\n\ncross-cutting concern 是一个适用于整个应用的行为，这会影响整个应用程序。例如，日志记录，安全性和数据传输是应用程序几乎每个模块都需要关注的问题，因此它们是跨领域的问题。\n\n# aop 有哪些实现方式？\n\n实现 aop 的技术，主要分为两大类：\n\n * 静态代理 - 指使用 aop 框架提供的命令进行编译，从而在编译阶段就可生成 aop 代理类，因此也称为编译时增强；\n   * 编译时编织（特殊编译器实现）\n   * 类加载时编织（特殊的类加载器实现）。\n * 动态代理 - 在运行时在内存中“临时”生成 aop 动态代理类，因此也被称为运行时增强。\n   * jdk 动态代理\n   * cglib\n\n# spring aop and aspectj aop 有什么区别？\n\nspring aop 基于动态代理方式实现；aspectj 基于静态代理方式实现。 spring aop 仅支持方法级别的 pointcut；提供了完全的 aop 支持，它还支持属性级别的 pointcut。\n\n# 如何理解 spring 中的代理？\n\n将 advice 应用于目标对象后创建的对象称为代理。在客户端对象的情况下，目标对象和代理对象是相同的。\n\nadvice + target object = proxy\n\n\n# 什么是编织（weaving）？\n\n为了创建一个 advice 对象而链接一个 aspect 和其它应用类型或对象，称为编织（weaving）。在 spring aop 中，编织在运行时执行。请参考下图：\n\n\n\n\n# 注解\n\n\n# 你用过哪些重要的 spring 注解？\n\n * @controller - 用于 spring mvc 项目中的控制器类。\n * @service - 用于服务类。\n * @requestmapping - 用于在控制器处理程序方法中配置 uri 映射。\n * @responsebody - 用于发送 object 作为响应，通常用于发送 xml 或 json 数据作为响应。\n * @pathvariable - 用于将动态值从 uri 映射到处理程序方法参数。\n * @autowired - 用于在 spring bean 中自动装配依赖项。\n * @qualifier - 使用 @autowired 注解，以避免在存在多个 bean 类型实例时出现混淆。\n * @scope - 用于配置 spring bean 的范围。\n * @configuration，@componentscan 和 @bean - 用于基于 java 的配置。\n * @aspect，@before，@after，@around，@pointcut - 用于切面编程（aop）。\n\n\n# 如何在 spring 中启动注解装配？\n\n默认情况下，spring 容器中未打开注解装配。因此，要使用基于注解装配，我们必须通过配置<context：annotation-config /> 元素在 spring 配置文件中启用它。\n\n\n# @component, @controller, @repository, @service 有何区别？\n\n * @component：这将 java 类标记为 bean。它是任何 spring 管理组件的通用构造型。spring 的组件扫描机制现在可以将其拾取并将其拉入应用程序环境中。\n * @controller：这将一个类标记为 spring web mvc 控制器。标有它的 bean 会自动导入到 ioc 容器中。\n * @service：此注解是组件注解的特化。它不会对 @component 注解提供任何其他行为。您可以在服务层类中使用 @service 而不是 @component，因为它以更好的方式指定了意图。\n * @repository：这个注解是具有类似用途和功能的 @component 注解的特化。它为 dao 提供了额外的好处。它将 dao 导入 ioc 容器，并使未经检查的异常有资格转换为 spring dataaccessexception。\n\n\n# @required 注解有什么用？\n\n@required 应用于 bean 属性 setter 方法。此注解仅指示必须在配置时使用 bean 定义中的显式属性值或使用自动装配填充受影响的 bean 属性。如果尚未填充受影响的 bean 属性，则容器将抛出 beaninitializationexception。\n\n示例：\n\npublic class employee {\n    private string name;\n    @required\n    public void setname(string name){\n        this.name=name;\n    }\n    public string getname(){\n        return name;\n    }\n}\n\n\n\n# @autowired 注解有什么用？\n\n@autowired 可以更准确地控制应该在何处以及如何进行自动装配。此注解用于在 setter 方法，构造器，具有任意名称或多个参数的属性或方法上自动装配 bean。默认情况下，它是类型驱动的注入。\n\npublic class employee {\n    private string name;\n    @autowired\n    public void setname(string name) {\n        this.name=name;\n    }\n    public string getname(){\n        return name;\n    }\n}\n\n\n\n# @qualifier 注解有什么用？\n\n当您创建多个相同类型的 bean 并希望仅使用属性装配其中一个 bean 时，您可以使用@qualifier 注解和 @autowired 通过指定应该装配哪个确切的 bean 来消除歧义。\n\n例如，这里我们分别有两个类，employee 和 empaccount。在 empaccount 中，使用@qualifier 指定了必须装配 id 为 emp1 的 bean。\n\nemployee.java\n\npublic class employee {\n    private string name;\n    @autowired\n    public void setname(string name) {\n        this.name=name;\n    }\n    public string getname() {\n        return name;\n    }\n}\n\n\nempaccount.java\n\npublic class empaccount {\n    private employee emp;\n\n    @autowired\n    @qualifier(emp1)\n    public void showname() {\n        system.out.println(“employee name : ”+emp.getname);\n    }\n}\n\n\n\n# @requestmapping 注解有什么用？\n\n@requestmapping 注解用于将特定 http 请求方法映射到将处理相应请求的控制器中的特定类/方法。此注解可应用于两个级别：\n\n * 类级别：映射请求的 url\n * 方法级别：映射 url 以及 http 请求方法\n\n\n# 数据篇\n\n\n# spring dao 有什么用？\n\nspring dao 使得 jdbc，hibernate 或 jdo 这样的数据访问技术更容易以一种统一的方式工作。这使得用户容易在持久性技术之间切换。它还允许您在编写代码时，无需考虑捕获每种技术不同的异常。\n\n\n# 列举 spring dao 抛出的异常。\n\n\n\n\n# spring jdbc api 中存在哪些类？\n\n * jdbctemplate\n * simplejdbctemplate\n * namedparameterjdbctemplate\n * simplejdbcinsert\n * simplejdbccall\n\n\n# 使用 spring 访问 hibernate 的方法有哪些？\n\n我们可以通过两种方式使用 spring 访问 hibernate：\n\n 1. 使用 hibernate 模板和回调进行控制反转\n 2. 扩展 hibernatedaosupport 并应用 aop 拦截器节点\n\n\n# 列举 spring 支持的事务管理类型\n\nspring 支持两种类型的事务管理：\n\n 1. 程序化事务管理：在此过程中，在编程的帮助下管理事务。它为您提供极大的灵活性，但维护起来非常困难。\n 2. 声明式事务管理：在此，事务管理与业务代码分离。仅使用注解或基于 xml 的配置来管理事务。\n\n\n# spring 支持哪些 orm 框架\n\n * hibernate\n * ibatis\n * jpa\n * jdo\n * ojb\n\n\n# mvc\n\n\n# spring mvc 框架有什么用？\n\nspring web mvc 框架提供 模型-视图-控制器 架构和随时可用的组件，用于开发灵活且松散耦合的 web 应用程序。 mvc 模式有助于分离应用程序的不同方面，如输入逻辑，业务逻辑和 ui 逻辑，同时在所有这些元素之间提供松散耦合。\n\n\n# 描述一下 dispatcherservlet 的工作流程\n\ndispatcherservlet 的工作流程可以用一幅图来说明：\n\n\n\n 1. 向服务器发送 http 请求，请求被前端控制器 dispatcherservlet 捕获。\n 2. dispatcherservlet 根据 <servlet-name>-servlet.xml 中的配置对请求的 url 进行解析，得到请求资源标识符（uri）。然后根据该 uri，调用 handlermapping 获得该 handler 配置的所有相关的对象（包括 handler 对象以及 handler 对象对应的拦截器），最后以handlerexecutionchain 对象的形式返回。\n 3. dispatcherservlet 根据获得的handler，选择一个合适的 handleradapter。（附注：如果成功获得handleradapter后，此时将开始执行拦截器的 prehandler(...)方法）。\n 4. 提取request中的模型数据，填充handler入参，开始执行handler（controller)。 在填充handler的入参过程中，根据你的配置，spring 将帮你做一些额外的工作：\n    * httpmessageconveter： 将请求消息（如 json、xml 等数据）转换成一个对象，将对象转换为指定的响应信息。\n    * 数据转换：对请求消息进行数据转换。如string转换成integer、double等。\n    * 数据根式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等。\n    * 数据验证： 验证数据的有效性（长度、格式等），验证结果存储到bindingresult或error中。\n 5. handler(controller)执行完成后，向 dispatcherservlet 返回一个 modelandview 对象；\n 6. 根据返回的modelandview，选择一个适合的 viewresolver（必须是已经注册到 spring 容器中的viewresolver)返回给dispatcherservlet。\n 7. viewresolver 结合model和view，来渲染视图。\n 8. 视图负责将渲染结果返回给客户端。\n\n\n# 介绍一下 webapplicationcontext\n\nwebapplicationcontext 是 applicationcontext 的扩展。它具有 web 应用程序所需的一些额外功能。它与普通的 applicationcontext 在解析主题和决定与哪个 servlet 关联的能力方面有所不同。\n\n（完）\n\n----------------------------------------\n\n👉 想学习更多 spring 内容可以访问我的 spring 教程：spring-notes\n\n\n# 资料\n\n * top 50 spring interview questions you must prepare in 2018\n * spring interview questions and answers',charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Spring Bean",frontmatter:{title:"Spring Bean",date:"2021-12-10T19:15:42.000Z",order:1,categories:["Java","框架","Spring","Spring核心"],tags:["Java","框架","Spring","Bean","BeanDefinition"],permalink:"/pages/68097d/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/01.Spring%E6%A0%B8%E5%BF%83/01.SpringBean.html",relativePath:"01.Java/13.框架/01.Spring/01.Spring核心/01.SpringBean.md",key:"v-617edf3a",path:"/pages/68097d/",headers:[{level:2,title:"Spring Bean 定义",slug:"spring-bean-定义",normalizedTitle:"spring bean 定义",charIndex:133},{level:3,title:"BeanDefinition",slug:"beandefinition",normalizedTitle:"beandefinition",charIndex:152},{level:4,title:"BeanDefinition 元信息",slug:"beandefinition-元信息",normalizedTitle:"beandefinition 元信息",charIndex:428},{level:4,title:"BeanDefinition 构建",slug:"beandefinition-构建",normalizedTitle:"beandefinition 构建",charIndex:931},{level:3,title:"Spring Bean 命名",slug:"spring-bean-命名",normalizedTitle:"spring bean 命名",charIndex:1085},{level:4,title:"Spring Bean 命名规则",slug:"spring-bean-命名规则",normalizedTitle:"spring bean 命名规则",charIndex:1103},{level:4,title:"Spring Bean 命名生成器",slug:"spring-bean-命名生成器",normalizedTitle:"spring bean 命名生成器",charIndex:1469},{level:4,title:"Spring Bean 别名",slug:"spring-bean-别名",normalizedTitle:"spring bean 别名",charIndex:1769},{level:2,title:"Spring Bean 生命周期",slug:"spring-bean-生命周期",normalizedTitle:"spring bean 生命周期",charIndex:2166},{level:2,title:"Spring Bean 注册",slug:"spring-bean-注册",normalizedTitle:"spring bean 注册",charIndex:3495},{level:3,title:"XML 配置元信息",slug:"xml-配置元信息",normalizedTitle:"xml 配置元信息",charIndex:3564},{level:3,title:"注解配置元信息",slug:"注解配置元信息",normalizedTitle:"注解配置元信息",charIndex:3651},{level:3,title:"Java API 配置元信息",slug:"java-api-配置元信息",normalizedTitle:"java api 配置元信息",charIndex:3710},{level:2,title:"Spring Bean 实例化",slug:"spring-bean-实例化",normalizedTitle:"spring bean 实例化",charIndex:4016},{level:2,title:"Spring Bean 初始化和销毁",slug:"spring-bean-初始化和销毁",normalizedTitle:"spring bean 初始化和销毁",charIndex:4546},{level:2,title:"Spring Bean 垃圾回收",slug:"spring-bean-垃圾回收",normalizedTitle:"spring bean 垃圾回收",charIndex:5589},{level:2,title:"Spring Bean 作用范围",slug:"spring-bean-作用范围",normalizedTitle:"spring bean 作用范围",charIndex:5703},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:6830}],headersStr:"Spring Bean 定义 BeanDefinition BeanDefinition 元信息 BeanDefinition 构建 Spring Bean 命名 Spring Bean 命名规则 Spring Bean 命名生成器 Spring Bean 别名 Spring Bean 生命周期 Spring Bean 注册 XML 配置元信息 注解配置元信息 Java API 配置元信息 Spring Bean 实例化 Spring Bean 初始化和销毁 Spring Bean 垃圾回收 Spring Bean 作用范围 参考资料",content:'# Spring Bean\n\n在 Spring 中，构成应用程序主体由 Spring IoC 容器管理的对象称为 Bean。Bean 是由 Spring IoC 容器实例化、装配和管理的对象。 Bean 以及它们之间的依赖关系反映在容器使用的配置元数据中。\n\n\n# Spring Bean 定义\n\n\n# BeanDefinition\n\nSpring IoC 容器本身，并不能识别配置的元数据。为此，要将这些配置信息转为 Spring 能识别的格式——BeanDefinition 对象。\n\nBeanDefinition 是 Spring 中定义 Bean 的配置元信息接口，它包含：\n\n * Bean 类名\n * Bean 行为配置元素，如：作用域、自动绑定的模式、生命周期回调等\n * 其他 Bean 引用，也可称为合作者（Collaborators）或依赖（Dependencies）\n * 配置设置，如 Bean 属性（Properties）\n\n# BeanDefinition 元信息\n\nBeanDefinition 元信息如下：\n\n属性（PROPERTY）               说明\nClass                      全类名，必须是具体类，不能用抽象类或接口\nName                       Bean 的名称或者 ID\nScope                      Bean 的作用域（如：singleton、prototype 等）\nConstructor arguments      Bean 构造器参数（用于依赖注入）\nProperties                 Bean 属性设置（用于依赖注入）\nAutowiring mode            Bean 自动绑定模式（如：通过名称 byName）\nLazy initialization mode   Bean 延迟初始化模式（延迟和非延迟）\nInitialization method      Bean 初始化回调方法名称\nDestruction method         Bean 销毁回调方法名称\n\n# BeanDefinition 构建\n\nBeanDefinition 构建方式：\n\n * 通过 BeanDefinitionBuilder\n\n * 通过 AbstractBeanDefinition 以及派生类\n\n> 💻 Spring Bean 定义示例源码：BeanDefinitionTests\n\n\n# Spring Bean 命名\n\n# Spring Bean 命名规则\n\n每个 Bean 拥有一个或多个标识符（identifiers），这些标识符在 Bean 所在的容器必须是唯一的。通常，一个 Bean 仅有一个标识符，如果需要额外的，可考虑使用别名（Alias）来扩充。\n\n在基于 XML 的配置元信息中，开发人员可以使用 id 属性、name 属性或来指定 Bean 标识符。通常，Bean 的标识符由字母组成，允许出现特殊字符。如果要想引入 Bean 的别名的话，可在 name 属性使用半角逗号（“,”）或分号（“;”) 来间隔。\n\nSpring 中，为 Bean 指定 id 和 name 属性不是必须的。如果不指定，Spring 会自动为 Bean 分配一个唯一的名称。尽管 Bean 的命名没有限制，不过官方建议采用驼峰命名法来命名 Bean。\n\n# Spring Bean 命名生成器\n\nSpring 提供了两种 Spring Bean 命名生成器：\n\n * DefaultBeanNameGenerator：默认通用 BeanNameGenerator 实现。\n * AnnotationBeanNameGenerator：基于注解扫描的 BeanNameGenerator 实现。\n\npublic interface BeanNameGenerator {\n   String generateBeanName(BeanDefinition definition, BeanDefinitionRegistry registry);\n}\n\n\n# Spring Bean 别名\n\nSpring 支持通过 <alias> 属性为 Bean 设置别名。\n\nBean 别名（Alias）的作用：\n\n * 复用现有的 BeanDefinition\n * 更具有场景化的命名方法，比如：\n   * <alias name="myApp-dataSource" alias="subsystemA-dataSource"/>\n   * <alias name="myApp-dataSource" alias="subsystemB-dataSource"/>\n\n<bean id="user" class="io.github.dunwu.spring.core.bean.entity.person.User">\n  \x3c!-- 属性略 --\x3e\n</bean>\n<alias name="user" alias="aliasUser" />\n\n\n\n# Spring Bean 生命周期\n\n\n\n 1.  Spring 对 Bean 进行实例化（相当于 new XXX()）\n\n 2.  Spring 将值和引用注入到 Bean 对应的属性中\n\n 3.  如果 Bean 实现了 BeanNameAware 接口，Spring 将 Bean 的 ID 传递给 setBeanName 方法\n     \n     * 作用是通过 Bean 的引用来获得 Bean ID，一般业务中是很少有用到 Bean 的 ID 的\n\n 4.  如果 Bean 实现了 BeanFactoryAware 接口，Spring 将调用 setBeanDactory 方法，并把 BeanFactory 容器实例作为参数传入。\n     \n     * 作用是获取 Spring 容器，如 Bean 通过 Spring 容器发布事件等\n\n 5.  如果 Bean 实现了 ApplicationContextAware 接口，Spring 容器将调用 setApplicationContext 方法，把应用上下文作为参数传入\n     \n     * 作用与 BeanFactory 类似都是为了获取 Spring 容器，不同的是 Spring 容器在调用 setApplicationContext 方法时会把它自己作为 setApplicationContext 的参数传入，而 Spring 容器在调用 setBeanFactory 前需要使用者自己指定（注入）setBeanFactory 里的参数 BeanFactory\n\n 6.  如果 Bean 实现了 BeanPostProcess 接口，Spring 将调用 postProcessBeforeInitialization 方法\n     \n     * 作用是在 Bean 实例创建成功后对其进行增强处理，如对 Bean 进行修改，增加某个功能\n\n 7.  如果 Bean 实现了 InitializingBean 接口，Spring 将调用 afterPropertiesSet 方法，作用与在配置文件中对 Bean 使用 init-method 声明初始化的作用一样，都是在 Bean 的全部属性设置成功后执行的初始化方法。\n\n 8.  如果 Bean 实现了 BeanPostProcess 接口，Spring 将调用 postProcessAfterInitialization 方法\n     \n     * postProcessBeforeInitialization 是在 Bean 初始化前执行的，而 postProcessAfterInitialization 是在 Bean 初始化后执行的\n\n 9.  经过以上的工作后，Bean 将一直驻留在应用上下文中给应用使用，直到应用上下文被销毁\n\n 10. 如果 Bean 实现了 DispostbleBean 接口，Spring 将调用它的 destory 方法，作用与在配置文件中对 Bean 使用 destory-method 属性的作用一样，都是在 Bean 实例销毁前执行的方法。\n\n\n# Spring Bean 注册\n\n注册 Spring Bean 实际上是将 BeanDefinition 注册到 IoC 容器中。\n\n\n# XML 配置元信息\n\nSpring 的传统配置方式。在 <bean> 标签中配置元数据内容。\n\n缺点是当 JavaBean 过多时，产生的配置文件足以让你眼花缭乱。\n\n\n# 注解配置元信息\n\n使用 @Bean、@Component、@Import 注解注册 Spring Bean。\n\n\n# Java API 配置元信息\n\n * 命名方式：BeanDefinitionRegistry#registerBeanDefinition(String,BeanDefinition)\n * 非命名方式：BeanDefinitionReaderUtils#registerWithGeneratedName(AbstractBeanDefinition,BeanDefinitionRegistry)\n * 配置类方式：AnnotatedBeanDefinitionReader#register(Class...)\n\n> 💻 Spring Bean 注册示例源码：BeanRegistryTests\n\n\n# Spring Bean 实例化\n\nSpring Bean 实例化方式：\n\n * 常规方式\n   * 通过构造器（配置元信息：XML、Java 注解和 Java API）\n   * 通过静态方法（配置元信息：XML、Java 注解和 Java API）\n   * 通过 Bean 工厂方法（配置元信息：XML、Java 注解和 Java API）\n   * 通过 FactoryBean（配置元信息：XML、Java 注解和 Java API）\n * 特殊方式\n   * 通过 ServiceLoaderFactoryBean（配置元信息：XML、Java 注解和 Java API ）\n   * 通过 AutowireCapableBeanFactory#createBean(java.lang.Class, int, boolean)\n   * 通过 BeanDefinitionRegistry#registerBeanDefinition(String,BeanDefinition)\n\n> 💻 Spring Bean 实例化示例源码：BeanInstantiationTests、BeanInstantiationSpecialTests\n\n\n# Spring Bean 初始化和销毁\n\nSpring Bean 初始化和销毁的方式有以下几种：\n\n 1. 使用 @PostConstruct 和 @PreDestroy 注解分别指定相应的初始化方法和销毁方法。\n\n 2. 实现 InitializingBean 接口的 afterPropertiesSet() 方法来编写初始化方法；实现 DisposableBean 接口的 destroy() 方法来编写销毁方法。\n    \n    * InitializingBean 接口包含一个 afterPropertiesSet 方法，可以通过实现该接口，然后在这个方法中编写初始化逻辑。\n    * DisposableBean接口包含一个 destory 方法，可以通过实现该接口，然后在这个方法中编写销毁逻辑。\n\n 3. 自定义初始化方法\n    \n    * XML 配置：<bean init-method="init" destroy="destroy" ... />\n    * Java 注解：@Bean(initMethod = "init", destroyMethod = "destroy")\n    * Java API：AbstractBeanDefinition#setInitMethodName(String) 和 AbstractBeanDefinition#setDestroyMethodName(String) 分别定义初始化和销毁方法\n\n注意：如果同时存在，执行顺序会按照序列执行。\n\nBean 的延迟初始化\n\n * xml 方式：<bean lazy-init="true" ... />\n * 注解方式：@Lazy\n\nSpring 提供了一个 BeanPostProcessor 接口，提供了两个方法 postProcessBeforeInitialization 和 postProcessAfterInitialization。其中postProcessBeforeInitialization 在组件的初始化方法调用之前执行，postProcessAfterInitialization 在组件的初始化方法调用之后执行。它们都包含两个入参：\n\n * bean：当前组件对象；\n * beanName：当前组件在容器中的名称。\n\n> 💻 Spring Bean 初始化和销毁示例源码：BeanInitDestroyTests\n\n\n# Spring Bean 垃圾回收\n\nSpring Bean 垃圾回收步骤：\n\n 1. 关闭 Spring 容器（应用上下文）\n 2. 执行 GC\n 3. Spring Bean 覆盖的 finalize() 方法被回调\n\n\n# Spring Bean 作用范围\n\nSCOPE         DESCRIPTION\nsingleton     (Default) Scopes a single bean definition to a single object\n              instance for each Spring IoC container.\nprototype     Scopes a single bean definition to any number of object\n              instances.\nrequest       Scopes a single bean definition to the lifecycle of a single\n              HTTP request. That is, each HTTP request has its own\n              instance of a bean created off the back of a single bean\n              definition. Only valid in the context of a web-aware Spring\n              ApplicationContext.\nsession       Scopes a single bean definition to the lifecycle of an HTTP\n              Session. Only valid in the context of a web-aware Spring\n              ApplicationContext.\napplication   Scopes a single bean definition to the lifecycle of a\n              ServletContext. Only valid in the context of a web-aware\n              Spring ApplicationContext.\nwebsocket     Scopes a single bean definition to the lifecycle of a\n              WebSocket. Only valid in the context of a web-aware Spring\n              ApplicationContext.\n\n\n# 参考资料\n\n * Spring 官方文档之 Core Technologies\n * 《小马哥讲 Spring 核心编程思想》',normalizedContent:'# spring bean\n\n在 spring 中，构成应用程序主体由 spring ioc 容器管理的对象称为 bean。bean 是由 spring ioc 容器实例化、装配和管理的对象。 bean 以及它们之间的依赖关系反映在容器使用的配置元数据中。\n\n\n# spring bean 定义\n\n\n# beandefinition\n\nspring ioc 容器本身，并不能识别配置的元数据。为此，要将这些配置信息转为 spring 能识别的格式——beandefinition 对象。\n\nbeandefinition 是 spring 中定义 bean 的配置元信息接口，它包含：\n\n * bean 类名\n * bean 行为配置元素，如：作用域、自动绑定的模式、生命周期回调等\n * 其他 bean 引用，也可称为合作者（collaborators）或依赖（dependencies）\n * 配置设置，如 bean 属性（properties）\n\n# beandefinition 元信息\n\nbeandefinition 元信息如下：\n\n属性（property）               说明\nclass                      全类名，必须是具体类，不能用抽象类或接口\nname                       bean 的名称或者 id\nscope                      bean 的作用域（如：singleton、prototype 等）\nconstructor arguments      bean 构造器参数（用于依赖注入）\nproperties                 bean 属性设置（用于依赖注入）\nautowiring mode            bean 自动绑定模式（如：通过名称 byname）\nlazy initialization mode   bean 延迟初始化模式（延迟和非延迟）\ninitialization method      bean 初始化回调方法名称\ndestruction method         bean 销毁回调方法名称\n\n# beandefinition 构建\n\nbeandefinition 构建方式：\n\n * 通过 beandefinitionbuilder\n\n * 通过 abstractbeandefinition 以及派生类\n\n> 💻 spring bean 定义示例源码：beandefinitiontests\n\n\n# spring bean 命名\n\n# spring bean 命名规则\n\n每个 bean 拥有一个或多个标识符（identifiers），这些标识符在 bean 所在的容器必须是唯一的。通常，一个 bean 仅有一个标识符，如果需要额外的，可考虑使用别名（alias）来扩充。\n\n在基于 xml 的配置元信息中，开发人员可以使用 id 属性、name 属性或来指定 bean 标识符。通常，bean 的标识符由字母组成，允许出现特殊字符。如果要想引入 bean 的别名的话，可在 name 属性使用半角逗号（“,”）或分号（“;”) 来间隔。\n\nspring 中，为 bean 指定 id 和 name 属性不是必须的。如果不指定，spring 会自动为 bean 分配一个唯一的名称。尽管 bean 的命名没有限制，不过官方建议采用驼峰命名法来命名 bean。\n\n# spring bean 命名生成器\n\nspring 提供了两种 spring bean 命名生成器：\n\n * defaultbeannamegenerator：默认通用 beannamegenerator 实现。\n * annotationbeannamegenerator：基于注解扫描的 beannamegenerator 实现。\n\npublic interface beannamegenerator {\n   string generatebeanname(beandefinition definition, beandefinitionregistry registry);\n}\n\n\n# spring bean 别名\n\nspring 支持通过 <alias> 属性为 bean 设置别名。\n\nbean 别名（alias）的作用：\n\n * 复用现有的 beandefinition\n * 更具有场景化的命名方法，比如：\n   * <alias name="myapp-datasource" alias="subsystema-datasource"/>\n   * <alias name="myapp-datasource" alias="subsystemb-datasource"/>\n\n<bean id="user" class="io.github.dunwu.spring.core.bean.entity.person.user">\n  \x3c!-- 属性略 --\x3e\n</bean>\n<alias name="user" alias="aliasuser" />\n\n\n\n# spring bean 生命周期\n\n\n\n 1.  spring 对 bean 进行实例化（相当于 new xxx()）\n\n 2.  spring 将值和引用注入到 bean 对应的属性中\n\n 3.  如果 bean 实现了 beannameaware 接口，spring 将 bean 的 id 传递给 setbeanname 方法\n     \n     * 作用是通过 bean 的引用来获得 bean id，一般业务中是很少有用到 bean 的 id 的\n\n 4.  如果 bean 实现了 beanfactoryaware 接口，spring 将调用 setbeandactory 方法，并把 beanfactory 容器实例作为参数传入。\n     \n     * 作用是获取 spring 容器，如 bean 通过 spring 容器发布事件等\n\n 5.  如果 bean 实现了 applicationcontextaware 接口，spring 容器将调用 setapplicationcontext 方法，把应用上下文作为参数传入\n     \n     * 作用与 beanfactory 类似都是为了获取 spring 容器，不同的是 spring 容器在调用 setapplicationcontext 方法时会把它自己作为 setapplicationcontext 的参数传入，而 spring 容器在调用 setbeanfactory 前需要使用者自己指定（注入）setbeanfactory 里的参数 beanfactory\n\n 6.  如果 bean 实现了 beanpostprocess 接口，spring 将调用 postprocessbeforeinitialization 方法\n     \n     * 作用是在 bean 实例创建成功后对其进行增强处理，如对 bean 进行修改，增加某个功能\n\n 7.  如果 bean 实现了 initializingbean 接口，spring 将调用 afterpropertiesset 方法，作用与在配置文件中对 bean 使用 init-method 声明初始化的作用一样，都是在 bean 的全部属性设置成功后执行的初始化方法。\n\n 8.  如果 bean 实现了 beanpostprocess 接口，spring 将调用 postprocessafterinitialization 方法\n     \n     * postprocessbeforeinitialization 是在 bean 初始化前执行的，而 postprocessafterinitialization 是在 bean 初始化后执行的\n\n 9.  经过以上的工作后，bean 将一直驻留在应用上下文中给应用使用，直到应用上下文被销毁\n\n 10. 如果 bean 实现了 dispostblebean 接口，spring 将调用它的 destory 方法，作用与在配置文件中对 bean 使用 destory-method 属性的作用一样，都是在 bean 实例销毁前执行的方法。\n\n\n# spring bean 注册\n\n注册 spring bean 实际上是将 beandefinition 注册到 ioc 容器中。\n\n\n# xml 配置元信息\n\nspring 的传统配置方式。在 <bean> 标签中配置元数据内容。\n\n缺点是当 javabean 过多时，产生的配置文件足以让你眼花缭乱。\n\n\n# 注解配置元信息\n\n使用 @bean、@component、@import 注解注册 spring bean。\n\n\n# java api 配置元信息\n\n * 命名方式：beandefinitionregistry#registerbeandefinition(string,beandefinition)\n * 非命名方式：beandefinitionreaderutils#registerwithgeneratedname(abstractbeandefinition,beandefinitionregistry)\n * 配置类方式：annotatedbeandefinitionreader#register(class...)\n\n> 💻 spring bean 注册示例源码：beanregistrytests\n\n\n# spring bean 实例化\n\nspring bean 实例化方式：\n\n * 常规方式\n   * 通过构造器（配置元信息：xml、java 注解和 java api）\n   * 通过静态方法（配置元信息：xml、java 注解和 java api）\n   * 通过 bean 工厂方法（配置元信息：xml、java 注解和 java api）\n   * 通过 factorybean（配置元信息：xml、java 注解和 java api）\n * 特殊方式\n   * 通过 serviceloaderfactorybean（配置元信息：xml、java 注解和 java api ）\n   * 通过 autowirecapablebeanfactory#createbean(java.lang.class, int, boolean)\n   * 通过 beandefinitionregistry#registerbeandefinition(string,beandefinition)\n\n> 💻 spring bean 实例化示例源码：beaninstantiationtests、beaninstantiationspecialtests\n\n\n# spring bean 初始化和销毁\n\nspring bean 初始化和销毁的方式有以下几种：\n\n 1. 使用 @postconstruct 和 @predestroy 注解分别指定相应的初始化方法和销毁方法。\n\n 2. 实现 initializingbean 接口的 afterpropertiesset() 方法来编写初始化方法；实现 disposablebean 接口的 destroy() 方法来编写销毁方法。\n    \n    * initializingbean 接口包含一个 afterpropertiesset 方法，可以通过实现该接口，然后在这个方法中编写初始化逻辑。\n    * disposablebean接口包含一个 destory 方法，可以通过实现该接口，然后在这个方法中编写销毁逻辑。\n\n 3. 自定义初始化方法\n    \n    * xml 配置：<bean init-method="init" destroy="destroy" ... />\n    * java 注解：@bean(initmethod = "init", destroymethod = "destroy")\n    * java api：abstractbeandefinition#setinitmethodname(string) 和 abstractbeandefinition#setdestroymethodname(string) 分别定义初始化和销毁方法\n\n注意：如果同时存在，执行顺序会按照序列执行。\n\nbean 的延迟初始化\n\n * xml 方式：<bean lazy-init="true" ... />\n * 注解方式：@lazy\n\nspring 提供了一个 beanpostprocessor 接口，提供了两个方法 postprocessbeforeinitialization 和 postprocessafterinitialization。其中postprocessbeforeinitialization 在组件的初始化方法调用之前执行，postprocessafterinitialization 在组件的初始化方法调用之后执行。它们都包含两个入参：\n\n * bean：当前组件对象；\n * beanname：当前组件在容器中的名称。\n\n> 💻 spring bean 初始化和销毁示例源码：beaninitdestroytests\n\n\n# spring bean 垃圾回收\n\nspring bean 垃圾回收步骤：\n\n 1. 关闭 spring 容器（应用上下文）\n 2. 执行 gc\n 3. spring bean 覆盖的 finalize() 方法被回调\n\n\n# spring bean 作用范围\n\nscope         description\nsingleton     (default) scopes a single bean definition to a single object\n              instance for each spring ioc container.\nprototype     scopes a single bean definition to any number of object\n              instances.\nrequest       scopes a single bean definition to the lifecycle of a single\n              http request. that is, each http request has its own\n              instance of a bean created off the back of a single bean\n              definition. only valid in the context of a web-aware spring\n              applicationcontext.\nsession       scopes a single bean definition to the lifecycle of an http\n              session. only valid in the context of a web-aware spring\n              applicationcontext.\napplication   scopes a single bean definition to the lifecycle of a\n              servletcontext. only valid in the context of a web-aware\n              spring applicationcontext.\nwebsocket     scopes a single bean definition to the lifecycle of a\n              websocket. only valid in the context of a web-aware spring\n              applicationcontext.\n\n\n# 参考资料\n\n * spring 官方文档之 core technologies\n * 《小马哥讲 spring 核心编程思想》',charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Spring 依赖查找",frontmatter:{title:"Spring 依赖查找",date:"2020-08-30T16:06:10.000Z",order:3,categories:["Java","框架","Spring","Spring核心"],tags:["Java","框架","Spring","IOC","依赖查找"],permalink:"/pages/9a6f6b/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/01.Spring%E6%A0%B8%E5%BF%83/03.Spring%E4%BE%9D%E8%B5%96%E6%9F%A5%E6%89%BE.html",relativePath:"01.Java/13.框架/01.Spring/01.Spring核心/03.Spring依赖查找.md",key:"v-2a4dda94",path:"/pages/9a6f6b/",headers:[{level:2,title:"单一类型依赖查找",slug:"单一类型依赖查找",normalizedTitle:"单一类型依赖查找",charIndex:200},{level:2,title:"集合类型依赖查找",slug:"集合类型依赖查找",normalizedTitle:"集合类型依赖查找",charIndex:577},{level:2,title:"层次性依赖查找",slug:"层次性依赖查找",normalizedTitle:"层次性依赖查找",charIndex:1141},{level:2,title:"延迟依赖查找",slug:"延迟依赖查找",normalizedTitle:"延迟依赖查找",charIndex:1493},{level:2,title:"安全依赖查找",slug:"安全依赖查找",normalizedTitle:"安全依赖查找",charIndex:1736},{level:2,title:"内建可查找的依赖",slug:"内建可查找的依赖",normalizedTitle:"内建可查找的依赖",charIndex:2132},{level:2,title:"依赖查找中的经典异常",slug:"依赖查找中的经典异常",normalizedTitle:"依赖查找中的经典异常",charIndex:3799},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:4338}],headersStr:"单一类型依赖查找 集合类型依赖查找 层次性依赖查找 延迟依赖查找 安全依赖查找 内建可查找的依赖 依赖查找中的经典异常 参考资料",content:"# Spring 依赖查找\n\n依赖查找是主动或手动的依赖查找方式，通常需要依赖容器或标准 API 实现。\n\nIoC 依赖查找大致可以分为以下几类：\n\n * 根据 Bean 名称查找\n * 根据 Bean 类型查找\n * 根据 Bean 名称 + 类型查找\n * 根据 Java 注解查找\n\n此外，根据查找的 Bean 对象是单一或集合对象，是否需要延迟查找等特定常见，有相应不同的 API。\n\n\n# 单一类型依赖查找\n\n单一类型依赖查找接口- BeanFactory\n\n * 根据 Bean 名称查找\n   * getBean(String)\n   * Spring 2.5 覆盖默认参数：getBean(String,Object...)\n * 根据 Bean 类型查找\n   * Bean 实时查找\n     * Spring 3.0 getBean(Class)\n     * Spring 4.1 覆盖默认参数：getBean(Class,Object...)\n   * Spring 5.1 Bean 延迟查找\n     * getBeanProvider(Class)\n     * getBeanProvider(ResolvableType)\n * 根据 Bean 名称 + 类型查找：getBean(String,Class)\n\n\n# 集合类型依赖查找\n\n集合类型依赖查找接口- ListableBeanFactory\n\n * 根据 Bean 类型查找\n   \n   * 获取同类型 Bean 名称列表\n     * getBeanNamesForType(Class)\n     * Spring 4.2 getBeanNamesForType(ResolvableType)\n   * 获取同类型 Bean 实例列表\n     * getBeansOfType(Class) 以及重载方法\n\n * 通过注解类型查找\n   \n   * Spring 3.0 获取标注类型 Bean 名称列表\n     \n     * getBeanNamesForAnnotation(Class<? extends Annotation>)\n   \n   * Spring 3.0 获取标注类型 Bean 实例列表\n     \n     * getBeansWithAnnotation(Class<? extends Annotation>)\n   \n   * Spring 3.0 获取指定名称+ 标注类型 Bean 实例\n     \n     * findAnnotationOnBean(String,Class<? extends Annotation>)\n\n\n# 层次性依赖查找\n\n层次性依赖查找接口- HierarchicalBeanFactory\n\n * 双亲 BeanFactory：getParentBeanFactory()\n * 层次性查找\n   * 根据 Bean 名称查找\n     * 基于 containsLocalBean 方法实现\n   * 根据 Bean 类型查找实例列表\n     * 单一类型：BeanFactoryUtils#beanOfType\n     * 集合类型：BeanFactoryUtils#beansOfTypeIncludingAncestors\n   * 根据 Java 注解查找名称列表\n     * BeanFactoryUtils#beanNamesForTypeIncludingAncestors\n\n\n# 延迟依赖查找\n\nBean 延迟依赖查找接口\n\n * org.springframework.beans.factory.ObjectFactory\n * org.springframework.beans.factory.ObjectProvider（Spring 5 对 Java 8 特性扩展）\n * 函数式接口\n   * getIfAvailable(Supplier)\n   * ifAvailable(Consumer)\n * Stream 扩展- stream()\n\n\n# 安全依赖查找\n\n依赖查找类型   代表实现                                 是否安全\n单一类型查找   BeanFactory#getBean                  否\n         ObjectFactory#getObject              否\n         ObjectProvider#getIfAvailable        是\n                                              \n集合类型查找   ListableBeanFactory#getBeansOfType   是\n         ObjectProvider#stream                是\n\n注意：层次性依赖查找的安全性取决于其扩展的单一或集合类型的 BeanFactory 接口\n\n\n# 内建可查找的依赖\n\nAbstractApplicationContext 内建可查找的依赖\n\nBEAN                          名称 BEAN                          实例使用场景\nenvironment                   Environment 对象                   外部化配置以及 Profiles\nsystemProperties              java.util.Properties 对象          Java 系统属性\nsystemEnvironment             java.util.Map 对象                 操作系统环境变量\nmessageSource                 MessageSource 对象                 国际化文案\nlifecycleProcessor            LifecycleProcessor 对象            Lifecycle Bean 处理器\napplicationEventMulticaster   ApplicationEventMulticaster 对象   Spring 事件广播器\n\n注解驱动 Spring 应用上下文内建可查找的依赖（部分）\n\nBEAN 名称                                                                           BEAN 实例                                     使用场景\norg.springframework.context.annotation.internalConfigurationAnnotationProcessor   ConfigurationClassPostProcessor 对象          处理 Spring 配置类\norg.springframework.context.annotation.internalAutowiredAnnotationProcessor       AutowiredAnnotationBeanPostProcessor 对象     处理@Autowired 以及@Value 注解\norg.springframework.context.annotation.internalCommonAnnotationProcessor          CommonAnnotationBeanPostProcessor 对象        （条件激活）处理 JSR-250 注解，如@PostConstruct 等\norg.springframework.context.event.internalEventListenerProcessor                  EventListenerMethodProcessor 对象             处理标注@EventListener 的 Spring 事件监听方法\norg.springframework.context.event.internalEventListenerFactory                    DefaultEventListenerFactory 对象              @EventListener 事件监听方法适配为 ApplicationListener\norg.springframework.context.annotation.internalPersistenceAnnotationProcessor     PersistenceAnnotationBeanPostProcessor 对象   （条件激活）处理 JPA 注解场景\n\n\n# 依赖查找中的经典异常\n\nBeansException 子类型\n\n异常类型                              触发条件（举例）                     场景举例\nNoSuchBeanDefinitionException     当查找 Bean 不存在于 IoC 容器时        BeanFactory#getBeanObjectFactory#getObject\nNoUniqueBeanDefinitionException   类型依赖查找时，IoC 容器存在多个 Bean 实例   BeanFactory#getBean(Class)\nBeanInstantiationException        当 Bean 所对应的类型非具体类时           BeanFactory#getBean\nBeanCreationException             当 Bean 初始化过程中                Bean 初始化方法执行异常时\nBeanDefinitionStoreException      当 BeanDefinition 配置元信息非法时    XML 配置资源无法打开时\n\n\n# 参考资料\n\n * Spring 官方文档之 Core Technologies\n * 《小马哥讲 Spring 核心编程思想》",normalizedContent:"# spring 依赖查找\n\n依赖查找是主动或手动的依赖查找方式，通常需要依赖容器或标准 api 实现。\n\nioc 依赖查找大致可以分为以下几类：\n\n * 根据 bean 名称查找\n * 根据 bean 类型查找\n * 根据 bean 名称 + 类型查找\n * 根据 java 注解查找\n\n此外，根据查找的 bean 对象是单一或集合对象，是否需要延迟查找等特定常见，有相应不同的 api。\n\n\n# 单一类型依赖查找\n\n单一类型依赖查找接口- beanfactory\n\n * 根据 bean 名称查找\n   * getbean(string)\n   * spring 2.5 覆盖默认参数：getbean(string,object...)\n * 根据 bean 类型查找\n   * bean 实时查找\n     * spring 3.0 getbean(class)\n     * spring 4.1 覆盖默认参数：getbean(class,object...)\n   * spring 5.1 bean 延迟查找\n     * getbeanprovider(class)\n     * getbeanprovider(resolvabletype)\n * 根据 bean 名称 + 类型查找：getbean(string,class)\n\n\n# 集合类型依赖查找\n\n集合类型依赖查找接口- listablebeanfactory\n\n * 根据 bean 类型查找\n   \n   * 获取同类型 bean 名称列表\n     * getbeannamesfortype(class)\n     * spring 4.2 getbeannamesfortype(resolvabletype)\n   * 获取同类型 bean 实例列表\n     * getbeansoftype(class) 以及重载方法\n\n * 通过注解类型查找\n   \n   * spring 3.0 获取标注类型 bean 名称列表\n     \n     * getbeannamesforannotation(class<? extends annotation>)\n   \n   * spring 3.0 获取标注类型 bean 实例列表\n     \n     * getbeanswithannotation(class<? extends annotation>)\n   \n   * spring 3.0 获取指定名称+ 标注类型 bean 实例\n     \n     * findannotationonbean(string,class<? extends annotation>)\n\n\n# 层次性依赖查找\n\n层次性依赖查找接口- hierarchicalbeanfactory\n\n * 双亲 beanfactory：getparentbeanfactory()\n * 层次性查找\n   * 根据 bean 名称查找\n     * 基于 containslocalbean 方法实现\n   * 根据 bean 类型查找实例列表\n     * 单一类型：beanfactoryutils#beanoftype\n     * 集合类型：beanfactoryutils#beansoftypeincludingancestors\n   * 根据 java 注解查找名称列表\n     * beanfactoryutils#beannamesfortypeincludingancestors\n\n\n# 延迟依赖查找\n\nbean 延迟依赖查找接口\n\n * org.springframework.beans.factory.objectfactory\n * org.springframework.beans.factory.objectprovider（spring 5 对 java 8 特性扩展）\n * 函数式接口\n   * getifavailable(supplier)\n   * ifavailable(consumer)\n * stream 扩展- stream()\n\n\n# 安全依赖查找\n\n依赖查找类型   代表实现                                 是否安全\n单一类型查找   beanfactory#getbean                  否\n         objectfactory#getobject              否\n         objectprovider#getifavailable        是\n                                              \n集合类型查找   listablebeanfactory#getbeansoftype   是\n         objectprovider#stream                是\n\n注意：层次性依赖查找的安全性取决于其扩展的单一或集合类型的 beanfactory 接口\n\n\n# 内建可查找的依赖\n\nabstractapplicationcontext 内建可查找的依赖\n\nbean                          名称 bean                          实例使用场景\nenvironment                   environment 对象                   外部化配置以及 profiles\nsystemproperties              java.util.properties 对象          java 系统属性\nsystemenvironment             java.util.map 对象                 操作系统环境变量\nmessagesource                 messagesource 对象                 国际化文案\nlifecycleprocessor            lifecycleprocessor 对象            lifecycle bean 处理器\napplicationeventmulticaster   applicationeventmulticaster 对象   spring 事件广播器\n\n注解驱动 spring 应用上下文内建可查找的依赖（部分）\n\nbean 名称                                                                           bean 实例                                     使用场景\norg.springframework.context.annotation.internalconfigurationannotationprocessor   configurationclasspostprocessor 对象          处理 spring 配置类\norg.springframework.context.annotation.internalautowiredannotationprocessor       autowiredannotationbeanpostprocessor 对象     处理@autowired 以及@value 注解\norg.springframework.context.annotation.internalcommonannotationprocessor          commonannotationbeanpostprocessor 对象        （条件激活）处理 jsr-250 注解，如@postconstruct 等\norg.springframework.context.event.internaleventlistenerprocessor                  eventlistenermethodprocessor 对象             处理标注@eventlistener 的 spring 事件监听方法\norg.springframework.context.event.internaleventlistenerfactory                    defaulteventlistenerfactory 对象              @eventlistener 事件监听方法适配为 applicationlistener\norg.springframework.context.annotation.internalpersistenceannotationprocessor     persistenceannotationbeanpostprocessor 对象   （条件激活）处理 jpa 注解场景\n\n\n# 依赖查找中的经典异常\n\nbeansexception 子类型\n\n异常类型                              触发条件（举例）                     场景举例\nnosuchbeandefinitionexception     当查找 bean 不存在于 ioc 容器时        beanfactory#getbeanobjectfactory#getobject\nnouniquebeandefinitionexception   类型依赖查找时，ioc 容器存在多个 bean 实例   beanfactory#getbean(class)\nbeaninstantiationexception        当 bean 所对应的类型非具体类时           beanfactory#getbean\nbeancreationexception             当 bean 初始化过程中                bean 初始化方法执行异常时\nbeandefinitionstoreexception      当 beandefinition 配置元信息非法时    xml 配置资源无法打开时\n\n\n# 参考资料\n\n * spring 官方文档之 core technologies\n * 《小马哥讲 spring 核心编程思想》",charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Spring IoC",frontmatter:{title:"Spring IoC",date:"2020-08-30T16:06:10.000Z",order:2,categories:["Java","框架","Spring","Spring核心"],tags:["Java","框架","Spring","IOC"],permalink:"/pages/915530/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/01.Spring%E6%A0%B8%E5%BF%83/02.SpringIoC.html",relativePath:"01.Java/13.框架/01.Spring/01.Spring核心/02.SpringIoC.md",key:"v-55cc8b3f",path:"/pages/915530/",headers:[{level:2,title:"IoC 简介",slug:"ioc-简介",normalizedTitle:"ioc 简介",charIndex:17},{level:3,title:"IoC 是什么",slug:"ioc-是什么",normalizedTitle:"ioc 是什么",charIndex:28},{level:3,title:"IoC 能做什么",slug:"ioc-能做什么",normalizedTitle:"ioc 能做什么",charIndex:671},{level:3,title:"IoC 和 DI",slug:"ioc-和-di",normalizedTitle:"ioc 和 di",charIndex:1081},{level:3,title:"IoC 容器",slug:"ioc-容器",normalizedTitle:"ioc 容器",charIndex:471},{level:3,title:"Bean",slug:"bean",normalizedTitle:"bean",charIndex:1497},{level:3,title:"Spring IoC",slug:"spring-ioc-2",normalizedTitle:"spring ioc",charIndex:2},{level:2,title:"IoC 容器",slug:"ioc-容器-2",normalizedTitle:"ioc 容器",charIndex:471},{level:3,title:"配置元数据",slug:"配置元数据",normalizedTitle:"配置元数据",charIndex:1586},{level:3,title:"实例化容器",slug:"实例化容器",normalizedTitle:"实例化容器",charIndex:3390},{level:3,title:"使用容器",slug:"使用容器",normalizedTitle:"使用容器",charIndex:3519},{level:2,title:"IoC 依赖来源",slug:"ioc-依赖来源",normalizedTitle:"ioc 依赖来源",charIndex:8776},{level:2,title:"IoC 配置元数据",slug:"ioc-配置元数据",normalizedTitle:"ioc 配置元数据",charIndex:8821},{level:3,title:"Xml 配置",slug:"xml-配置",normalizedTitle:"xml 配置",charIndex:9025},{level:4,title:"实例化容器",slug:"实例化容器-2",normalizedTitle:"实例化容器",charIndex:3390},{level:4,title:"使用容器",slug:"使用容器-2",normalizedTitle:"使用容器",charIndex:3519},{level:3,title:"注解配置",slug:"注解配置",normalizedTitle:"注解配置",charIndex:3758},{level:4,title:"启动注解",slug:"启动注解",normalizedTitle:"启动注解",charIndex:11107},{level:4,title:"@Required",slug:"required",normalizedTitle:"@required",charIndex:11365},{level:4,title:"@Autowired",slug:"autowired",normalizedTitle:"@autowired",charIndex:11337},{level:4,title:"@Qualifier",slug:"qualifier",normalizedTitle:"@qualifier",charIndex:13969},{level:4,title:"@Resource",slug:"resource",normalizedTitle:"@resource",charIndex:15630},{level:4,title:"@PostConstruct 和 @PreDestroy",slug:"postconstruct-和-predestroy",normalizedTitle:"@postconstruct 和 @predestroy",charIndex:17189},{level:4,title:"@Inject",slug:"inject",normalizedTitle:"@inject",charIndex:12176},{level:3,title:"Java 配置",slug:"java-配置",normalizedTitle:"java 配置",charIndex:3810},{level:4,title:"@Bean",slug:"bean-2",normalizedTitle:"@bean",charIndex:3888},{level:4,title:"声明一个 bean",slug:"声明一个-bean",normalizedTitle:"声明一个 bean",charIndex:19723},{level:4,title:"@Configuration",slug:"configuration",normalizedTitle:"@configuration",charIndex:3865},{level:2,title:"依赖解决过程",slug:"依赖解决过程",normalizedTitle:"依赖解决过程",charIndex:21290},{level:2,title:"最佳实践",slug:"最佳实践",normalizedTitle:"最佳实践",charIndex:22326},{level:3,title:"singleton 的 Bean 如何注入 prototype 的 Bean",slug:"singleton-的-bean-如何注入-prototype-的-bean",normalizedTitle:"singleton 的 bean 如何注入 prototype 的 bean",charIndex:22335},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:24298}],headersStr:"IoC 简介 IoC 是什么 IoC 能做什么 IoC 和 DI IoC 容器 Bean Spring IoC IoC 容器 配置元数据 实例化容器 使用容器 IoC 依赖来源 IoC 配置元数据 Xml 配置 实例化容器 使用容器 注解配置 启动注解 @Required @Autowired @Qualifier @Resource @PostConstruct 和 @PreDestroy @Inject Java 配置 @Bean 声明一个 bean @Configuration 依赖解决过程 最佳实践 singleton 的 Bean 如何注入 prototype 的 Bean 参考资料",content:'# Spring IoC\n\n\n# IoC 简介\n\n\n# IoC 是什么\n\nIoC 即控制反转（Inversion of Control，缩写为 IoC）。IoC 又称为依赖倒置原则（设计模式六大原则之一），它的要点在于：程序要依赖于抽象接口，不要依赖于具体实现。它的作用就是用于降低代码间的耦合度。\n\nIoC 的实现方式有两种：\n\n * 依赖注入（Dependency Injection，简称 DI）：不通过 new() 的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类使用。\n * 依赖查找（Dependency Lookup）：容器中的受控对象通过容器的 API 来查找自己所依赖的资源和协作对象。\n\n理解 Ioc 的关键是要明确两个要点：\n\n * 谁控制谁，控制什么：传统 Java SE 程序设计，我们直接在对象内部通过 new 进行创建对象，是程序主动去创建依赖对象；而 IoC 是有专门一个容器来创建这些对象，即由 Ioc 容器来控制对象的创建；谁控制谁？当然是 IoC 容器控制了对象；控制什么？那就是主要控制了外部资源获取（不只是对象包括比如文件等）。\n * 为何是反转，哪些方面反转了：有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了。\n\n\n\n\n# IoC 能做什么\n\nIoC 不是一种技术，而是编程思想，一个重要的面向对象编程的法则，它能指导我们如何设计出松耦合、更优良的程序。传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试；有了 IoC 容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。\n\n其实 IoC 对编程带来的最大改变不是从代码上，而是从思想上，发生了“主从换位”的变化。应用程序原本是老大，要获取什么资源都是主动出击，但是在 IoC/DI 思想中，应用程序就变成被动的了，被动的等待 IoC 容器来创建并注入它所需要的资源了。\n\nIoC 很好的体现了面向对象设计法则之一—— 好莱坞法则：“别找我们，我们找你”；即由 IoC 容器帮对象找相应的依赖对象并注入，而不是由对象主动去找。\n\n\n# IoC 和 DI\n\n其实它们是同一个概念的不同角度描述，由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以 2004 年大师级人物 Martin Fowler 又给出了一个新的名字：“依赖注入”，相对 IoC 而言，“依赖注入”明确描述了“被注入对象依赖 IoC 容器配置依赖对象”。\n\n> 注：如果想要更加深入的了解 IoC 和 DI，请参考大师级人物 Martin Fowler 的一篇经典文章 Inversion of Control Containers and the Dependency Injection pattern 。\n\n\n# IoC 容器\n\nIoC 容器就是具有依赖注入功能的容器。IoC 容器负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。应用程序无需直接在代码中 new 相关的对象，应用程序由 IoC 容器进行组装。在 Spring 中 BeanFactory 是 IoC 容器的实际代表者。\n\nSpring IoC 容器如何知道哪些是它管理的对象呢？这就需要配置文件，Spring IoC 容器通过读取配置文件中的配置元数据，通过元数据对应用中的各个对象进行实例化及装配。一般使用基于 xml 配置文件进行配置元数据，而且 Spring 与配置文件完全解耦的，可以使用其他任何可能的方式进行配置元数据，比如注解、基于 java 文件的、基于属性文件的配置都可以。\n\n\n# Bean\n\n> JavaBean 是一种 JAVA 语言写成的可重用组件。为写成 JavaBean，类必须是具体的和公共的，并且具有无参数的构造器。JavaBean 对外部通过提供 getter / setter 方法来访问其成员。\n\n由 IoC 容器管理的那些组成你应用程序的对象我们就叫它 Bean。Bean 就是由 Spring 容器初始化、装配及管理的对象，除此之外，bean 就与应用程序中的其他对象没有什么区别了。那 IoC 怎样确定如何实例化 Bean、管理 Bean 之间的依赖关系以及管理 Bean 呢？这就需要配置元数据，在 Spring 中由 BeanDefinition 代表，后边会详细介绍，配置元数据指定如何实例化 Bean、如何组装 Bean 等。\n\n\n# Spring IoC\n\nSpring IoC 容器中的对象仅通过构造函数参数、工厂方法的参数或在对象实例被构造或从工厂方法返回后设置的属性来定义它们的依赖关系（即与它们一起工作的其他对象）。然后容器在创建 bean 时注入这些依赖项。这个过程基本上是 bean 本身通过使用类的直接构造或诸如服务定位器模式之类的机制来控制其依赖关系的实例化或位置的逆过程（因此称为控制反转）。\n\norg.springframework.beans 和 org.springframework.context 是 IoC 容器的基础。\n\n\n# IoC 容器\n\n在 Spring 中，有两种 IoC 容器：BeanFactory 和 ApplicationContext。\n\n * BeanFactory：BeanFactory 是 Spring 基础 IoC 容器。BeanFactory 提供了 Spring 容器的配置框架和基本功能。\n * ApplicationContext：ApplicationContext 是具备应用特性的 BeanFactory 的子接口。它还扩展了其他一些接口，以支持更丰富的功能，如：国际化、访问资源、事件机制、更方便的支持 AOP、在 web 应用中指定应用层上下文等。\n\n实际开发中，更推荐使用 ApplicationContext 作为 IoC 容器，因为它的功能远多于 BeanFactory。\n\norg.springframework.context.ApplicationContext 接口代表 Spring IoC 容器，负责实例化、配置和组装 bean。容器通过读取配置元数据来获取关于要实例化、配置和组装哪些对象的指令。配置元数据以 XML、Java 注释或 Java 代码表示。它允许您表达组成应用程序的对象以及这些对象之间丰富的相互依赖关系。\n\nSpring 提供了 ApplicationContext 接口的几个实现，例如：\n\n * ClassPathXmlApplicationContext：ApplicationContext 的实现，从 classpath 获取配置信息。\n\nBeanFactory beanFactory = new ClassPathXmlApplicationContext("classpath.xml");\n\n\n * FileSystemXmlApplicationContext：ApplicationContext 的实现，从文件系统获取配置信息。\n\nBeanFactory beanFactory = new FileSystemXmlApplicationContext("fileSystemConfig.xml");\n\n\n在大多数应用场景中，不需要显式通过用户代码来实例化 Spring IoC 容器的一个或多个实例。\n\n下图显示了 Spring IoC 容器的工作步骤\n\n\n\n使用 IoC 容器可分为三步骤：\n\n 1. 配置元数据：需要配置一些元数据来告诉 Spring，你希望容器如何工作，具体来说，就是如何去初始化、配置、管理 JavaBean 对象。\n 2. 实例化容器：由 IoC 容器解析配置的元数据。IoC 容器的 Bean Reader 读取并解析配置文件，根据定义生成 BeanDefinition 配置元数据对象，IoC 容器根据 BeanDefinition 进行实例化、配置及组装 Bean。\n 3. 使用容器：由客户端实例化容器，获取需要的 Bean。\n\n\n# 配置元数据\n\n**元数据（Metadata）**又称中介数据、中继数据，为描述数据的数据（data about data），主要是描述数据属性（property）的信息。\n\n配置元数据的方式：\n\n * 基于 xml 配置：Spring 的传统配置方式。通常是在顶级元素 <beans> 中通过 <bean>元素配置元数据。这种方式的缺点是：如果 JavaBean 过多，则产生的配置文件足以让你眼花缭乱。\n * 基于注解配置：Spring 2.5 引入了对基于注解的配置元数据的支持。可以大大简化你的配置。\n * 基于 Java 配置：从 Spring 3.0 开始，Spring 支持使用 Java 代码来配置元数据。通常是在 @Configuration 修饰的类中通过 @Bean 指定实例化 Bean 的方法。更多详情，可以参阅 @Configuration、@Bean、@Import 和 @DependsOn 注释。\n\n这些 bean 定义对应于构成应用程序的实际对象。例如：定义服务层对象、数据访问对象 (DAO)、表示对象（如 Struts Action 实例）、基础设施对象（如 Hibernate SessionFactories、JMS 队列等）。通常，不会在容器中配置细粒度的域对象，因为创建和加载域对象通常是 DAO 和业务逻辑的责任。但是，可以使用 Spring 与 AspectJ 的集成来配置在 IoC 容器控制之外创建的对象。\n\n以下示例显示了基于 XML 的配置元数据的基本结构：\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n    xsi:schemaLocation="http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd">\n\n    \x3c!--id 属性用于唯一标识单个 bean 定义--\x3e\n    \x3c!--class 属性用于指明 bean 类型的完全限定名--\x3e\n    <bean id="..." class="...">\n        \x3c!-- 这里配置 Bean 的属性 --\x3e\n    </bean>\n\n    <bean id="..." class="...">\n        \x3c!-- 这里配置 Bean 的属性 --\x3e\n    </bean>\n\n    \x3c!-- 更多的 Bean 定义 --\x3e\n\n</beans>\n\n\n\n# 实例化容器\n\n可以通过为 ApplicationContext 的构造函数指定外部资源路径，来加载配置元数据。\n\nApplicationContext context = new ClassPathXmlApplicationContext("services.xml", "daos.xml");\n\n\n以下示例显示了服务层对象 (services.xml) 配置文件：\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n    xsi:schemaLocation="http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd">\n\n    \x3c!-- services --\x3e\n\n    <bean id="petStore" class="org.springframework.samples.jpetstore.services.PetStoreServiceImpl">\n        <property name="accountDao" ref="accountDao"/>\n        <property name="itemDao" ref="itemDao"/>\n        \x3c!-- additional collaborators and configuration for this bean go here --\x3e\n    </bean>\n\n    \x3c!-- more bean definitions for services go here --\x3e\n\n</beans>\n\n\n以下示例显示了数据访问对象 (daos.xml) 配置文件：\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n    xsi:schemaLocation="http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd">\n\n    <bean id="accountDao"\n        class="org.springframework.samples.jpetstore.dao.jpa.JpaAccountDao">\n        \x3c!-- additional collaborators and configuration for this bean go here --\x3e\n    </bean>\n\n    <bean id="itemDao" class="org.springframework.samples.jpetstore.dao.jpa.JpaItemDao">\n        \x3c!-- additional collaborators and configuration for this bean go here --\x3e\n    </bean>\n\n    \x3c!-- more bean definitions for data access objects go here --\x3e\n\n</beans>\n\n\n上面的示例中，服务层由 PetStoreServiceImpl 类和类型为 JpaAccountDao 和 JpaItemDao 的两个数据访问对象（基于 JPA 对象关系映射标准）组成。 property name 元素指的是 JavaBean 属性的名称，ref 元素指的是另一个 bean 定义的名称。 id 和 ref 元素之间的这种联系表达了协作对象之间的依赖关系。\n\nSpring 支持通过多个 xml 文件来定义 Bean，每个单独的 XML 配置文件都代表架构中的一个逻辑层或模块。可以使用 ApplicationContext 构造函数从所有这些 XML 片段加载 bean 定义。或者，使用 <import/> 元素从另一个或多个文件加载 bean 定义。如下所示：\n\n<beans>\n    <import resource="services.xml"/>\n    <import resource="resources/messageSource.xml"/>\n    <import resource="/resources/themeSource.xml"/>\n\n    <bean id="bean1" class="..."/>\n    <bean id="bean2" class="..."/>\n</beans>\n\n\n在上面的示例中，外部 bean 定义从三个文件加载：services.xml、messageSource.xml 和 themeSource.xml。services.xml 文件必须和当前 xml 文件位于同一目录或类路径位置；而 messageSource.xml 和 themeSource.xml 必须位于当前文件所在目录的子目录 resources 下。/resources 的 / 会被忽略。但是，鉴于这些路径是相对的，最好不要使用 /。根据 Spring Schema，被导入文件的内容，包括顶级 <beans/> 元素，必须是有效的 XML bean 定义。\n\n> 注意：\n> \n> 可以，但不推荐使用相对 “../” 路径来引用父目录中的文件。这样做会创建对当前应用程序之外的文件的依赖。特别是，不建议将此引用用于 classpath：URL（例如， classpath:../services.xml），其中运行时解析过程会选择“最近的”类路径根，然后查看其父目录。类路径配置更改可能会导致选择不同的、不正确的目录。\n> \n> 可以使用完全限定的资源位置而不是相对路径：例如，file:C:/config/services.xml 或 classpath:/config/services.xml。建议为此类绝对路径保留一定的间接性  —  例如，通过 “${...}” 占位符来引用运行时指定 的 JVM 参数。\n\n命名空间本身提供了导入指令功能。 Spring 提供的一系列 XML 命名空间中提供了除了普通 bean 定义之外的更多配置特性  —  例如，context 和 util 命名空间。\n\n\n# 使用容器\n\nApplicationContext 能够维护不同 bean 及其依赖项的注册表。通过使用方法 T getBean(String name, Class T requiredType)，可以检索并获取 bean 的实例。\n\nApplicationContext 允许读取 bean 定义并访问它们，如以下示例所示：\n\n// create and configure beans\nApplicationContext context = new ClassPathXmlApplicationContext("services.xml", "daos.xml");\n\n// retrieve configured instance\nPetStoreService service = context.getBean("petStore", PetStoreService.class);\n\n// use configured instance\nList<String> userList = service.getUsernameList();\n\n\n最灵活的变体是 GenericApplicationContext 结合阅读器委托  —  例如，结合 XML 文件的 XmlBeanDefinitionReader，如下例所示：\n\nGenericApplicationContext context = new GenericApplicationContext();\nnew XmlBeanDefinitionReader(context).loadBeanDefinitions("services.xml", "daos.xml");\ncontext.refresh();\n\n\n可以在同一个 ApplicationContext 上混合和匹配此类读取器委托，从不同的配置源读取 bean 定义。\n\n然后，可以使用 getBean 检索 bean 的实例。 ApplicationContext 接口还有一些其他方法用于检索 bean，但理想情况下，应用程序代码不应该使用它们。实际上，应用程序代码根本不应该调用 getBean() 方法，因此根本不依赖 Spring API。例如，Spring 与 Web 框架的集成为各种 Web 框架组件（例如控制器和 JSF 管理的 bean）提供了依赖注入，让您可以通过元数据（例如自动装配注释）声明对特定 bean 的依赖。\n\n\n# IoC 依赖来源\n\n自定义 Bean\n\n容器内建 Bean 对象\n\n容器内建依赖\n\n\n# IoC 配置元数据\n\nIoC 容器的配置有三种方式：\n\n * 基于 xml 配置\n * 基于 properties 配置\n * 基于注解配置\n * 基于 Java 配置\n\n作为 Spring 传统的配置方式，xml 配置方式一般为大家所熟知。\n\n如果厌倦了 xml 配置，Spring 也提供了注解配置方式或 Java 配置方式来简化配置。\n\n本文，将对 Java 配置 IoC 容器做详细的介绍。\n\n\n# Xml 配置\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans\n         http://www.springframework.org/schema/beans/spring-beans.xsd">\n  <import resource="resource1.xml" />\n  <bean id="bean1" class=""></bean>\n  <bean id="bean2" class=""></bean>\n  <bean name="bean2" class=""></bean>\n\n  <alias alias="bean3" name="bean2"/>\n  <import resource="resource2.xml" />\n</beans>\n\n\n标签说明：\n\n * <beans> 是 Spring 配置文件的根节点。\n * <bean> 用来定义一个 JavaBean。id 属性是它的标识，在文件中必须唯一；class 属性是它关联的类。\n * <alias> 用来定义 Bean 的别名。\n * <import> 用来导入其他配置文件的 Bean 定义。这是为了加载多个配置文件，当然也可以把这些配置文件构造为一个数组（new String[] {“config1.xml”, config2.xml}）传给 ApplicationContext 实现类进行加载多个配置文件，那一个更适合由用户决定；这两种方式都是通过调用 Bean Definition Reader 读取 Bean 定义，内部实现没有任何区别。<import> 标签可以放在 <beans> 下的任何位置，没有顺序关系。\n\n# 实例化容器\n\n实例化容器的过程： 定位资源（XML 配置文件） 读取配置信息(Resource) 转化为 Spring 可识别的数据形式（BeanDefinition）\n\nApplicationContext context =\n      new ClassPathXmlApplicationContext(new String[] {"services.xml", "daos.xml"});\n\n\n组合 xml 配置文件 配置的 Bean 功能各不相同，都放在一个 xml 文件中，不便管理。 Java 设计模式讲究职责单一原则。配置其实也是如此，功能不同的 JavaBean 应该被组织在不同的 xml 文件中。然后使用 import 标签把它们统一导入。\n\n<import resource="classpath:spring/applicationContext.xml"/>\n<import resource="/WEB-INF/spring/service.xml"/>\n\n\n# 使用容器\n\n使用容器的方式就是通过getBean获取 IoC 容器中的 JavaBean。 Spring 也有其他方法去获得 JavaBean，但是 Spring 并不推荐其他方式。\n\n// create and configure beans\nApplicationContext context =\nnew ClassPathXmlApplicationContext(new String[] {"services.xml", "daos.xml"});\n// retrieve configured instance\nPetStoreService service = context.getBean("petStore", PetStoreService.class);\n// use configured instance\nList<String> userList = service.getUsernameList();\n\n\n\n# 注解配置\n\nSpring2.5 引入了注解。 于是，一个问题产生了：使用注解方式注入 JavaBean 是不是一定完爆 xml 方式？ 未必。正所谓，仁者见仁智者见智。任何事物都有其优缺点，看你如何取舍。来看看注解的优缺点： 优点：大大减少了配置，并且可以使配置更加精细——类，方法，字段都可以用注解去标记。 缺点：使用注解，不可避免产生了侵入式编程，也产生了一些问题。\n\n * 你需要将注解加入你的源码并编译它；\n\n * 注解往往比较分散，不易管控。\n\n> 注：spring 中，先进行注解注入，然后才是 xml 注入，因此如果注入的目标相同，后者会覆盖前者。\n\n# 启动注解\n\nSpring 默认是不启用注解的。如果想使用注解，需要先在 xml 中启动注解。 启动方式：在 xml 中加入一个标签，很简单吧。\n\n<context:annotation-config/>\n\n\n> 注：<context:annotation-config/> 只会检索定义它的上下文。什么意思呢？就是说，如果你 为 DispatcherServlet 指定了一个WebApplicationContext，那么它只在 controller 中查找@Autowired注解，而不会检查其它的路径。\n\n# @Required\n\n@Required 注解只能用于修饰 bean 属性的 setter 方法。受影响的 bean 属性必须在配置时被填充在 xml 配置文件中，否则容器将抛出BeanInitializationException。\n\npublic class AnnotationRequired {\n    private String name;\n    private String sex;\n\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * @Required 注解用于bean属性的setter方法并且它指示，受影响的bean属性必须在配置时被填充在xml配置文件中，\n     *           否则容器将抛出BeanInitializationException。\n     */\n    @Required\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getSex() {\n        return sex;\n    }\n\n    public void setSex(String sex) {\n        this.sex = sex;\n    }\n}\n\n\n# @Autowired\n\n@Autowired注解可用于修饰属性、setter 方法、构造方法。\n\n@Autowired 注入过程\n\n * 元信息解析\n * 依赖查找\n * 依赖注入（字段、方法）\n\n> 注：@Autowired注解也可用于修饰构造方法，但如果类中只有默认构造方法，则没有必要。如果有多个构造器，至少应该修饰一个，来告诉容器哪一个必须使用。\n\n可以使用 JSR330 的注解@Inject来替代@Autowired。\n\n范例\n\npublic class AnnotationAutowired {\n    private static final Logger log = LoggerFactory.getLogger(AnnotationRequired.class);\n\n    @Autowired\n    private Apple fieldA;\n\n    private Banana fieldB;\n\n    private Orange fieldC;\n\n    public Apple getFieldA() {\n        return fieldA;\n    }\n\n    public void setFieldA(Apple fieldA) {\n        this.fieldA = fieldA;\n    }\n\n    public Banana getFieldB() {\n        return fieldB;\n    }\n\n    @Autowired\n    public void setFieldB(Banana fieldB) {\n        this.fieldB = fieldB;\n    }\n\n    public Orange getFieldC() {\n        return fieldC;\n    }\n\n    public void setFieldC(Orange fieldC) {\n        this.fieldC = fieldC;\n    }\n\n    public AnnotationAutowired() {}\n\n    @Autowired\n    public AnnotationAutowired(Orange fieldC) {\n        this.fieldC = fieldC;\n    }\n\n    public static void main(String[] args) throws Exception {\n        AbstractApplicationContext ctx =\n                        new ClassPathXmlApplicationContext("spring/spring-annotation.xml");\n\n        AnnotationAutowired annotationAutowired =\n                        (AnnotationAutowired) ctx.getBean("annotationAutowired");\n        log.debug("fieldA: {}, fieldB:{}, fieldC:{}", annotationAutowired.getFieldA().getName(),\n                        annotationAutowired.getFieldB().getName(),\n                        annotationAutowired.getFieldC().getName());\n        ctx.close();\n    }\n}\n\n\nxml 中的配置\n\n\x3c!-- 测试@Autowired --\x3e\n<bean id="apple" class="org.zp.notes.spring.beans.annotation.sample.Apple"/>\n<bean id="potato" class="org.zp.notes.spring.beans.annotation.sample.Banana"/>\n<bean id="tomato" class="org.zp.notes.spring.beans.annotation.sample.Orange"/>\n<bean id="annotationAutowired" class="org.zp.notes.spring.beans.annotation.sample.AnnotationAutowired"/>\n\n\n# @Qualifier\n\n在@Autowired注解中，提到了如果发现有多个候选的 bean 都符合修饰类型，Spring 就会抓瞎了。\n\n那么，如何解决这个问题。\n\n可以通过@Qualifier指定 bean 名称来锁定真正需要的那个 bean。\n\n范例\n\npublic class AnnotationQualifier {\n    private static final Logger log = LoggerFactory.getLogger(AnnotationQualifier.class);\n\n    @Autowired\n    @Qualifier("dog") /** 去除这行，会报异常 */\n    Animal dog;\n\n    Animal cat;\n\n    public Animal getDog() {\n        return dog;\n    }\n\n    public void setDog(Animal dog) {\n        this.dog = dog;\n    }\n\n    public Animal getCat() {\n        return cat;\n    }\n\n    @Autowired\n    public void setCat(@Qualifier("cat") Animal cat) {\n        this.cat = cat;\n    }\n\n    public static void main(String[] args) throws Exception {\n        AbstractApplicationContext ctx =\n                new ClassPathXmlApplicationContext("spring/spring-annotation.xml");\n\n        AnnotationQualifier annotationQualifier =\n                (AnnotationQualifier) ctx.getBean("annotationQualifier");\n\n        log.debug("Dog name: {}", annotationQualifier.getDog().getName());\n        log.debug("Cat name: {}", annotationQualifier.getCat().getName());\n        ctx.close();\n    }\n}\n\nabstract class Animal {\n    public String getName() {\n        return null;\n    }\n}\n\nclass Dog extends Animal {\n    public String getName() {\n        return "狗";\n    }\n}\n\nclass Cat extends Animal {\n    public String getName() {\n        return "猫";\n    }\n}\n\n\nxml 中的配置\n\n\x3c!-- 测试@Qualifier --\x3e\n<bean id="dog" class="org.zp.notes.spring.beans.annotation.sample.Dog"/>\n<bean id="cat" class="org.zp.notes.spring.beans.annotation.sample.Cat"/>\n<bean id="annotationQualifier" class="org.zp.notes.spring.beans.annotation.sample.AnnotationQualifier"/>\n\n\n# @Resource\n\nSpring 支持 JSP250 规定的注解@Resource。这个注解根据指定的名称来注入 bean。\n\n如果没有为@Resource指定名称，它会像@Autowired一样按照类型去寻找匹配。\n\n在 Spring 中，由CommonAnnotationBeanPostProcessor来处理@Resource注解。\n\n范例\n\npublic class AnnotationResource {\n    private static final Logger log = LoggerFactory.getLogger(AnnotationResource.class);\n\n    @Resource(name = "flower")\n    Plant flower;\n\n    @Resource(name = "tree")\n    Plant tree;\n\n    public Plant getFlower() {\n        return flower;\n    }\n\n    public void setFlower(Plant flower) {\n        this.flower = flower;\n    }\n\n    public Plant getTree() {\n        return tree;\n    }\n\n    public void setTree(Plant tree) {\n        this.tree = tree;\n    }\n\n    public static void main(String[] args) throws Exception {\n        AbstractApplicationContext ctx =\n                        new ClassPathXmlApplicationContext("spring/spring-annotation.xml");\n\n        AnnotationResource annotationResource =\n                        (AnnotationResource) ctx.getBean("annotationResource");\n        log.debug("type: {}, name: {}", annotationResource.getFlower().getClass(), annotationResource.getFlower().getName());\n        log.debug("type: {}, name: {}", annotationResource.getTree().getClass(), annotationResource.getTree().getName());\n        ctx.close();\n    }\n}\n\n\nxml 的配置\n\n\x3c!-- 测试@Resource --\x3e\n<bean id="flower" class="org.zp.notes.spring.beans.annotation.sample.Flower"/>\n<bean id="tree" class="org.zp.notes.spring.beans.annotation.sample.Tree"/>\n<bean id="annotationResource" class="org.zp.notes.spring.beans.annotation.sample.AnnotationResource"/>\n\n\n# @PostConstruct 和 @PreDestroy\n\n@PostConstruct 和 @PreDestroy 是 JSR 250 规定的用于生命周期的注解。\n\n从其名号就可以看出，一个是在构造之后调用的方法，一个是销毁之前调用的方法。\n\npublic class AnnotationPostConstructAndPreDestroy {\n    private static final Logger log = LoggerFactory.getLogger(AnnotationPostConstructAndPreDestroy.class);\n\n    @PostConstruct\n    public void init() {\n        log.debug("call @PostConstruct method");\n    }\n\n    @PreDestroy\n    public void destroy() {\n        log.debug("call @PreDestroy method");\n    }\n}\n\n\n# @Inject\n\n从 Spring3.0 开始，Spring 支持 JSR 330 标准注解（依赖注入）。\n\n注：如果要使用 JSR 330 注解，需要使用外部 jar 包。\n\n若你使用 maven 管理 jar 包，只需要添加依赖到 pom.xml 即可：\n\n<dependency>\n  <groupId>javax.inject</groupId>\n  <artifactId>javax.inject</artifactId>\n  <version>1</version>\n</dependency>\n\n\n@Inject 和 @Autowired 一样，可以修饰属性、setter 方法、构造方法。\n\n范例\n\npublic class AnnotationInject {\n    private static final Logger log = LoggerFactory.getLogger(AnnotationInject.class);\n    @Inject\n    Apple fieldA;\n\n    Banana fieldB;\n\n    Orange fieldC;\n\n    public Apple getFieldA() {\n        return fieldA;\n    }\n\n    public void setFieldA(Apple fieldA) {\n        this.fieldA = fieldA;\n    }\n\n    public Banana getFieldB() {\n        return fieldB;\n    }\n\n    @Inject\n    public void setFieldB(Banana fieldB) {\n        this.fieldB = fieldB;\n    }\n\n    public Orange getFieldC() {\n        return fieldC;\n    }\n\n    public AnnotationInject() {}\n\n    @Inject\n    public AnnotationInject(Orange fieldC) {\n        this.fieldC = fieldC;\n    }\n\n    public static void main(String[] args) throws Exception {\n        AbstractApplicationContext ctx =\n                        new ClassPathXmlApplicationContext("spring/spring-annotation.xml");\n        AnnotationInject annotationInject = (AnnotationInject) ctx.getBean("annotationInject");\n\n        log.debug("type: {}, name: {}", annotationInject.getFieldA().getClass(),\n                        annotationInject.getFieldA().getName());\n\n        log.debug("type: {}, name: {}", annotationInject.getFieldB().getClass(),\n                        annotationInject.getFieldB().getName());\n\n        log.debug("type: {}, name: {}", annotationInject.getFieldC().getClass(),\n                        annotationInject.getFieldC().getName());\n\n        ctx.close();\n    }\n}\n\n\n\n# Java 配置\n\n基于 Java 配置 Spring IoC 容器，实际上是Spring 允许用户定义一个类，在这个类中去管理 IoC 容器的配置。\n\n为了让 Spring 识别这个定义类为一个 Spring 配置类，需要用到两个注解：@Configuration和@Bean。\n\n如果你熟悉 Spring 的 xml 配置方式，你可以将@Configuration等价于<beans>标签；将@Bean等价于<bean>标签。\n\n# @Bean\n\n@Bean 的修饰目标只能是方法或注解。\n\n@Bean 只能定义在 @Configuration 或 @Component 注解修饰的类中。\n\n# 声明一个 bean\n\n此外，@Configuration 类允许在同一个类中通过@Bean 定义内部 bean 依赖。\n\n声明一个 bean，只需要在 bean 属性的 set 方法上标注@Bean 即可。\n\n@Configuration\npublic class AnnotationConfiguration {\n    private static final Logger log = LoggerFactory.getLogger(JavaComponentScan.class);\n\n    @Bean\n    public Job getPolice() {\n        return new Police();\n    }\n\n    public static void main(String[] args) {\n        AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(AnnotationConfiguration.class);\n        ctx.scan("org.zp.notes.spring.beans");\n        ctx.refresh();\n        Job job = (Job) ctx.getBean("police");\n        log.debug("job: {}, work: {}", job.getClass(), job.work());\n    }\n}\n\npublic interface Job {\n    String work();\n}\n\n@Component("police")\npublic class Police implements Job {\n    @Override\n    public String work() {\n        return "抓罪犯";\n    }\n}\n\n\n这等价于配置\n\n<beans>\n\t<bean id="police" class="org.zp.notes.spring.ioc.sample.job.Police"/>\n</beans>\n\n\n@Bean 注解用来表明一个方法实例化、配置合初始化一个被 Spring IoC 容器管理的新对象。\n\n如果你熟悉 Spring 的 xml 配置，你可以将@Bean 视为等价于<beans>标签。\n\n@Bean 注解可以用于任何的 Spring @Component bean，然而，通常被用于@Configuration bean。\n\n# @Configuration\n\n@Configuration 是一个类级别的注解，用来标记被修饰类的对象是一个BeanDefinition。\n\n@Configuration 声明 bean 是通过被 @Bean 修饰的公共方法。此外，@Configuration 允许在同一个类中通过 @Bean 定义内部 bean 依赖。\n\n@Configuration\npublic class AppConfig {\n    @Bean\n    public MyService myService() {\n        return new MyServiceImpl();\n    }\n}\n\n\n这等价于配置\n\n<beans>\n\t<bean id="myService" class="com.acme.services.MyServiceImpl"/>\n</beans>\n\n\n用 AnnotationConfigApplicationContext 实例化 IoC 容器。\n\n\n# 依赖解决过程\n\n容器执行 bean 依赖解析如下：\n\n * ApplicationContext 使用配置元数据创建和初始化 Bean。配置元数据可以由 XML、Java 代码或注解指定。\n * 对于每个 bean，其依赖关系以属性、构造函数参数或静态工厂方法的参数的形式表示。这些依赖项在实际创建 bean 时提供给 bean。\n * 每个属性或构造函数参数都是要设置的值的实际定义，或者是对容器中另一个 bean 的引用。\n * 作为值的每个属性或构造函数参数都从其指定格式转换为该属性或构造函数参数的实际类型。默认情况下，Spring 可以将以字符串格式提供的值转换为所有内置类型，例如 int、long、String、boolean 等。\n\nSpring 容器在创建容器时验证每个 bean 的配置。但是，在实际创建 bean 之前，不会设置 bean 属性本身。在创建容器时会创建 singleton 型的实例并设置为默认的 Bean。否则，只有在请求时才会创建 bean。\n\n需注意：构造器注入，可能会导致无法解决循环依赖问题。\n\n例如：A 类通过构造器注入需要 B 类的实例，B 类通过构造器注入需要 A 类的实例。Spring IoC 容器会在运行时检测到此循环引用，并抛出 BeanCurrentlyInCreationException。\n\n一种解决方案是使用 setter 方法注入替代构造器注入。\n\n另一种解决方案是：bean A 和 bean B 之间的循环依赖关系，强制其中一个 bean 在完全初始化之前注入另一个 bean（典型的先有鸡还是先有蛋的场景）。\n\nSpring 会在容器加载时检测配置问题，例如引用不存在的 bean 或循环依赖。在实际创建 bean 时，Spring 会尽可能晚地设置属性并解析依赖关系。这意味着，如果在创建该对象或其依赖项之一时出现问题，则正确加载的 Spring 容器稍后可以在您请求对象时生成异常  —  例如，bean 由于丢失或无效而引发异常。某些配置问题的这种潜在的延迟可见性是默认情况下 ApplicationContext 实现预实例化单例 bean 的原因。以在实际需要之前创建这些 bean 的一些前期时间和内存为代价，您会在创建 ApplicationContext 时发现配置问题，而不是稍后。您仍然可以覆盖此默认行为，以便单例 bean 延迟初始化，而不是急切地预先实例化。\n\n\n# 最佳实践\n\n\n# singleton 的 Bean 如何注入 prototype 的 Bean\n\nSpring 创建的 Bean 默认是单例的，但当 Bean 遇到继承的时候，可能会忽略这一点。\n\n假设有一个 SayService 抽象类，其中维护了一个类型是 ArrayList 的字段 data，用于保存方法处理的中间数据。每次调用 say 方法都会往 data 加入新数据，可以认为 SayService 是有状态，如果 SayService 是单例的话必然会 OOM。\n\n/**\n * SayService 是有状态，如果 SayService 是单例的话必然会 OOM\n */\n@Slf4j\npublic abstract class SayService {\n\n   List<String> data = new ArrayList<>();\n\n   public void say() {\n      data.add(IntStream.rangeClosed(1, 1000000)\n         .mapToObj(__ -> "a")\n         .collect(Collectors.joining("")) + UUID.randomUUID().toString());\n      log.info("I\'m {} size:{}", this, data.size());\n   }\n\n}\n\n\n但实际开发的时候，开发同学没有过多思考就把 SayHello 和 SayBye 类加上了 @Service 注解，让它们成为了 Bean，也没有考虑到父类是有状态的。\n\n@Service\n@Slf4j\npublic class SayBye extends SayService {\n\n   @Override\n   public void say() {\n      super.say();\n      log.info("bye");\n   }\n\n}\n\n@Service\n@Slf4j\npublic class SayHello extends SayService {\n\n\t@Override\n\tpublic void say() {\n\t\tsuper.say();\n\t\tlog.info("hello");\n\t}\n\n}\n\n\n在为类标记上 @Service 注解把类型交由容器管理前，首先评估一下类是否有状态，然后为 Bean 设置合适的 Scope。\n\n调用代码：\n\n@Slf4j\n@RestController\n@RequestMapping("beansingletonandorder")\npublic class BeanSingletonAndOrderController {\n\n   @Autowired\n   List<SayService> sayServiceList;\n   @Autowired\n   private ApplicationContext applicationContext;\n\n   @GetMapping("test")\n   public void test() {\n      log.info("====================");\n      sayServiceList.forEach(SayService::say);\n   }\n\n}\n\n\n可能有人认为，为 SayHello 和 SayBye 两个类都标记了 @Scope 注解，设置了 PROTOTYPE 的生命周期就可以解决上面的问题。\n\n@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)\n\n\n但实际上还是有问题。因为@RestController 注解 =@Controller 注解 +@ResponseBody 注解，又因为 @Controller 标记了 @Component 元注解，所以 @RestController 注解其实也是一个 Spring Bean。\n\nBean 默认是单例的，所以单例的 Controller 注入的 Service 也是一次性创建的，即使 Service 本身标识了 prototype 的范围也没用。\n\n修复方式是，让 Service 以代理方式注入。这样虽然 Controller 本身是单例的，但每次都能从代理获取 Service。这样一来，prototype 范围的配置才能真正生效。\n\n@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE, proxyMode = ScopedProx)\n\n\n\n# 参考资料\n\n * Spring 官方文档之 Core Technologies\n * 《小马哥讲 Spring 核心编程思想》',normalizedContent:'# spring ioc\n\n\n# ioc 简介\n\n\n# ioc 是什么\n\nioc 即控制反转（inversion of control，缩写为 ioc）。ioc 又称为依赖倒置原则（设计模式六大原则之一），它的要点在于：程序要依赖于抽象接口，不要依赖于具体实现。它的作用就是用于降低代码间的耦合度。\n\nioc 的实现方式有两种：\n\n * 依赖注入（dependency injection，简称 di）：不通过 new() 的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类使用。\n * 依赖查找（dependency lookup）：容器中的受控对象通过容器的 api 来查找自己所依赖的资源和协作对象。\n\n理解 ioc 的关键是要明确两个要点：\n\n * 谁控制谁，控制什么：传统 java se 程序设计，我们直接在对象内部通过 new 进行创建对象，是程序主动去创建依赖对象；而 ioc 是有专门一个容器来创建这些对象，即由 ioc 容器来控制对象的创建；谁控制谁？当然是 ioc 容器控制了对象；控制什么？那就是主要控制了外部资源获取（不只是对象包括比如文件等）。\n * 为何是反转，哪些方面反转了：有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了。\n\n\n\n\n# ioc 能做什么\n\nioc 不是一种技术，而是编程思想，一个重要的面向对象编程的法则，它能指导我们如何设计出松耦合、更优良的程序。传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试；有了 ioc 容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。\n\n其实 ioc 对编程带来的最大改变不是从代码上，而是从思想上，发生了“主从换位”的变化。应用程序原本是老大，要获取什么资源都是主动出击，但是在 ioc/di 思想中，应用程序就变成被动的了，被动的等待 ioc 容器来创建并注入它所需要的资源了。\n\nioc 很好的体现了面向对象设计法则之一—— 好莱坞法则：“别找我们，我们找你”；即由 ioc 容器帮对象找相应的依赖对象并注入，而不是由对象主动去找。\n\n\n# ioc 和 di\n\n其实它们是同一个概念的不同角度描述，由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以 2004 年大师级人物 martin fowler 又给出了一个新的名字：“依赖注入”，相对 ioc 而言，“依赖注入”明确描述了“被注入对象依赖 ioc 容器配置依赖对象”。\n\n> 注：如果想要更加深入的了解 ioc 和 di，请参考大师级人物 martin fowler 的一篇经典文章 inversion of control containers and the dependency injection pattern 。\n\n\n# ioc 容器\n\nioc 容器就是具有依赖注入功能的容器。ioc 容器负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。应用程序无需直接在代码中 new 相关的对象，应用程序由 ioc 容器进行组装。在 spring 中 beanfactory 是 ioc 容器的实际代表者。\n\nspring ioc 容器如何知道哪些是它管理的对象呢？这就需要配置文件，spring ioc 容器通过读取配置文件中的配置元数据，通过元数据对应用中的各个对象进行实例化及装配。一般使用基于 xml 配置文件进行配置元数据，而且 spring 与配置文件完全解耦的，可以使用其他任何可能的方式进行配置元数据，比如注解、基于 java 文件的、基于属性文件的配置都可以。\n\n\n# bean\n\n> javabean 是一种 java 语言写成的可重用组件。为写成 javabean，类必须是具体的和公共的，并且具有无参数的构造器。javabean 对外部通过提供 getter / setter 方法来访问其成员。\n\n由 ioc 容器管理的那些组成你应用程序的对象我们就叫它 bean。bean 就是由 spring 容器初始化、装配及管理的对象，除此之外，bean 就与应用程序中的其他对象没有什么区别了。那 ioc 怎样确定如何实例化 bean、管理 bean 之间的依赖关系以及管理 bean 呢？这就需要配置元数据，在 spring 中由 beandefinition 代表，后边会详细介绍，配置元数据指定如何实例化 bean、如何组装 bean 等。\n\n\n# spring ioc\n\nspring ioc 容器中的对象仅通过构造函数参数、工厂方法的参数或在对象实例被构造或从工厂方法返回后设置的属性来定义它们的依赖关系（即与它们一起工作的其他对象）。然后容器在创建 bean 时注入这些依赖项。这个过程基本上是 bean 本身通过使用类的直接构造或诸如服务定位器模式之类的机制来控制其依赖关系的实例化或位置的逆过程（因此称为控制反转）。\n\norg.springframework.beans 和 org.springframework.context 是 ioc 容器的基础。\n\n\n# ioc 容器\n\n在 spring 中，有两种 ioc 容器：beanfactory 和 applicationcontext。\n\n * beanfactory：beanfactory 是 spring 基础 ioc 容器。beanfactory 提供了 spring 容器的配置框架和基本功能。\n * applicationcontext：applicationcontext 是具备应用特性的 beanfactory 的子接口。它还扩展了其他一些接口，以支持更丰富的功能，如：国际化、访问资源、事件机制、更方便的支持 aop、在 web 应用中指定应用层上下文等。\n\n实际开发中，更推荐使用 applicationcontext 作为 ioc 容器，因为它的功能远多于 beanfactory。\n\norg.springframework.context.applicationcontext 接口代表 spring ioc 容器，负责实例化、配置和组装 bean。容器通过读取配置元数据来获取关于要实例化、配置和组装哪些对象的指令。配置元数据以 xml、java 注释或 java 代码表示。它允许您表达组成应用程序的对象以及这些对象之间丰富的相互依赖关系。\n\nspring 提供了 applicationcontext 接口的几个实现，例如：\n\n * classpathxmlapplicationcontext：applicationcontext 的实现，从 classpath 获取配置信息。\n\nbeanfactory beanfactory = new classpathxmlapplicationcontext("classpath.xml");\n\n\n * filesystemxmlapplicationcontext：applicationcontext 的实现，从文件系统获取配置信息。\n\nbeanfactory beanfactory = new filesystemxmlapplicationcontext("filesystemconfig.xml");\n\n\n在大多数应用场景中，不需要显式通过用户代码来实例化 spring ioc 容器的一个或多个实例。\n\n下图显示了 spring ioc 容器的工作步骤\n\n\n\n使用 ioc 容器可分为三步骤：\n\n 1. 配置元数据：需要配置一些元数据来告诉 spring，你希望容器如何工作，具体来说，就是如何去初始化、配置、管理 javabean 对象。\n 2. 实例化容器：由 ioc 容器解析配置的元数据。ioc 容器的 bean reader 读取并解析配置文件，根据定义生成 beandefinition 配置元数据对象，ioc 容器根据 beandefinition 进行实例化、配置及组装 bean。\n 3. 使用容器：由客户端实例化容器，获取需要的 bean。\n\n\n# 配置元数据\n\n**元数据（metadata）**又称中介数据、中继数据，为描述数据的数据（data about data），主要是描述数据属性（property）的信息。\n\n配置元数据的方式：\n\n * 基于 xml 配置：spring 的传统配置方式。通常是在顶级元素 <beans> 中通过 <bean>元素配置元数据。这种方式的缺点是：如果 javabean 过多，则产生的配置文件足以让你眼花缭乱。\n * 基于注解配置：spring 2.5 引入了对基于注解的配置元数据的支持。可以大大简化你的配置。\n * 基于 java 配置：从 spring 3.0 开始，spring 支持使用 java 代码来配置元数据。通常是在 @configuration 修饰的类中通过 @bean 指定实例化 bean 的方法。更多详情，可以参阅 @configuration、@bean、@import 和 @dependson 注释。\n\n这些 bean 定义对应于构成应用程序的实际对象。例如：定义服务层对象、数据访问对象 (dao)、表示对象（如 struts action 实例）、基础设施对象（如 hibernate sessionfactories、jms 队列等）。通常，不会在容器中配置细粒度的域对象，因为创建和加载域对象通常是 dao 和业务逻辑的责任。但是，可以使用 spring 与 aspectj 的集成来配置在 ioc 容器控制之外创建的对象。\n\n以下示例显示了基于 xml 的配置元数据的基本结构：\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n    xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n    xsi:schemalocation="http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd">\n\n    \x3c!--id 属性用于唯一标识单个 bean 定义--\x3e\n    \x3c!--class 属性用于指明 bean 类型的完全限定名--\x3e\n    <bean id="..." class="...">\n        \x3c!-- 这里配置 bean 的属性 --\x3e\n    </bean>\n\n    <bean id="..." class="...">\n        \x3c!-- 这里配置 bean 的属性 --\x3e\n    </bean>\n\n    \x3c!-- 更多的 bean 定义 --\x3e\n\n</beans>\n\n\n\n# 实例化容器\n\n可以通过为 applicationcontext 的构造函数指定外部资源路径，来加载配置元数据。\n\napplicationcontext context = new classpathxmlapplicationcontext("services.xml", "daos.xml");\n\n\n以下示例显示了服务层对象 (services.xml) 配置文件：\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n    xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n    xsi:schemalocation="http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd">\n\n    \x3c!-- services --\x3e\n\n    <bean id="petstore" class="org.springframework.samples.jpetstore.services.petstoreserviceimpl">\n        <property name="accountdao" ref="accountdao"/>\n        <property name="itemdao" ref="itemdao"/>\n        \x3c!-- additional collaborators and configuration for this bean go here --\x3e\n    </bean>\n\n    \x3c!-- more bean definitions for services go here --\x3e\n\n</beans>\n\n\n以下示例显示了数据访问对象 (daos.xml) 配置文件：\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n    xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n    xsi:schemalocation="http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd">\n\n    <bean id="accountdao"\n        class="org.springframework.samples.jpetstore.dao.jpa.jpaaccountdao">\n        \x3c!-- additional collaborators and configuration for this bean go here --\x3e\n    </bean>\n\n    <bean id="itemdao" class="org.springframework.samples.jpetstore.dao.jpa.jpaitemdao">\n        \x3c!-- additional collaborators and configuration for this bean go here --\x3e\n    </bean>\n\n    \x3c!-- more bean definitions for data access objects go here --\x3e\n\n</beans>\n\n\n上面的示例中，服务层由 petstoreserviceimpl 类和类型为 jpaaccountdao 和 jpaitemdao 的两个数据访问对象（基于 jpa 对象关系映射标准）组成。 property name 元素指的是 javabean 属性的名称，ref 元素指的是另一个 bean 定义的名称。 id 和 ref 元素之间的这种联系表达了协作对象之间的依赖关系。\n\nspring 支持通过多个 xml 文件来定义 bean，每个单独的 xml 配置文件都代表架构中的一个逻辑层或模块。可以使用 applicationcontext 构造函数从所有这些 xml 片段加载 bean 定义。或者，使用 <import/> 元素从另一个或多个文件加载 bean 定义。如下所示：\n\n<beans>\n    <import resource="services.xml"/>\n    <import resource="resources/messagesource.xml"/>\n    <import resource="/resources/themesource.xml"/>\n\n    <bean id="bean1" class="..."/>\n    <bean id="bean2" class="..."/>\n</beans>\n\n\n在上面的示例中，外部 bean 定义从三个文件加载：services.xml、messagesource.xml 和 themesource.xml。services.xml 文件必须和当前 xml 文件位于同一目录或类路径位置；而 messagesource.xml 和 themesource.xml 必须位于当前文件所在目录的子目录 resources 下。/resources 的 / 会被忽略。但是，鉴于这些路径是相对的，最好不要使用 /。根据 spring schema，被导入文件的内容，包括顶级 <beans/> 元素，必须是有效的 xml bean 定义。\n\n> 注意：\n> \n> 可以，但不推荐使用相对 “../” 路径来引用父目录中的文件。这样做会创建对当前应用程序之外的文件的依赖。特别是，不建议将此引用用于 classpath：url（例如， classpath:../services.xml），其中运行时解析过程会选择“最近的”类路径根，然后查看其父目录。类路径配置更改可能会导致选择不同的、不正确的目录。\n> \n> 可以使用完全限定的资源位置而不是相对路径：例如，file:c:/config/services.xml 或 classpath:/config/services.xml。建议为此类绝对路径保留一定的间接性  —  例如，通过 “${...}” 占位符来引用运行时指定 的 jvm 参数。\n\n命名空间本身提供了导入指令功能。 spring 提供的一系列 xml 命名空间中提供了除了普通 bean 定义之外的更多配置特性  —  例如，context 和 util 命名空间。\n\n\n# 使用容器\n\napplicationcontext 能够维护不同 bean 及其依赖项的注册表。通过使用方法 t getbean(string name, class t requiredtype)，可以检索并获取 bean 的实例。\n\napplicationcontext 允许读取 bean 定义并访问它们，如以下示例所示：\n\n// create and configure beans\napplicationcontext context = new classpathxmlapplicationcontext("services.xml", "daos.xml");\n\n// retrieve configured instance\npetstoreservice service = context.getbean("petstore", petstoreservice.class);\n\n// use configured instance\nlist<string> userlist = service.getusernamelist();\n\n\n最灵活的变体是 genericapplicationcontext 结合阅读器委托  —  例如，结合 xml 文件的 xmlbeandefinitionreader，如下例所示：\n\ngenericapplicationcontext context = new genericapplicationcontext();\nnew xmlbeandefinitionreader(context).loadbeandefinitions("services.xml", "daos.xml");\ncontext.refresh();\n\n\n可以在同一个 applicationcontext 上混合和匹配此类读取器委托，从不同的配置源读取 bean 定义。\n\n然后，可以使用 getbean 检索 bean 的实例。 applicationcontext 接口还有一些其他方法用于检索 bean，但理想情况下，应用程序代码不应该使用它们。实际上，应用程序代码根本不应该调用 getbean() 方法，因此根本不依赖 spring api。例如，spring 与 web 框架的集成为各种 web 框架组件（例如控制器和 jsf 管理的 bean）提供了依赖注入，让您可以通过元数据（例如自动装配注释）声明对特定 bean 的依赖。\n\n\n# ioc 依赖来源\n\n自定义 bean\n\n容器内建 bean 对象\n\n容器内建依赖\n\n\n# ioc 配置元数据\n\nioc 容器的配置有三种方式：\n\n * 基于 xml 配置\n * 基于 properties 配置\n * 基于注解配置\n * 基于 java 配置\n\n作为 spring 传统的配置方式，xml 配置方式一般为大家所熟知。\n\n如果厌倦了 xml 配置，spring 也提供了注解配置方式或 java 配置方式来简化配置。\n\n本文，将对 java 配置 ioc 容器做详细的介绍。\n\n\n# xml 配置\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n       xsi:schemalocation="http://www.springframework.org/schema/beans\n         http://www.springframework.org/schema/beans/spring-beans.xsd">\n  <import resource="resource1.xml" />\n  <bean id="bean1" class=""></bean>\n  <bean id="bean2" class=""></bean>\n  <bean name="bean2" class=""></bean>\n\n  <alias alias="bean3" name="bean2"/>\n  <import resource="resource2.xml" />\n</beans>\n\n\n标签说明：\n\n * <beans> 是 spring 配置文件的根节点。\n * <bean> 用来定义一个 javabean。id 属性是它的标识，在文件中必须唯一；class 属性是它关联的类。\n * <alias> 用来定义 bean 的别名。\n * <import> 用来导入其他配置文件的 bean 定义。这是为了加载多个配置文件，当然也可以把这些配置文件构造为一个数组（new string[] {“config1.xml”, config2.xml}）传给 applicationcontext 实现类进行加载多个配置文件，那一个更适合由用户决定；这两种方式都是通过调用 bean definition reader 读取 bean 定义，内部实现没有任何区别。<import> 标签可以放在 <beans> 下的任何位置，没有顺序关系。\n\n# 实例化容器\n\n实例化容器的过程： 定位资源（xml 配置文件） 读取配置信息(resource) 转化为 spring 可识别的数据形式（beandefinition）\n\napplicationcontext context =\n      new classpathxmlapplicationcontext(new string[] {"services.xml", "daos.xml"});\n\n\n组合 xml 配置文件 配置的 bean 功能各不相同，都放在一个 xml 文件中，不便管理。 java 设计模式讲究职责单一原则。配置其实也是如此，功能不同的 javabean 应该被组织在不同的 xml 文件中。然后使用 import 标签把它们统一导入。\n\n<import resource="classpath:spring/applicationcontext.xml"/>\n<import resource="/web-inf/spring/service.xml"/>\n\n\n# 使用容器\n\n使用容器的方式就是通过getbean获取 ioc 容器中的 javabean。 spring 也有其他方法去获得 javabean，但是 spring 并不推荐其他方式。\n\n// create and configure beans\napplicationcontext context =\nnew classpathxmlapplicationcontext(new string[] {"services.xml", "daos.xml"});\n// retrieve configured instance\npetstoreservice service = context.getbean("petstore", petstoreservice.class);\n// use configured instance\nlist<string> userlist = service.getusernamelist();\n\n\n\n# 注解配置\n\nspring2.5 引入了注解。 于是，一个问题产生了：使用注解方式注入 javabean 是不是一定完爆 xml 方式？ 未必。正所谓，仁者见仁智者见智。任何事物都有其优缺点，看你如何取舍。来看看注解的优缺点： 优点：大大减少了配置，并且可以使配置更加精细——类，方法，字段都可以用注解去标记。 缺点：使用注解，不可避免产生了侵入式编程，也产生了一些问题。\n\n * 你需要将注解加入你的源码并编译它；\n\n * 注解往往比较分散，不易管控。\n\n> 注：spring 中，先进行注解注入，然后才是 xml 注入，因此如果注入的目标相同，后者会覆盖前者。\n\n# 启动注解\n\nspring 默认是不启用注解的。如果想使用注解，需要先在 xml 中启动注解。 启动方式：在 xml 中加入一个标签，很简单吧。\n\n<context:annotation-config/>\n\n\n> 注：<context:annotation-config/> 只会检索定义它的上下文。什么意思呢？就是说，如果你 为 dispatcherservlet 指定了一个webapplicationcontext，那么它只在 controller 中查找@autowired注解，而不会检查其它的路径。\n\n# @required\n\n@required 注解只能用于修饰 bean 属性的 setter 方法。受影响的 bean 属性必须在配置时被填充在 xml 配置文件中，否则容器将抛出beaninitializationexception。\n\npublic class annotationrequired {\n    private string name;\n    private string sex;\n\n    public string getname() {\n        return name;\n    }\n\n    /**\n     * @required 注解用于bean属性的setter方法并且它指示，受影响的bean属性必须在配置时被填充在xml配置文件中，\n     *           否则容器将抛出beaninitializationexception。\n     */\n    @required\n    public void setname(string name) {\n        this.name = name;\n    }\n\n    public string getsex() {\n        return sex;\n    }\n\n    public void setsex(string sex) {\n        this.sex = sex;\n    }\n}\n\n\n# @autowired\n\n@autowired注解可用于修饰属性、setter 方法、构造方法。\n\n@autowired 注入过程\n\n * 元信息解析\n * 依赖查找\n * 依赖注入（字段、方法）\n\n> 注：@autowired注解也可用于修饰构造方法，但如果类中只有默认构造方法，则没有必要。如果有多个构造器，至少应该修饰一个，来告诉容器哪一个必须使用。\n\n可以使用 jsr330 的注解@inject来替代@autowired。\n\n范例\n\npublic class annotationautowired {\n    private static final logger log = loggerfactory.getlogger(annotationrequired.class);\n\n    @autowired\n    private apple fielda;\n\n    private banana fieldb;\n\n    private orange fieldc;\n\n    public apple getfielda() {\n        return fielda;\n    }\n\n    public void setfielda(apple fielda) {\n        this.fielda = fielda;\n    }\n\n    public banana getfieldb() {\n        return fieldb;\n    }\n\n    @autowired\n    public void setfieldb(banana fieldb) {\n        this.fieldb = fieldb;\n    }\n\n    public orange getfieldc() {\n        return fieldc;\n    }\n\n    public void setfieldc(orange fieldc) {\n        this.fieldc = fieldc;\n    }\n\n    public annotationautowired() {}\n\n    @autowired\n    public annotationautowired(orange fieldc) {\n        this.fieldc = fieldc;\n    }\n\n    public static void main(string[] args) throws exception {\n        abstractapplicationcontext ctx =\n                        new classpathxmlapplicationcontext("spring/spring-annotation.xml");\n\n        annotationautowired annotationautowired =\n                        (annotationautowired) ctx.getbean("annotationautowired");\n        log.debug("fielda: {}, fieldb:{}, fieldc:{}", annotationautowired.getfielda().getname(),\n                        annotationautowired.getfieldb().getname(),\n                        annotationautowired.getfieldc().getname());\n        ctx.close();\n    }\n}\n\n\nxml 中的配置\n\n\x3c!-- 测试@autowired --\x3e\n<bean id="apple" class="org.zp.notes.spring.beans.annotation.sample.apple"/>\n<bean id="potato" class="org.zp.notes.spring.beans.annotation.sample.banana"/>\n<bean id="tomato" class="org.zp.notes.spring.beans.annotation.sample.orange"/>\n<bean id="annotationautowired" class="org.zp.notes.spring.beans.annotation.sample.annotationautowired"/>\n\n\n# @qualifier\n\n在@autowired注解中，提到了如果发现有多个候选的 bean 都符合修饰类型，spring 就会抓瞎了。\n\n那么，如何解决这个问题。\n\n可以通过@qualifier指定 bean 名称来锁定真正需要的那个 bean。\n\n范例\n\npublic class annotationqualifier {\n    private static final logger log = loggerfactory.getlogger(annotationqualifier.class);\n\n    @autowired\n    @qualifier("dog") /** 去除这行，会报异常 */\n    animal dog;\n\n    animal cat;\n\n    public animal getdog() {\n        return dog;\n    }\n\n    public void setdog(animal dog) {\n        this.dog = dog;\n    }\n\n    public animal getcat() {\n        return cat;\n    }\n\n    @autowired\n    public void setcat(@qualifier("cat") animal cat) {\n        this.cat = cat;\n    }\n\n    public static void main(string[] args) throws exception {\n        abstractapplicationcontext ctx =\n                new classpathxmlapplicationcontext("spring/spring-annotation.xml");\n\n        annotationqualifier annotationqualifier =\n                (annotationqualifier) ctx.getbean("annotationqualifier");\n\n        log.debug("dog name: {}", annotationqualifier.getdog().getname());\n        log.debug("cat name: {}", annotationqualifier.getcat().getname());\n        ctx.close();\n    }\n}\n\nabstract class animal {\n    public string getname() {\n        return null;\n    }\n}\n\nclass dog extends animal {\n    public string getname() {\n        return "狗";\n    }\n}\n\nclass cat extends animal {\n    public string getname() {\n        return "猫";\n    }\n}\n\n\nxml 中的配置\n\n\x3c!-- 测试@qualifier --\x3e\n<bean id="dog" class="org.zp.notes.spring.beans.annotation.sample.dog"/>\n<bean id="cat" class="org.zp.notes.spring.beans.annotation.sample.cat"/>\n<bean id="annotationqualifier" class="org.zp.notes.spring.beans.annotation.sample.annotationqualifier"/>\n\n\n# @resource\n\nspring 支持 jsp250 规定的注解@resource。这个注解根据指定的名称来注入 bean。\n\n如果没有为@resource指定名称，它会像@autowired一样按照类型去寻找匹配。\n\n在 spring 中，由commonannotationbeanpostprocessor来处理@resource注解。\n\n范例\n\npublic class annotationresource {\n    private static final logger log = loggerfactory.getlogger(annotationresource.class);\n\n    @resource(name = "flower")\n    plant flower;\n\n    @resource(name = "tree")\n    plant tree;\n\n    public plant getflower() {\n        return flower;\n    }\n\n    public void setflower(plant flower) {\n        this.flower = flower;\n    }\n\n    public plant gettree() {\n        return tree;\n    }\n\n    public void settree(plant tree) {\n        this.tree = tree;\n    }\n\n    public static void main(string[] args) throws exception {\n        abstractapplicationcontext ctx =\n                        new classpathxmlapplicationcontext("spring/spring-annotation.xml");\n\n        annotationresource annotationresource =\n                        (annotationresource) ctx.getbean("annotationresource");\n        log.debug("type: {}, name: {}", annotationresource.getflower().getclass(), annotationresource.getflower().getname());\n        log.debug("type: {}, name: {}", annotationresource.gettree().getclass(), annotationresource.gettree().getname());\n        ctx.close();\n    }\n}\n\n\nxml 的配置\n\n\x3c!-- 测试@resource --\x3e\n<bean id="flower" class="org.zp.notes.spring.beans.annotation.sample.flower"/>\n<bean id="tree" class="org.zp.notes.spring.beans.annotation.sample.tree"/>\n<bean id="annotationresource" class="org.zp.notes.spring.beans.annotation.sample.annotationresource"/>\n\n\n# @postconstruct 和 @predestroy\n\n@postconstruct 和 @predestroy 是 jsr 250 规定的用于生命周期的注解。\n\n从其名号就可以看出，一个是在构造之后调用的方法，一个是销毁之前调用的方法。\n\npublic class annotationpostconstructandpredestroy {\n    private static final logger log = loggerfactory.getlogger(annotationpostconstructandpredestroy.class);\n\n    @postconstruct\n    public void init() {\n        log.debug("call @postconstruct method");\n    }\n\n    @predestroy\n    public void destroy() {\n        log.debug("call @predestroy method");\n    }\n}\n\n\n# @inject\n\n从 spring3.0 开始，spring 支持 jsr 330 标准注解（依赖注入）。\n\n注：如果要使用 jsr 330 注解，需要使用外部 jar 包。\n\n若你使用 maven 管理 jar 包，只需要添加依赖到 pom.xml 即可：\n\n<dependency>\n  <groupid>javax.inject</groupid>\n  <artifactid>javax.inject</artifactid>\n  <version>1</version>\n</dependency>\n\n\n@inject 和 @autowired 一样，可以修饰属性、setter 方法、构造方法。\n\n范例\n\npublic class annotationinject {\n    private static final logger log = loggerfactory.getlogger(annotationinject.class);\n    @inject\n    apple fielda;\n\n    banana fieldb;\n\n    orange fieldc;\n\n    public apple getfielda() {\n        return fielda;\n    }\n\n    public void setfielda(apple fielda) {\n        this.fielda = fielda;\n    }\n\n    public banana getfieldb() {\n        return fieldb;\n    }\n\n    @inject\n    public void setfieldb(banana fieldb) {\n        this.fieldb = fieldb;\n    }\n\n    public orange getfieldc() {\n        return fieldc;\n    }\n\n    public annotationinject() {}\n\n    @inject\n    public annotationinject(orange fieldc) {\n        this.fieldc = fieldc;\n    }\n\n    public static void main(string[] args) throws exception {\n        abstractapplicationcontext ctx =\n                        new classpathxmlapplicationcontext("spring/spring-annotation.xml");\n        annotationinject annotationinject = (annotationinject) ctx.getbean("annotationinject");\n\n        log.debug("type: {}, name: {}", annotationinject.getfielda().getclass(),\n                        annotationinject.getfielda().getname());\n\n        log.debug("type: {}, name: {}", annotationinject.getfieldb().getclass(),\n                        annotationinject.getfieldb().getname());\n\n        log.debug("type: {}, name: {}", annotationinject.getfieldc().getclass(),\n                        annotationinject.getfieldc().getname());\n\n        ctx.close();\n    }\n}\n\n\n\n# java 配置\n\n基于 java 配置 spring ioc 容器，实际上是spring 允许用户定义一个类，在这个类中去管理 ioc 容器的配置。\n\n为了让 spring 识别这个定义类为一个 spring 配置类，需要用到两个注解：@configuration和@bean。\n\n如果你熟悉 spring 的 xml 配置方式，你可以将@configuration等价于<beans>标签；将@bean等价于<bean>标签。\n\n# @bean\n\n@bean 的修饰目标只能是方法或注解。\n\n@bean 只能定义在 @configuration 或 @component 注解修饰的类中。\n\n# 声明一个 bean\n\n此外，@configuration 类允许在同一个类中通过@bean 定义内部 bean 依赖。\n\n声明一个 bean，只需要在 bean 属性的 set 方法上标注@bean 即可。\n\n@configuration\npublic class annotationconfiguration {\n    private static final logger log = loggerfactory.getlogger(javacomponentscan.class);\n\n    @bean\n    public job getpolice() {\n        return new police();\n    }\n\n    public static void main(string[] args) {\n        annotationconfigapplicationcontext ctx = new annotationconfigapplicationcontext(annotationconfiguration.class);\n        ctx.scan("org.zp.notes.spring.beans");\n        ctx.refresh();\n        job job = (job) ctx.getbean("police");\n        log.debug("job: {}, work: {}", job.getclass(), job.work());\n    }\n}\n\npublic interface job {\n    string work();\n}\n\n@component("police")\npublic class police implements job {\n    @override\n    public string work() {\n        return "抓罪犯";\n    }\n}\n\n\n这等价于配置\n\n<beans>\n\t<bean id="police" class="org.zp.notes.spring.ioc.sample.job.police"/>\n</beans>\n\n\n@bean 注解用来表明一个方法实例化、配置合初始化一个被 spring ioc 容器管理的新对象。\n\n如果你熟悉 spring 的 xml 配置，你可以将@bean 视为等价于<beans>标签。\n\n@bean 注解可以用于任何的 spring @component bean，然而，通常被用于@configuration bean。\n\n# @configuration\n\n@configuration 是一个类级别的注解，用来标记被修饰类的对象是一个beandefinition。\n\n@configuration 声明 bean 是通过被 @bean 修饰的公共方法。此外，@configuration 允许在同一个类中通过 @bean 定义内部 bean 依赖。\n\n@configuration\npublic class appconfig {\n    @bean\n    public myservice myservice() {\n        return new myserviceimpl();\n    }\n}\n\n\n这等价于配置\n\n<beans>\n\t<bean id="myservice" class="com.acme.services.myserviceimpl"/>\n</beans>\n\n\n用 annotationconfigapplicationcontext 实例化 ioc 容器。\n\n\n# 依赖解决过程\n\n容器执行 bean 依赖解析如下：\n\n * applicationcontext 使用配置元数据创建和初始化 bean。配置元数据可以由 xml、java 代码或注解指定。\n * 对于每个 bean，其依赖关系以属性、构造函数参数或静态工厂方法的参数的形式表示。这些依赖项在实际创建 bean 时提供给 bean。\n * 每个属性或构造函数参数都是要设置的值的实际定义，或者是对容器中另一个 bean 的引用。\n * 作为值的每个属性或构造函数参数都从其指定格式转换为该属性或构造函数参数的实际类型。默认情况下，spring 可以将以字符串格式提供的值转换为所有内置类型，例如 int、long、string、boolean 等。\n\nspring 容器在创建容器时验证每个 bean 的配置。但是，在实际创建 bean 之前，不会设置 bean 属性本身。在创建容器时会创建 singleton 型的实例并设置为默认的 bean。否则，只有在请求时才会创建 bean。\n\n需注意：构造器注入，可能会导致无法解决循环依赖问题。\n\n例如：a 类通过构造器注入需要 b 类的实例，b 类通过构造器注入需要 a 类的实例。spring ioc 容器会在运行时检测到此循环引用，并抛出 beancurrentlyincreationexception。\n\n一种解决方案是使用 setter 方法注入替代构造器注入。\n\n另一种解决方案是：bean a 和 bean b 之间的循环依赖关系，强制其中一个 bean 在完全初始化之前注入另一个 bean（典型的先有鸡还是先有蛋的场景）。\n\nspring 会在容器加载时检测配置问题，例如引用不存在的 bean 或循环依赖。在实际创建 bean 时，spring 会尽可能晚地设置属性并解析依赖关系。这意味着，如果在创建该对象或其依赖项之一时出现问题，则正确加载的 spring 容器稍后可以在您请求对象时生成异常  —  例如，bean 由于丢失或无效而引发异常。某些配置问题的这种潜在的延迟可见性是默认情况下 applicationcontext 实现预实例化单例 bean 的原因。以在实际需要之前创建这些 bean 的一些前期时间和内存为代价，您会在创建 applicationcontext 时发现配置问题，而不是稍后。您仍然可以覆盖此默认行为，以便单例 bean 延迟初始化，而不是急切地预先实例化。\n\n\n# 最佳实践\n\n\n# singleton 的 bean 如何注入 prototype 的 bean\n\nspring 创建的 bean 默认是单例的，但当 bean 遇到继承的时候，可能会忽略这一点。\n\n假设有一个 sayservice 抽象类，其中维护了一个类型是 arraylist 的字段 data，用于保存方法处理的中间数据。每次调用 say 方法都会往 data 加入新数据，可以认为 sayservice 是有状态，如果 sayservice 是单例的话必然会 oom。\n\n/**\n * sayservice 是有状态，如果 sayservice 是单例的话必然会 oom\n */\n@slf4j\npublic abstract class sayservice {\n\n   list<string> data = new arraylist<>();\n\n   public void say() {\n      data.add(intstream.rangeclosed(1, 1000000)\n         .maptoobj(__ -> "a")\n         .collect(collectors.joining("")) + uuid.randomuuid().tostring());\n      log.info("i\'m {} size:{}", this, data.size());\n   }\n\n}\n\n\n但实际开发的时候，开发同学没有过多思考就把 sayhello 和 saybye 类加上了 @service 注解，让它们成为了 bean，也没有考虑到父类是有状态的。\n\n@service\n@slf4j\npublic class saybye extends sayservice {\n\n   @override\n   public void say() {\n      super.say();\n      log.info("bye");\n   }\n\n}\n\n@service\n@slf4j\npublic class sayhello extends sayservice {\n\n\t@override\n\tpublic void say() {\n\t\tsuper.say();\n\t\tlog.info("hello");\n\t}\n\n}\n\n\n在为类标记上 @service 注解把类型交由容器管理前，首先评估一下类是否有状态，然后为 bean 设置合适的 scope。\n\n调用代码：\n\n@slf4j\n@restcontroller\n@requestmapping("beansingletonandorder")\npublic class beansingletonandordercontroller {\n\n   @autowired\n   list<sayservice> sayservicelist;\n   @autowired\n   private applicationcontext applicationcontext;\n\n   @getmapping("test")\n   public void test() {\n      log.info("====================");\n      sayservicelist.foreach(sayservice::say);\n   }\n\n}\n\n\n可能有人认为，为 sayhello 和 saybye 两个类都标记了 @scope 注解，设置了 prototype 的生命周期就可以解决上面的问题。\n\n@scope(value = configurablebeanfactory.scope_prototype)\n\n\n但实际上还是有问题。因为@restcontroller 注解 =@controller 注解 +@responsebody 注解，又因为 @controller 标记了 @component 元注解，所以 @restcontroller 注解其实也是一个 spring bean。\n\nbean 默认是单例的，所以单例的 controller 注入的 service 也是一次性创建的，即使 service 本身标识了 prototype 的范围也没用。\n\n修复方式是，让 service 以代理方式注入。这样虽然 controller 本身是单例的，但每次都能从代理获取 service。这样一来，prototype 范围的配置才能真正生效。\n\n@scope(value = configurablebeanfactory.scope_prototype, proxymode = scopedprox)\n\n\n\n# 参考资料\n\n * spring 官方文档之 core technologies\n * 《小马哥讲 spring 核心编程思想》',charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Spring 依赖注入",frontmatter:{title:"Spring 依赖注入",date:"2020-08-30T16:06:10.000Z",order:4,categories:["Java","框架","Spring","Spring核心"],tags:["Java","框架","Spring","IOC","依赖注入"],permalink:"/pages/f61a1c/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/01.Spring%E6%A0%B8%E5%BF%83/04.Spring%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5.html",relativePath:"01.Java/13.框架/01.Spring/01.Spring核心/04.Spring依赖注入.md",key:"v-5ff32bba",path:"/pages/f61a1c/",headers:[{level:2,title:"IoC 依赖注入 API",slug:"ioc-依赖注入-api",normalizedTitle:"ioc 依赖注入 api",charIndex:823},{level:2,title:"依赖注入模式",slug:"依赖注入模式",normalizedTitle:"依赖注入模式",charIndex:934},{level:3,title:"手动注入模式",slug:"手动注入模式",normalizedTitle:"手动注入模式",charIndex:952},{level:3,title:"自动注入模式",slug:"自动注入模式",normalizedTitle:"自动注入模式",charIndex:959},{level:4,title:"自动装配策略",slug:"自动装配策略",normalizedTitle:"自动装配策略",charIndex:1259},{level:4,title:"@Autowired 注入过程",slug:"autowired-注入过程",normalizedTitle:"@autowired 注入过程",charIndex:1658},{level:4,title:"自动装配的限制和不足",slug:"自动装配的限制和不足",normalizedTitle:"自动装配的限制和不足",charIndex:1710},{level:2,title:"依赖注入方式",slug:"依赖注入方式",normalizedTitle:"依赖注入方式",charIndex:2101},{level:3,title:"构造器注入",slug:"构造器注入",normalizedTitle:"构造器注入",charIndex:2196},{level:3,title:"Setter 方法注入",slug:"setter-方法注入",normalizedTitle:"setter 方法注入",charIndex:2143},{level:3,title:"字段注入",slug:"字段注入",normalizedTitle:"字段注入",charIndex:2257},{level:3,title:"方法注入",slug:"方法注入",normalizedTitle:"方法注入",charIndex:2150},{level:3,title:"接口回调注入",slug:"接口回调注入",normalizedTitle:"接口回调注入",charIndex:2354},{level:3,title:"依赖注入选型",slug:"依赖注入选型",normalizedTitle:"依赖注入选型",charIndex:6603},{level:2,title:"限定注入和延迟注入",slug:"限定注入和延迟注入",normalizedTitle:"限定注入和延迟注入",charIndex:6671},{level:3,title:"限定注入",slug:"限定注入",normalizedTitle:"限定注入",charIndex:6671},{level:3,title:"延迟注入",slug:"延迟注入",normalizedTitle:"延迟注入",charIndex:925},{level:2,title:"依赖注入数据类型",slug:"依赖注入数据类型",normalizedTitle:"依赖注入数据类型",charIndex:6868},{level:3,title:"基础类型",slug:"基础类型",normalizedTitle:"基础类型",charIndex:6881},{level:3,title:"集合类型",slug:"集合类型",normalizedTitle:"集合类型",charIndex:7123},{level:2,title:"依赖处理过程",slug:"依赖处理过程",normalizedTitle:"依赖处理过程",charIndex:7217},{level:2,title:"依赖查找 VS. 依赖注入",slug:"依赖查找-vs-依赖注入",normalizedTitle:"依赖查找 vs. 依赖注入",charIndex:7812},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:7970}],headersStr:"IoC 依赖注入 API 依赖注入模式 手动注入模式 自动注入模式 自动装配策略 @Autowired 注入过程 自动装配的限制和不足 依赖注入方式 构造器注入 Setter 方法注入 字段注入 方法注入 接口回调注入 依赖注入选型 限定注入和延迟注入 限定注入 延迟注入 依赖注入数据类型 基础类型 集合类型 依赖处理过程 依赖查找 VS. 依赖注入 参考资料",content:'# Spring 依赖注入\n\nDI，是 Dependency Injection 的缩写，即依赖注入。依赖注入是 IoC 的最常见形式。依赖注入是手动或自动绑定的方式，无需依赖特定的容器或 API。\n\n依赖注入 (Dependency Injection，简称 DI) 是一个过程，其中对象仅通过构造函数参数、工厂方法的参数或对象实例在构造或从工厂方法返回。然后容器在创建 bean 时注入这些依赖项。这个过程基本上是 bean 本身的逆过程（因此得名，控制反转），它通过使用类的直接构造或服务定位器模式自行控制其依赖项的实例化或位置。\n\n使用 DI，代码更干净，当对象具有依赖关系时，解耦更有效。对象不查找其依赖项，也不知道依赖项的位置或类别。结果，您的类变得更容易测试，特别是当依赖关系在接口或抽象基类上时，它们允许在单元测试中使用存根或模拟实现。\n\n容器全权负责组件的装配，它会把符合依赖关系的对象通过 JavaBean 属性或者构造函数传递给需要的对象。\n\nDI 是组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。\n\n理解 DI 的关键是：“谁依赖谁，为什么需要依赖，谁注入谁，注入了什么”，那我们来深入分析一下：\n\n * **谁依赖于谁：**当然是应用程序依赖于 IoC 容器；\n * **为什么需要依赖：**应用程序需要 IoC 容器来提供对象需要的外部资源；\n * **谁注入谁：**很明显是 IoC 容器注入应用程序某个对象，应用程序依赖的对象；\n * 注入了什么：就是注入某个对象所需要的外部资源（包括对象、资源、常量数据）。\n\n\n# IoC 依赖注入 API\n\n * 根据 Bean 名称注入\n * 根据 Bean 类型注入\n * 注入容器内建 Bean 对象\n * 注入非 Bean 对象\n * 注入类型\n   * 实时注入\n   * 延迟注入\n\n\n# 依赖注入模式\n\n依赖注入模式可以分为手动注入模式和自动注入模式。\n\n\n# 手动注入模式\n\n手动注入模式：配置或者编程的方式，提前安排注入规则\n\n * XML 资源配置元信息\n * Java 注解配置元信息\n * API 配置元信息\n\n\n# 自动注入模式\n\n自动注入模式即自动装配。自动装配（Autowiring）是指 Spring 容器可以自动装配 Bean 之间的关系。Spring 可以通过检查 ApplicationContext 的内容，自动解析合作者（其他 Bean）。\n\n * 自动装配可以显著减少属性或构造函数参数的配置。\n * 随着对象的发展，自动装配可以更新配置。\n\n> 注：由于自动装配存在一些限制和不足，官方不推荐使用。\n\n# 自动装配策略\n\n当使用基于 XML 的配置元数据时，可以使用 <bean/> 元素的 autowire 属性为 Bean 指定自动装配模式。自动装配模式有以下类型：\n\n模式            说明\nno            默认值，未激活 Autowiring，需要手动指定依赖注入对象。\nbyName        根据被注入属性的名称作为 Bean 名称进行依赖查找，并将对象设置到该属性。\nbyType        根据被注入属性的类型作为依赖类型进行查找，并将对象设置到该属性。\nconstructor   特殊 byType 类型，用于构造器参数。\n\norg.springframework.beans.factory.config.AutowireCapableBeanFactory 是 BeanFactory 的子接口，它是 Spring 中用于实现自动装配的容器。\n\n# @Autowired 注入过程\n\n * 元信息解析\n * 依赖查找\n * 依赖注入（字段、方法）\n\n# 自动装配的限制和不足\n\n自动装配有以下限制和不足：\n\n * 属性和构造函数参数设置中的显式依赖项会覆盖自动装配。您不能自动装配简单属性，例如基础数据类型、字符串和类（以及此类简单属性的数组）。\n * 自动装配不如显式装配精准。Spring 会尽量避免猜测可能存在歧义的结果。\n * Spring 容器生成文档的工具可能无法解析自动装配信息。\n * 如果同一类型存在多个 Bean 时，自动装配时会存在歧义。容器内的多个 Bean 定义可能与要自动装配的 Setter 方法或构造函数参数指定的类型匹配。对于数组、集合或 Map 实例，这不一定是问题。但是，对于期望单值的依赖项，如果没有唯一的 Bean 定义可用，则会引发异常。\n\n> 自动装配的限制和不足，详情可以参考官方文档：Limitations and Disadvantages of Autowiring 小节\n\n\n# 依赖注入方式\n\n依赖注入有如下方式：\n\n依赖注入方式        配置元数据举例\nSetter 方法注入   <proeprty name="user" ref="userBean"/>\n构造器注入         <constructor-arg name="user" ref="userBean" />\n字段注入          @Autowired User user;\n方法注入          @Autowired public void user(User user) { ... }\n接口回调注入        class MyBean implements BeanFactoryAware { ... }\n\n\n# 构造器注入\n\n * 手动模式\n   * xml 配置元信息\n   * 注解配置元信息\n   * Java 配置元信息\n * 自动模式\n   * constructor\n\n构造器注入是通过容器调用具有多个参数的构造函数来完成的，每个参数代表一个依赖项。调用带有特定参数的静态工厂方法来构造 bean 几乎是等价的，并且本次讨论对构造函数和静态工厂方法的参数进行了类似的处理。\n\n下面是一个构造器注入示例：\n\npublic class SimpleMovieLister {\n\n    // the SimpleMovieLister has a dependency on a MovieFinder\n    private final MovieFinder movieFinder;\n\n    // a constructor so that the Spring container can inject a MovieFinder\n    public SimpleMovieLister(MovieFinder movieFinder) {\n        this.movieFinder = movieFinder;\n    }\n\n    // business logic that actually uses the injected MovieFinder is omitted...\n}\n\n\n构造函数参数解析匹配通过使用参数的类型进行。如果 bean 定义的构造函数参数中不存在潜在的歧义，则在 bean 定义中定义构造函数参数的顺序是在实例化 bean 时将这些参数提供给适当构造函数的顺序。\n\npackage x.y;\n\npublic class ThingOne {\n\n    public ThingOne(ThingTwo thingTwo, ThingThree thingThree) {\n        // ...\n    }\n}\n\n\n假设 ThingTwo 和 ThingThree 类没有继承关系，则不存在潜在的歧义。因此，以下配置工作正常，您无需在 <constructor-arg/> 元素中显式指定构造函数参数索引或类型。\n\n<beans>\n    <bean id="beanOne" class="x.y.ThingOne">\n        <constructor-arg ref="beanTwo"/>\n        <constructor-arg ref="beanThree"/>\n    </bean>\n\n    <bean id="beanTwo" class="x.y.ThingTwo"/>\n\n    <bean id="beanThree" class="x.y.ThingThree"/>\n</beans>\n\n\n当引用另一个 bean 时，类型是已知的，并且可以发生匹配（就像前面的示例一样）。当使用简单类型时，例如 <value>true</value> ，Spring 无法确定 value 的类型，因此无法在没有帮助的情况下按类型匹配。考虑以下类：\n\npackage examples;\n\npublic class ExampleBean {\n\n    // Number of years to calculate the Ultimate Answer\n    private final int years;\n\n    // The Answer to Life, the Universe, and Everything\n    private final String ultimateAnswer;\n\n    public ExampleBean(int years, String ultimateAnswer) {\n        this.years = years;\n        this.ultimateAnswer = ultimateAnswer;\n    }\n}\n\n\n构造函数参数类型匹配\n\n在上述场景中，如果您使用 type 属性显式指定构造函数参数的类型，则容器可以使用简单类型的类型匹配，如以下示例所示：\n\n<bean id="exampleBean" class="examples.ExampleBean">\n    <constructor-arg type="int" value="7500000"/>\n    <constructor-arg type="java.lang.String" value="42"/>\n</bean>\n\n\n构造函数参数索引匹配\n\n可以使用 index 属性显式指定构造函数参数的索引，如以下示例所示\n\n<bean id="exampleBean" class="examples.ExampleBean">\n    <constructor-arg index="0" value="7500000"/>\n    <constructor-arg index="1" value="42"/>\n</bean>\n\n\n构造函数参数名称匹配\n\n<bean id="exampleBean" class="examples.ExampleBean">\n    <constructor-arg name="years" value="7500000"/>\n    <constructor-arg name="ultimateAnswer" value="42"/>\n</bean>\n\n\n可以使用 @ConstructorProperties 显式命名构造函数参数。\n\npackage examples;\n\npublic class ExampleBean {\n\n    // Fields omitted\n\n    @ConstructorProperties({"years", "ultimateAnswer"})\n    public ExampleBean(int years, String ultimateAnswer) {\n        this.years = years;\n        this.ultimateAnswer = ultimateAnswer;\n    }\n}\n\n\n\n# Setter 方法注入\n\n * 手动模式\n   * xml 配置元信息\n   * 注解配置元信息\n   * Java 配置元信息\n * 自动模式\n   * byName\n   * byType\n\nSetter 方法注入是通过容器在调用无参数构造函数或无参数静态工厂方法来实例化 bean 后调用 bean 上的 setter 方法来完成的。\n\n以下示例显示了一个只能通过使用纯 setter 注入进行依赖注入的类。\n\npublic class SimpleMovieLister {\n\n    // the SimpleMovieLister has a dependency on the MovieFinder\n    private MovieFinder movieFinder;\n\n    // a setter method so that the Spring container can inject a MovieFinder\n    public void setMovieFinder(MovieFinder movieFinder) {\n        this.movieFinder = movieFinder;\n    }\n\n    // business logic that actually uses the injected MovieFinder is omitted...\n}\n\n\n在 Spring 中，可以混合使用构造器注入和 setter 方法注入。建议将构造器注入用于强制依赖项；并将 setter 方法注入或配置方法用于可选依赖项。需要注意的是，在 setter 方法上使用 @Required 注解可用于使属性成为必需的依赖项；然而，更建议使用构造器注入来完成这项工作。\n\n\n# 字段注入\n\n手动模式（Java 注解配置元信息）\n\n * @Autowired\n * @Resource\n * @Inject（可选）\n\n\n# 方法注入\n\n手动模式（Java 注解配置元信息）\n\n * @Autowired\n * @Resource\n * @Inject（可选）\n * @Bean\n\n\n# 接口回调注入\n\nAware 系列接口回调\n\n內建接口                             说明\nBeanFactoryAware                 获取 IoC 容器- BeanFactory\nApplicationContextAware          获取 Spring 应用上下文- ApplicationContext 对象\nEnvironmentAware                 获取 Environment 对象\nResourceLoaderAware              获取资源加载器对象- ResourceLoader\nBeanClassLoaderAware             获取加载当前 Bean Class 的 ClassLoader\nBeanNameAware                    获取当前 Bean 的名称\nMessageSourceAware               获取 MessageSource 对象，用于 Spring 国际化\nApplicationEventPublisherAware   获取 ApplicationEventPublishAware 对象，用于 Spring 事件\nEmbeddedValueResolverAware       获取 StringValueResolver 对象，用于占位符处理\n\n\n# 依赖注入选型\n\n * 低依赖：构造器注入\n * 多依赖：Setter 方法注入\n * 便利性：字段注入\n * 声明类：方法注入\n\n\n# 限定注入和延迟注入\n\n\n# 限定注入\n\n * 使用 @Qualifier 注解限定\n   * 通过 Bean 名称限定\n   * 通过分组限定\n * 通过 @Qualifier 注解扩展限定\n   * 自定义注解：如 Spring Cloud 的 @LoadBalanced\n\n\n# 延迟注入\n\n * 使用 ObjectFactory\n * 使用 ObjectProvider（推荐）\n\n\n# 依赖注入数据类型\n\n\n# 基础类型\n\n * 基础数据类型：boolean、byte、char、short、int、float、long、double\n * 标量类型：Number、Character、Boolean、Enum、Locale、Charset、Currency、Properties、UUID\n * 常规类型：Object、String、TimeZone、Calendar、Optional 等\n * Spring 类型：Resource、InputSource、Formatter 等。\n\n\n# 集合类型\n\n数组类型：基础数据类型、标量类型、常规类型、String 类型的数组\n\n集合类型：\n\n * Collection：List、Set\n * Map：Properties\n\n\n# 依赖处理过程\n\n入口：DefaultListableBeanFactory#resolveDependency\n\n依赖描述符：DependencyDescriptor\n\n自定义绑定候选对象处理器：AutowireCandidateResolver\n\n@Autowired、@Value、@javax.inject.Inject 处理器：AutowiredAnnotationBeanPostProcessor\n\n通用注解处理器：CommonAnnotationBeanPostProcessor\n\n * 注入注解\n   * javax.xml.ws.WebServiceRef\n   * javax.ejb.EJB\n   * javax.annotation.Resources\n * 生命周期注解\n   * javax.annotation.PostConstruct\n   * javax.annotation.PreDestroy\n\n自定义依赖注入注解：\n\n * 生命周期处理\n   * InstantiationAwareBeanPostProcessor\n   * MergedBeanDefinitionPostProcessor\n * 元数据\n   * InjectionMetadata\n   * InjectionMetadata.InjectedElement\n\n\n# 依赖查找 VS. 依赖注入\n\n类型     依赖处理   实现复杂度   代码侵入性    API 依赖性     可读性\n依赖查找   主动     相对繁琐    侵入业务逻辑   依赖容器 API    良好\n依赖注入   被动     相对便利    低侵入性     不依赖容器 API   一般\n\n\n# 参考资料\n\n * Spring 官方文档之 Core Technologies\n * 《小马哥讲 Spring 核心编程思想》',normalizedContent:'# spring 依赖注入\n\ndi，是 dependency injection 的缩写，即依赖注入。依赖注入是 ioc 的最常见形式。依赖注入是手动或自动绑定的方式，无需依赖特定的容器或 api。\n\n依赖注入 (dependency injection，简称 di) 是一个过程，其中对象仅通过构造函数参数、工厂方法的参数或对象实例在构造或从工厂方法返回。然后容器在创建 bean 时注入这些依赖项。这个过程基本上是 bean 本身的逆过程（因此得名，控制反转），它通过使用类的直接构造或服务定位器模式自行控制其依赖项的实例化或位置。\n\n使用 di，代码更干净，当对象具有依赖关系时，解耦更有效。对象不查找其依赖项，也不知道依赖项的位置或类别。结果，您的类变得更容易测试，特别是当依赖关系在接口或抽象基类上时，它们允许在单元测试中使用存根或模拟实现。\n\n容器全权负责组件的装配，它会把符合依赖关系的对象通过 javabean 属性或者构造函数传递给需要的对象。\n\ndi 是组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。\n\n理解 di 的关键是：“谁依赖谁，为什么需要依赖，谁注入谁，注入了什么”，那我们来深入分析一下：\n\n * **谁依赖于谁：**当然是应用程序依赖于 ioc 容器；\n * **为什么需要依赖：**应用程序需要 ioc 容器来提供对象需要的外部资源；\n * **谁注入谁：**很明显是 ioc 容器注入应用程序某个对象，应用程序依赖的对象；\n * 注入了什么：就是注入某个对象所需要的外部资源（包括对象、资源、常量数据）。\n\n\n# ioc 依赖注入 api\n\n * 根据 bean 名称注入\n * 根据 bean 类型注入\n * 注入容器内建 bean 对象\n * 注入非 bean 对象\n * 注入类型\n   * 实时注入\n   * 延迟注入\n\n\n# 依赖注入模式\n\n依赖注入模式可以分为手动注入模式和自动注入模式。\n\n\n# 手动注入模式\n\n手动注入模式：配置或者编程的方式，提前安排注入规则\n\n * xml 资源配置元信息\n * java 注解配置元信息\n * api 配置元信息\n\n\n# 自动注入模式\n\n自动注入模式即自动装配。自动装配（autowiring）是指 spring 容器可以自动装配 bean 之间的关系。spring 可以通过检查 applicationcontext 的内容，自动解析合作者（其他 bean）。\n\n * 自动装配可以显著减少属性或构造函数参数的配置。\n * 随着对象的发展，自动装配可以更新配置。\n\n> 注：由于自动装配存在一些限制和不足，官方不推荐使用。\n\n# 自动装配策略\n\n当使用基于 xml 的配置元数据时，可以使用 <bean/> 元素的 autowire 属性为 bean 指定自动装配模式。自动装配模式有以下类型：\n\n模式            说明\nno            默认值，未激活 autowiring，需要手动指定依赖注入对象。\nbyname        根据被注入属性的名称作为 bean 名称进行依赖查找，并将对象设置到该属性。\nbytype        根据被注入属性的类型作为依赖类型进行查找，并将对象设置到该属性。\nconstructor   特殊 bytype 类型，用于构造器参数。\n\norg.springframework.beans.factory.config.autowirecapablebeanfactory 是 beanfactory 的子接口，它是 spring 中用于实现自动装配的容器。\n\n# @autowired 注入过程\n\n * 元信息解析\n * 依赖查找\n * 依赖注入（字段、方法）\n\n# 自动装配的限制和不足\n\n自动装配有以下限制和不足：\n\n * 属性和构造函数参数设置中的显式依赖项会覆盖自动装配。您不能自动装配简单属性，例如基础数据类型、字符串和类（以及此类简单属性的数组）。\n * 自动装配不如显式装配精准。spring 会尽量避免猜测可能存在歧义的结果。\n * spring 容器生成文档的工具可能无法解析自动装配信息。\n * 如果同一类型存在多个 bean 时，自动装配时会存在歧义。容器内的多个 bean 定义可能与要自动装配的 setter 方法或构造函数参数指定的类型匹配。对于数组、集合或 map 实例，这不一定是问题。但是，对于期望单值的依赖项，如果没有唯一的 bean 定义可用，则会引发异常。\n\n> 自动装配的限制和不足，详情可以参考官方文档：limitations and disadvantages of autowiring 小节\n\n\n# 依赖注入方式\n\n依赖注入有如下方式：\n\n依赖注入方式        配置元数据举例\nsetter 方法注入   <proeprty name="user" ref="userbean"/>\n构造器注入         <constructor-arg name="user" ref="userbean" />\n字段注入          @autowired user user;\n方法注入          @autowired public void user(user user) { ... }\n接口回调注入        class mybean implements beanfactoryaware { ... }\n\n\n# 构造器注入\n\n * 手动模式\n   * xml 配置元信息\n   * 注解配置元信息\n   * java 配置元信息\n * 自动模式\n   * constructor\n\n构造器注入是通过容器调用具有多个参数的构造函数来完成的，每个参数代表一个依赖项。调用带有特定参数的静态工厂方法来构造 bean 几乎是等价的，并且本次讨论对构造函数和静态工厂方法的参数进行了类似的处理。\n\n下面是一个构造器注入示例：\n\npublic class simplemovielister {\n\n    // the simplemovielister has a dependency on a moviefinder\n    private final moviefinder moviefinder;\n\n    // a constructor so that the spring container can inject a moviefinder\n    public simplemovielister(moviefinder moviefinder) {\n        this.moviefinder = moviefinder;\n    }\n\n    // business logic that actually uses the injected moviefinder is omitted...\n}\n\n\n构造函数参数解析匹配通过使用参数的类型进行。如果 bean 定义的构造函数参数中不存在潜在的歧义，则在 bean 定义中定义构造函数参数的顺序是在实例化 bean 时将这些参数提供给适当构造函数的顺序。\n\npackage x.y;\n\npublic class thingone {\n\n    public thingone(thingtwo thingtwo, thingthree thingthree) {\n        // ...\n    }\n}\n\n\n假设 thingtwo 和 thingthree 类没有继承关系，则不存在潜在的歧义。因此，以下配置工作正常，您无需在 <constructor-arg/> 元素中显式指定构造函数参数索引或类型。\n\n<beans>\n    <bean id="beanone" class="x.y.thingone">\n        <constructor-arg ref="beantwo"/>\n        <constructor-arg ref="beanthree"/>\n    </bean>\n\n    <bean id="beantwo" class="x.y.thingtwo"/>\n\n    <bean id="beanthree" class="x.y.thingthree"/>\n</beans>\n\n\n当引用另一个 bean 时，类型是已知的，并且可以发生匹配（就像前面的示例一样）。当使用简单类型时，例如 <value>true</value> ，spring 无法确定 value 的类型，因此无法在没有帮助的情况下按类型匹配。考虑以下类：\n\npackage examples;\n\npublic class examplebean {\n\n    // number of years to calculate the ultimate answer\n    private final int years;\n\n    // the answer to life, the universe, and everything\n    private final string ultimateanswer;\n\n    public examplebean(int years, string ultimateanswer) {\n        this.years = years;\n        this.ultimateanswer = ultimateanswer;\n    }\n}\n\n\n构造函数参数类型匹配\n\n在上述场景中，如果您使用 type 属性显式指定构造函数参数的类型，则容器可以使用简单类型的类型匹配，如以下示例所示：\n\n<bean id="examplebean" class="examples.examplebean">\n    <constructor-arg type="int" value="7500000"/>\n    <constructor-arg type="java.lang.string" value="42"/>\n</bean>\n\n\n构造函数参数索引匹配\n\n可以使用 index 属性显式指定构造函数参数的索引，如以下示例所示\n\n<bean id="examplebean" class="examples.examplebean">\n    <constructor-arg index="0" value="7500000"/>\n    <constructor-arg index="1" value="42"/>\n</bean>\n\n\n构造函数参数名称匹配\n\n<bean id="examplebean" class="examples.examplebean">\n    <constructor-arg name="years" value="7500000"/>\n    <constructor-arg name="ultimateanswer" value="42"/>\n</bean>\n\n\n可以使用 @constructorproperties 显式命名构造函数参数。\n\npackage examples;\n\npublic class examplebean {\n\n    // fields omitted\n\n    @constructorproperties({"years", "ultimateanswer"})\n    public examplebean(int years, string ultimateanswer) {\n        this.years = years;\n        this.ultimateanswer = ultimateanswer;\n    }\n}\n\n\n\n# setter 方法注入\n\n * 手动模式\n   * xml 配置元信息\n   * 注解配置元信息\n   * java 配置元信息\n * 自动模式\n   * byname\n   * bytype\n\nsetter 方法注入是通过容器在调用无参数构造函数或无参数静态工厂方法来实例化 bean 后调用 bean 上的 setter 方法来完成的。\n\n以下示例显示了一个只能通过使用纯 setter 注入进行依赖注入的类。\n\npublic class simplemovielister {\n\n    // the simplemovielister has a dependency on the moviefinder\n    private moviefinder moviefinder;\n\n    // a setter method so that the spring container can inject a moviefinder\n    public void setmoviefinder(moviefinder moviefinder) {\n        this.moviefinder = moviefinder;\n    }\n\n    // business logic that actually uses the injected moviefinder is omitted...\n}\n\n\n在 spring 中，可以混合使用构造器注入和 setter 方法注入。建议将构造器注入用于强制依赖项；并将 setter 方法注入或配置方法用于可选依赖项。需要注意的是，在 setter 方法上使用 @required 注解可用于使属性成为必需的依赖项；然而，更建议使用构造器注入来完成这项工作。\n\n\n# 字段注入\n\n手动模式（java 注解配置元信息）\n\n * @autowired\n * @resource\n * @inject（可选）\n\n\n# 方法注入\n\n手动模式（java 注解配置元信息）\n\n * @autowired\n * @resource\n * @inject（可选）\n * @bean\n\n\n# 接口回调注入\n\naware 系列接口回调\n\n內建接口                             说明\nbeanfactoryaware                 获取 ioc 容器- beanfactory\napplicationcontextaware          获取 spring 应用上下文- applicationcontext 对象\nenvironmentaware                 获取 environment 对象\nresourceloaderaware              获取资源加载器对象- resourceloader\nbeanclassloaderaware             获取加载当前 bean class 的 classloader\nbeannameaware                    获取当前 bean 的名称\nmessagesourceaware               获取 messagesource 对象，用于 spring 国际化\napplicationeventpublisheraware   获取 applicationeventpublishaware 对象，用于 spring 事件\nembeddedvalueresolveraware       获取 stringvalueresolver 对象，用于占位符处理\n\n\n# 依赖注入选型\n\n * 低依赖：构造器注入\n * 多依赖：setter 方法注入\n * 便利性：字段注入\n * 声明类：方法注入\n\n\n# 限定注入和延迟注入\n\n\n# 限定注入\n\n * 使用 @qualifier 注解限定\n   * 通过 bean 名称限定\n   * 通过分组限定\n * 通过 @qualifier 注解扩展限定\n   * 自定义注解：如 spring cloud 的 @loadbalanced\n\n\n# 延迟注入\n\n * 使用 objectfactory\n * 使用 objectprovider（推荐）\n\n\n# 依赖注入数据类型\n\n\n# 基础类型\n\n * 基础数据类型：boolean、byte、char、short、int、float、long、double\n * 标量类型：number、character、boolean、enum、locale、charset、currency、properties、uuid\n * 常规类型：object、string、timezone、calendar、optional 等\n * spring 类型：resource、inputsource、formatter 等。\n\n\n# 集合类型\n\n数组类型：基础数据类型、标量类型、常规类型、string 类型的数组\n\n集合类型：\n\n * collection：list、set\n * map：properties\n\n\n# 依赖处理过程\n\n入口：defaultlistablebeanfactory#resolvedependency\n\n依赖描述符：dependencydescriptor\n\n自定义绑定候选对象处理器：autowirecandidateresolver\n\n@autowired、@value、@javax.inject.inject 处理器：autowiredannotationbeanpostprocessor\n\n通用注解处理器：commonannotationbeanpostprocessor\n\n * 注入注解\n   * javax.xml.ws.webserviceref\n   * javax.ejb.ejb\n   * javax.annotation.resources\n * 生命周期注解\n   * javax.annotation.postconstruct\n   * javax.annotation.predestroy\n\n自定义依赖注入注解：\n\n * 生命周期处理\n   * instantiationawarebeanpostprocessor\n   * mergedbeandefinitionpostprocessor\n * 元数据\n   * injectionmetadata\n   * injectionmetadata.injectedelement\n\n\n# 依赖查找 vs. 依赖注入\n\n类型     依赖处理   实现复杂度   代码侵入性    api 依赖性     可读性\n依赖查找   主动     相对繁琐    侵入业务逻辑   依赖容器 api    良好\n依赖注入   被动     相对便利    低侵入性     不依赖容器 api   一般\n\n\n# 参考资料\n\n * spring 官方文档之 core technologies\n * 《小马哥讲 spring 核心编程思想》',charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Spring IoC 依赖来源",frontmatter:{title:"Spring IoC 依赖来源",date:"2022-12-20T20:33:51.000Z",order:5,categories:["Java","框架","Spring","Spring核心"],tags:["Java","框架","Spring","IOC","依赖注入"],permalink:"/pages/a5f257/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/01.Spring%E6%A0%B8%E5%BF%83/05.SpringIoC%E4%BE%9D%E8%B5%96%E6%9D%A5%E6%BA%90.html",relativePath:"01.Java/13.框架/01.Spring/01.Spring核心/05.SpringIoC依赖来源.md",key:"v-4643e240",path:"/pages/a5f257/",headers:[{level:2,title:"依赖查找的来源",slug:"依赖查找的来源",normalizedTitle:"依赖查找的来源",charIndex:22},{level:2,title:"依赖注入的来源",slug:"依赖注入的来源",normalizedTitle:"依赖注入的来源",charIndex:1569},{level:2,title:"Spring 容器管理和游离对象",slug:"spring-容器管理和游离对象",normalizedTitle:"spring 容器管理和游离对象",charIndex:1832},{level:2,title:"Spring BeanDefinition 作为依赖来源",slug:"spring-beandefinition-作为依赖来源",normalizedTitle:"spring beandefinition 作为依赖来源",charIndex:2116},{level:2,title:"单例对象作为依赖来源",slug:"单例对象作为依赖来源",normalizedTitle:"单例对象作为依赖来源",charIndex:2261},{level:2,title:"非 Spring 对象容器管理对象作为依赖来源",slug:"非-spring-对象容器管理对象作为依赖来源",normalizedTitle:"非 spring 对象容器管理对象作为依赖来源",charIndex:2402},{level:2,title:"外部化配置作为依赖来源",slug:"外部化配置作为依赖来源",normalizedTitle:"外部化配置作为依赖来源",charIndex:2559},{level:2,title:"问题",slug:"问题",normalizedTitle:"问题",charIndex:2661},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:3028}],headersStr:"依赖查找的来源 依赖注入的来源 Spring 容器管理和游离对象 Spring BeanDefinition 作为依赖来源 单例对象作为依赖来源 非 Spring 对象容器管理对象作为依赖来源 外部化配置作为依赖来源 问题 参考资料",content:'# Spring IoC 依赖来源\n\n\n# 依赖查找的来源\n\n查找来源\n\n来源                      配置元数据\nSpring BeanDefinition   <bean id ="user" class="xxx.xxx.User">\n                        @Bean public User user() {...}\n                        BeanDefinitionBuilder\n单例对象                    API 实现\n\nSpring 內建 BeanDefintion\n\nBEAN 名称                                                                           BEAN 实例                                   使用场景\norg.springframework.context.annotation.internalConfigurationAnnotationProcessor   ConfigurationClassPostProcessor 对象        处理 Spring 配置类\norg.springframework.context.annotation.internalAutowiredAnnotationProcessor       AutowiredAnnotationBeanPostProcessor 对象   处理 @Autowired 以及 @Value 注解\norg.springframework.context.annotation.internalCommonAnnotationProcessor          CommonAnnotationBeanPostProcessor 对象      （条件激活）处理 JSR-250 注解，如 @PostConstruct 等\norg.springframework.context.event.internalEventListenerProcessor                  EventListenerMethodProcessor 对象           处理标注 @EventListener 的 Spring 事件监听方法\n\nSpring 內建单例对象\n\nBEAN 名称                       BEAN 实例                          使用场景\nenvironment                   Environment 对象                   外部化配置以及 Profiles\nsystemProperties              java.util.Properties 对象          Java 系统属性\nsystemEnvironment             java.util.Map 对象                 操作系统环境变量\nmessageSource                 MessageSource 对象                 国际化文案\nlifecycleProcessor            LifecycleProcessor 对象            Lifecycle Bean 处理器\napplicationEventMulticaster   ApplicationEventMulticaster 对象   Spring 事件广播器\n\n\n# 依赖注入的来源\n\n来源                      配置元数据\nSpring BeanDefinition   <bean id ="user" class="xxx.xxx.User">\n                        @Bean public User user() {...}\n                        BeanDefinitionBuilder\n单例对象                    API 实现\n非 Spring 容器管理对象         \n\n\n# Spring 容器管理和游离对象\n\n来源                      SPRING BEAN 对象   生命周期管理   配置元信息   使用场景\nSpring BeanDefinition   是                是        有       依赖查找、依赖注入\n单体对象                    是                否        无       依赖查找、依赖注入\nResolvable Dependency   否                否        无       依赖注入\n\n\n# Spring BeanDefinition 作为依赖来源\n\n * 元数据：BeanDefinition\n * 注册：BeanDefinitionRegistry#registerBeanDefinition\n * 类型：延迟和非延迟\n * 顺序：Bean 生命周期顺序按照注册顺序\n\n\n# 单例对象作为依赖来源\n\n * 要素\n   * 来源：外部普通 Java 对象（不一定是 POJO）\n   * 注册：SingletonBeanRegistry#registerSingleton\n * 限制\n   * 无生命周期管理\n   * 无法实现延迟初始化 Bean\n\n\n# 非 Spring 对象容器管理对象作为依赖来源\n\n * 要素\n   * 注册：ConfigurableListableBeanFactory#registerResolvableDependency\n * 限制\n   * 无生命周期管理\n   * 无法实现延迟初始化 Bean\n   * 无法通过依赖查找\n\n\n# 外部化配置作为依赖来源\n\n * 要素\n   * 类型：非常规 Spring 对象依赖来源\n * 限制\n   * 无生命周期管理\n   * 无法实现延迟初始化 Bean\n   * 无法通过依赖查找\n\n\n# 问题\n\n注入和查找的依赖来源是否相同？\n\n否，依赖查找的来源仅限于 Spring BeanDefinition 以及单例对象，而依赖注入的来源还包括 Resolvable Dependency 以及 @Value 所标注的外部化配置\n\n单例对象能在 IoC 容器启动后注册吗？\n\n可以的，单例对象的注册与 BeanDefinition 不同，BeanDefinition 会被 ConfigurableListableBeanFactory#freezeConfiguration() 方法影响，从而冻结注册，单例对象则没有这个限制。\n\nSpring 依赖注入的来源有哪些？\n\n * Spring BeanDefinition\n * 单例对象\n * Resolvable Dependency\n * @Value 外部化配置\n\n\n# 参考资料\n\n * Spring 官方文档之 Core Technologies\n * 《小马哥讲 Spring 核心编程思想》',normalizedContent:'# spring ioc 依赖来源\n\n\n# 依赖查找的来源\n\n查找来源\n\n来源                      配置元数据\nspring beandefinition   <bean id ="user" class="xxx.xxx.user">\n                        @bean public user user() {...}\n                        beandefinitionbuilder\n单例对象                    api 实现\n\nspring 內建 beandefintion\n\nbean 名称                                                                           bean 实例                                   使用场景\norg.springframework.context.annotation.internalconfigurationannotationprocessor   configurationclasspostprocessor 对象        处理 spring 配置类\norg.springframework.context.annotation.internalautowiredannotationprocessor       autowiredannotationbeanpostprocessor 对象   处理 @autowired 以及 @value 注解\norg.springframework.context.annotation.internalcommonannotationprocessor          commonannotationbeanpostprocessor 对象      （条件激活）处理 jsr-250 注解，如 @postconstruct 等\norg.springframework.context.event.internaleventlistenerprocessor                  eventlistenermethodprocessor 对象           处理标注 @eventlistener 的 spring 事件监听方法\n\nspring 內建单例对象\n\nbean 名称                       bean 实例                          使用场景\nenvironment                   environment 对象                   外部化配置以及 profiles\nsystemproperties              java.util.properties 对象          java 系统属性\nsystemenvironment             java.util.map 对象                 操作系统环境变量\nmessagesource                 messagesource 对象                 国际化文案\nlifecycleprocessor            lifecycleprocessor 对象            lifecycle bean 处理器\napplicationeventmulticaster   applicationeventmulticaster 对象   spring 事件广播器\n\n\n# 依赖注入的来源\n\n来源                      配置元数据\nspring beandefinition   <bean id ="user" class="xxx.xxx.user">\n                        @bean public user user() {...}\n                        beandefinitionbuilder\n单例对象                    api 实现\n非 spring 容器管理对象         \n\n\n# spring 容器管理和游离对象\n\n来源                      spring bean 对象   生命周期管理   配置元信息   使用场景\nspring beandefinition   是                是        有       依赖查找、依赖注入\n单体对象                    是                否        无       依赖查找、依赖注入\nresolvable dependency   否                否        无       依赖注入\n\n\n# spring beandefinition 作为依赖来源\n\n * 元数据：beandefinition\n * 注册：beandefinitionregistry#registerbeandefinition\n * 类型：延迟和非延迟\n * 顺序：bean 生命周期顺序按照注册顺序\n\n\n# 单例对象作为依赖来源\n\n * 要素\n   * 来源：外部普通 java 对象（不一定是 pojo）\n   * 注册：singletonbeanregistry#registersingleton\n * 限制\n   * 无生命周期管理\n   * 无法实现延迟初始化 bean\n\n\n# 非 spring 对象容器管理对象作为依赖来源\n\n * 要素\n   * 注册：configurablelistablebeanfactory#registerresolvabledependency\n * 限制\n   * 无生命周期管理\n   * 无法实现延迟初始化 bean\n   * 无法通过依赖查找\n\n\n# 外部化配置作为依赖来源\n\n * 要素\n   * 类型：非常规 spring 对象依赖来源\n * 限制\n   * 无生命周期管理\n   * 无法实现延迟初始化 bean\n   * 无法通过依赖查找\n\n\n# 问题\n\n注入和查找的依赖来源是否相同？\n\n否，依赖查找的来源仅限于 spring beandefinition 以及单例对象，而依赖注入的来源还包括 resolvable dependency 以及 @value 所标注的外部化配置\n\n单例对象能在 ioc 容器启动后注册吗？\n\n可以的，单例对象的注册与 beandefinition 不同，beandefinition 会被 configurablelistablebeanfactory#freezeconfiguration() 方法影响，从而冻结注册，单例对象则没有这个限制。\n\nspring 依赖注入的来源有哪些？\n\n * spring beandefinition\n * 单例对象\n * resolvable dependency\n * @value 外部化配置\n\n\n# 参考资料\n\n * spring 官方文档之 core technologies\n * 《小马哥讲 spring 核心编程思想》',charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Spring Bean 作用域",frontmatter:{title:"Spring Bean 作用域",date:"2022-12-21T11:42:00.000Z",order:6,categories:["Java","框架","Spring","Spring核心"],tags:["Java","框架","Spring","Bean"],permalink:"/pages/8289f5/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/01.Spring%E6%A0%B8%E5%BF%83/06.SpringBean%E4%BD%9C%E7%94%A8%E5%9F%9F.html",relativePath:"01.Java/13.框架/01.Spring/01.Spring核心/06.SpringBean作用域.md",key:"v-6b2eab00",path:"/pages/8289f5/",headers:[{level:2,title:"Spring Bean 作用域",slug:"spring-bean-作用域-2",normalizedTitle:"spring bean 作用域",charIndex:2},{level:2,title:'"singleton" Bean 作用域',slug:"singleton-bean-作用域",normalizedTitle:"&quot;singleton&quot; bean 作用域",charIndex:null},{level:2,title:'"prototype" Bean 作用域',slug:"prototype-bean-作用域",normalizedTitle:"&quot;prototype&quot; bean 作用域",charIndex:null},{level:2,title:'"request" Bean 作用域',slug:"request-bean-作用域",normalizedTitle:"&quot;request&quot; bean 作用域",charIndex:null},{level:2,title:'"session" Bean 作用域',slug:"session-bean-作用域",normalizedTitle:"&quot;session&quot; bean 作用域",charIndex:null},{level:2,title:'"application" Bean 作用域',slug:"application-bean-作用域",normalizedTitle:"&quot;application&quot; bean 作用域",charIndex:null},{level:2,title:"自定义 Bean 作用域",slug:"自定义-bean-作用域",normalizedTitle:"自定义 bean 作用域",charIndex:1033},{level:2,title:"问题",slug:"问题",normalizedTitle:"问题",charIndex:1452},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:1716}],headersStr:'Spring Bean 作用域 "singleton" Bean 作用域 "prototype" Bean 作用域 "request" Bean 作用域 "session" Bean 作用域 "application" Bean 作用域 自定义 Bean 作用域 问题 参考资料',content:'# Spring Bean 作用域\n\n\n# Spring Bean 作用域\n\n来源            说明\nsingleton     默认 Spring Bean 作用域，一个 BeanFactory 有且仅有一个实例\nprototype     原型作用域，每次依赖查找和依赖注入生成新 Bean 对象\nrequest       将 Spring Bean 存储在 ServletRequest 上下文中\nsession       将 Spring Bean 存储在 HttpSession 中\napplication   将 Spring Bean 存储在 ServletContext 中\n\n\n# "singleton" Bean 作用域\n\n\n\n\n# "prototype" Bean 作用域\n\nSpring 容器没有办法管理 prototype Bean 的完整生命周期，也没有办法记录实例的存在。销毁回调方法将不会执行，可以利用 BeanPostProcessor 进行清扫工作。\n\n\n# "request" Bean 作用域\n\n * 配置\n   * XML - <bean class="..." scope = “request" />\n   * Java 注解 - @RequestScope 或 @Scope(WebApplicationContext.SCOPE_REQUEST)\n * 实现\n   * API - RequestScope\n\n\n# "session" Bean 作用域\n\n * 配置\n   * XML - <bean class="..." scope = “session" />\n   * Java 注解 - @SessionScope 或 @Scope(WebApplicationContext.SCOPE_SESSION)\n * 实现\n   * API - SessionScope\n\n\n# "application" Bean 作用域\n\n * 配置\n   * XML - <bean class="..." scope = “application" />\n   * Java 注解 - @ApplicationScope 或 @Scope(WebApplicationContext.SCOPE_APPLICATION)\n * 实现\n   * API - ServletContextScope\n\n\n# 自定义 Bean 作用域\n\n * 实现 Scope\n   \n   * org.springframework.beans.factory.config.Scope\n\n * 注册 Scope\n   \n   * API - org.springframework.beans.factory.config.ConfigurableBeanFactory#registerScope\n\n * 配置\n   \n   <bean class="org.springframework.beans.factory.config.CustomScopeConfigurer">\n     <property name="scopes">\n       <map>\n         <entry key="...">\n         </entry>\n       </map>\n     </property>\n   </bean>\n   \n\n\n# 问题\n\nSpring 內建的 Bean 作用域有几种？\n\nsingleton、prototype、request、session、application 以及 websocket\n\nsingleton Bean 是否在一个应用是唯一的？\n\n否。singleton bean 仅在当前 Spring IoC 容器（BeanFactory）中是单例对象。\n\napplication Bean 是否可以被其他方案替代？\n\n可以的，实际上，“application” Bean 与“singleton” Bean 没有本质区别\n\n\n# 参考资料\n\n * Spring 官方文档之 Core Technologies\n * 《小马哥讲 Spring 核心编程思想》',normalizedContent:'# spring bean 作用域\n\n\n# spring bean 作用域\n\n来源            说明\nsingleton     默认 spring bean 作用域，一个 beanfactory 有且仅有一个实例\nprototype     原型作用域，每次依赖查找和依赖注入生成新 bean 对象\nrequest       将 spring bean 存储在 servletrequest 上下文中\nsession       将 spring bean 存储在 httpsession 中\napplication   将 spring bean 存储在 servletcontext 中\n\n\n# "singleton" bean 作用域\n\n\n\n\n# "prototype" bean 作用域\n\nspring 容器没有办法管理 prototype bean 的完整生命周期，也没有办法记录实例的存在。销毁回调方法将不会执行，可以利用 beanpostprocessor 进行清扫工作。\n\n\n# "request" bean 作用域\n\n * 配置\n   * xml - <bean class="..." scope = “request" />\n   * java 注解 - @requestscope 或 @scope(webapplicationcontext.scope_request)\n * 实现\n   * api - requestscope\n\n\n# "session" bean 作用域\n\n * 配置\n   * xml - <bean class="..." scope = “session" />\n   * java 注解 - @sessionscope 或 @scope(webapplicationcontext.scope_session)\n * 实现\n   * api - sessionscope\n\n\n# "application" bean 作用域\n\n * 配置\n   * xml - <bean class="..." scope = “application" />\n   * java 注解 - @applicationscope 或 @scope(webapplicationcontext.scope_application)\n * 实现\n   * api - servletcontextscope\n\n\n# 自定义 bean 作用域\n\n * 实现 scope\n   \n   * org.springframework.beans.factory.config.scope\n\n * 注册 scope\n   \n   * api - org.springframework.beans.factory.config.configurablebeanfactory#registerscope\n\n * 配置\n   \n   <bean class="org.springframework.beans.factory.config.customscopeconfigurer">\n     <property name="scopes">\n       <map>\n         <entry key="...">\n         </entry>\n       </map>\n     </property>\n   </bean>\n   \n\n\n# 问题\n\nspring 內建的 bean 作用域有几种？\n\nsingleton、prototype、request、session、application 以及 websocket\n\nsingleton bean 是否在一个应用是唯一的？\n\n否。singleton bean 仅在当前 spring ioc 容器（beanfactory）中是单例对象。\n\napplication bean 是否可以被其他方案替代？\n\n可以的，实际上，“application” bean 与“singleton” bean 没有本质区别\n\n\n# 参考资料\n\n * spring 官方文档之 core technologies\n * 《小马哥讲 spring 核心编程思想》',charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Spring Bean 生命周期",frontmatter:{title:"Spring Bean 生命周期",date:"2022-12-21T19:26:01.000Z",order:7,categories:["Java","框架","Spring","Spring核心"],tags:["Java","框架","Spring","Bean"],permalink:"/pages/4ab176/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/01.Spring%E6%A0%B8%E5%BF%83/07.SpringBean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html",relativePath:"01.Java/13.框架/01.Spring/01.Spring核心/07.SpringBean生命周期.md",key:"v-1243db1d",path:"/pages/4ab176/",headers:[{level:2,title:"Spring Bean 元信息配置阶段",slug:"spring-bean-元信息配置阶段",normalizedTitle:"spring bean 元信息配置阶段",charIndex:23},{level:2,title:"Spring Bean 元信息解析阶段",slug:"spring-bean-元信息解析阶段",normalizedTitle:"spring bean 元信息解析阶段",charIndex:126},{level:2,title:"Spring Bean 注册阶段",slug:"spring-bean-注册阶段",normalizedTitle:"spring bean 注册阶段",charIndex:300},{level:2,title:"Spring BeanDefinition 合并阶段",slug:"spring-beandefinition-合并阶段",normalizedTitle:"spring beandefinition 合并阶段",charIndex:365},{level:2,title:"Spring Bean Class 加载阶段",slug:"spring-bean-class-加载阶段",normalizedTitle:"spring bean class 加载阶段",charIndex:481},{level:2,title:"Spring Bean 实例化前阶段",slug:"spring-bean-实例化前阶段",normalizedTitle:"spring bean 实例化前阶段",charIndex:592},{level:2,title:"Spring Bean 实例化阶段",slug:"spring-bean-实例化阶段",normalizedTitle:"spring bean 实例化阶段",charIndex:674},{level:2,title:"Spring Bean 实例化后阶段",slug:"spring-bean-实例化后阶段",normalizedTitle:"spring bean 实例化后阶段",charIndex:787},{level:2,title:"Spring Bean 属性赋值前阶段",slug:"spring-bean-属性赋值前阶段",normalizedTitle:"spring bean 属性赋值前阶段",charIndex:900},{level:2,title:"Spring Bean Aware 接口回调阶段",slug:"spring-bean-aware-接口回调阶段",normalizedTitle:"spring bean aware 接口回调阶段",charIndex:1134},{level:2,title:"Spring Bean 初始化前阶段",slug:"spring-bean-初始化前阶段",normalizedTitle:"spring bean 初始化前阶段",charIndex:1399},{level:2,title:"Spring Bean 初始化阶段",slug:"spring-bean-初始化阶段",normalizedTitle:"spring bean 初始化阶段",charIndex:1536},{level:2,title:"Spring Bean 初始化后阶段",slug:"spring-bean-初始化后阶段",normalizedTitle:"spring bean 初始化后阶段",charIndex:1671},{level:2,title:"Spring Bean 初始化完成阶段",slug:"spring-bean-初始化完成阶段",normalizedTitle:"spring bean 初始化完成阶段",charIndex:1749},{level:2,title:"Spring Bean 销毁前阶段",slug:"spring-bean-销毁前阶段",normalizedTitle:"spring bean 销毁前阶段",charIndex:1847},{level:2,title:"Spring Bean 销毁阶段",slug:"spring-bean-销毁阶段",normalizedTitle:"spring bean 销毁阶段",charIndex:1938},{level:2,title:"Spring Bean 垃圾收集",slug:"spring-bean-垃圾收集",normalizedTitle:"spring bean 垃圾收集",charIndex:2047},{level:2,title:"问题",slug:"问题",normalizedTitle:"问题",charIndex:2152},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:3358}],headersStr:"Spring Bean 元信息配置阶段 Spring Bean 元信息解析阶段 Spring Bean 注册阶段 Spring BeanDefinition 合并阶段 Spring Bean Class 加载阶段 Spring Bean 实例化前阶段 Spring Bean 实例化阶段 Spring Bean 实例化后阶段 Spring Bean 属性赋值前阶段 Spring Bean Aware 接口回调阶段 Spring Bean 初始化前阶段 Spring Bean 初始化阶段 Spring Bean 初始化后阶段 Spring Bean 初始化完成阶段 Spring Bean 销毁前阶段 Spring Bean 销毁阶段 Spring Bean 垃圾收集 问题 参考资料",content:"# Spring Bean 生命周期\n\n\n# Spring Bean 元信息配置阶段\n\nBeanDefinition 配置\n\n * 面向资源\n   * XML 配置\n   * Properties 资源配置\n * 面向注解\n * 面向 API\n\n\n# Spring Bean 元信息解析阶段\n\n * 面向资源 BeanDefinition 解析\n   * BeanDefinitionReader\n   * XML 解析器 - BeanDefinitionParser\n * 面向注解 BeanDefinition 解析\n   * AnnotatedBeanDefinitionReader\n\n\n# Spring Bean 注册阶段\n\nBeanDefinition 注册接口：BeanDefinitionRegistry\n\n\n# Spring BeanDefinition 合并阶段\n\nBeanDefinition 合并\n\n父子 BeanDefinition 合并\n\n * 当前 BeanFactory 查找\n * 层次性 BeanFactory 查找\n\n\n# Spring Bean Class 加载阶段\n\n * ClassLoader 类加载\n * Java Security 安全控制\n * ConfigurableBeanFactory 临时 ClassLoader\n\n\n# Spring Bean 实例化前阶段\n\n实例化方式\n\n * 传统实例化方式：实例化策略（InstantiationStrategy）\n * 构造器依赖注入\n\n\n# Spring Bean 实例化阶段\n\n非主流生命周期 - Bean 实例化前阶段\n\nInstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation\n\n\n# Spring Bean 实例化后阶段\n\nBean 属性赋值（Populate）判断\n\nInstantiationAwareBeanPostProcessor#postProcessAfterInstantiation\n\n\n# Spring Bean 属性赋值前阶段\n\n * Bean 属性值元信息\n   * PropertyValues\n * Bean 属性赋值前回调\n   * Spring 1.2 - 5.0：InstantiationAwareBeanPostProcessor#postProcessPropertyValues\n   * Spring 5.1：InstantiationAwareBeanPostProcessor#postProcessProperties\n\n\n# Spring Bean Aware 接口回调阶段\n\nSpring Aware 接口：\n\n * BeanNameAware\n * BeanClassLoaderAware\n * BeanFactoryAware\n * EnvironmentAware\n * EmbeddedValueResolverAware\n * ResourceLoaderAware\n * ApplicationEventPublisherAware\n * MessageSourceAware\n * ApplicationContextAware\n\n\n# Spring Bean 初始化前阶段\n\n已完成：\n\n * Bean 实例化\n\n * Bean 属性赋值\n\n * Bean Aware 接口回调\n\n方法回调：\n\n * BeanPostProcessor#postProcessBeforeInitialization\n\n\n# Spring Bean 初始化阶段\n\nBean 初始化（Initialization）\n\n * @PostConstruct 标注方法\n * 实现 InitializingBean 接口的 afterPropertiesSet() 方法\n * 自定义初始化方法\n\n\n# Spring Bean 初始化后阶段\n\n方法回调：BeanPostProcessor#postProcessAfterInitialization\n\n\n# Spring Bean 初始化完成阶段\n\n方法回调：Spring 4.1 +：SmartInitializingSingleton#afterSingletonsInstantiated\n\n\n# Spring Bean 销毁前阶段\n\n方法回调：DestructionAwareBeanPostProcessor#postProcessBeforeDestruction\n\n\n# Spring Bean 销毁阶段\n\nBean 销毁（Destroy）\n\n * @PreDestroy 标注方法\n * 实现 DisposableBean 接口的 destroy() 方法\n * 自定义销毁方法\n\n\n# Spring Bean 垃圾收集\n\nBean 垃圾回收（GC）\n\n * 关闭 Spring 容器（应用上下文）\n * 执行 GC\n * Spring Bean 覆盖的 finalize() 方法被回调\n\n\n# 问题\n\nBeanPostProcessor 的使用场景有哪些？\n\nBeanPostProcessor 提供 Spring Bean 初始化前和初始化后的生命周期回调，分别对应 postProcessBeforeInitialization 以及 postProcessAfterInitialization 方法，允许对关心的 Bean 进行扩展，甚至是替换。\n\n加分项：其中，ApplicationContext 相关的 Aware 回调也是基于 BeanPostProcessor 实现，即 ApplicationContextAwareProcessor。\n\nBeanFactoryPostProcessor 与 BeanPostProcessor 的区别？\n\nBeanFactoryPostProcessor 是 Spring BeanFactory（实际为 ConfigurableListableBeanFactory） 的后置处理器，用于扩展 BeanFactory，或通过 BeanFactory 进行依赖查找和依赖注入。\n\nBeanFactoryPostProcessor 必须有 Spring ApplicationContext 执行，BeanFactory 无法与其直接交互。\n\n而 BeanPostProcessor 则直接与 BeanFactory 关联，属于 N 对 1 的关系。\n\nBeanFactory 是怎样处理 Bean 生命周期？\n\nBeanFactory 的默认实现为 DefaultListableBeanFactory，其中 Bean生命周期与方法映射如下：\n\n * BeanDefinition 注册阶段 - registerBeanDefinition\n * BeanDefinition 合并阶段 - getMergedBeanDefinition\n * Bean 实例化前阶段 - resolveBeforeInstantiation\n * Bean 实例化阶段 - createBeanInstance\n * Bean 初始化后阶段 - populateBean\n * Bean 属性赋值前阶段 - populateBean\n * Bean 属性赋值阶段 - populateBean\n * Bean Aware 接口回调阶段 - initializeBean\n * Bean 初始化前阶段 - initializeBean\n * Bean 初始化阶段 - initializeBean\n * Bean 初始化后阶段 - initializeBean\n * Bean 初始化完成阶段 - preInstantiateSingletons\n * Bean 销毁前阶段 - destroyBean\n * Bean 销毁阶段 - destroyBean\n\n\n# 参考资料\n\n * Spring 官方文档之 Core Technologies\n * 《小马哥讲 Spring 核心编程思想》",normalizedContent:"# spring bean 生命周期\n\n\n# spring bean 元信息配置阶段\n\nbeandefinition 配置\n\n * 面向资源\n   * xml 配置\n   * properties 资源配置\n * 面向注解\n * 面向 api\n\n\n# spring bean 元信息解析阶段\n\n * 面向资源 beandefinition 解析\n   * beandefinitionreader\n   * xml 解析器 - beandefinitionparser\n * 面向注解 beandefinition 解析\n   * annotatedbeandefinitionreader\n\n\n# spring bean 注册阶段\n\nbeandefinition 注册接口：beandefinitionregistry\n\n\n# spring beandefinition 合并阶段\n\nbeandefinition 合并\n\n父子 beandefinition 合并\n\n * 当前 beanfactory 查找\n * 层次性 beanfactory 查找\n\n\n# spring bean class 加载阶段\n\n * classloader 类加载\n * java security 安全控制\n * configurablebeanfactory 临时 classloader\n\n\n# spring bean 实例化前阶段\n\n实例化方式\n\n * 传统实例化方式：实例化策略（instantiationstrategy）\n * 构造器依赖注入\n\n\n# spring bean 实例化阶段\n\n非主流生命周期 - bean 实例化前阶段\n\ninstantiationawarebeanpostprocessor#postprocessbeforeinstantiation\n\n\n# spring bean 实例化后阶段\n\nbean 属性赋值（populate）判断\n\ninstantiationawarebeanpostprocessor#postprocessafterinstantiation\n\n\n# spring bean 属性赋值前阶段\n\n * bean 属性值元信息\n   * propertyvalues\n * bean 属性赋值前回调\n   * spring 1.2 - 5.0：instantiationawarebeanpostprocessor#postprocesspropertyvalues\n   * spring 5.1：instantiationawarebeanpostprocessor#postprocessproperties\n\n\n# spring bean aware 接口回调阶段\n\nspring aware 接口：\n\n * beannameaware\n * beanclassloaderaware\n * beanfactoryaware\n * environmentaware\n * embeddedvalueresolveraware\n * resourceloaderaware\n * applicationeventpublisheraware\n * messagesourceaware\n * applicationcontextaware\n\n\n# spring bean 初始化前阶段\n\n已完成：\n\n * bean 实例化\n\n * bean 属性赋值\n\n * bean aware 接口回调\n\n方法回调：\n\n * beanpostprocessor#postprocessbeforeinitialization\n\n\n# spring bean 初始化阶段\n\nbean 初始化（initialization）\n\n * @postconstruct 标注方法\n * 实现 initializingbean 接口的 afterpropertiesset() 方法\n * 自定义初始化方法\n\n\n# spring bean 初始化后阶段\n\n方法回调：beanpostprocessor#postprocessafterinitialization\n\n\n# spring bean 初始化完成阶段\n\n方法回调：spring 4.1 +：smartinitializingsingleton#aftersingletonsinstantiated\n\n\n# spring bean 销毁前阶段\n\n方法回调：destructionawarebeanpostprocessor#postprocessbeforedestruction\n\n\n# spring bean 销毁阶段\n\nbean 销毁（destroy）\n\n * @predestroy 标注方法\n * 实现 disposablebean 接口的 destroy() 方法\n * 自定义销毁方法\n\n\n# spring bean 垃圾收集\n\nbean 垃圾回收（gc）\n\n * 关闭 spring 容器（应用上下文）\n * 执行 gc\n * spring bean 覆盖的 finalize() 方法被回调\n\n\n# 问题\n\nbeanpostprocessor 的使用场景有哪些？\n\nbeanpostprocessor 提供 spring bean 初始化前和初始化后的生命周期回调，分别对应 postprocessbeforeinitialization 以及 postprocessafterinitialization 方法，允许对关心的 bean 进行扩展，甚至是替换。\n\n加分项：其中，applicationcontext 相关的 aware 回调也是基于 beanpostprocessor 实现，即 applicationcontextawareprocessor。\n\nbeanfactorypostprocessor 与 beanpostprocessor 的区别？\n\nbeanfactorypostprocessor 是 spring beanfactory（实际为 configurablelistablebeanfactory） 的后置处理器，用于扩展 beanfactory，或通过 beanfactory 进行依赖查找和依赖注入。\n\nbeanfactorypostprocessor 必须有 spring applicationcontext 执行，beanfactory 无法与其直接交互。\n\n而 beanpostprocessor 则直接与 beanfactory 关联，属于 n 对 1 的关系。\n\nbeanfactory 是怎样处理 bean 生命周期？\n\nbeanfactory 的默认实现为 defaultlistablebeanfactory，其中 bean生命周期与方法映射如下：\n\n * beandefinition 注册阶段 - registerbeandefinition\n * beandefinition 合并阶段 - getmergedbeandefinition\n * bean 实例化前阶段 - resolvebeforeinstantiation\n * bean 实例化阶段 - createbeaninstance\n * bean 初始化后阶段 - populatebean\n * bean 属性赋值前阶段 - populatebean\n * bean 属性赋值阶段 - populatebean\n * bean aware 接口回调阶段 - initializebean\n * bean 初始化前阶段 - initializebean\n * bean 初始化阶段 - initializebean\n * bean 初始化后阶段 - initializebean\n * bean 初始化完成阶段 - preinstantiatesingletons\n * bean 销毁前阶段 - destroybean\n * bean 销毁阶段 - destroybean\n\n\n# 参考资料\n\n * spring 官方文档之 core technologies\n * 《小马哥讲 spring 核心编程思想》",charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Spring 配置元数据",frontmatter:{title:"Spring 配置元数据",date:"2022-12-21T19:49:48.000Z",order:"08",categories:["Java","框架","Spring","Spring核心"],tags:["Java","框架","Spring","Bean"],permalink:"/pages/55f315/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/01.Spring%E6%A0%B8%E5%BF%83/08.Spring%E9%85%8D%E7%BD%AE%E5%85%83%E6%95%B0%E6%8D%AE.html",relativePath:"01.Java/13.框架/01.Spring/01.Spring核心/08.Spring配置元数据.md",key:"v-10b9b6b6",path:"/pages/55f315/",headers:[{level:2,title:"Spring 配置元信息",slug:"spring-配置元信息",normalizedTitle:"spring 配置元信息",charIndex:19},{level:2,title:"Spring Bean 配置元信息",slug:"spring-bean-配置元信息",normalizedTitle:"spring bean 配置元信息",charIndex:36},{level:2,title:"Spring Bean 属性元信息",slug:"spring-bean-属性元信息",normalizedTitle:"spring bean 属性元信息",charIndex:74},{level:2,title:"Spring 容器配置元信息",slug:"spring-容器配置元信息",normalizedTitle:"spring 容器配置元信息",charIndex:112},{level:2,title:"基于 XML 文件装载 Spring Bean 配置元信息",slug:"基于-xml-文件装载-spring-bean-配置元信息",normalizedTitle:"基于 xml 文件装载 spring bean 配置元信息",charIndex:1718},{level:2,title:"基于 Properties 文件装载 Spring Bean 配置元信息",slug:"基于-properties-文件装载-spring-bean-配置元信息",normalizedTitle:"基于 properties 文件装载 spring bean 配置元信息",charIndex:2008},{level:2,title:"基于 Java 注解装载 Spring Bean 配置元信息",slug:"基于-java-注解装载-spring-bean-配置元信息",normalizedTitle:"基于 java 注解装载 spring bean 配置元信息",charIndex:2351},{level:2,title:"Spring Bean 配置元信息底层实现",slug:"spring-bean-配置元信息底层实现",normalizedTitle:"spring bean 配置元信息底层实现",charIndex:3854},{level:3,title:"Spring XML 资源 BeanDefinition 解析与注册",slug:"spring-xml-资源-beandefinition-解析与注册",normalizedTitle:"spring xml 资源 beandefinition 解析与注册",charIndex:3880},{level:3,title:"Spring Properties 资源 BeanDefinition 解析与注册",slug:"spring-properties-资源-beandefinition-解析与注册",normalizedTitle:"spring properties 资源 beandefinition 解析与注册",charIndex:4145},{level:3,title:"Spring Java 注册 BeanDefinition 解析与注册",slug:"spring-java-注册-beandefinition-解析与注册",normalizedTitle:"spring java 注册 beandefinition 解析与注册",charIndex:4404},{level:2,title:"基于 XML 文件装载 Spring IoC 容器配置元信息",slug:"基于-xml-文件装载-spring-ioc-容器配置元信息",normalizedTitle:"基于 xml 文件装载 spring ioc 容器配置元信息",charIndex:4759},{level:2,title:"基于 Java 注解装载 Spring IoC 容器配置元信息",slug:"基于-java-注解装载-spring-ioc-容器配置元信息",normalizedTitle:"基于 java 注解装载 spring ioc 容器配置元信息",charIndex:5417},{level:2,title:"基于 Extensible XML authoring 扩展 SpringXML 元素",slug:"基于-extensible-xml-authoring-扩展-springxml-元素",normalizedTitle:"基于 extensible xml authoring 扩展 springxml 元素",charIndex:5865},{level:2,title:"Extensible XML authoring 扩展原理",slug:"extensible-xml-authoring-扩展原理",normalizedTitle:"extensible xml authoring 扩展原理",charIndex:6083},{level:3,title:"触发时机",slug:"触发时机",normalizedTitle:"触发时机",charIndex:6117},{level:3,title:"核心流程",slug:"核心流程",normalizedTitle:"核心流程",charIndex:6449},{level:2,title:"基于 Properties 文件装载外部化配置",slug:"基于-properties-文件装载外部化配置",normalizedTitle:"基于 properties 文件装载外部化配置",charIndex:6644},{level:2,title:"基于 YAML 文件装载外部化配置",slug:"基于-yaml-文件装载外部化配置",normalizedTitle:"基于 yaml 文件装载外部化配置",charIndex:6900},{level:2,title:"问题",slug:"问题",normalizedTitle:"问题",charIndex:7126},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:8247}],headersStr:"Spring 配置元信息 Spring Bean 配置元信息 Spring Bean 属性元信息 Spring 容器配置元信息 基于 XML 文件装载 Spring Bean 配置元信息 基于 Properties 文件装载 Spring Bean 配置元信息 基于 Java 注解装载 Spring Bean 配置元信息 Spring Bean 配置元信息底层实现 Spring XML 资源 BeanDefinition 解析与注册 Spring Properties 资源 BeanDefinition 解析与注册 Spring Java 注册 BeanDefinition 解析与注册 基于 XML 文件装载 Spring IoC 容器配置元信息 基于 Java 注解装载 Spring IoC 容器配置元信息 基于 Extensible XML authoring 扩展 SpringXML 元素 Extensible XML authoring 扩展原理 触发时机 核心流程 基于 Properties 文件装载外部化配置 基于 YAML 文件装载外部化配置 问题 参考资料",content:'# Spring 配置元数据\n\n\n# Spring 配置元信息\n\n * Spring Bean 配置元信息 - BeanDefinition\n * Spring Bean 属性元信息 - PropertyValues\n * Spring 容器配置元信息\n * Spring 外部化配置元信息 - PropertySource\n * Spring Profile 元信息 - @Profile\n\n\n# Spring Bean 配置元信息\n\nBean 配置元信息 - BeanDefinition\n\n * GenericBeanDefinition：通用型 BeanDefinition\n * RootBeanDefinition：无 Parent 的 BeanDefinition 或者合并后 BeanDefinition\n * AnnotatedBeanDefinition：注解标注的 BeanDefinition\n\n\n# Spring Bean 属性元信息\n\n * Bean 属性元信息 - PropertyValues\n   * 可修改实现 - MutablePropertyValues\n   * 元素成员 - PropertyValue\n * Bean 属性上下文存储 - AttributeAccessor\n * Bean 元信息元素 - BeanMetadataElement\n\n\n# Spring 容器配置元信息\n\nSpring XML 配置元信息 - beans 元素相关\n\nBEANS 元素属性                    默认值        使用场景\nprofile                       null（留空）   Spring Profiles 配置值\ndefault-lazy-init             default    当 outter beans “default-lazy-init” 属性存在时，继承该值，否则为“false”\ndefault-merge                 default    当 outter beans “default-merge” 属性存在时，继承该值，否则为“false”\ndefault-autowire              default    当 outter beans “default-autowire” 属性存在时，继承该值，否则为“no”\ndefault-autowire-candidates   null（留空）   默认 Spring Beans 名称 pattern\ndefault-init-method           null（留空）   默认 Spring Beans 自定义初始化方法\ndefault-destroy-method        null（留空）   默认 Spring Beans 自定义销毁方法\n\nSpring XML 配置元信息 - 应用上下文相关\n\nXML 元素                             使用场景\n<context:annotation-config />      激活 Spring 注解驱动\n<context:component-scan />         Spring @Component 以及自定义注解扫描\n<context:load-time-weaver />       激活 Spring LoadTimeWeaver\n<context:mbean-export />           暴露 Spring Beans 作为 JMX Beans\n<context:mbean-server />           将当前平台作为 MBeanServer\n<context:property-placeholder />   加载外部化配置资源作为 Spring 属性配\n<context:property-override />      利用外部化配置资源覆盖 Spring 属\n\n\n# 基于 XML 文件装载 Spring Bean 配置元信息\n\n底层实现 - XmlBeanDefinitionReader\n\nXML 元素             使用场景\n<beans:beans />    单 XML 资源下的多个 Spring Beans 配置\n<beans:bean />     单个 Spring Bean 定义（BeanDefinition）配置\n<beans:alias />    为 Spring Bean 定义（BeanDefinition）映射别名\n<beans:import />   加载外部 Spring XML 配置资源\n\n\n# 基于 Properties 文件装载 Spring Bean 配置元信息\n\n底层实现 - PropertiesBeanDefinitionReader\n\nPROPERTIES 属性名   使用场景\nclass            Bean 类全称限定名\nabstract         是否为抽象的 BeanDefinition\nparent           指定 parent BeanDefinition 名称\nlazy-init        是否为延迟初始化\nref              引用其他 Bean 的名称\nscope            设置 Bean 的 scope 属性\n${n}             n 表示第 n+1 个构造器参数\n\n\n# 基于 Java 注解装载 Spring Bean 配置元信息\n\nSpring 模式注解\n\nSPRING 注解        场景说明          起始版本\n@Repository      数据仓储模式注解      2.0\n@Component       通用组件模式注解      2.5\n@Service         服务模式注解        2.5\n@Controller      Web 控制器模式注解   2.5\n@Configuration   配置类模式注解       3.0\n\nSpring Bean 定义注解\n\nSPRING 注解    场景说明                                           起始版本\n@Bean        替换 XML 元素 <bean>                               3.0\n@DependsOn   替代 XML 属性 <bean depends-on="..."/>             3.0\n@Lazy        替代 XML 属性 <bean lazy-init="true | falses" />   3.0\n@Primary     替换 XML 元素 <bean primary="true | false" />      3.0\n@Role        替换 XML 元素 <bean role="..." />                  3.1\n@Lookup      替代 XML 属性 <bean lookup-method="...">           4.1\n\nSpring Bean 依赖注入注解\n\nSPRING 注解    场景说明                   起始版本\n@Autowired   Bean 依赖注入，支持多种依赖查找方式   2.5\n@Qualifier   细粒度的 @Autowired 依赖查找   2.5\n\nJAVA 注解     场景说明             起始版本\n@Resource   类似于 @Autowired   2.5\n@Inject     类似于 @Autowired   2.5\n\nSpring Bean 条件装配注解\n\nSPRING 注解      场景说明      起始版本\n@Profile       配置化条件装配   3.1\n@Conditional   编程条件装配    4.0\n\nSpring Bean 生命周期回调注解\n\nSPRING 注解        场景说明                           起始版本\n@PostConstruct   替换 XML 元素 或 InitializingBean   2.5\n@PreDestroy      替换 XML 元素 或 DisposableBean     2.5\n\nSpring BeanDefinition 解析与注册\n\nSPRING 注解       场景说明                             起始版本\nXML 资源          XmlBeanDefinitionReader          1.0\nProperties 资源   PropertiesBeanDefinitionReader   1.0\nJava 注解         AnnotatedBeanDefinitionReader    3.0\n\n\n# Spring Bean 配置元信息底层实现\n\n\n# Spring XML 资源 BeanDefinition 解析与注册\n\n核心 API - XmlBeanDefinitionReader\n\n * 资源 - Resource\n * 底层 - BeanDefinitionDocumentReader\n   * XML 解析 - Java DOM Level 3 API\n   * BeanDefinition 解析 - BeanDefinitionParserDelegate\n   * BeanDefinition 注册 - BeanDefinitionRegistry\n\n\n# Spring Properties 资源 BeanDefinition 解析与注册\n\n核心 API - PropertiesBeanDefinitionReader\n\n * 资源\n   * 字节流 - Resource\n   * 字符流 - EncodedResouce\n * 底层\n   * 存储 - java.util.Properties\n   * BeanDefinition 解析 - API 内部实现\n   * BeanDefinition 注册 - BeanDefinitionRegistry\n\n\n# Spring Java 注册 BeanDefinition 解析与注册\n\n核心 API - AnnotatedBeanDefinitionReader\n\n * 资源\n   * 类对象 - java.lang.Class\n * 底层\n   * 条件评估 - ConditionEvaluator\n   * Bean 范围解析 - ScopeMetadataResolver\n   * BeanDefinition 解析 - 内部 API 实现\n   * BeanDefinition 处理 - AnnotationConfigUtils.processCommonDefinitionAnnotations\n   * BeanDefinition 注册 - BeanDefinitionRegistry\n\n\n# 基于 XML 文件装载 Spring IoC 容器配置元信息\n\nSpring IoC 容器相关 XML 配置\n\n命名空间      所属模块             SCHEMA 资源 URL\nbeans     spring-beans     https://www.springframework.org/schema/beans/spring-beans.xsd\ncontext   spring-context   https://www.springframework.org/schema/context/spring-context.xsd\naop       spring-aop       https://www.springframework.org/schema/aop/spring-aop.xsd\ntx        spring-tx        https://www.springframework.org/schema/tx/spring-tx.xsd\nutil      spring-beans     beans\n                           https://www.springframework.org/schema/util/spring-util.xsd\ntool      spring-beans     https://www.springframework.org/schema/tool/spring-tool.xsd\n\n\n# 基于 Java 注解装载 Spring IoC 容器配置元信息\n\nSpring IoC 容器装配注解\n\nSPRING 注解         场景说明                             起始版本\n@ImportResource   替换 XML 元素 <import>               3.0\n@Import           导入 Configuration Class           3.0\n@ComponentScan    扫描指定 package 下标注 Spring 模式注解的类   3.1\n\nSpring IoC 配属属性注解\n\nSPRING 注解          场景说明                       起始版本\n@PropertySource    配置属性抽象 PropertySource 注解   3.1\n@PropertySources   @PropertySource 集合注解       4.0\n\n\n# 基于 Extensible XML authoring 扩展 SpringXML 元素\n\nSpring XML 扩展\n\n * 编写 XML Schema 文件：定义 XML 结构\n * 自定义 NamespaceHandler 实现：命名空间绑定\n * 自定义 BeanDefinitionParser 实现：XML 元素与 BeanDefinition 解析\n * 注册 XML 扩展：命名空间与 XML Schema 映射\n\n\n# Extensible XML authoring 扩展原理\n\n\n# 触发时机\n\n * AbstractApplicationContext#obtainFreshBeanFactory\n   * AbstractRefreshableApplicationContext#refreshBeanFactory\n     * AbstractXmlApplicationContext#loadBeanDefinitions\n       * ...\n         * XmlBeanDefinitionReader#doLoadBeanDefinitions\n           * ...\n             * BeanDefinitionParserDelegate#parseCustomElement\n\n\n# 核心流程\n\nBeanDefinitionParserDelegate#parseCustomElement(org.w3c.dom.Element, BeanDefinition)\n\n * 获取 namespace\n * 通过 namespace 解析 NamespaceHandler\n * 构造 ParserContext\n * 解析元素，获取 BeanDefinintion\n\n\n# 基于 Properties 文件装载外部化配置\n\n注解驱动\n\n * @org.springframework.context.annotation.PropertySource\n * @org.springframework.context.annotation.PropertySources\n\nAPI 编程\n\n * org.springframework.core.env.PropertySource\n * org.springframework.core.env.PropertySources\n\n\n# 基于 YAML 文件装载外部化配置\n\nAPI 编程\n\n * org.springframework.beans.factory.config.YamlProcessor\n   * org.springframework.beans.factory.config.YamlMapFactoryBean\n   * org.springframework.beans.factory.config.YamlPropertiesFactoryBean\n\n\n# 问题\n\nSpring 內建 XML Schema 常见有哪些？\n\n命名空间      所属模块             SCHEMA 资源 URL\nbeans     spring-beans     https://www.springframework.org/schema/beans/spring-beans.xsd\ncontext   spring-context   https://www.springframework.org/schema/context/spring-context.xsd\naop       spring-aop       https://www.springframework.org/schema/aop/spring-aop.xsd\ntx        spring-tx        https://www.springframework.org/schema/tx/spring-tx.xsd\nutil      spring-beans     beans\n                           https://www.springframework.org/schema/util/spring-util.xsd\ntool      spring-beans     https://www.springframework.org/schema/tool/spring-tool.xsd\n\nSpring 配置元信息具体有哪些？\n\n * Bean 配置元信息：通过媒介（如 XML、Proeprties 等），解析 BeanDefinition\n * IoC 容器配置元信息：通过媒介（如 XML、Proeprties 等），控制 IoC 容器行为，比如注解驱动、AOP 等\n * 外部化配置：通过资源抽象（如 Proeprties、YAML 等），控制 PropertySource\n * Spring Profile：通过外部化配置，提供条件分支流程\n\nExtensible XML authoring 的缺点？\n\n * 高复杂度：开发人员需要熟悉 XML Schema，spring.handlers，spring.schemas 以及 Spring API\n * 嵌套元素支持较弱：通常需要使用方法递归或者其嵌套解析的方式处理嵌套（子）元素\n * XML 处理性能较差：Spring XML 基于 DOM Level 3 API 实现，该 API 便于理解，然而性能较差\n * XML 框架移植性差：很难适配高性能和便利性的 XML 框架，如 JAXB\n\n\n# 参考资料\n\n * Spring 官方文档之 Core Technologies\n * 《小马哥讲 Spring 核心编程思想》',normalizedContent:'# spring 配置元数据\n\n\n# spring 配置元信息\n\n * spring bean 配置元信息 - beandefinition\n * spring bean 属性元信息 - propertyvalues\n * spring 容器配置元信息\n * spring 外部化配置元信息 - propertysource\n * spring profile 元信息 - @profile\n\n\n# spring bean 配置元信息\n\nbean 配置元信息 - beandefinition\n\n * genericbeandefinition：通用型 beandefinition\n * rootbeandefinition：无 parent 的 beandefinition 或者合并后 beandefinition\n * annotatedbeandefinition：注解标注的 beandefinition\n\n\n# spring bean 属性元信息\n\n * bean 属性元信息 - propertyvalues\n   * 可修改实现 - mutablepropertyvalues\n   * 元素成员 - propertyvalue\n * bean 属性上下文存储 - attributeaccessor\n * bean 元信息元素 - beanmetadataelement\n\n\n# spring 容器配置元信息\n\nspring xml 配置元信息 - beans 元素相关\n\nbeans 元素属性                    默认值        使用场景\nprofile                       null（留空）   spring profiles 配置值\ndefault-lazy-init             default    当 outter beans “default-lazy-init” 属性存在时，继承该值，否则为“false”\ndefault-merge                 default    当 outter beans “default-merge” 属性存在时，继承该值，否则为“false”\ndefault-autowire              default    当 outter beans “default-autowire” 属性存在时，继承该值，否则为“no”\ndefault-autowire-candidates   null（留空）   默认 spring beans 名称 pattern\ndefault-init-method           null（留空）   默认 spring beans 自定义初始化方法\ndefault-destroy-method        null（留空）   默认 spring beans 自定义销毁方法\n\nspring xml 配置元信息 - 应用上下文相关\n\nxml 元素                             使用场景\n<context:annotation-config />      激活 spring 注解驱动\n<context:component-scan />         spring @component 以及自定义注解扫描\n<context:load-time-weaver />       激活 spring loadtimeweaver\n<context:mbean-export />           暴露 spring beans 作为 jmx beans\n<context:mbean-server />           将当前平台作为 mbeanserver\n<context:property-placeholder />   加载外部化配置资源作为 spring 属性配\n<context:property-override />      利用外部化配置资源覆盖 spring 属\n\n\n# 基于 xml 文件装载 spring bean 配置元信息\n\n底层实现 - xmlbeandefinitionreader\n\nxml 元素             使用场景\n<beans:beans />    单 xml 资源下的多个 spring beans 配置\n<beans:bean />     单个 spring bean 定义（beandefinition）配置\n<beans:alias />    为 spring bean 定义（beandefinition）映射别名\n<beans:import />   加载外部 spring xml 配置资源\n\n\n# 基于 properties 文件装载 spring bean 配置元信息\n\n底层实现 - propertiesbeandefinitionreader\n\nproperties 属性名   使用场景\nclass            bean 类全称限定名\nabstract         是否为抽象的 beandefinition\nparent           指定 parent beandefinition 名称\nlazy-init        是否为延迟初始化\nref              引用其他 bean 的名称\nscope            设置 bean 的 scope 属性\n${n}             n 表示第 n+1 个构造器参数\n\n\n# 基于 java 注解装载 spring bean 配置元信息\n\nspring 模式注解\n\nspring 注解        场景说明          起始版本\n@repository      数据仓储模式注解      2.0\n@component       通用组件模式注解      2.5\n@service         服务模式注解        2.5\n@controller      web 控制器模式注解   2.5\n@configuration   配置类模式注解       3.0\n\nspring bean 定义注解\n\nspring 注解    场景说明                                           起始版本\n@bean        替换 xml 元素 <bean>                               3.0\n@dependson   替代 xml 属性 <bean depends-on="..."/>             3.0\n@lazy        替代 xml 属性 <bean lazy-init="true | falses" />   3.0\n@primary     替换 xml 元素 <bean primary="true | false" />      3.0\n@role        替换 xml 元素 <bean role="..." />                  3.1\n@lookup      替代 xml 属性 <bean lookup-method="...">           4.1\n\nspring bean 依赖注入注解\n\nspring 注解    场景说明                   起始版本\n@autowired   bean 依赖注入，支持多种依赖查找方式   2.5\n@qualifier   细粒度的 @autowired 依赖查找   2.5\n\njava 注解     场景说明             起始版本\n@resource   类似于 @autowired   2.5\n@inject     类似于 @autowired   2.5\n\nspring bean 条件装配注解\n\nspring 注解      场景说明      起始版本\n@profile       配置化条件装配   3.1\n@conditional   编程条件装配    4.0\n\nspring bean 生命周期回调注解\n\nspring 注解        场景说明                           起始版本\n@postconstruct   替换 xml 元素 或 initializingbean   2.5\n@predestroy      替换 xml 元素 或 disposablebean     2.5\n\nspring beandefinition 解析与注册\n\nspring 注解       场景说明                             起始版本\nxml 资源          xmlbeandefinitionreader          1.0\nproperties 资源   propertiesbeandefinitionreader   1.0\njava 注解         annotatedbeandefinitionreader    3.0\n\n\n# spring bean 配置元信息底层实现\n\n\n# spring xml 资源 beandefinition 解析与注册\n\n核心 api - xmlbeandefinitionreader\n\n * 资源 - resource\n * 底层 - beandefinitiondocumentreader\n   * xml 解析 - java dom level 3 api\n   * beandefinition 解析 - beandefinitionparserdelegate\n   * beandefinition 注册 - beandefinitionregistry\n\n\n# spring properties 资源 beandefinition 解析与注册\n\n核心 api - propertiesbeandefinitionreader\n\n * 资源\n   * 字节流 - resource\n   * 字符流 - encodedresouce\n * 底层\n   * 存储 - java.util.properties\n   * beandefinition 解析 - api 内部实现\n   * beandefinition 注册 - beandefinitionregistry\n\n\n# spring java 注册 beandefinition 解析与注册\n\n核心 api - annotatedbeandefinitionreader\n\n * 资源\n   * 类对象 - java.lang.class\n * 底层\n   * 条件评估 - conditionevaluator\n   * bean 范围解析 - scopemetadataresolver\n   * beandefinition 解析 - 内部 api 实现\n   * beandefinition 处理 - annotationconfigutils.processcommondefinitionannotations\n   * beandefinition 注册 - beandefinitionregistry\n\n\n# 基于 xml 文件装载 spring ioc 容器配置元信息\n\nspring ioc 容器相关 xml 配置\n\n命名空间      所属模块             schema 资源 url\nbeans     spring-beans     https://www.springframework.org/schema/beans/spring-beans.xsd\ncontext   spring-context   https://www.springframework.org/schema/context/spring-context.xsd\naop       spring-aop       https://www.springframework.org/schema/aop/spring-aop.xsd\ntx        spring-tx        https://www.springframework.org/schema/tx/spring-tx.xsd\nutil      spring-beans     beans\n                           https://www.springframework.org/schema/util/spring-util.xsd\ntool      spring-beans     https://www.springframework.org/schema/tool/spring-tool.xsd\n\n\n# 基于 java 注解装载 spring ioc 容器配置元信息\n\nspring ioc 容器装配注解\n\nspring 注解         场景说明                             起始版本\n@importresource   替换 xml 元素 <import>               3.0\n@import           导入 configuration class           3.0\n@componentscan    扫描指定 package 下标注 spring 模式注解的类   3.1\n\nspring ioc 配属属性注解\n\nspring 注解          场景说明                       起始版本\n@propertysource    配置属性抽象 propertysource 注解   3.1\n@propertysources   @propertysource 集合注解       4.0\n\n\n# 基于 extensible xml authoring 扩展 springxml 元素\n\nspring xml 扩展\n\n * 编写 xml schema 文件：定义 xml 结构\n * 自定义 namespacehandler 实现：命名空间绑定\n * 自定义 beandefinitionparser 实现：xml 元素与 beandefinition 解析\n * 注册 xml 扩展：命名空间与 xml schema 映射\n\n\n# extensible xml authoring 扩展原理\n\n\n# 触发时机\n\n * abstractapplicationcontext#obtainfreshbeanfactory\n   * abstractrefreshableapplicationcontext#refreshbeanfactory\n     * abstractxmlapplicationcontext#loadbeandefinitions\n       * ...\n         * xmlbeandefinitionreader#doloadbeandefinitions\n           * ...\n             * beandefinitionparserdelegate#parsecustomelement\n\n\n# 核心流程\n\nbeandefinitionparserdelegate#parsecustomelement(org.w3c.dom.element, beandefinition)\n\n * 获取 namespace\n * 通过 namespace 解析 namespacehandler\n * 构造 parsercontext\n * 解析元素，获取 beandefinintion\n\n\n# 基于 properties 文件装载外部化配置\n\n注解驱动\n\n * @org.springframework.context.annotation.propertysource\n * @org.springframework.context.annotation.propertysources\n\napi 编程\n\n * org.springframework.core.env.propertysource\n * org.springframework.core.env.propertysources\n\n\n# 基于 yaml 文件装载外部化配置\n\napi 编程\n\n * org.springframework.beans.factory.config.yamlprocessor\n   * org.springframework.beans.factory.config.yamlmapfactorybean\n   * org.springframework.beans.factory.config.yamlpropertiesfactorybean\n\n\n# 问题\n\nspring 內建 xml schema 常见有哪些？\n\n命名空间      所属模块             schema 资源 url\nbeans     spring-beans     https://www.springframework.org/schema/beans/spring-beans.xsd\ncontext   spring-context   https://www.springframework.org/schema/context/spring-context.xsd\naop       spring-aop       https://www.springframework.org/schema/aop/spring-aop.xsd\ntx        spring-tx        https://www.springframework.org/schema/tx/spring-tx.xsd\nutil      spring-beans     beans\n                           https://www.springframework.org/schema/util/spring-util.xsd\ntool      spring-beans     https://www.springframework.org/schema/tool/spring-tool.xsd\n\nspring 配置元信息具体有哪些？\n\n * bean 配置元信息：通过媒介（如 xml、proeprties 等），解析 beandefinition\n * ioc 容器配置元信息：通过媒介（如 xml、proeprties 等），控制 ioc 容器行为，比如注解驱动、aop 等\n * 外部化配置：通过资源抽象（如 proeprties、yaml 等），控制 propertysource\n * spring profile：通过外部化配置，提供条件分支流程\n\nextensible xml authoring 的缺点？\n\n * 高复杂度：开发人员需要熟悉 xml schema，spring.handlers，spring.schemas 以及 spring api\n * 嵌套元素支持较弱：通常需要使用方法递归或者其嵌套解析的方式处理嵌套（子）元素\n * xml 处理性能较差：spring xml 基于 dom level 3 api 实现，该 api 便于理解，然而性能较差\n * xml 框架移植性差：很难适配高性能和便利性的 xml 框架，如 jaxb\n\n\n# 参考资料\n\n * spring 官方文档之 core technologies\n * 《小马哥讲 spring 核心编程思想》',charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Spring 应用上下文生命周期",frontmatter:{title:"Spring 应用上下文生命周期",date:"2022-12-23T09:58:09.000Z",order:"09",categories:["Java","框架","Spring","Spring核心"],tags:["Java","框架","Spring"],permalink:"/pages/ad472e/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/01.Spring%E6%A0%B8%E5%BF%83/09.Spring%E5%BA%94%E7%94%A8%E4%B8%8A%E4%B8%8B%E6%96%87%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html",relativePath:"01.Java/13.框架/01.Spring/01.Spring核心/09.Spring应用上下文生命周期.md",key:"v-3fdf0214",path:"/pages/ad472e/",headers:[{level:2,title:"Spring 应用上下文启动准备阶段",slug:"spring-应用上下文启动准备阶段",normalizedTitle:"spring 应用上下文启动准备阶段",charIndex:23},{level:2,title:"BeanFactory 创建阶段",slug:"beanfactory-创建阶段",normalizedTitle:"beanfactory 创建阶段",charIndex:260},{level:2,title:"BeanFactory 准备阶段",slug:"beanfactory-准备阶段",normalizedTitle:"beanfactory 准备阶段",charIndex:813},{level:2,title:"BeanFactory 后置处理阶段",slug:"beanfactory-后置处理阶段",normalizedTitle:"beanfactory 后置处理阶段",charIndex:1351},{level:2,title:"BeanFactory 注册 BeanPostProcessor 阶段",slug:"beanfactory-注册-beanpostprocessor-阶段",normalizedTitle:"beanfactory 注册 beanpostprocessor 阶段",charIndex:1680},{level:2,title:"初始化內建 Bean：MessageSource",slug:"初始化內建-bean-messagesource",normalizedTitle:"初始化內建 bean：messagesource",charIndex:2019},{level:2,title:"初始化內建 Bean：Spring 事件广播器",slug:"初始化內建-bean-spring-事件广播器",normalizedTitle:"初始化內建 bean：spring 事件广播器",charIndex:2099},{level:2,title:"Spring 应用上下文刷新阶段",slug:"spring-应用上下文刷新阶段",normalizedTitle:"spring 应用上下文刷新阶段",charIndex:2192},{level:2,title:"Spring 事件监听器注册阶段",slug:"spring-事件监听器注册阶段",normalizedTitle:"spring 事件监听器注册阶段",charIndex:2721},{level:2,title:"BeanFactory 初始化完成阶段",slug:"beanfactory-初始化完成阶段",normalizedTitle:"beanfactory 初始化完成阶段",charIndex:2904},{level:2,title:"Spring 应用上下刷新完成阶段",slug:"spring-应用上下刷新完成阶段",normalizedTitle:"spring 应用上下刷新完成阶段",charIndex:3221},{level:2,title:"Spring 应用上下文启动阶段",slug:"spring-应用上下文启动阶段",normalizedTitle:"spring 应用上下文启动阶段",charIndex:3525},{level:2,title:"Spring 应用上下文停止阶段",slug:"spring-应用上下文停止阶段",normalizedTitle:"spring 应用上下文停止阶段",charIndex:3707},{level:2,title:"Spring 应用上下文关闭阶段",slug:"spring-应用上下文关闭阶段",normalizedTitle:"spring 应用上下文关闭阶段",charIndex:3888},{level:2,title:"问题",slug:"问题",normalizedTitle:"问题",charIndex:4290},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:4519}],headersStr:"Spring 应用上下文启动准备阶段 BeanFactory 创建阶段 BeanFactory 准备阶段 BeanFactory 后置处理阶段 BeanFactory 注册 BeanPostProcessor 阶段 初始化內建 Bean：MessageSource 初始化內建 Bean：Spring 事件广播器 Spring 应用上下文刷新阶段 Spring 事件监听器注册阶段 BeanFactory 初始化完成阶段 Spring 应用上下刷新完成阶段 Spring 应用上下文启动阶段 Spring 应用上下文停止阶段 Spring 应用上下文关闭阶段 问题 参考资料",content:"# Spring 应用上下文生命周期\n\n\n# Spring 应用上下文启动准备阶段\n\nAbstractApplicationContext#prepareRefresh() 方法\n\n * 启动时间 - startupDate\n * 状态标识 - closed(false)、active(true)\n * 初始化 PropertySources - initPropertySources()\n * 检验 Environment 中必须属性\n * 初始化事件监听器集合\n * 初始化早期 Spring 事件集合\n\n\n# BeanFactory 创建阶段\n\nAbstractApplicationContext#obtainFreshBeanFactory() 方法\n\n * 刷新 Spring 应用上下文底层 BeanFactory - refreshBeanFactory()\n   * 销毁或关闭 BeanFactory，如果已存在的话\n   * 创建 BeanFactory - createBeanFactory()\n   * 设置 BeanFactory Id\n   * 设置“是否允许 BeanDefinition 重复定义” - customizeBeanFactory(DefaultListableBeanFactory)\n   * 设置“是否允许循环引用（依赖）” - customizeBeanFactory(DefaultListableBeanFactory)\n   * 加载 BeanDefinition - loadBeanDefinitions(DefaultListableBeanFactory) 方法\n   * 关联新建 BeanFactory 到 Spring 应用上下文\n * 返回 Spring 应用上下文底层 BeanFactory - getBeanFactory()\n\n\n# BeanFactory 准备阶段\n\nAbstractApplicationContext#prepareBeanFactory(ConfigurableListableBeanFactory) 方法\n\n * 关联 ClassLoader\n * 设置 Bean 表达式处理器\n * 添加 PropertyEditorRegistrar 实现 - ResourceEditorRegistrar\n * 添加 Aware 回调接口 BeanPostProcessor 实现 - ApplicationContextAwareProcessor\n * 忽略 Aware 回调接口作为依赖注入接口\n * 注册 ResolvableDependency 对象 - BeanFactory、ResourceLoader、ApplicationEventPublisher 以及 ApplicationContext\n * 注册 ApplicationListenerDetector 对象\n * 注册 LoadTimeWeaverAwareProcessor 对象\n * 注册单例对象 - Environment、Java System Properties 以及 OS 环境变量\n\n\n# BeanFactory 后置处理阶段\n\n * AbstractApplicationContext#postProcessBeanFactory(ConfigurableListableBeanFactory) 方法\n   * 由子类覆盖该方法\n * AbstractApplicationContext#invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory 方法\n   * 调用 BeanFactoryPostProcessor 或 BeanDefinitionRegistry 后置处理方法\n   * 注册 LoadTimeWeaverAwareProcessor 对象\n\n\n# BeanFactory 注册 BeanPostProcessor 阶段\n\nAbstractApplicationContext#registerBeanPostProcessors(ConfigurableListableBeanFactory) 方法\n\n * 注册 PriorityOrdered 类型的 BeanPostProcessor Beans\n * 注册 Ordered 类型的 BeanPostProcessor Beans\n * 注册普通 BeanPostProcessor Beans\n * 注册 MergedBeanDefinitionPostProcessor Beans\n * 注册 ApplicationListenerDetector 对象\n\n\n# 初始化內建 Bean：MessageSource\n\nAbstractApplicationContext#initMessageSource() 方法\n\n\n# 初始化內建 Bean：Spring 事件广播器\n\nAbstractApplicationContext#initApplicationEventMulticaster() 方法\n\n\n# Spring 应用上下文刷新阶段\n\nAbstractApplicationContext#onRefresh() 方法\n\n子类覆盖该方法\n\n * org.springframework.web.context.support.AbstractRefreshableWebApplicationContext#onRefresh()\n * org.springframework.web.context.support.GenericWebApplicationContext#onRefresh()\n * org.springframework.boot.web.reactive.context.ReactiveWebServerApplicationContext#onRefresh()\n * org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext#onRefresh()\n * org.springframework.web.context.support.StaticWebApplicationContext#onRefresh()\n\n\n# Spring 事件监听器注册阶段\n\nAbstractApplicationContext#registerListeners() 方法\n\n * 添加当前应用上下文所关联的 ApplicationListener 对象（集合）\n * 添加 BeanFactory 所注册 ApplicationListener Beans\n * 广播早期 Spring 事件\n\n\n# BeanFactory 初始化完成阶段\n\nAbstractApplicationContext#finishBeanFactoryInitialization(ConfigurableListableBeanFactory) 方法\n\n * BeanFactory 关联 ConversionService Bean，如果存在\n * 添加 StringValueResolver 对象\n * 依赖查找 LoadTimeWeaverAware Bean\n * BeanFactory 临时 ClassLoader 置为 null\n * BeanFactory 冻结配置\n * BeanFactory 初始化非延迟单例 Beans\n\n\n# Spring 应用上下刷新完成阶段\n\nAbstractApplicationContext#finishRefresh() 方法\n\n * 清除 ResourceLoader 缓存 - clearResourceCaches() @since 5.0\n * 初始化 LifecycleProcessor 对象 - initLifecycleProcessor()\n * 调用 LifecycleProcessor#onRefresh() 方法\n * 发布 Spring 应用上下文已刷新事件 - ContextRefreshedEvent\n * 向 MBeanServer 托管 Live Beans\n\n\n# Spring 应用上下文启动阶段\n\nAbstractApplicationContext#start() 方法\n\n * 启动 LifecycleProcessor\n   * 依赖查找 Lifecycle Beans\n   * 启动 Lifecycle Beans\n * 发布 Spring 应用上下文已启动事件 - ContextStartedEvent\n\n\n# Spring 应用上下文停止阶段\n\nAbstractApplicationContext#stop() 方法\n\n * 停止 LifecycleProcessor\n   * 依赖查找 Lifecycle Beans\n   * 停止 Lifecycle Beans\n * 发布 Spring 应用上下文已停止事件 - ContextStoppedEvent\n\n\n# Spring 应用上下文关闭阶段\n\nAbstractApplicationContext#close() 方法\n\n * 状态标识：active(false)、closed(true)\n * Live Beans JMX 撤销托管\n   * LiveBeansView.unregisterApplicationContext(ConfigurableApplicationContext)\n * 发布 Spring 应用上下文已关闭事件 - ContextClosedEvent\n * 关闭 LifecycleProcessor\n   * 依赖查找 Lifecycle Beans\n   * 停止 Lifecycle Beans\n * 销毁 Spring Beans\n * 关闭 BeanFactory\n * 回调 onClose()\n * 注册 Shutdown Hook 线程（如果曾注册）\n\n\n# 问题\n\nSpring 应用上下文生命周期有哪些阶段？\n\n * 刷新阶段 - ConfigurableApplicationContext#refresh()\n * 启动阶段 - ConfigurableApplicationContext#start()\n * 停止阶段 - ConfigurableApplicationContext#stop()\n * 关闭阶段 - ConfigurableApplicationContext#close()\n\n\n# 参考资料\n\n * Spring 官方文档之 Core Technologies\n * 《小马哥讲 Spring 核心编程思想》",normalizedContent:"# spring 应用上下文生命周期\n\n\n# spring 应用上下文启动准备阶段\n\nabstractapplicationcontext#preparerefresh() 方法\n\n * 启动时间 - startupdate\n * 状态标识 - closed(false)、active(true)\n * 初始化 propertysources - initpropertysources()\n * 检验 environment 中必须属性\n * 初始化事件监听器集合\n * 初始化早期 spring 事件集合\n\n\n# beanfactory 创建阶段\n\nabstractapplicationcontext#obtainfreshbeanfactory() 方法\n\n * 刷新 spring 应用上下文底层 beanfactory - refreshbeanfactory()\n   * 销毁或关闭 beanfactory，如果已存在的话\n   * 创建 beanfactory - createbeanfactory()\n   * 设置 beanfactory id\n   * 设置“是否允许 beandefinition 重复定义” - customizebeanfactory(defaultlistablebeanfactory)\n   * 设置“是否允许循环引用（依赖）” - customizebeanfactory(defaultlistablebeanfactory)\n   * 加载 beandefinition - loadbeandefinitions(defaultlistablebeanfactory) 方法\n   * 关联新建 beanfactory 到 spring 应用上下文\n * 返回 spring 应用上下文底层 beanfactory - getbeanfactory()\n\n\n# beanfactory 准备阶段\n\nabstractapplicationcontext#preparebeanfactory(configurablelistablebeanfactory) 方法\n\n * 关联 classloader\n * 设置 bean 表达式处理器\n * 添加 propertyeditorregistrar 实现 - resourceeditorregistrar\n * 添加 aware 回调接口 beanpostprocessor 实现 - applicationcontextawareprocessor\n * 忽略 aware 回调接口作为依赖注入接口\n * 注册 resolvabledependency 对象 - beanfactory、resourceloader、applicationeventpublisher 以及 applicationcontext\n * 注册 applicationlistenerdetector 对象\n * 注册 loadtimeweaverawareprocessor 对象\n * 注册单例对象 - environment、java system properties 以及 os 环境变量\n\n\n# beanfactory 后置处理阶段\n\n * abstractapplicationcontext#postprocessbeanfactory(configurablelistablebeanfactory) 方法\n   * 由子类覆盖该方法\n * abstractapplicationcontext#invokebeanfactorypostprocessors(configurablelistablebeanfactory 方法\n   * 调用 beanfactorypostprocessor 或 beandefinitionregistry 后置处理方法\n   * 注册 loadtimeweaverawareprocessor 对象\n\n\n# beanfactory 注册 beanpostprocessor 阶段\n\nabstractapplicationcontext#registerbeanpostprocessors(configurablelistablebeanfactory) 方法\n\n * 注册 priorityordered 类型的 beanpostprocessor beans\n * 注册 ordered 类型的 beanpostprocessor beans\n * 注册普通 beanpostprocessor beans\n * 注册 mergedbeandefinitionpostprocessor beans\n * 注册 applicationlistenerdetector 对象\n\n\n# 初始化內建 bean：messagesource\n\nabstractapplicationcontext#initmessagesource() 方法\n\n\n# 初始化內建 bean：spring 事件广播器\n\nabstractapplicationcontext#initapplicationeventmulticaster() 方法\n\n\n# spring 应用上下文刷新阶段\n\nabstractapplicationcontext#onrefresh() 方法\n\n子类覆盖该方法\n\n * org.springframework.web.context.support.abstractrefreshablewebapplicationcontext#onrefresh()\n * org.springframework.web.context.support.genericwebapplicationcontext#onrefresh()\n * org.springframework.boot.web.reactive.context.reactivewebserverapplicationcontext#onrefresh()\n * org.springframework.boot.web.servlet.context.servletwebserverapplicationcontext#onrefresh()\n * org.springframework.web.context.support.staticwebapplicationcontext#onrefresh()\n\n\n# spring 事件监听器注册阶段\n\nabstractapplicationcontext#registerlisteners() 方法\n\n * 添加当前应用上下文所关联的 applicationlistener 对象（集合）\n * 添加 beanfactory 所注册 applicationlistener beans\n * 广播早期 spring 事件\n\n\n# beanfactory 初始化完成阶段\n\nabstractapplicationcontext#finishbeanfactoryinitialization(configurablelistablebeanfactory) 方法\n\n * beanfactory 关联 conversionservice bean，如果存在\n * 添加 stringvalueresolver 对象\n * 依赖查找 loadtimeweaveraware bean\n * beanfactory 临时 classloader 置为 null\n * beanfactory 冻结配置\n * beanfactory 初始化非延迟单例 beans\n\n\n# spring 应用上下刷新完成阶段\n\nabstractapplicationcontext#finishrefresh() 方法\n\n * 清除 resourceloader 缓存 - clearresourcecaches() @since 5.0\n * 初始化 lifecycleprocessor 对象 - initlifecycleprocessor()\n * 调用 lifecycleprocessor#onrefresh() 方法\n * 发布 spring 应用上下文已刷新事件 - contextrefreshedevent\n * 向 mbeanserver 托管 live beans\n\n\n# spring 应用上下文启动阶段\n\nabstractapplicationcontext#start() 方法\n\n * 启动 lifecycleprocessor\n   * 依赖查找 lifecycle beans\n   * 启动 lifecycle beans\n * 发布 spring 应用上下文已启动事件 - contextstartedevent\n\n\n# spring 应用上下文停止阶段\n\nabstractapplicationcontext#stop() 方法\n\n * 停止 lifecycleprocessor\n   * 依赖查找 lifecycle beans\n   * 停止 lifecycle beans\n * 发布 spring 应用上下文已停止事件 - contextstoppedevent\n\n\n# spring 应用上下文关闭阶段\n\nabstractapplicationcontext#close() 方法\n\n * 状态标识：active(false)、closed(true)\n * live beans jmx 撤销托管\n   * livebeansview.unregisterapplicationcontext(configurableapplicationcontext)\n * 发布 spring 应用上下文已关闭事件 - contextclosedevent\n * 关闭 lifecycleprocessor\n   * 依赖查找 lifecycle beans\n   * 停止 lifecycle beans\n * 销毁 spring beans\n * 关闭 beanfactory\n * 回调 onclose()\n * 注册 shutdown hook 线程（如果曾注册）\n\n\n# 问题\n\nspring 应用上下文生命周期有哪些阶段？\n\n * 刷新阶段 - configurableapplicationcontext#refresh()\n * 启动阶段 - configurableapplicationcontext#start()\n * 停止阶段 - configurableapplicationcontext#stop()\n * 关闭阶段 - configurableapplicationcontext#close()\n\n\n# 参考资料\n\n * spring 官方文档之 core technologies\n * 《小马哥讲 spring 核心编程思想》",charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Spring AOP",frontmatter:{title:"Spring AOP",date:"2020-02-26T23:47:47.000Z",order:10,categories:["Java","框架","Spring","Spring核心"],tags:["Java","框架","Spring","AOP"],permalink:"/pages/53aedb/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/01.Spring%E6%A0%B8%E5%BF%83/10.SpringAop.html",relativePath:"01.Java/13.框架/01.Spring/01.Spring核心/10.SpringAop.md",key:"v-95b1a28a",path:"/pages/53aedb/",headers:[{level:2,title:"AOP 概念",slug:"aop-概念",normalizedTitle:"aop 概念",charIndex:17},{level:3,title:"什么是 AOP",slug:"什么是-aop",normalizedTitle:"什么是 aop",charIndex:28},{level:3,title:"术语",slug:"术语",normalizedTitle:"术语",charIndex:208},{level:4,title:"Aspect(切面)",slug:"aspect-切面",normalizedTitle:"aspect(切面)",charIndex:193},{level:4,title:"advice(增强)",slug:"advice-增强",normalizedTitle:"advice(增强)",charIndex:480},{level:4,title:"连接点(join point)",slug:"连接点-join-point",normalizedTitle:"连接点(join point)",charIndex:832},{level:4,title:"切点(point cut)",slug:"切点-point-cut",normalizedTitle:"切点(point cut)",charIndex:1114},{level:4,title:"关于 join point 和 point cut 的区别",slug:"关于-join-point-和-point-cut-的区别",normalizedTitle:"关于 join point 和 point cut 的区别",charIndex:1424},{level:4,title:"introduction",slug:"introduction",normalizedTitle:"introduction",charIndex:1697},{level:4,title:"目标对象(Target)",slug:"目标对象-target",normalizedTitle:"目标对象(target)",charIndex:1839},{level:4,title:"AOP proxy",slug:"aop-proxy",normalizedTitle:"aop proxy",charIndex:2028},{level:4,title:"织入(Weaving)",slug:"织入-weaving",normalizedTitle:"织入(weaving)",charIndex:2144},{level:3,title:"advice 的类型",slug:"advice-的类型",normalizedTitle:"advice 的类型",charIndex:2365},{level:3,title:"关于 AOP Proxy",slug:"关于-aop-proxy",normalizedTitle:"关于 aop proxy",charIndex:2811},{level:3,title:"彻底理解 aspect, join point, point cut, advice",slug:"彻底理解-aspect-join-point-point-cut-advice",normalizedTitle:"彻底理解 aspect, join point, point cut, advice",charIndex:3113},{level:2,title:"@AspectJ 支持",slug:"aspectj-支持",normalizedTitle:"@aspectj 支持",charIndex:4839},{level:3,title:"使能 @AspectJ 支持",slug:"使能-aspectj-支持",normalizedTitle:"使能 @aspectj 支持",charIndex:4980},{level:4,title:"使用 Java Configuration 方式使能@AspectJ",slug:"使用-java-configuration-方式使能-aspectj",normalizedTitle:"使用 java configuration 方式使能@aspectj",charIndex:5093},{level:4,title:"使用 XML 方式使能@AspectJ",slug:"使用-xml-方式使能-aspectj",normalizedTitle:"使用 xml 方式使能@aspectj",charIndex:5199},{level:3,title:"定义 aspect(切面)",slug:"定义-aspect-切面",normalizedTitle:"定义 aspect(切面)",charIndex:5250},{level:3,title:"声明 pointcut",slug:"声明-pointcut",normalizedTitle:"声明 pointcut",charIndex:5576},{level:4,title:"切点标志符(designator)",slug:"切点标志符-designator",normalizedTitle:"切点标志符(designator)",charIndex:6017},{level:5,title:"execution",slug:"execution",normalizedTitle:"execution",charIndex:870},{level:5,title:"within",slug:"within",normalizedTitle:"within",charIndex:6276},{level:5,title:"this 与 target",slug:"this-与-target",normalizedTitle:"this 与 target",charIndex:6446},{level:5,title:"bean",slug:"bean",normalizedTitle:"bean",charIndex:1793},{level:5,title:"args",slug:"args",normalizedTitle:"args",charIndex:6760},{level:5,title:"@annotation",slug:"annotation",normalizedTitle:"@annotation",charIndex:7769},{level:4,title:"常见的切点表达式",slug:"常见的切点表达式",normalizedTitle:"常见的切点表达式",charIndex:7913},{level:5,title:"匹配方法签名",slug:"匹配方法签名",normalizedTitle:"匹配方法签名",charIndex:7925},{level:5,title:"匹配类型签名",slug:"匹配类型签名",normalizedTitle:"匹配类型签名",charIndex:8305},{level:5,title:"匹配 Bean 名字",slug:"匹配-bean-名字",normalizedTitle:"匹配 bean 名字",charIndex:8498},{level:5,title:"切点表达式组合",slug:"切点表达式组合",normalizedTitle:"切点表达式组合",charIndex:8555},{level:3,title:"声明 advice",slug:"声明-advice",normalizedTitle:"声明 advice",charIndex:8733},{level:4,title:"Before advice",slug:"before-advice",normalizedTitle:"before advice",charIndex:8918},{level:4,title:"around advice",slug:"around-advice",normalizedTitle:"around advice",charIndex:2732},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:10705}],headersStr:"AOP 概念 什么是 AOP 术语 Aspect(切面) advice(增强) 连接点(join point) 切点(point cut) 关于 join point 和 point cut 的区别 introduction 目标对象(Target) AOP proxy 织入(Weaving) advice 的类型 关于 AOP Proxy 彻底理解 aspect, join point, point cut, advice @AspectJ 支持 使能 @AspectJ 支持 使用 Java Configuration 方式使能@AspectJ 使用 XML 方式使能@AspectJ 定义 aspect(切面) 声明 pointcut 切点标志符(designator) execution within this 与 target bean args @annotation 常见的切点表达式 匹配方法签名 匹配类型签名 匹配 Bean 名字 切点表达式组合 声明 advice Before advice around advice 参考资料",content:'# Spring AOP\n\n\n# AOP 概念\n\n\n# 什么是 AOP\n\nAOP(Aspect-Oriented Programming，即 面向切面编程)与 OOP( Object-Oriented Programming，面向对象编程) 相辅相成，提供了与 OOP 不同的抽象软件结构的视角。\n\n在 OOP 中，我们以类(class)作为我们的基本单元，而 AOP 中的基本单元是 Aspect(切面)\n\n\n# 术语\n\n# Aspect(切面)\n\naspect 由 pointcount 和 advice 组成, 它既包含了横切逻辑的定义, 也包括了连接点的定义. Spring AOP 就是负责实施切面的框架, 它将切面所定义的横切逻辑织入到切面所指定的连接点中. AOP 的工作重心在于如何将增强织入目标对象的连接点上, 这里包含两个工作:\n\n 1. 如何通过 pointcut 和 advice 定位到特定的 joinpoint 上\n 2. 如何在 advice 中编写切面代码.\n\n可以简单地认为, 使用 @Aspect 注解的类就是切面.\n\n# advice(增强)\n\n由 aspect 添加到特定的 join point(即满足 point cut 规则的 join point) 的一段代码. 许多 AOP 框架, 包括 Spring AOP, 会将 advice 模拟为一个拦截器(interceptor), 并且在 join point 上维护多个 advice, 进行层层拦截. 例如 HTTP 鉴权的实现, 我们可以为每个使用 RequestMapping 标注的方法织入 advice, 当 HTTP 请求到来时, 首先进入到 advice 代码中, 在这里我们可以分析这个 HTTP 请求是否有相应的权限, 如果有, 则执行 Controller, 如果没有, 则抛出异常. 这里的 advice 就扮演着鉴权拦截器的角色了.\n\n# 连接点(join point)\n\n> a point during the execution of a program, such as the execution of a method or the handling of an exception. In Spring AOP, a join point always represents a method execution.\n\n程序运行中的一些时间点, 例如一个方法的执行, 或者是一个异常的处理. 在 Spring AOP 中, join point 总是方法的执行点, 即只有方法连接点.\n\n# 切点(point cut)\n\n匹配 join point 的谓词(a predicate that matches join points). Advice 是和特定的 point cut 关联的, 并且在 point cut 相匹配的 join point 中执行. 在 Spring 中, 所有的方法都可以认为是 joinpoint, 但是我们并不希望在所有的方法上都添加 Advice, 而 pointcut 的作用就是提供一组规则(使用 AspectJ pointcut expression language 来描述) 来匹配joinpoint, 给满足规则的 joinpoint 添加 Advice.\n\n# 关于 join point 和 point cut 的区别\n\n在 Spring AOP 中, 所有的方法执行都是 join point. 而 point cut 是一个描述信息, 它修饰的是 join point, 通过 point cut, 我们就可以确定哪些 join point 可以被织入 Advice. 因此 join point 和 point cut 本质上就是两个不同纬度上的东西. advice 是在 join point 上执行的, 而 point cut 规定了哪些 join point 可以执行哪些 advice\n\n# introduction\n\n为一个类型添加额外的方法或字段. Spring AOP 允许我们为 目标对象 引入新的接口(和对应的实现). 例如我们可以使用 introduction 来为一个 bean 实现 IsModified 接口, 并以此来简化 caching 的实现.\n\n# 目标对象(Target)\n\n织入 advice 的目标对象. 目标对象也被称为 advised object. 因为 Spring AOP 使用运行时代理的方式来实现 aspect, 因此 adviced object 总是一个代理对象(proxied object) 注意, adviced object 指的不是原来的类, 而是织入 advice 后所产生的代理类.\n\n# AOP proxy\n\n一个类被 AOP 织入 advice, 就会产生一个结果类, 它是融合了原类和增强逻辑的代理类. 在 Spring AOP 中, 一个 AOP 代理是一个 JDK 动态代理对象或 CGLIB 代理对象.\n\n# 织入(Weaving)\n\n将 aspect 和其他对象连接起来, 并创建 adviced object 的过程. 根据不同的实现技术, AOP 织入有三种方式:\n\n * 编译器织入, 这要求有特殊的 Java 编译器.\n * 类装载期织入, 这需要有特殊的类装载器.\n * 动态代理织入, 在运行期为目标类添加增强(Advice)生成子类的方式. Spring 采用动态代理织入, 而 AspectJ 采用编译器织入和类装载期织入.\n\n\n# advice 的类型\n\n * before advice, 在 join point 前被执行的 advice. 虽然 before advice 是在 join point 前被执行, 但是它并不能够阻止 join point 的执行, 除非发生了异常(即我们在 before advice 代码中, 不能人为地决定是否继续执行 join point 中的代码)\n * after return advice, 在一个 join point 正常返回后执行的 advice\n * after throwing advice, 当一个 join point 抛出异常后执行的 advice\n * after(final) advice, 无论一个 join point 是正常退出还是发生了异常, 都会被执行的 advice.\n * around advice, 在 join point 前和 joint point 退出后都执行的 advice. 这个是最常用的 advice.\n\n\n# 关于 AOP Proxy\n\nSpring AOP 默认使用标准的 JDK 动态代理(dynamic proxy)技术来实现 AOP 代理, 通过它, 我们可以为任意的接口实现代理. 如果需要为一个类实现代理, 那么可以使用 CGLIB 代理. 当一个业务逻辑对象没有实现接口时, 那么 Spring AOP 就默认使用 CGLIB 来作为 AOP 代理了. 即如果我们需要为一个方法织入 advice, 但是这个方法不是一个接口所提供的方法, 则此时 Spring AOP 会使用 CGLIB 来实现动态代理. 鉴于此, Spring AOP 建议基于接口编程, 对接口进行 AOP 而不是类.\n\n\n# 彻底理解 aspect, join point, point cut, advice\n\n看完了上面的理论部分知识, 我相信还是会有不少朋友感觉到 AOP 的概念还是很模糊, 对 AOP 中的各种概念理解的还不是很透彻. 其实这很正常, 因为 AOP 中的概念是在是太多了, 我当时也是花了老大劲才梳理清楚的. 下面我以一个简单的例子来比喻一下 AOP 中 aspect, jointpoint, pointcut 与 advice 之间的关系.\n\n让我们来假设一下, 从前有一个叫爪哇的小县城, 在一个月黑风高的晚上, 这个县城中发生了命案. 作案的凶手十分狡猾, 现场没有留下什么有价值的线索. 不过万幸的是, 刚从隔壁回来的老王恰好在这时候无意中发现了凶手行凶的过程, 但是由于天色已晚, 加上凶手蒙着面, 老王并没有看清凶手的面目, 只知道凶手是个男性, 身高约七尺五寸. 爪哇县的县令根据老王的描述, 对守门的士兵下命令说: 凡是发现有身高七尺五寸的男性, 都要抓过来审问. 士兵当然不敢违背县令的命令, 只好把进出城的所有符合条件的人都抓了起来.\n\n来让我们看一下上面的一个小故事和 AOP 到底有什么对应关系. 首先我们知道, 在 Spring AOP 中 join point 指代的是所有方法的执行点, 而 point cut 是一个描述信息, 它修饰的是 join point, 通过 point cut, 我们就可以确定哪些 join point 可以被织入 Advice. 对应到我们在上面举的例子, 我们可以做一个简单的类比, join point 就相当于 爪哇的小县城里的百姓, point cut 就相当于 老王所做的指控, 即凶手是个男性, 身高约七尺五寸, 而 advice 则是施加在符合老王所描述的嫌疑人的动作: 抓过来审问. 为什么可以这样类比呢?\n\n * join point --\x3e 爪哇的小县城里的百姓: 因为根据定义, join point 是所有可能被织入 advice 的候选的点, 在 Spring AOP 中, 则可以认为所有方法执行点都是 join point. 而在我们上面的例子中, 命案发生在小县城中, 按理说在此县城中的所有人都有可能是嫌疑人.\n * point cut --\x3e 男性, 身高约七尺五寸: 我们知道, 所有的方法(joint point) 都可以织入 advice, 但是我们并不希望在所有方法上都织入 advice, 而 pointcut 的作用就是提供一组规则来匹配 joinpoint, 给满足规则的 joinpoint 添加 advice. 同理, 对于县令来说, 他再昏庸, 也知道不能把县城中的所有百姓都抓起来审问, 而是根据凶手是个男性, 身高约七尺五寸, 把符合条件的人抓起来. 在这里凶手是个男性, 身高约七尺五寸 就是一个修饰谓语, 它限定了凶手的范围, 满足此修饰规则的百姓都是嫌疑人, 都需要抓起来审问.\n * advice --\x3e 抓过来审问, advice 是一个动作, 即一段 Java 代码, 这段 Java 代码是作用于 point cut 所限定的那些 join point 上的. 同理, 对比到我们的例子中, 抓过来审问 这个动作就是对作用于那些满足 男性, 身高约七尺五寸 的爪哇的小县城里的百姓.\n * aspect: aspect 是 point cut 与 advice 的组合, 因此在这里我们就可以类比: "根据老王的线索, 凡是发现有身高七尺五寸的男性, 都要抓过来审问" 这一整个动作可以被认为是一个 aspect.\n\n或则我们也可以从语法的角度来简单类比一下. 我们在学英语时, 经常会接触什么 定语, 被动句 之类的概念, 那么可以做一个不严谨的类比, 即 joinpoint 可以认为是一个 宾语, 而 pointcut 则可以类比为修饰 joinpoint 的定语, 那么整个 aspect 就可以描述为: 满足 pointcut 规则的 joinpoint 会被添加相应的 advice 操作.\n\n\n# @AspectJ 支持\n\n@AspectJ 是一种使用 Java 注解来实现 AOP 的编码风格。\n\n@AspectJ 风格的 AOP 是 AspectJ Project 在 AspectJ 5 中引入的, 并且 Spring 也支持 @AspectJ 的 AOP 风格.\n\n\n# 使能 @AspectJ 支持\n\n@AspectJ 可以以 XML 的方式或以注解的方式来使能, 并且不论以哪种方式使能@ASpectJ, 我们都必须保证 aspectjweaver.jar 在 classpath 中.\n\n# 使用 Java Configuration 方式使能@AspectJ\n\n@Configuration\n@EnableAspectJAutoProxy\npublic class AppConfig {\n}\n\n\n# 使用 XML 方式使能@AspectJ\n\n<aop:aspectj-autoproxy/>\n\n\n\n# 定义 aspect(切面)\n\n当使用注解 @Aspect 标注一个 Bean 后, 那么 Spring 框架会自动收集这些 Bean, 并添加到 Spring AOP 中, 例如:\n\n@Component\n@Aspect\npublic class MyTest {\n}\n\n\n注意, 仅仅使用@Aspect 注解, 并不能将一个 Java 对象转换为 Bean, 因此我们还需要使用类似 @Component 之类的注解. 注意, 如果一个 类被@Aspect 标注, 则这个类就不能是其他 aspect 的 **advised object** 了, 因为使用 @Aspect 后, 这个类就会被排除在 auto-proxying 机制之外.\n\n\n# 声明 pointcut\n\n一个 pointcut 的声明由两部分组成:\n\n * 一个方法签名, 包括方法名和相关参数\n * 一个 pointcut 表达式, 用来指定哪些方法执行是我们感兴趣的(即因此可以织入 advice).\n\n在@AspectJ 风格的 AOP 中, 我们使用一个方法来描述 pointcut, 即:\n\n@Pointcut("execution(* com.xys.service.UserService.*(..))") // 切点表达式\nprivate void dataAccessOperation() {} // 切点前面\n\n\n这个方法必须无返回值. 这个方法本身就是 pointcut signature, pointcut 表达式使用@Pointcut 注解指定. 上面我们简单地定义了一个 pointcut, 这个 pointcut 所描述的是: 匹配所有在包 com.xys.service.UserService 下的所有方法的执行.\n\n# 切点标志符(designator)\n\nAspectJ5 的切点表达式由标志符(designator)和操作参数组成. 如 "execution(* greetTo(..))" 的切点表达式, **execution** 就是 标志符, 而圆括号里的 *****greetTo(..) 就是操作参数\n\n# execution\n\n匹配 join point 的执行, 例如 "execution(* hello(..))" 表示匹配所有目标类中的 hello() 方法. 这个是最基本的 pointcut 标志符.\n\n# within\n\n匹配特定包下的所有 join point, 例如 within(com.xys.*) 表示 com.xys 包中的所有连接点, 即包中的所有类的所有方法. 而within(com.xys.service.*Service) 表示在 com.xys.service 包中所有以 Service 结尾的类的所有的连接点.\n\n# this 与 target\n\nthis 的作用是匹配一个 bean, 这个 bean(Spring AOP proxy) 是一个给定类型的实例(instance of). 而 target 匹配的是一个目标对象(target object, 即需要织入 advice 的原始的类), 此对象是一个给定类型的实例(instance of).\n\n# bean\n\n匹配 bean 名字为指定值的 bean 下的所有方法, 例如:\n\nbean(*Service) // 匹配名字后缀为 Service 的 bean 下的所有方法\nbean(myService) // 匹配名字为 myService 的 bean 下的所有方法\n\n\n# args\n\n匹配参数满足要求的的方法. 例如:\n\n@Pointcut("within(com.xys.demo2.*)")\npublic void pointcut2() {\n}\n\n@Before(value = "pointcut2()  &&  args(name)")\npublic void doSomething(String name) {\n    logger.info("---page: {}---", name);\n}\n\n\n@Service\npublic class NormalService {\n    private Logger logger = LoggerFactory.getLogger(getClass());\n\n    public void someMethod() {\n        logger.info("---NormalService: someMethod invoked---");\n    }\n\n    public String test(String name) {\n        logger.info("---NormalService: test invoked---");\n        return "服务一切正常";\n    }\n}\n\n\n当 NormalService.test 执行时, 则 advice doSomething 就会执行, test 方法的参数 name 就会传递到 doSomething 中.\n\n常用例子:\n\n// 匹配只有一个参数 name 的方法\n@Before(value = "aspectMethod()  &&  args(name)")\npublic void doSomething(String name) {\n}\n\n// 匹配第一个参数为 name 的方法\n@Before(value = "aspectMethod()  &&  args(name, ..)")\npublic void doSomething(String name) {\n}\n\n// 匹配第二个参数为 name 的方法\nBefore(value = "aspectMethod()  &&  args(*, name, ..)")\npublic void doSomething(String name) {\n}\n\n\n# @annotation\n\n匹配由指定注解所标注的方法, 例如:\n\n@Pointcut("@annotation(com.xys.demo1.AuthChecker)")\npublic void pointcut() {\n}\n\n\n则匹配由注解 AuthChecker 所标注的方法.\n\n# 常见的切点表达式\n\n# 匹配方法签名\n\n// 匹配指定包中的所有的方法\nexecution(* com.xys.service.*(..))\n\n// 匹配当前包中的指定类的所有方法\nexecution(* UserService.*(..))\n\n// 匹配指定包中的所有 public 方法\nexecution(public * com.xys.service.*(..))\n\n// 匹配指定包中的所有 public 方法, 并且返回值是 int 类型的方法\nexecution(public int com.xys.service.*(..))\n\n// 匹配指定包中的所有 public 方法, 并且第一个参数是 String, 返回值是 int 类型的方法\nexecution(public int com.xys.service.*(String name, ..))\n\n\n# 匹配类型签名\n\n// 匹配指定包中的所有的方法, 但不包括子包\nwithin(com.xys.service.*)\n\n// 匹配指定包中的所有的方法, 包括子包\nwithin(com.xys.service..*)\n\n// 匹配当前包中的指定类中的方法\nwithin(UserService)\n\n\n// 匹配一个接口的所有实现类中的实现的方法\nwithin(UserDao+)\n\n\n# 匹配 Bean 名字\n\n// 匹配以指定名字结尾的 Bean 中的所有方法\nbean(*Service)\n\n\n# 切点表达式组合\n\n// 匹配以 Service 或 ServiceImpl 结尾的 bean\nbean(*Service || *ServiceImpl)\n\n// 匹配名字以 Service 结尾, 并且在包 com.xys.service 中的 bean\nbean(*Service) && within(com.xys.service.*)\n\n\n\n# 声明 advice\n\nadvice 是和一个 pointcut 表达式关联在一起的, 并且会在匹配的 join point 的方法执行的前/后/周围 运行. pointcut 表达式可以是简单的一个 pointcut 名字的引用, 或者是完整的 pointcut 表达式. 下面我们以几个简单的 advice 为例子, 来看一下一个 advice 是如何声明的.\n\n# Before advice\n\n/**\n * @author xiongyongshun\n * @version 1.0\n * @created 16/9/9 13:13\n */\n@Component\n@Aspect\npublic class BeforeAspectTest {\n    // 定义一个 Pointcut, 使用 切点表达式函数 来描述对哪些 Join point 使用 advise.\n    @Pointcut("execution(* com.xys.service.UserService.*(..))")\n    public void dataAccessOperation() {\n    }\n}\n\n\n@Component\n@Aspect\npublic class AdviseDefine {\n    // 定义 advise\n    @Before("com.xys.aspect.PointcutDefine.dataAccessOperation()")\n    public void doBeforeAccessCheck(JoinPoint joinPoint) {\n        System.out.println("*****Before advise, method: " + joinPoint.getSignature().toShortString() + " *****");\n    }\n}\n\n\n这里, @Before 引用了一个 pointcut, 即 "com.xys.aspect.PointcutDefine.dataAccessOperation()" 是一个 pointcut 的名字. 如果我们在 advice 在内置 pointcut, 则可以:\n\n@Component\n@Aspect\npublic class AdviseDefine {\n    // 将 pointcut 和 advice 同时定义\n    @Before("within(com.xys.service..*)")\n    public void doAccessCheck(JoinPoint joinPoint) {\n        System.out.println("*****doAccessCheck, Before advise, method: " + joinPoint.getSignature().toShortString() + " *****");\n    }\n}\n\n\n# around advice\n\naround advice 比较特别, 它可以在一个方法的之前之前和之后添加不同的操作, 并且甚至可以决定何时, 如何, 是否调用匹配到的方法.\n\n@Component\n@Aspect\npublic class AdviseDefine {\n    // 定义 advise\n    @Around("com.xys.aspect.PointcutDefine.dataAccessOperation()")\n    public Object doAroundAccessCheck(ProceedingJoinPoint pjp) throws Throwable {\n        StopWatch stopWatch = new StopWatch();\n        stopWatch.start();\n        // 开始\n        Object retVal = pjp.proceed();\n        stopWatch.stop();\n        // 结束\n        System.out.println("invoke method: " + pjp.getSignature().getName() + ", elapsed time: " + stopWatch.getTotalTimeMillis());\n        return retVal;\n    }\n}\n\n\naround advice 和前面的 before advice 差不多, 只是我们把注解 @Before 改为了 @Around 了.\n\n\n# 参考资料\n\n * 《 Spring 实战（第 4 版）》',normalizedContent:'# spring aop\n\n\n# aop 概念\n\n\n# 什么是 aop\n\naop(aspect-oriented programming，即 面向切面编程)与 oop( object-oriented programming，面向对象编程) 相辅相成，提供了与 oop 不同的抽象软件结构的视角。\n\n在 oop 中，我们以类(class)作为我们的基本单元，而 aop 中的基本单元是 aspect(切面)\n\n\n# 术语\n\n# aspect(切面)\n\naspect 由 pointcount 和 advice 组成, 它既包含了横切逻辑的定义, 也包括了连接点的定义. spring aop 就是负责实施切面的框架, 它将切面所定义的横切逻辑织入到切面所指定的连接点中. aop 的工作重心在于如何将增强织入目标对象的连接点上, 这里包含两个工作:\n\n 1. 如何通过 pointcut 和 advice 定位到特定的 joinpoint 上\n 2. 如何在 advice 中编写切面代码.\n\n可以简单地认为, 使用 @aspect 注解的类就是切面.\n\n# advice(增强)\n\n由 aspect 添加到特定的 join point(即满足 point cut 规则的 join point) 的一段代码. 许多 aop 框架, 包括 spring aop, 会将 advice 模拟为一个拦截器(interceptor), 并且在 join point 上维护多个 advice, 进行层层拦截. 例如 http 鉴权的实现, 我们可以为每个使用 requestmapping 标注的方法织入 advice, 当 http 请求到来时, 首先进入到 advice 代码中, 在这里我们可以分析这个 http 请求是否有相应的权限, 如果有, 则执行 controller, 如果没有, 则抛出异常. 这里的 advice 就扮演着鉴权拦截器的角色了.\n\n# 连接点(join point)\n\n> a point during the execution of a program, such as the execution of a method or the handling of an exception. in spring aop, a join point always represents a method execution.\n\n程序运行中的一些时间点, 例如一个方法的执行, 或者是一个异常的处理. 在 spring aop 中, join point 总是方法的执行点, 即只有方法连接点.\n\n# 切点(point cut)\n\n匹配 join point 的谓词(a predicate that matches join points). advice 是和特定的 point cut 关联的, 并且在 point cut 相匹配的 join point 中执行. 在 spring 中, 所有的方法都可以认为是 joinpoint, 但是我们并不希望在所有的方法上都添加 advice, 而 pointcut 的作用就是提供一组规则(使用 aspectj pointcut expression language 来描述) 来匹配joinpoint, 给满足规则的 joinpoint 添加 advice.\n\n# 关于 join point 和 point cut 的区别\n\n在 spring aop 中, 所有的方法执行都是 join point. 而 point cut 是一个描述信息, 它修饰的是 join point, 通过 point cut, 我们就可以确定哪些 join point 可以被织入 advice. 因此 join point 和 point cut 本质上就是两个不同纬度上的东西. advice 是在 join point 上执行的, 而 point cut 规定了哪些 join point 可以执行哪些 advice\n\n# introduction\n\n为一个类型添加额外的方法或字段. spring aop 允许我们为 目标对象 引入新的接口(和对应的实现). 例如我们可以使用 introduction 来为一个 bean 实现 ismodified 接口, 并以此来简化 caching 的实现.\n\n# 目标对象(target)\n\n织入 advice 的目标对象. 目标对象也被称为 advised object. 因为 spring aop 使用运行时代理的方式来实现 aspect, 因此 adviced object 总是一个代理对象(proxied object) 注意, adviced object 指的不是原来的类, 而是织入 advice 后所产生的代理类.\n\n# aop proxy\n\n一个类被 aop 织入 advice, 就会产生一个结果类, 它是融合了原类和增强逻辑的代理类. 在 spring aop 中, 一个 aop 代理是一个 jdk 动态代理对象或 cglib 代理对象.\n\n# 织入(weaving)\n\n将 aspect 和其他对象连接起来, 并创建 adviced object 的过程. 根据不同的实现技术, aop 织入有三种方式:\n\n * 编译器织入, 这要求有特殊的 java 编译器.\n * 类装载期织入, 这需要有特殊的类装载器.\n * 动态代理织入, 在运行期为目标类添加增强(advice)生成子类的方式. spring 采用动态代理织入, 而 aspectj 采用编译器织入和类装载期织入.\n\n\n# advice 的类型\n\n * before advice, 在 join point 前被执行的 advice. 虽然 before advice 是在 join point 前被执行, 但是它并不能够阻止 join point 的执行, 除非发生了异常(即我们在 before advice 代码中, 不能人为地决定是否继续执行 join point 中的代码)\n * after return advice, 在一个 join point 正常返回后执行的 advice\n * after throwing advice, 当一个 join point 抛出异常后执行的 advice\n * after(final) advice, 无论一个 join point 是正常退出还是发生了异常, 都会被执行的 advice.\n * around advice, 在 join point 前和 joint point 退出后都执行的 advice. 这个是最常用的 advice.\n\n\n# 关于 aop proxy\n\nspring aop 默认使用标准的 jdk 动态代理(dynamic proxy)技术来实现 aop 代理, 通过它, 我们可以为任意的接口实现代理. 如果需要为一个类实现代理, 那么可以使用 cglib 代理. 当一个业务逻辑对象没有实现接口时, 那么 spring aop 就默认使用 cglib 来作为 aop 代理了. 即如果我们需要为一个方法织入 advice, 但是这个方法不是一个接口所提供的方法, 则此时 spring aop 会使用 cglib 来实现动态代理. 鉴于此, spring aop 建议基于接口编程, 对接口进行 aop 而不是类.\n\n\n# 彻底理解 aspect, join point, point cut, advice\n\n看完了上面的理论部分知识, 我相信还是会有不少朋友感觉到 aop 的概念还是很模糊, 对 aop 中的各种概念理解的还不是很透彻. 其实这很正常, 因为 aop 中的概念是在是太多了, 我当时也是花了老大劲才梳理清楚的. 下面我以一个简单的例子来比喻一下 aop 中 aspect, jointpoint, pointcut 与 advice 之间的关系.\n\n让我们来假设一下, 从前有一个叫爪哇的小县城, 在一个月黑风高的晚上, 这个县城中发生了命案. 作案的凶手十分狡猾, 现场没有留下什么有价值的线索. 不过万幸的是, 刚从隔壁回来的老王恰好在这时候无意中发现了凶手行凶的过程, 但是由于天色已晚, 加上凶手蒙着面, 老王并没有看清凶手的面目, 只知道凶手是个男性, 身高约七尺五寸. 爪哇县的县令根据老王的描述, 对守门的士兵下命令说: 凡是发现有身高七尺五寸的男性, 都要抓过来审问. 士兵当然不敢违背县令的命令, 只好把进出城的所有符合条件的人都抓了起来.\n\n来让我们看一下上面的一个小故事和 aop 到底有什么对应关系. 首先我们知道, 在 spring aop 中 join point 指代的是所有方法的执行点, 而 point cut 是一个描述信息, 它修饰的是 join point, 通过 point cut, 我们就可以确定哪些 join point 可以被织入 advice. 对应到我们在上面举的例子, 我们可以做一个简单的类比, join point 就相当于 爪哇的小县城里的百姓, point cut 就相当于 老王所做的指控, 即凶手是个男性, 身高约七尺五寸, 而 advice 则是施加在符合老王所描述的嫌疑人的动作: 抓过来审问. 为什么可以这样类比呢?\n\n * join point --\x3e 爪哇的小县城里的百姓: 因为根据定义, join point 是所有可能被织入 advice 的候选的点, 在 spring aop 中, 则可以认为所有方法执行点都是 join point. 而在我们上面的例子中, 命案发生在小县城中, 按理说在此县城中的所有人都有可能是嫌疑人.\n * point cut --\x3e 男性, 身高约七尺五寸: 我们知道, 所有的方法(joint point) 都可以织入 advice, 但是我们并不希望在所有方法上都织入 advice, 而 pointcut 的作用就是提供一组规则来匹配 joinpoint, 给满足规则的 joinpoint 添加 advice. 同理, 对于县令来说, 他再昏庸, 也知道不能把县城中的所有百姓都抓起来审问, 而是根据凶手是个男性, 身高约七尺五寸, 把符合条件的人抓起来. 在这里凶手是个男性, 身高约七尺五寸 就是一个修饰谓语, 它限定了凶手的范围, 满足此修饰规则的百姓都是嫌疑人, 都需要抓起来审问.\n * advice --\x3e 抓过来审问, advice 是一个动作, 即一段 java 代码, 这段 java 代码是作用于 point cut 所限定的那些 join point 上的. 同理, 对比到我们的例子中, 抓过来审问 这个动作就是对作用于那些满足 男性, 身高约七尺五寸 的爪哇的小县城里的百姓.\n * aspect: aspect 是 point cut 与 advice 的组合, 因此在这里我们就可以类比: "根据老王的线索, 凡是发现有身高七尺五寸的男性, 都要抓过来审问" 这一整个动作可以被认为是一个 aspect.\n\n或则我们也可以从语法的角度来简单类比一下. 我们在学英语时, 经常会接触什么 定语, 被动句 之类的概念, 那么可以做一个不严谨的类比, 即 joinpoint 可以认为是一个 宾语, 而 pointcut 则可以类比为修饰 joinpoint 的定语, 那么整个 aspect 就可以描述为: 满足 pointcut 规则的 joinpoint 会被添加相应的 advice 操作.\n\n\n# @aspectj 支持\n\n@aspectj 是一种使用 java 注解来实现 aop 的编码风格。\n\n@aspectj 风格的 aop 是 aspectj project 在 aspectj 5 中引入的, 并且 spring 也支持 @aspectj 的 aop 风格.\n\n\n# 使能 @aspectj 支持\n\n@aspectj 可以以 xml 的方式或以注解的方式来使能, 并且不论以哪种方式使能@aspectj, 我们都必须保证 aspectjweaver.jar 在 classpath 中.\n\n# 使用 java configuration 方式使能@aspectj\n\n@configuration\n@enableaspectjautoproxy\npublic class appconfig {\n}\n\n\n# 使用 xml 方式使能@aspectj\n\n<aop:aspectj-autoproxy/>\n\n\n\n# 定义 aspect(切面)\n\n当使用注解 @aspect 标注一个 bean 后, 那么 spring 框架会自动收集这些 bean, 并添加到 spring aop 中, 例如:\n\n@component\n@aspect\npublic class mytest {\n}\n\n\n注意, 仅仅使用@aspect 注解, 并不能将一个 java 对象转换为 bean, 因此我们还需要使用类似 @component 之类的注解. 注意, 如果一个 类被@aspect 标注, 则这个类就不能是其他 aspect 的 **advised object** 了, 因为使用 @aspect 后, 这个类就会被排除在 auto-proxying 机制之外.\n\n\n# 声明 pointcut\n\n一个 pointcut 的声明由两部分组成:\n\n * 一个方法签名, 包括方法名和相关参数\n * 一个 pointcut 表达式, 用来指定哪些方法执行是我们感兴趣的(即因此可以织入 advice).\n\n在@aspectj 风格的 aop 中, 我们使用一个方法来描述 pointcut, 即:\n\n@pointcut("execution(* com.xys.service.userservice.*(..))") // 切点表达式\nprivate void dataaccessoperation() {} // 切点前面\n\n\n这个方法必须无返回值. 这个方法本身就是 pointcut signature, pointcut 表达式使用@pointcut 注解指定. 上面我们简单地定义了一个 pointcut, 这个 pointcut 所描述的是: 匹配所有在包 com.xys.service.userservice 下的所有方法的执行.\n\n# 切点标志符(designator)\n\naspectj5 的切点表达式由标志符(designator)和操作参数组成. 如 "execution(* greetto(..))" 的切点表达式, **execution** 就是 标志符, 而圆括号里的 *****greetto(..) 就是操作参数\n\n# execution\n\n匹配 join point 的执行, 例如 "execution(* hello(..))" 表示匹配所有目标类中的 hello() 方法. 这个是最基本的 pointcut 标志符.\n\n# within\n\n匹配特定包下的所有 join point, 例如 within(com.xys.*) 表示 com.xys 包中的所有连接点, 即包中的所有类的所有方法. 而within(com.xys.service.*service) 表示在 com.xys.service 包中所有以 service 结尾的类的所有的连接点.\n\n# this 与 target\n\nthis 的作用是匹配一个 bean, 这个 bean(spring aop proxy) 是一个给定类型的实例(instance of). 而 target 匹配的是一个目标对象(target object, 即需要织入 advice 的原始的类), 此对象是一个给定类型的实例(instance of).\n\n# bean\n\n匹配 bean 名字为指定值的 bean 下的所有方法, 例如:\n\nbean(*service) // 匹配名字后缀为 service 的 bean 下的所有方法\nbean(myservice) // 匹配名字为 myservice 的 bean 下的所有方法\n\n\n# args\n\n匹配参数满足要求的的方法. 例如:\n\n@pointcut("within(com.xys.demo2.*)")\npublic void pointcut2() {\n}\n\n@before(value = "pointcut2()  &&  args(name)")\npublic void dosomething(string name) {\n    logger.info("---page: {}---", name);\n}\n\n\n@service\npublic class normalservice {\n    private logger logger = loggerfactory.getlogger(getclass());\n\n    public void somemethod() {\n        logger.info("---normalservice: somemethod invoked---");\n    }\n\n    public string test(string name) {\n        logger.info("---normalservice: test invoked---");\n        return "服务一切正常";\n    }\n}\n\n\n当 normalservice.test 执行时, 则 advice dosomething 就会执行, test 方法的参数 name 就会传递到 dosomething 中.\n\n常用例子:\n\n// 匹配只有一个参数 name 的方法\n@before(value = "aspectmethod()  &&  args(name)")\npublic void dosomething(string name) {\n}\n\n// 匹配第一个参数为 name 的方法\n@before(value = "aspectmethod()  &&  args(name, ..)")\npublic void dosomething(string name) {\n}\n\n// 匹配第二个参数为 name 的方法\nbefore(value = "aspectmethod()  &&  args(*, name, ..)")\npublic void dosomething(string name) {\n}\n\n\n# @annotation\n\n匹配由指定注解所标注的方法, 例如:\n\n@pointcut("@annotation(com.xys.demo1.authchecker)")\npublic void pointcut() {\n}\n\n\n则匹配由注解 authchecker 所标注的方法.\n\n# 常见的切点表达式\n\n# 匹配方法签名\n\n// 匹配指定包中的所有的方法\nexecution(* com.xys.service.*(..))\n\n// 匹配当前包中的指定类的所有方法\nexecution(* userservice.*(..))\n\n// 匹配指定包中的所有 public 方法\nexecution(public * com.xys.service.*(..))\n\n// 匹配指定包中的所有 public 方法, 并且返回值是 int 类型的方法\nexecution(public int com.xys.service.*(..))\n\n// 匹配指定包中的所有 public 方法, 并且第一个参数是 string, 返回值是 int 类型的方法\nexecution(public int com.xys.service.*(string name, ..))\n\n\n# 匹配类型签名\n\n// 匹配指定包中的所有的方法, 但不包括子包\nwithin(com.xys.service.*)\n\n// 匹配指定包中的所有的方法, 包括子包\nwithin(com.xys.service..*)\n\n// 匹配当前包中的指定类中的方法\nwithin(userservice)\n\n\n// 匹配一个接口的所有实现类中的实现的方法\nwithin(userdao+)\n\n\n# 匹配 bean 名字\n\n// 匹配以指定名字结尾的 bean 中的所有方法\nbean(*service)\n\n\n# 切点表达式组合\n\n// 匹配以 service 或 serviceimpl 结尾的 bean\nbean(*service || *serviceimpl)\n\n// 匹配名字以 service 结尾, 并且在包 com.xys.service 中的 bean\nbean(*service) && within(com.xys.service.*)\n\n\n\n# 声明 advice\n\nadvice 是和一个 pointcut 表达式关联在一起的, 并且会在匹配的 join point 的方法执行的前/后/周围 运行. pointcut 表达式可以是简单的一个 pointcut 名字的引用, 或者是完整的 pointcut 表达式. 下面我们以几个简单的 advice 为例子, 来看一下一个 advice 是如何声明的.\n\n# before advice\n\n/**\n * @author xiongyongshun\n * @version 1.0\n * @created 16/9/9 13:13\n */\n@component\n@aspect\npublic class beforeaspecttest {\n    // 定义一个 pointcut, 使用 切点表达式函数 来描述对哪些 join point 使用 advise.\n    @pointcut("execution(* com.xys.service.userservice.*(..))")\n    public void dataaccessoperation() {\n    }\n}\n\n\n@component\n@aspect\npublic class advisedefine {\n    // 定义 advise\n    @before("com.xys.aspect.pointcutdefine.dataaccessoperation()")\n    public void dobeforeaccesscheck(joinpoint joinpoint) {\n        system.out.println("*****before advise, method: " + joinpoint.getsignature().toshortstring() + " *****");\n    }\n}\n\n\n这里, @before 引用了一个 pointcut, 即 "com.xys.aspect.pointcutdefine.dataaccessoperation()" 是一个 pointcut 的名字. 如果我们在 advice 在内置 pointcut, 则可以:\n\n@component\n@aspect\npublic class advisedefine {\n    // 将 pointcut 和 advice 同时定义\n    @before("within(com.xys.service..*)")\n    public void doaccesscheck(joinpoint joinpoint) {\n        system.out.println("*****doaccesscheck, before advise, method: " + joinpoint.getsignature().toshortstring() + " *****");\n    }\n}\n\n\n# around advice\n\naround advice 比较特别, 它可以在一个方法的之前之前和之后添加不同的操作, 并且甚至可以决定何时, 如何, 是否调用匹配到的方法.\n\n@component\n@aspect\npublic class advisedefine {\n    // 定义 advise\n    @around("com.xys.aspect.pointcutdefine.dataaccessoperation()")\n    public object doaroundaccesscheck(proceedingjoinpoint pjp) throws throwable {\n        stopwatch stopwatch = new stopwatch();\n        stopwatch.start();\n        // 开始\n        object retval = pjp.proceed();\n        stopwatch.stop();\n        // 结束\n        system.out.println("invoke method: " + pjp.getsignature().getname() + ", elapsed time: " + stopwatch.gettotaltimemillis());\n        return retval;\n    }\n}\n\n\naround advice 和前面的 before advice 差不多, 只是我们把注解 @before 改为了 @around 了.\n\n\n# 参考资料\n\n * 《 spring 实战（第 4 版）》',charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Spring 资源管理",frontmatter:{title:"Spring 资源管理",date:"2019-09-04T19:46:41.000Z",order:20,categories:["Java","框架","Spring","Spring核心"],tags:["Java","框架","Spring","Resource"],permalink:"/pages/a1549f/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/01.Spring%E6%A0%B8%E5%BF%83/20.Spring%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86.html",relativePath:"01.Java/13.框架/01.Spring/01.Spring核心/20.Spring资源管理.md",key:"v-7bfb01a8",path:"/pages/a1549f/",headers:[{level:2,title:"Resource 接口",slug:"resource-接口",normalizedTitle:"resource 接口",charIndex:35},{level:2,title:"内置的 Resource 实现",slug:"内置的-resource-实现",normalizedTitle:"内置的 resource 实现",charIndex:1403},{level:2,title:"ResourceLoader 接口",slug:"resourceloader-接口",normalizedTitle:"resourceloader 接口",charIndex:2964},{level:2,title:"ResourcePatternResolver 接口",slug:"resourcepatternresolver-接口",normalizedTitle:"resourcepatternresolver 接口",charIndex:4099},{level:2,title:"ResourceLoaderAware 接口",slug:"resourceloaderaware-接口",normalizedTitle:"resourceloaderaware 接口",charIndex:4743},{level:2,title:"资源依赖",slug:"资源依赖",normalizedTitle:"资源依赖",charIndex:5654},{level:2,title:"应用上下文和资源路径",slug:"应用上下文和资源路径",normalizedTitle:"应用上下文和资源路径",charIndex:7137},{level:3,title:"构造应用上下文",slug:"构造应用上下文",normalizedTitle:"构造应用上下文",charIndex:7152},{level:3,title:"使用通配符构造应用上下文",slug:"使用通配符构造应用上下文",normalizedTitle:"使用通配符构造应用上下文",charIndex:7646},{level:2,title:"问题",slug:"问题",normalizedTitle:"问题",charIndex:8078},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:8146}],headersStr:"Resource 接口 内置的 Resource 实现 ResourceLoader 接口 ResourcePatternResolver 接口 ResourceLoaderAware 接口 资源依赖 应用上下文和资源路径 构造应用上下文 使用通配符构造应用上下文 问题 参考资料",content:'# Spring 资源管理\n\n> Version 6.0.3\n\n\n# Resource 接口\n\n相对标准 URL 访问机制，Spring 的 org.springframework.core.io.Resource 接口抽象了对底层资源的访问接口，提供了一套更好的访问方式。\n\npublic interface Resource extends InputStreamSource {\n\n    boolean exists();\n\n    boolean isReadable();\n\n    boolean isOpen();\n\n    boolean isFile();\n\n    URL getURL() throws IOException;\n\n    URI getURI() throws IOException;\n\n    File getFile() throws IOException;\n\n    ReadableByteChannel readableChannel() throws IOException;\n\n    long contentLength() throws IOException;\n\n    long lastModified() throws IOException;\n\n    Resource createRelative(String relativePath) throws IOException;\n\n    String getFilename();\n\n    String getDescription();\n}\n\n\n正如 Resource 接口的定义所示，它扩展了 InputStreamSource 接口。Resource 最核心的方法如下：\n\n * getInputStream() - 定位并且打开当前资源，返回当前资源的 InputStream。每次调用都会返回一个新的 InputStream。调用者需要负责关闭流。\n * exists() - 判断当前资源是否真的存在。\n * isOpen() - 判断当前资源是否是一个已打开的 InputStream。如果为 true，则 InputStream 不能被多次读取，必须只读取一次然后关闭以避免资源泄漏。对所有常用资源实现返回 false，InputStreamResource 除外。\n * getDescription() - 返回当前资源的描述，当处理资源出错时，资源的描述会用于错误信息的输出。一般来说，资源的描述是一个完全限定的文件名称，或者是当前资源的真实 URL。\n\n常见 Spring 资源接口：\n\n类型      接口\n输入流     org.springframework.core.io.InputStreamSource\n只读资源    org.springframework.core.io.Resource\n可写资源    org.springframework.core.io.WritableResource\n编码资源    org.springframework.core.io.support.EncodedResource\n上下文资源   org.springframework.core.io.ContextResource\n\n\n\n\n# 内置的 Resource 实现\n\nSpring 包括几个内置的 Resource 实现：\n\n资源来源                     前缀                    说明\nUrlResource              file:、https:、ftp: 等   UrlResource 封装了一个 java.net.URL 对象，用于访问可通过 URL\n                                               访问的任何对象，例如文件、HTTPS 目标、FTP 目标等。所有 URL\n                                               都可以通过标准化的字符串形式表示，因此可以使用适当的标准化前缀来指示一种 URL 类型与另一种 URL 类型的区别。\n                                               这包括：file：用于访问文件系统路径；https：用于通过 HTTPS 协议访问资源；ftp：用于通过 FTP\n                                               访问资源等等。\nClassPathResource        classpath:            ClassPathResource 从类路径上加载资源。它使用线程上下文加载器、给定的类加载器或指定的 class\n                                               类型中的任意一个来加载资源。\nFileSystemResource       file:                 FileSystemResource 是 java.io.File 的资源实现。它还支持\n                                               java.nio.file.Path ，应用 Spring\n                                               的标准对字符串路径进行转换。FileSystemResource 支持解析为文件和 URL。\nPathResource             无                     PathResource 是 java.nio.file.Path 的资源实现。\nServletContextResource   无                     ServletContextResource 是 ServletContext 的资源实现。它表示相应 Web\n                                               应用程序根目录中的相对路径。\nInputStreamResource      无                     InputStreamResource 是指定 InputStream 的资源实现。注意：如果该 InputStream\n                                               已被打开，则不可以多次读取该流。\nByteArrayResource        无                     ByteArrayResource 是指定的二进制数组的资源实现。它会为给定的字节数组创建一个\n                                               ByteArrayInputStream。\n\n\n# ResourceLoader 接口\n\nResourceLoader 接口用于加载 Resource 对象。其定义如下：\n\npublic interface ResourceLoader {\n\n    Resource getResource(String location);\n\n    ClassLoader getClassLoader();\n}\n\n\nSpring 中主要的 ResourceLoader 实现：\n\n\n\nSpring 中，所有的 ApplicationContext 都实现了 ResourceLoader 接口。因此，所有 ApplicationContext 都可以通过 getResource() 方法获取 Resource 实例。\n\n【示例】\n\n// 如果没有指定资源前缀，Spring 会尝试返回合适的资源\nResource template = ctx.getResource("some/resource/path/myTemplate.txt");\n// 如果指定 classpath: 前缀，Spring 会强制使用 ClassPathResource\nResource template = ctx.getResource("classpath:some/resource/path/myTemplate.txt");\n// 如果指定 file:、http 等 URL 前缀，Spring 会强制使用 UrlResource\nResource template = ctx.getResource("file:///some/resource/path/myTemplate.txt");\nResource template = ctx.getResource("http://myhost.com/resource/path/myTemplate.txt");\n\n\n下表列举了 Spring 根据各种位置路径加载资源的策略：\n\n前缀           样例                               说明\nclasspath:   classpath:com/myapp/config.xml   从类路径加载\nfile:        file:///data/config.xml          以 URL 形式从文件系统加载\nhttp:        http://myserver/logo.png         以 URL 形式加载\n无            /data/config.xml                 由底层的 ApplicationContext 实现决定\n\n\n# ResourcePatternResolver 接口\n\nResourcePatternResolver 接口是 ResourceLoader 接口的扩展，它的作用是定义策略，根据位置模式解析 Resource 对象。\n\npublic interface ResourcePatternResolver extends ResourceLoader {\n\n    String CLASSPATH_ALL_URL_PREFIX = "classpath*:";\n\n    Resource[] getResources(String locationPattern) throws IOException;\n}\n\n\nPathMatchingResourcePatternResolver 是一个独立的实现，可以在 ApplicationContext 之外使用，也可以被 ResourceArrayPropertyEditor 用于填充 Resource[] bean 属性。PathMatchingResourcePatternResolver 能够将指定的资源位置路径解析为一个或多个匹配的 Resource 对象。\n\n> 注意：任何标准 ApplicationContext 中的默认 ResourceLoader 实际上是 PathMatchingResourcePatternResolver 的一个实例，它实现了 ResourcePatternResolver 接口。\n\n\n# ResourceLoaderAware 接口\n\nResourceLoaderAware 接口是一个特殊的回调接口，用来标记提供 ResourceLoader 引用的对象。ResourceLoaderAware 接口定义如下：\n\npublic interface ResourceLoaderAware {\n    void setResourceLoader(ResourceLoader resourceLoader);\n}\n\n\n当一个类实现 ResourceLoaderAware 并部署到应用程序上下文中（作为 Spring 管理的 bean）时，它会被应用程序上下文识别为 ResourceLoaderAware，然后，应用程序上下文会调用 setResourceLoader(ResourceLoader)，将自身作为参数提供（请记住，Spring 中的所有应用程序上下文都实现 ResourceLoader 接口）。\n\n由于 ApplicationContext 是一个 ResourceLoader，该 bean 还可以实现 ApplicationContextAware 接口并直接使用提供的应用程序上下文来加载资源。 但是，一般来说，如果您只需要这些，最好使用专门的 ResourceLoader 接口。 该代码将仅耦合到资源加载接口（可以被视为实用程序接口），而不耦合到整个 Spring ApplicationContext 接口。\n\n在应用程序中，还可以使用 ResourceLoader 的自动装配作为实现 ResourceLoaderAware 接口的替代方法。传统的构造函数和 byType 自动装配模式能够分别为构造函数参数或 setter 方法参数提供 ResourceLoader。 为了获得更大的灵活性（包括自动装配字段和多参数方法的能力），请考虑使用基于注解的自动装配功能。 在这种情况下，ResourceLoader 会自动连接到需要 ResourceLoader 类型的字段、构造函数参数或方法参数中，只要相关字段、构造函数或方法带有 @Autowired 注解即可。\n\n\n# 资源依赖\n\n如果 bean 本身要通过某种动态过程来确定和提供资源路径，那么 bean 可以使用 ResourceLoader 或 ResourcePatternResolver 接口来加载资源。 例如，考虑加载某种模板，其中所需的特定资源取决于用户的角色。 如果资源是静态的，完全消除 ResourceLoader 接口（或 ResourcePatternResolver 接口）的使用，让 bean 公开它需要的 Resource 属性，并期望将它们注入其中是有意义的。\n\n使注入这些属性变得简单的原因是所有应用程序上下文都注册并使用一个特殊的 JavaBeans PropertyEditor，它可以将 String 路径转换为 Resource 对象。 例如，下面的 MyBean 类有一个 Resource 类型的模板属性。\n\n【示例】\n\n<bean id="myBean" class="example.MyBean">\n    <property name="template" value="some/resource/path/myTemplate.txt"/>\n</bean>\n\n\n请注意，配置中引用的模板资源路径没有前缀，因为应用程序上下文本身将用作 ResourceLoader，资源本身将根据需要通过 ClassPathResource，FileSystemResource 或 ServletContextResource 加载，具体取决于上下文的确切类型。\n\n如果需要强制使用特定的资源类型，则可以使用前缀。 以下两个示例显示如何强制使用 ClassPathResource 和 UrlResource（后者用于访问文件系统文件）。\n\n<property name="template" value="classpath:some/resource/path/myTemplate.txt">\n<property name="template" value="file:///some/resource/path/myTemplate.txt"/>\n\n\n可以通过 @Value 注解加载资源文件 myTemplate.txt，示例如下：\n\n@Component\npublic class MyBean {\n\n    private final Resource template;\n\n    public MyBean(@Value("${template.path}") Resource template) {\n        this.template = template;\n    }\n\n    // ...\n}\n\n\nSpring 的 PropertyEditor 会根据资源文件的路径字符串，加载 Resource 对象，并将其注入到 MyBean 的构造方法。\n\n如果想要加载多个资源文件，可以使用 classpath*: 前缀，例如：classpath*:/config/templates/*.txt。\n\n@Component\npublic class MyBean {\n\n    private final Resource[] templates;\n\n    public MyBean(@Value("${templates.path}") Resource[] templates) {\n        this.templates = templates;\n    }\n\n    // ...\n}\n\n\n\n# 应用上下文和资源路径\n\n\n# 构造应用上下文\n\n应用上下文构造函数（针对特定的应用上下文类型）通常将字符串或字符串数组作为资源的位置路径，例如构成上下文定义的 XML 文件。\n\n【示例】\n\nApplicationContext ctx = new ClassPathXmlApplicationContext("conf/appContext.xml");\nApplicationContext ctx = new FileSystemXmlApplicationContext("conf/appContext.xml");\nApplicationContext ctx = new FileSystemXmlApplicationContext("classpath:conf/appContext.xml");\nApplicationContext ctx = new ClassPathXmlApplicationContext(\n                new String[] {"services.xml", "daos.xml"}, MessengerService.class);\n\n\n\n# 使用通配符构造应用上下文\n\nApplicationContext 构造器的中的资源路径可以是单一的路径（即一对一地映射到目标资源）；也可以是通配符形式——可包含 classpath*：也可以是前缀或 ant 风格的正则表达式（使用 spring 的 PathMatcher 来匹配）。\n\n示例：\n\nApplicationContext ctx = new ClassPathXmlApplicationContext("classpath*:conf/appContext.xml");\n\n\n使用 classpath* 表示类路径下所有匹配文件名称的资源都会被获取(本质上就是调用了 ClassLoader.getResources(…) 方法），接着将获取到的资源组装成最终的应用上下文。\n\n在位置路径的其余部分，classpath*: 前缀可以与 PathMatcher 结合使用，如：classpath*:META-INF/*-beans.xml。\n\n\n# 问题\n\nSpring 配置资源中有哪些常见类型？\n\n * XML 资源\n * Properties 资源\n * YAML 资源\n\n\n# 参考资料\n\n * Spring 官方文档之 Core Technologies\n * 《小马哥讲 Spring 核心编程思想》',normalizedContent:'# spring 资源管理\n\n> version 6.0.3\n\n\n# resource 接口\n\n相对标准 url 访问机制，spring 的 org.springframework.core.io.resource 接口抽象了对底层资源的访问接口，提供了一套更好的访问方式。\n\npublic interface resource extends inputstreamsource {\n\n    boolean exists();\n\n    boolean isreadable();\n\n    boolean isopen();\n\n    boolean isfile();\n\n    url geturl() throws ioexception;\n\n    uri geturi() throws ioexception;\n\n    file getfile() throws ioexception;\n\n    readablebytechannel readablechannel() throws ioexception;\n\n    long contentlength() throws ioexception;\n\n    long lastmodified() throws ioexception;\n\n    resource createrelative(string relativepath) throws ioexception;\n\n    string getfilename();\n\n    string getdescription();\n}\n\n\n正如 resource 接口的定义所示，它扩展了 inputstreamsource 接口。resource 最核心的方法如下：\n\n * getinputstream() - 定位并且打开当前资源，返回当前资源的 inputstream。每次调用都会返回一个新的 inputstream。调用者需要负责关闭流。\n * exists() - 判断当前资源是否真的存在。\n * isopen() - 判断当前资源是否是一个已打开的 inputstream。如果为 true，则 inputstream 不能被多次读取，必须只读取一次然后关闭以避免资源泄漏。对所有常用资源实现返回 false，inputstreamresource 除外。\n * getdescription() - 返回当前资源的描述，当处理资源出错时，资源的描述会用于错误信息的输出。一般来说，资源的描述是一个完全限定的文件名称，或者是当前资源的真实 url。\n\n常见 spring 资源接口：\n\n类型      接口\n输入流     org.springframework.core.io.inputstreamsource\n只读资源    org.springframework.core.io.resource\n可写资源    org.springframework.core.io.writableresource\n编码资源    org.springframework.core.io.support.encodedresource\n上下文资源   org.springframework.core.io.contextresource\n\n\n\n\n# 内置的 resource 实现\n\nspring 包括几个内置的 resource 实现：\n\n资源来源                     前缀                    说明\nurlresource              file:、https:、ftp: 等   urlresource 封装了一个 java.net.url 对象，用于访问可通过 url\n                                               访问的任何对象，例如文件、https 目标、ftp 目标等。所有 url\n                                               都可以通过标准化的字符串形式表示，因此可以使用适当的标准化前缀来指示一种 url 类型与另一种 url 类型的区别。\n                                               这包括：file：用于访问文件系统路径；https：用于通过 https 协议访问资源；ftp：用于通过 ftp\n                                               访问资源等等。\nclasspathresource        classpath:            classpathresource 从类路径上加载资源。它使用线程上下文加载器、给定的类加载器或指定的 class\n                                               类型中的任意一个来加载资源。\nfilesystemresource       file:                 filesystemresource 是 java.io.file 的资源实现。它还支持\n                                               java.nio.file.path ，应用 spring\n                                               的标准对字符串路径进行转换。filesystemresource 支持解析为文件和 url。\npathresource             无                     pathresource 是 java.nio.file.path 的资源实现。\nservletcontextresource   无                     servletcontextresource 是 servletcontext 的资源实现。它表示相应 web\n                                               应用程序根目录中的相对路径。\ninputstreamresource      无                     inputstreamresource 是指定 inputstream 的资源实现。注意：如果该 inputstream\n                                               已被打开，则不可以多次读取该流。\nbytearrayresource        无                     bytearrayresource 是指定的二进制数组的资源实现。它会为给定的字节数组创建一个\n                                               bytearrayinputstream。\n\n\n# resourceloader 接口\n\nresourceloader 接口用于加载 resource 对象。其定义如下：\n\npublic interface resourceloader {\n\n    resource getresource(string location);\n\n    classloader getclassloader();\n}\n\n\nspring 中主要的 resourceloader 实现：\n\n\n\nspring 中，所有的 applicationcontext 都实现了 resourceloader 接口。因此，所有 applicationcontext 都可以通过 getresource() 方法获取 resource 实例。\n\n【示例】\n\n// 如果没有指定资源前缀，spring 会尝试返回合适的资源\nresource template = ctx.getresource("some/resource/path/mytemplate.txt");\n// 如果指定 classpath: 前缀，spring 会强制使用 classpathresource\nresource template = ctx.getresource("classpath:some/resource/path/mytemplate.txt");\n// 如果指定 file:、http 等 url 前缀，spring 会强制使用 urlresource\nresource template = ctx.getresource("file:///some/resource/path/mytemplate.txt");\nresource template = ctx.getresource("http://myhost.com/resource/path/mytemplate.txt");\n\n\n下表列举了 spring 根据各种位置路径加载资源的策略：\n\n前缀           样例                               说明\nclasspath:   classpath:com/myapp/config.xml   从类路径加载\nfile:        file:///data/config.xml          以 url 形式从文件系统加载\nhttp:        http://myserver/logo.png         以 url 形式加载\n无            /data/config.xml                 由底层的 applicationcontext 实现决定\n\n\n# resourcepatternresolver 接口\n\nresourcepatternresolver 接口是 resourceloader 接口的扩展，它的作用是定义策略，根据位置模式解析 resource 对象。\n\npublic interface resourcepatternresolver extends resourceloader {\n\n    string classpath_all_url_prefix = "classpath*:";\n\n    resource[] getresources(string locationpattern) throws ioexception;\n}\n\n\npathmatchingresourcepatternresolver 是一个独立的实现，可以在 applicationcontext 之外使用，也可以被 resourcearraypropertyeditor 用于填充 resource[] bean 属性。pathmatchingresourcepatternresolver 能够将指定的资源位置路径解析为一个或多个匹配的 resource 对象。\n\n> 注意：任何标准 applicationcontext 中的默认 resourceloader 实际上是 pathmatchingresourcepatternresolver 的一个实例，它实现了 resourcepatternresolver 接口。\n\n\n# resourceloaderaware 接口\n\nresourceloaderaware 接口是一个特殊的回调接口，用来标记提供 resourceloader 引用的对象。resourceloaderaware 接口定义如下：\n\npublic interface resourceloaderaware {\n    void setresourceloader(resourceloader resourceloader);\n}\n\n\n当一个类实现 resourceloaderaware 并部署到应用程序上下文中（作为 spring 管理的 bean）时，它会被应用程序上下文识别为 resourceloaderaware，然后，应用程序上下文会调用 setresourceloader(resourceloader)，将自身作为参数提供（请记住，spring 中的所有应用程序上下文都实现 resourceloader 接口）。\n\n由于 applicationcontext 是一个 resourceloader，该 bean 还可以实现 applicationcontextaware 接口并直接使用提供的应用程序上下文来加载资源。 但是，一般来说，如果您只需要这些，最好使用专门的 resourceloader 接口。 该代码将仅耦合到资源加载接口（可以被视为实用程序接口），而不耦合到整个 spring applicationcontext 接口。\n\n在应用程序中，还可以使用 resourceloader 的自动装配作为实现 resourceloaderaware 接口的替代方法。传统的构造函数和 bytype 自动装配模式能够分别为构造函数参数或 setter 方法参数提供 resourceloader。 为了获得更大的灵活性（包括自动装配字段和多参数方法的能力），请考虑使用基于注解的自动装配功能。 在这种情况下，resourceloader 会自动连接到需要 resourceloader 类型的字段、构造函数参数或方法参数中，只要相关字段、构造函数或方法带有 @autowired 注解即可。\n\n\n# 资源依赖\n\n如果 bean 本身要通过某种动态过程来确定和提供资源路径，那么 bean 可以使用 resourceloader 或 resourcepatternresolver 接口来加载资源。 例如，考虑加载某种模板，其中所需的特定资源取决于用户的角色。 如果资源是静态的，完全消除 resourceloader 接口（或 resourcepatternresolver 接口）的使用，让 bean 公开它需要的 resource 属性，并期望将它们注入其中是有意义的。\n\n使注入这些属性变得简单的原因是所有应用程序上下文都注册并使用一个特殊的 javabeans propertyeditor，它可以将 string 路径转换为 resource 对象。 例如，下面的 mybean 类有一个 resource 类型的模板属性。\n\n【示例】\n\n<bean id="mybean" class="example.mybean">\n    <property name="template" value="some/resource/path/mytemplate.txt"/>\n</bean>\n\n\n请注意，配置中引用的模板资源路径没有前缀，因为应用程序上下文本身将用作 resourceloader，资源本身将根据需要通过 classpathresource，filesystemresource 或 servletcontextresource 加载，具体取决于上下文的确切类型。\n\n如果需要强制使用特定的资源类型，则可以使用前缀。 以下两个示例显示如何强制使用 classpathresource 和 urlresource（后者用于访问文件系统文件）。\n\n<property name="template" value="classpath:some/resource/path/mytemplate.txt">\n<property name="template" value="file:///some/resource/path/mytemplate.txt"/>\n\n\n可以通过 @value 注解加载资源文件 mytemplate.txt，示例如下：\n\n@component\npublic class mybean {\n\n    private final resource template;\n\n    public mybean(@value("${template.path}") resource template) {\n        this.template = template;\n    }\n\n    // ...\n}\n\n\nspring 的 propertyeditor 会根据资源文件的路径字符串，加载 resource 对象，并将其注入到 mybean 的构造方法。\n\n如果想要加载多个资源文件，可以使用 classpath*: 前缀，例如：classpath*:/config/templates/*.txt。\n\n@component\npublic class mybean {\n\n    private final resource[] templates;\n\n    public mybean(@value("${templates.path}") resource[] templates) {\n        this.templates = templates;\n    }\n\n    // ...\n}\n\n\n\n# 应用上下文和资源路径\n\n\n# 构造应用上下文\n\n应用上下文构造函数（针对特定的应用上下文类型）通常将字符串或字符串数组作为资源的位置路径，例如构成上下文定义的 xml 文件。\n\n【示例】\n\napplicationcontext ctx = new classpathxmlapplicationcontext("conf/appcontext.xml");\napplicationcontext ctx = new filesystemxmlapplicationcontext("conf/appcontext.xml");\napplicationcontext ctx = new filesystemxmlapplicationcontext("classpath:conf/appcontext.xml");\napplicationcontext ctx = new classpathxmlapplicationcontext(\n                new string[] {"services.xml", "daos.xml"}, messengerservice.class);\n\n\n\n# 使用通配符构造应用上下文\n\napplicationcontext 构造器的中的资源路径可以是单一的路径（即一对一地映射到目标资源）；也可以是通配符形式——可包含 classpath*：也可以是前缀或 ant 风格的正则表达式（使用 spring 的 pathmatcher 来匹配）。\n\n示例：\n\napplicationcontext ctx = new classpathxmlapplicationcontext("classpath*:conf/appcontext.xml");\n\n\n使用 classpath* 表示类路径下所有匹配文件名称的资源都会被获取(本质上就是调用了 classloader.getresources(…) 方法），接着将获取到的资源组装成最终的应用上下文。\n\n在位置路径的其余部分，classpath*: 前缀可以与 pathmatcher 结合使用，如：classpath*:meta-inf/*-beans.xml。\n\n\n# 问题\n\nspring 配置资源中有哪些常见类型？\n\n * xml 资源\n * properties 资源\n * yaml 资源\n\n\n# 参考资料\n\n * spring 官方文档之 core technologies\n * 《小马哥讲 spring 核心编程思想》',charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Spring 校验",frontmatter:{title:"Spring 校验",date:"2022-12-22T17:42:28.000Z",order:21,categories:["Java","框架","Spring","Spring核心"],tags:["Java","框架","Spring"],permalink:"/pages/fe6aad/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/01.Spring%E6%A0%B8%E5%BF%83/21.Spring%E6%A0%A1%E9%AA%8C.html",relativePath:"01.Java/13.框架/01.Spring/01.Spring核心/21.Spring校验.md",key:"v-2969c73e",path:"/pages/fe6aad/",headers:[{level:2,title:"快速入门",slug:"快速入门",normalizedTitle:"快速入门",charIndex:193},{level:3,title:"引入依赖",slug:"引入依赖",normalizedTitle:"引入依赖",charIndex:202},{level:3,title:"校验示例",slug:"校验示例",normalizedTitle:"校验示例",charIndex:739},{level:3,title:"统一异常处理",slug:"统一异常处理",normalizedTitle:"统一异常处理",charIndex:2072},{level:2,title:"进阶使用",slug:"进阶使用",normalizedTitle:"进阶使用",charIndex:4053},{level:3,title:"分组校验",slug:"分组校验",normalizedTitle:"分组校验",charIndex:4062},{level:3,title:"嵌套校验",slug:"嵌套校验",normalizedTitle:"嵌套校验",charIndex:5506},{level:3,title:"自定义校验注解",slug:"自定义校验注解",normalizedTitle:"自定义校验注解",charIndex:6978},{level:3,title:"自定义校验",slug:"自定义校验",normalizedTitle:"自定义校验",charIndex:6978},{level:3,title:"快速失败(Fail Fast)",slug:"快速失败-fail-fast",normalizedTitle:"快速失败(fail fast)",charIndex:10519},{level:2,title:"Spring 校验原理",slug:"spring-校验原理",normalizedTitle:"spring 校验原理",charIndex:10904},{level:3,title:"Spring 校验使用场景",slug:"spring-校验使用场景",normalizedTitle:"spring 校验使用场景",charIndex:10920},{level:3,title:"Validator 接口设计",slug:"validator-接口设计",normalizedTitle:"validator 接口设计",charIndex:11060},{level:3,title:"Errors 接口设计",slug:"errors-接口设计",normalizedTitle:"errors 接口设计",charIndex:11343},{level:3,title:"Errors 文案来源",slug:"errors-文案来源",normalizedTitle:"errors 文案来源",charIndex:11615},{level:3,title:"spring web 校验原理",slug:"spring-web-校验原理",normalizedTitle:"spring web 校验原理",charIndex:11891},{level:4,title:"RequestBody 参数校验实现原理",slug:"requestbody-参数校验实现原理",normalizedTitle:"requestbody 参数校验实现原理",charIndex:11910},{level:4,title:"方法级别的参数校验实现原理",slug:"方法级别的参数校验实现原理",normalizedTitle:"方法级别的参数校验实现原理",charIndex:14619},{level:2,title:"问题",slug:"问题",normalizedTitle:"问题",charIndex:4149},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:17299}],headersStr:"快速入门 引入依赖 校验示例 统一异常处理 进阶使用 分组校验 嵌套校验 自定义校验注解 自定义校验 快速失败(Fail Fast) Spring 校验原理 Spring 校验使用场景 Validator 接口设计 Errors 接口设计 Errors 文案来源 spring web 校验原理 RequestBody 参数校验实现原理 方法级别的参数校验实现原理 问题 参考资料",content:'# Spring 校验\n\nJava API 规范(JSR303)定义了Bean校验的标准validation-api，但没有提供实现。hibernate validation是对这个规范的实现，并增加了校验注解如@Email、@Length等。Spring Validation是对hibernate validation的二次封装，用于支持spring mvc参数自动校验。\n\n\n# 快速入门\n\n\n# 引入依赖\n\n如果 spring-boot 版本小于 2.3.x，spring-boot-starter-web 会自动传入 hibernate-validator 依赖。如果 spring-boot 版本大于 2.3.x，则需要手动引入依赖：\n\n<dependency>\n  <groupId>org.hibernate.validator</groupId>\n  <artifactId>hibernate-validator-parent</artifactId>\n  <version>6.2.5.Final</version>\n</dependency>\n\n\n对于 web 服务来说，为防止非法参数对业务造成影响，在 Controller 层一定要做参数校验的！大部分情况下，请求参数分为如下两种形式：\n\n * POST、PUT 请求，使用 requestBody 传递参数；\n * GET 请求，使用 requestParam/PathVariable 传递参数。\n\n实际上，不管是 requestBody 参数校验还是方法级别的校验，最终都是调用 Hibernate Validator 执行校验，Spring Validation 只是做了一层封装。\n\n\n# 校验示例\n\n（1）在实体上标记校验注解\n\n@Data\n@NoArgsConstructor\n@AllArgsConstructor\npublic class User implements Serializable {\n\n    @NotNull\n    private Long id;\n\n    @NotBlank\n    @Size(min = 2, max = 10)\n    private String name;\n\n    @Min(value = 1)\n    @Max(value = 100)\n    private Integer age;\n\n}\n\n\n（2）在方法参数上声明校验注解\n\n@Slf4j\n@Validated\n@RestController\n@RequestMapping("validate1")\npublic class ValidatorController {\n\n    /**\n     * {@link RequestBody} 参数校验\n     */\n    @PostMapping(value = "save")\n    public DataResult<Boolean> save(@Valid @RequestBody User entity) {\n        log.info("保存一条记录：{}", JSONUtil.toJsonStr(entity));\n        return DataResult.ok(true);\n    }\n\n    /**\n     * {@link RequestParam} 参数校验\n     */\n    @GetMapping(value = "queryByName")\n    public DataResult<User> queryByName(\n        @RequestParam("username")\n        @NotBlank\n        @Size(min = 2, max = 10)\n        String name\n    ) {\n        User user = new User(1L, name, 18);\n        return DataResult.ok(user);\n    }\n\n    /**\n     * {@link PathVariable} 参数校验\n     */\n    @GetMapping(value = "detail/{id}")\n    public DataResult<User> detail(@PathVariable("id") @Min(1L) Long id) {\n        User user = new User(id, "李四", 18);\n        return DataResult.ok(user);\n    }\n\n}\n\n\n（3）如果请求参数不满足校验规则，则会抛出 ConstraintViolationException 或 MethodArgumentNotValidException 异常。\n\n\n# 统一异常处理\n\n在实际项目开发中，通常会用统一异常处理来返回一个更友好的提示。\n\n@Slf4j\n@ControllerAdvice\npublic class GlobalExceptionHandler {\n\n    /**\n     * 处理所有不可知的异常\n     */\n    @ResponseBody\n    @ResponseStatus(HttpStatus.OK)\n    @ExceptionHandler(Throwable.class)\n    public Result handleException(Throwable e) {\n        log.error("未知异常", e);\n        return new Result(ResultStatus.HTTP_SERVER_ERROR.getCode(), e.getMessage());\n    }\n\n    /**\n     * 统一处理请求参数校验异常(普通传参)\n     *\n     * @param e ConstraintViolationException\n     * @return {@link DataResult}\n     */\n    @ResponseBody\n    @ResponseStatus(HttpStatus.BAD_REQUEST)\n    @ExceptionHandler({ ConstraintViolationException.class })\n    public Result handleConstraintViolationException(final ConstraintViolationException e) {\n        log.error("ConstraintViolationException", e);\n        List<String> errors = new ArrayList<>();\n        for (ConstraintViolation<?> violation : e.getConstraintViolations()) {\n            Path path = violation.getPropertyPath();\n            List<String> pathArr = StrUtil.split(path.toString(), \',\');\n            errors.add(pathArr.get(0) + " " + violation.getMessage());\n        }\n        return new Result(ResultStatus.REQUEST_ERROR.getCode(), CollectionUtil.join(errors, ","));\n    }\n\n    /**\n     * 处理参数校验异常\n     *\n     * @param e MethodArgumentNotValidException\n     * @return {@link DataResult}\n     */\n    @ResponseBody\n    @ResponseStatus(HttpStatus.BAD_REQUEST)\n    @ExceptionHandler({ MethodArgumentNotValidException.class })\n    private Result handleMethodArgumentNotValidException(final MethodArgumentNotValidException e) {\n        log.error("MethodArgumentNotValidException", e);\n        List<String> errors = new ArrayList<>();\n        for (ObjectError error : e.getBindingResult().getAllErrors()) {\n            errors.add(((FieldError) error).getField() + " " + error.getDefaultMessage());\n        }\n        return new Result(ResultStatus.REQUEST_ERROR.getCode(), CollectionUtil.join(errors, ","));\n    }\n\n}\n\n\n\n# 进阶使用\n\n\n# 分组校验\n\n在实际项目中，可能多个方法需要使用同一个 DTO 类来接收参数，而不同方法的校验规则很可能是不一样的。这个时候，简单地在 DTO 类的字段上加约束注解无法解决这个问题。因此，spring-validation 支持了分组校验的功能，专门用来解决这类问题。\n\n（1）定义分组\n\n@Target({ ElementType.FIELD, ElementType.PARAMETER })\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface AddCheck { }\n\n@Target({ ElementType.FIELD, ElementType.PARAMETER })\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface EditCheck { }\n\n\n（2）在实体上标记校验注解\n\n@Data\npublic class User2 {\n\n    @NotNull(groups = EditCheck.class)\n    private Long id;\n\n    @NotNull(groups = { AddCheck.class, EditCheck.class })\n    @Size(min = 2, max = 10, groups = { AddCheck.class, EditCheck.class })\n    private String name;\n\n    @IsMobile(message = "不是有效手机号", groups = { AddCheck.class, EditCheck.class })\n    private String mobile;\n\n}\n\n\n（3）在方法上根据不同场景进行校验分组\n\n@Slf4j\n@Validated\n@RestController\n@RequestMapping("validate2")\npublic class ValidatorController2 {\n\n    /**\n     * {@link RequestBody} 参数校验\n     */\n    @PostMapping(value = "add")\n    public DataResult<Boolean> add(@Validated(AddCheck.class) @RequestBody User2 entity) {\n        log.info("添加一条记录：{}", JSONUtil.toJsonStr(entity));\n        return DataResult.ok(true);\n    }\n\n    /**\n     * {@link RequestBody} 参数校验\n     */\n    @PostMapping(value = "edit")\n    public DataResult<Boolean> edit(@Validated(EditCheck.class) @RequestBody User2 entity) {\n        log.info("编辑一条记录：{}", JSONUtil.toJsonStr(entity));\n        return DataResult.ok(true);\n    }\n\n}\n\n\n\n# 嵌套校验\n\n前面的示例中，DTO 类里面的字段都是基本数据类型和 String 类型。但是实际场景中，有可能某个字段也是一个对象，这种情况先，可以使用嵌套校验。 post 比如，上面保存 User 信息的时候同时还带有 Job 信息。需要注意的是，此时 DTO 类的对应字段必须标记@Valid 注解。\n\n@Data\npublic class UserDTO {\n\n    @Min(value = 10000000000000000L, groups = Update.class)\n    private Long userId;\n\n    @NotNull(groups = {Save.class, Update.class})\n    @Length(min = 2, max = 10, groups = {Save.class, Update.class})\n    private String userName;\n\n    @NotNull(groups = {Save.class, Update.class})\n    @Length(min = 6, max = 20, groups = {Save.class, Update.class})\n    private String account;\n\n    @NotNull(groups = {Save.class, Update.class})\n    @Length(min = 6, max = 20, groups = {Save.class, Update.class})\n    private String password;\n\n    @NotNull(groups = {Save.class, Update.class})\n    @Valid\n    private Job job;\n\n    @Data\n    public static class Job {\n\n        @Min(value = 1, groups = Update.class)\n        private Long jobId;\n\n        @NotNull(groups = {Save.class, Update.class})\n        @Length(min = 2, max = 10, groups = {Save.class, Update.class})\n        private String jobName;\n\n        @NotNull(groups = {Save.class, Update.class})\n        @Length(min = 2, max = 10, groups = {Save.class, Update.class})\n        private String position;\n    }\n\n    /**\n     * 保存的时候校验分组\n     */\n    public interface Save {\n    }\n\n    /**\n     * 更新的时候校验分组\n     */\n    public interface Update {\n    }\n}\n复制代码\n\n\n嵌套校验可以结合分组校验一起使用。还有就是嵌套集合校验会对集合里面的每一项都进行校验，例如List<Job>字段会对这个 list 里面的每一个 Job 对象都进行校验\n\n\n# 自定义校验注解\n\n（1）自定义校验注解 @IsMobile\n\n@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })\n@Retention(RUNTIME)\n@Constraint(validatedBy = MobileValidator.class)\npublic @interface IsMobile {\n\n    String message();\n\n    Class<?>[] groups() default {};\n\n    Class<? extends Payload>[] payload() default {};\n\n}\n\n\n（2）实现 ConstraintValidator 接口，编写 @IsMobile 校验注解的解析器\n\nimport cn.hutool.core.util.StrUtil;\nimport io.github.dunwu.spring.core.validation.annotation.IsMobile;\nimport io.github.dunwu.tool.util.ValidatorUtil;\n\nimport javax.validation.ConstraintValidator;\nimport javax.validation.ConstraintValidatorContext;\n\npublic class MobileValidator implements ConstraintValidator<IsMobile, String> {\n\n    @Override\n    public void initialize(IsMobile isMobile) { }\n\n    @Override\n    public boolean isValid(String s, ConstraintValidatorContext constraintValidatorContext) {\n        if (StrUtil.isBlank(s)) {\n            return false;\n        } else {\n            return ValidatorUtil.isMobile(s);\n        }\n    }\n\n}\n\n\n\n# 自定义校验\n\n可以通过实现 org.springframework.validation.Validator 接口来自定义校验。\n\n有以下要点\n\n * 实现 supports 方法\n * 实现 validate 方法\n   * 通过 Errors 对象收集错误\n     * ObjectError：对象（Bean）错误：\n     * FieldError：对象（Bean）属性（Property）错误\n   * 通过 ObjectError 和 FieldError 关联 MessageSource 实现获取最终的错误文案\n\npackage io.github.dunwu.spring.core.validation;\n\nimport io.github.dunwu.spring.core.validation.annotation.Valid;\nimport io.github.dunwu.spring.core.validation.config.CustomValidatorConfig;\nimport io.github.dunwu.spring.core.validation.entity.Person;\nimport org.springframework.stereotype.Component;\nimport org.springframework.validation.Errors;\nimport org.springframework.validation.ValidationUtils;\nimport org.springframework.validation.Validator;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Field;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\n@Component\npublic class CustomValidator implements Validator {\n\n    private final CustomValidatorConfig validatorConfig;\n\n    public CustomValidator(CustomValidatorConfig validatorConfig) {\n        this.validatorConfig = validatorConfig;\n    }\n\n    /**\n     * 本校验器只针对 Person 对象进行校验\n     */\n    @Override\n    public boolean supports(Class<?> clazz) {\n        return Person.class.equals(clazz);\n    }\n\n    @Override\n    public void validate(Object target, Errors errors) {\n        ValidationUtils.rejectIfEmpty(errors, "name", "name.empty");\n\n        List<Field> fields = getFields(target.getClass());\n        for (Field field : fields) {\n            Annotation[] annotations = field.getAnnotations();\n            for (Annotation annotation : annotations) {\n                if (annotation.annotationType().getAnnotation(Valid.class) != null) {\n                    try {\n                        ValidatorRule validatorRule = validatorConfig.findRule(annotation);\n                        if (validatorRule != null) {\n                            validatorRule.valid(annotation, target, field, errors);\n                        }\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }\n    }\n\n    private List<Field> getFields(Class<?> clazz) {\n        // 声明Field数组\n        List<Field> fields = new ArrayList<>();\n        // 如果class类型不为空\n        while (clazz != null) {\n            // 添加属性到属性数组\n            Collections.addAll(fields, clazz.getDeclaredFields());\n            clazz = clazz.getSuperclass();\n        }\n        return fields;\n    }\n\n}\n\n\n\n# 快速失败(Fail Fast)\n\nSpring Validation 默认会校验完所有字段，然后才抛出异常。可以通过一些简单的配置，开启 Fali Fast 模式，一旦校验失败就立即返回。\n\n@Bean\npublic Validator validator() {\n    ValidatorFactory validatorFactory = Validation.byProvider(HibernateValidator.class)\n            .configure()\n            // 快速失败模式\n            .failFast(true)\n            .buildValidatorFactory();\n    return validatorFactory.getValidator();\n}\n\n\n\n# Spring 校验原理\n\n\n# Spring 校验使用场景\n\n * Spring 常规校验（Validator）\n * Spring 数据绑定（DataBinder）\n * Spring Web 参数绑定（WebDataBinder）\n * Spring WebMVC/WebFlux 处理方法参数校验\n\n\n# Validator 接口设计\n\n * 接口职责\n   * Spring 内部校验器接口，通过编程的方式校验目标对象\n * 核心方法\n   * supports(Class)：校验目标类能否校验\n   * validate(Object,Errors)：校验目标对象，并将校验失败的内容输出至 Errors 对象\n * 配套组件\n   * 错误收集器：org.springframework.validation.Errors\n   * Validator 工具类：org.springframework.validation.ValidationUtils\n\n\n# Errors 接口设计\n\n * 接口职责\n   * 数据绑定和校验错误收集接口，与 Java Bean 和其属性有强关联性\n * 核心方法\n   * reject 方法（重载）：收集错误文案\n   * rejectValue 方法（重载）：收集对象字段中的错误文案\n * 配套组件\n   * Java Bean 错误描述：org.springframework.validation.ObjectError\n   * Java Bean 属性错误描述：org.springframework.validation.FieldError\n\n\n# Errors 文案来源\n\nErrors 文案生成步骤\n\n * 选择 Errors 实现（如：org.springframework.validation.BeanPropertyBindingResult）\n * 调用 reject 或 rejectValue 方法\n * 获取 Errors 对象中 ObjectError 或 FieldError\n * 将 ObjectError 或 FieldError 中的 code 和 args，关联 MessageSource 实现（如：ResourceBundleMessageSource）\n\n\n# spring web 校验原理\n\n# RequestBody 参数校验实现原理\n\n在 spring-mvc 中，RequestResponseBodyMethodProcessor 是用于解析 @RequestBody 标注的参数以及处理@ResponseBody 标注方法的返回值的。其中，执行参数校验的逻辑肯定就在解析参数的方法 resolveArgument() 中：\n\n@Override\npublic Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,\n    NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception {\n\n    parameter = parameter.nestedIfOptional();\n    Object arg = readWithMessageConverters(webRequest, parameter, parameter.getNestedGenericParameterType());\n    String name = Conventions.getVariableNameForParameter(parameter);\n\n    if (binderFactory != null) {\n        WebDataBinder binder = binderFactory.createBinder(webRequest, arg, name);\n        if (arg != null) {\n            // 尝试进行参数校验\n            validateIfApplicable(binder, parameter);\n            if (binder.getBindingResult().hasErrors() && isBindExceptionRequired(binder, parameter)) {\n                // 如果存在校验错误，则抛出 MethodArgumentNotValidException\n                throw new MethodArgumentNotValidException(parameter, binder.getBindingResult());\n            }\n        }\n        if (mavContainer != null) {\n            mavContainer.addAttribute(BindingResult.MODEL_KEY_PREFIX + name, binder.getBindingResult());\n        }\n    }\n\n    return adaptArgumentIfNecessary(arg, parameter);\n}\n\n\n可以看到，resolveArgument()调用了 validateIfApplicable()进行参数校验。\n\nprotected void validateIfApplicable(WebDataBinder binder, MethodParameter parameter) {\n    // 获取参数注解，如 @RequestBody、@Valid、@Validated\n    Annotation[] annotations = parameter.getParameterAnnotations();\n    for (Annotation ann : annotations) {\n        // 先尝试获取 @Validated 注解\n        Validated validatedAnn = AnnotationUtils.getAnnotation(ann, Validated.class);\n        // 如果标注了 @Validated，直接开始校验。\n        // 如果没有，那么判断参数前是否有 Valid 开头的注解。\n        if (validatedAnn != null || ann.annotationType().getSimpleName().startsWith("Valid")) {\n            Object hints = (validatedAnn != null ? validatedAnn.value() : AnnotationUtils.getValue(ann));\n            Object[] validationHints = (hints instanceof Object[] ? (Object[]) hints : new Object[] {hints});\n            // 执行校验\n            binder.validate(validationHints);\n            break;\n        }\n    }\n}\n\n\n以上代码，就解释了 Spring 为什么能同时支持 @Validated、@Valid 两个注解。\n\n接下来，看一下 WebDataBinder.validate() 的实现：\n\n@Override\npublic void validate(Object target, Errors errors, Object... validationHints) {\n    if (this.targetValidator != null) {\n        processConstraintViolations(\n            // 此处调用 Hibernate Validator 执行真正的校验\n            this.targetValidator.validate(target, asValidationGroups(validationHints)), errors);\n    }\n}\n\n\n通过上面代码，可以看出 Spring 校验实际上是基于 Hibernate Validator 的封装。\n\n# 方法级别的参数校验实现原理\n\nSpring 支持根据方法去进行拦截、校验，原理就在于应用了 AOP 技术。具体来说，是通过 MethodValidationPostProcessor 动态注册 AOP 切面，然后使用 MethodValidationInterceptor 对切点方法织入增强。\n\npublic class MethodValidationPostProcessor extends AbstractBeanFactoryAwareAdvisingPostProcessorimplements InitializingBean {\n    @Override\n    public void afterPropertiesSet() {\n        // 为所有 @Validated 标注的 Bean 创建切面\n        Pointcut pointcut = new AnnotationMatchingPointcut(this.validatedAnnotationType, true);\n        // 创建 Advisor 进行增强\n        this.advisor = new DefaultPointcutAdvisor(pointcut, createMethodValidationAdvice(this.validator));\n    }\n\n    // 创建 Advice，本质就是一个方法拦截器\n    protected Advice createMethodValidationAdvice(@Nullable Validator validator) {\n        return (validator != null ? new MethodValidationInterceptor(validator) : new MethodValidationInterceptor());\n    }\n}\n\n\n接着看一下 MethodValidationInterceptor：\n\npublic class MethodValidationInterceptor implements MethodInterceptor {\n    @Override\n    public Object invoke(MethodInvocation invocation) throws Throwable {\n        // 无需增强的方法，直接跳过\n        if (isFactoryBeanMetadataMethod(invocation.getMethod())) {\n            return invocation.proceed();\n        }\n        // 获取分组信息\n        Class<?>[] groups = determineValidationGroups(invocation);\n        ExecutableValidator execVal = this.validator.forExecutables();\n        Method methodToValidate = invocation.getMethod();\n        Set<ConstraintViolation<Object>> result;\n        try {\n            // 方法入参校验，最终还是委托给 Hibernate Validator 来校验\n            result = execVal.validateParameters(\n                invocation.getThis(), methodToValidate, invocation.getArguments(), groups);\n        }\n        catch (IllegalArgumentException ex) {\n            ...\n        }\n        // 有异常直接抛出\n        if (!result.isEmpty()) {\n            throw new ConstraintViolationException(result);\n        }\n        // 真正的方法调用\n        Object returnValue = invocation.proceed();\n        // 对返回值做校验，最终还是委托给Hibernate Validator来校验\n        result = execVal.validateReturnValue(invocation.getThis(), methodToValidate, returnValue, groups);\n        // 有异常直接抛出\n        if (!result.isEmpty()) {\n            throw new ConstraintViolationException(result);\n        }\n        return returnValue;\n    }\n}\n\n\n实际上，不管是 requestBody 参数校验还是方法级别的校验，最终都是调用 Hibernate Validator 执行校验，Spring Validation 只是做了一层封装。\n\n\n# 问题\n\nSpring 有哪些校验核心组件？\n\n * 检验器：org.springframework.validation.Validator\n * 错误收集器：org.springframework.validation.Errors\n * Java Bean 错误描述：org.springframework.validation.ObjectError\n * Java Bean 属性错误描述：org.springframework.validation.FieldError\n * Bean Validation 适配：org.springframework.validation.beanvalidation.LocalValidatorFactoryBean\n\n\n# 参考资料\n\n * Spring 官方文档之 Core Technologies\n * 《小马哥讲 Spring 核心编程思想》\n * https://juejin.cn/post/6856541106626363399',normalizedContent:'# spring 校验\n\njava api 规范(jsr303)定义了bean校验的标准validation-api，但没有提供实现。hibernate validation是对这个规范的实现，并增加了校验注解如@email、@length等。spring validation是对hibernate validation的二次封装，用于支持spring mvc参数自动校验。\n\n\n# 快速入门\n\n\n# 引入依赖\n\n如果 spring-boot 版本小于 2.3.x，spring-boot-starter-web 会自动传入 hibernate-validator 依赖。如果 spring-boot 版本大于 2.3.x，则需要手动引入依赖：\n\n<dependency>\n  <groupid>org.hibernate.validator</groupid>\n  <artifactid>hibernate-validator-parent</artifactid>\n  <version>6.2.5.final</version>\n</dependency>\n\n\n对于 web 服务来说，为防止非法参数对业务造成影响，在 controller 层一定要做参数校验的！大部分情况下，请求参数分为如下两种形式：\n\n * post、put 请求，使用 requestbody 传递参数；\n * get 请求，使用 requestparam/pathvariable 传递参数。\n\n实际上，不管是 requestbody 参数校验还是方法级别的校验，最终都是调用 hibernate validator 执行校验，spring validation 只是做了一层封装。\n\n\n# 校验示例\n\n（1）在实体上标记校验注解\n\n@data\n@noargsconstructor\n@allargsconstructor\npublic class user implements serializable {\n\n    @notnull\n    private long id;\n\n    @notblank\n    @size(min = 2, max = 10)\n    private string name;\n\n    @min(value = 1)\n    @max(value = 100)\n    private integer age;\n\n}\n\n\n（2）在方法参数上声明校验注解\n\n@slf4j\n@validated\n@restcontroller\n@requestmapping("validate1")\npublic class validatorcontroller {\n\n    /**\n     * {@link requestbody} 参数校验\n     */\n    @postmapping(value = "save")\n    public dataresult<boolean> save(@valid @requestbody user entity) {\n        log.info("保存一条记录：{}", jsonutil.tojsonstr(entity));\n        return dataresult.ok(true);\n    }\n\n    /**\n     * {@link requestparam} 参数校验\n     */\n    @getmapping(value = "querybyname")\n    public dataresult<user> querybyname(\n        @requestparam("username")\n        @notblank\n        @size(min = 2, max = 10)\n        string name\n    ) {\n        user user = new user(1l, name, 18);\n        return dataresult.ok(user);\n    }\n\n    /**\n     * {@link pathvariable} 参数校验\n     */\n    @getmapping(value = "detail/{id}")\n    public dataresult<user> detail(@pathvariable("id") @min(1l) long id) {\n        user user = new user(id, "李四", 18);\n        return dataresult.ok(user);\n    }\n\n}\n\n\n（3）如果请求参数不满足校验规则，则会抛出 constraintviolationexception 或 methodargumentnotvalidexception 异常。\n\n\n# 统一异常处理\n\n在实际项目开发中，通常会用统一异常处理来返回一个更友好的提示。\n\n@slf4j\n@controlleradvice\npublic class globalexceptionhandler {\n\n    /**\n     * 处理所有不可知的异常\n     */\n    @responsebody\n    @responsestatus(httpstatus.ok)\n    @exceptionhandler(throwable.class)\n    public result handleexception(throwable e) {\n        log.error("未知异常", e);\n        return new result(resultstatus.http_server_error.getcode(), e.getmessage());\n    }\n\n    /**\n     * 统一处理请求参数校验异常(普通传参)\n     *\n     * @param e constraintviolationexception\n     * @return {@link dataresult}\n     */\n    @responsebody\n    @responsestatus(httpstatus.bad_request)\n    @exceptionhandler({ constraintviolationexception.class })\n    public result handleconstraintviolationexception(final constraintviolationexception e) {\n        log.error("constraintviolationexception", e);\n        list<string> errors = new arraylist<>();\n        for (constraintviolation<?> violation : e.getconstraintviolations()) {\n            path path = violation.getpropertypath();\n            list<string> patharr = strutil.split(path.tostring(), \',\');\n            errors.add(patharr.get(0) + " " + violation.getmessage());\n        }\n        return new result(resultstatus.request_error.getcode(), collectionutil.join(errors, ","));\n    }\n\n    /**\n     * 处理参数校验异常\n     *\n     * @param e methodargumentnotvalidexception\n     * @return {@link dataresult}\n     */\n    @responsebody\n    @responsestatus(httpstatus.bad_request)\n    @exceptionhandler({ methodargumentnotvalidexception.class })\n    private result handlemethodargumentnotvalidexception(final methodargumentnotvalidexception e) {\n        log.error("methodargumentnotvalidexception", e);\n        list<string> errors = new arraylist<>();\n        for (objecterror error : e.getbindingresult().getallerrors()) {\n            errors.add(((fielderror) error).getfield() + " " + error.getdefaultmessage());\n        }\n        return new result(resultstatus.request_error.getcode(), collectionutil.join(errors, ","));\n    }\n\n}\n\n\n\n# 进阶使用\n\n\n# 分组校验\n\n在实际项目中，可能多个方法需要使用同一个 dto 类来接收参数，而不同方法的校验规则很可能是不一样的。这个时候，简单地在 dto 类的字段上加约束注解无法解决这个问题。因此，spring-validation 支持了分组校验的功能，专门用来解决这类问题。\n\n（1）定义分组\n\n@target({ elementtype.field, elementtype.parameter })\n@retention(retentionpolicy.runtime)\npublic @interface addcheck { }\n\n@target({ elementtype.field, elementtype.parameter })\n@retention(retentionpolicy.runtime)\npublic @interface editcheck { }\n\n\n（2）在实体上标记校验注解\n\n@data\npublic class user2 {\n\n    @notnull(groups = editcheck.class)\n    private long id;\n\n    @notnull(groups = { addcheck.class, editcheck.class })\n    @size(min = 2, max = 10, groups = { addcheck.class, editcheck.class })\n    private string name;\n\n    @ismobile(message = "不是有效手机号", groups = { addcheck.class, editcheck.class })\n    private string mobile;\n\n}\n\n\n（3）在方法上根据不同场景进行校验分组\n\n@slf4j\n@validated\n@restcontroller\n@requestmapping("validate2")\npublic class validatorcontroller2 {\n\n    /**\n     * {@link requestbody} 参数校验\n     */\n    @postmapping(value = "add")\n    public dataresult<boolean> add(@validated(addcheck.class) @requestbody user2 entity) {\n        log.info("添加一条记录：{}", jsonutil.tojsonstr(entity));\n        return dataresult.ok(true);\n    }\n\n    /**\n     * {@link requestbody} 参数校验\n     */\n    @postmapping(value = "edit")\n    public dataresult<boolean> edit(@validated(editcheck.class) @requestbody user2 entity) {\n        log.info("编辑一条记录：{}", jsonutil.tojsonstr(entity));\n        return dataresult.ok(true);\n    }\n\n}\n\n\n\n# 嵌套校验\n\n前面的示例中，dto 类里面的字段都是基本数据类型和 string 类型。但是实际场景中，有可能某个字段也是一个对象，这种情况先，可以使用嵌套校验。 post 比如，上面保存 user 信息的时候同时还带有 job 信息。需要注意的是，此时 dto 类的对应字段必须标记@valid 注解。\n\n@data\npublic class userdto {\n\n    @min(value = 10000000000000000l, groups = update.class)\n    private long userid;\n\n    @notnull(groups = {save.class, update.class})\n    @length(min = 2, max = 10, groups = {save.class, update.class})\n    private string username;\n\n    @notnull(groups = {save.class, update.class})\n    @length(min = 6, max = 20, groups = {save.class, update.class})\n    private string account;\n\n    @notnull(groups = {save.class, update.class})\n    @length(min = 6, max = 20, groups = {save.class, update.class})\n    private string password;\n\n    @notnull(groups = {save.class, update.class})\n    @valid\n    private job job;\n\n    @data\n    public static class job {\n\n        @min(value = 1, groups = update.class)\n        private long jobid;\n\n        @notnull(groups = {save.class, update.class})\n        @length(min = 2, max = 10, groups = {save.class, update.class})\n        private string jobname;\n\n        @notnull(groups = {save.class, update.class})\n        @length(min = 2, max = 10, groups = {save.class, update.class})\n        private string position;\n    }\n\n    /**\n     * 保存的时候校验分组\n     */\n    public interface save {\n    }\n\n    /**\n     * 更新的时候校验分组\n     */\n    public interface update {\n    }\n}\n复制代码\n\n\n嵌套校验可以结合分组校验一起使用。还有就是嵌套集合校验会对集合里面的每一项都进行校验，例如list<job>字段会对这个 list 里面的每一个 job 对象都进行校验\n\n\n# 自定义校验注解\n\n（1）自定义校验注解 @ismobile\n\n@target({ method, field, annotation_type, constructor, parameter, type_use })\n@retention(runtime)\n@constraint(validatedby = mobilevalidator.class)\npublic @interface ismobile {\n\n    string message();\n\n    class<?>[] groups() default {};\n\n    class<? extends payload>[] payload() default {};\n\n}\n\n\n（2）实现 constraintvalidator 接口，编写 @ismobile 校验注解的解析器\n\nimport cn.hutool.core.util.strutil;\nimport io.github.dunwu.spring.core.validation.annotation.ismobile;\nimport io.github.dunwu.tool.util.validatorutil;\n\nimport javax.validation.constraintvalidator;\nimport javax.validation.constraintvalidatorcontext;\n\npublic class mobilevalidator implements constraintvalidator<ismobile, string> {\n\n    @override\n    public void initialize(ismobile ismobile) { }\n\n    @override\n    public boolean isvalid(string s, constraintvalidatorcontext constraintvalidatorcontext) {\n        if (strutil.isblank(s)) {\n            return false;\n        } else {\n            return validatorutil.ismobile(s);\n        }\n    }\n\n}\n\n\n\n# 自定义校验\n\n可以通过实现 org.springframework.validation.validator 接口来自定义校验。\n\n有以下要点\n\n * 实现 supports 方法\n * 实现 validate 方法\n   * 通过 errors 对象收集错误\n     * objecterror：对象（bean）错误：\n     * fielderror：对象（bean）属性（property）错误\n   * 通过 objecterror 和 fielderror 关联 messagesource 实现获取最终的错误文案\n\npackage io.github.dunwu.spring.core.validation;\n\nimport io.github.dunwu.spring.core.validation.annotation.valid;\nimport io.github.dunwu.spring.core.validation.config.customvalidatorconfig;\nimport io.github.dunwu.spring.core.validation.entity.person;\nimport org.springframework.stereotype.component;\nimport org.springframework.validation.errors;\nimport org.springframework.validation.validationutils;\nimport org.springframework.validation.validator;\n\nimport java.lang.annotation.annotation;\nimport java.lang.reflect.field;\nimport java.util.arraylist;\nimport java.util.collections;\nimport java.util.list;\n\n@component\npublic class customvalidator implements validator {\n\n    private final customvalidatorconfig validatorconfig;\n\n    public customvalidator(customvalidatorconfig validatorconfig) {\n        this.validatorconfig = validatorconfig;\n    }\n\n    /**\n     * 本校验器只针对 person 对象进行校验\n     */\n    @override\n    public boolean supports(class<?> clazz) {\n        return person.class.equals(clazz);\n    }\n\n    @override\n    public void validate(object target, errors errors) {\n        validationutils.rejectifempty(errors, "name", "name.empty");\n\n        list<field> fields = getfields(target.getclass());\n        for (field field : fields) {\n            annotation[] annotations = field.getannotations();\n            for (annotation annotation : annotations) {\n                if (annotation.annotationtype().getannotation(valid.class) != null) {\n                    try {\n                        validatorrule validatorrule = validatorconfig.findrule(annotation);\n                        if (validatorrule != null) {\n                            validatorrule.valid(annotation, target, field, errors);\n                        }\n                    } catch (exception e) {\n                        e.printstacktrace();\n                    }\n                }\n            }\n        }\n    }\n\n    private list<field> getfields(class<?> clazz) {\n        // 声明field数组\n        list<field> fields = new arraylist<>();\n        // 如果class类型不为空\n        while (clazz != null) {\n            // 添加属性到属性数组\n            collections.addall(fields, clazz.getdeclaredfields());\n            clazz = clazz.getsuperclass();\n        }\n        return fields;\n    }\n\n}\n\n\n\n# 快速失败(fail fast)\n\nspring validation 默认会校验完所有字段，然后才抛出异常。可以通过一些简单的配置，开启 fali fast 模式，一旦校验失败就立即返回。\n\n@bean\npublic validator validator() {\n    validatorfactory validatorfactory = validation.byprovider(hibernatevalidator.class)\n            .configure()\n            // 快速失败模式\n            .failfast(true)\n            .buildvalidatorfactory();\n    return validatorfactory.getvalidator();\n}\n\n\n\n# spring 校验原理\n\n\n# spring 校验使用场景\n\n * spring 常规校验（validator）\n * spring 数据绑定（databinder）\n * spring web 参数绑定（webdatabinder）\n * spring webmvc/webflux 处理方法参数校验\n\n\n# validator 接口设计\n\n * 接口职责\n   * spring 内部校验器接口，通过编程的方式校验目标对象\n * 核心方法\n   * supports(class)：校验目标类能否校验\n   * validate(object,errors)：校验目标对象，并将校验失败的内容输出至 errors 对象\n * 配套组件\n   * 错误收集器：org.springframework.validation.errors\n   * validator 工具类：org.springframework.validation.validationutils\n\n\n# errors 接口设计\n\n * 接口职责\n   * 数据绑定和校验错误收集接口，与 java bean 和其属性有强关联性\n * 核心方法\n   * reject 方法（重载）：收集错误文案\n   * rejectvalue 方法（重载）：收集对象字段中的错误文案\n * 配套组件\n   * java bean 错误描述：org.springframework.validation.objecterror\n   * java bean 属性错误描述：org.springframework.validation.fielderror\n\n\n# errors 文案来源\n\nerrors 文案生成步骤\n\n * 选择 errors 实现（如：org.springframework.validation.beanpropertybindingresult）\n * 调用 reject 或 rejectvalue 方法\n * 获取 errors 对象中 objecterror 或 fielderror\n * 将 objecterror 或 fielderror 中的 code 和 args，关联 messagesource 实现（如：resourcebundlemessagesource）\n\n\n# spring web 校验原理\n\n# requestbody 参数校验实现原理\n\n在 spring-mvc 中，requestresponsebodymethodprocessor 是用于解析 @requestbody 标注的参数以及处理@responsebody 标注方法的返回值的。其中，执行参数校验的逻辑肯定就在解析参数的方法 resolveargument() 中：\n\n@override\npublic object resolveargument(methodparameter parameter, @nullable modelandviewcontainer mavcontainer,\n    nativewebrequest webrequest, @nullable webdatabinderfactory binderfactory) throws exception {\n\n    parameter = parameter.nestedifoptional();\n    object arg = readwithmessageconverters(webrequest, parameter, parameter.getnestedgenericparametertype());\n    string name = conventions.getvariablenameforparameter(parameter);\n\n    if (binderfactory != null) {\n        webdatabinder binder = binderfactory.createbinder(webrequest, arg, name);\n        if (arg != null) {\n            // 尝试进行参数校验\n            validateifapplicable(binder, parameter);\n            if (binder.getbindingresult().haserrors() && isbindexceptionrequired(binder, parameter)) {\n                // 如果存在校验错误，则抛出 methodargumentnotvalidexception\n                throw new methodargumentnotvalidexception(parameter, binder.getbindingresult());\n            }\n        }\n        if (mavcontainer != null) {\n            mavcontainer.addattribute(bindingresult.model_key_prefix + name, binder.getbindingresult());\n        }\n    }\n\n    return adaptargumentifnecessary(arg, parameter);\n}\n\n\n可以看到，resolveargument()调用了 validateifapplicable()进行参数校验。\n\nprotected void validateifapplicable(webdatabinder binder, methodparameter parameter) {\n    // 获取参数注解，如 @requestbody、@valid、@validated\n    annotation[] annotations = parameter.getparameterannotations();\n    for (annotation ann : annotations) {\n        // 先尝试获取 @validated 注解\n        validated validatedann = annotationutils.getannotation(ann, validated.class);\n        // 如果标注了 @validated，直接开始校验。\n        // 如果没有，那么判断参数前是否有 valid 开头的注解。\n        if (validatedann != null || ann.annotationtype().getsimplename().startswith("valid")) {\n            object hints = (validatedann != null ? validatedann.value() : annotationutils.getvalue(ann));\n            object[] validationhints = (hints instanceof object[] ? (object[]) hints : new object[] {hints});\n            // 执行校验\n            binder.validate(validationhints);\n            break;\n        }\n    }\n}\n\n\n以上代码，就解释了 spring 为什么能同时支持 @validated、@valid 两个注解。\n\n接下来，看一下 webdatabinder.validate() 的实现：\n\n@override\npublic void validate(object target, errors errors, object... validationhints) {\n    if (this.targetvalidator != null) {\n        processconstraintviolations(\n            // 此处调用 hibernate validator 执行真正的校验\n            this.targetvalidator.validate(target, asvalidationgroups(validationhints)), errors);\n    }\n}\n\n\n通过上面代码，可以看出 spring 校验实际上是基于 hibernate validator 的封装。\n\n# 方法级别的参数校验实现原理\n\nspring 支持根据方法去进行拦截、校验，原理就在于应用了 aop 技术。具体来说，是通过 methodvalidationpostprocessor 动态注册 aop 切面，然后使用 methodvalidationinterceptor 对切点方法织入增强。\n\npublic class methodvalidationpostprocessor extends abstractbeanfactoryawareadvisingpostprocessorimplements initializingbean {\n    @override\n    public void afterpropertiesset() {\n        // 为所有 @validated 标注的 bean 创建切面\n        pointcut pointcut = new annotationmatchingpointcut(this.validatedannotationtype, true);\n        // 创建 advisor 进行增强\n        this.advisor = new defaultpointcutadvisor(pointcut, createmethodvalidationadvice(this.validator));\n    }\n\n    // 创建 advice，本质就是一个方法拦截器\n    protected advice createmethodvalidationadvice(@nullable validator validator) {\n        return (validator != null ? new methodvalidationinterceptor(validator) : new methodvalidationinterceptor());\n    }\n}\n\n\n接着看一下 methodvalidationinterceptor：\n\npublic class methodvalidationinterceptor implements methodinterceptor {\n    @override\n    public object invoke(methodinvocation invocation) throws throwable {\n        // 无需增强的方法，直接跳过\n        if (isfactorybeanmetadatamethod(invocation.getmethod())) {\n            return invocation.proceed();\n        }\n        // 获取分组信息\n        class<?>[] groups = determinevalidationgroups(invocation);\n        executablevalidator execval = this.validator.forexecutables();\n        method methodtovalidate = invocation.getmethod();\n        set<constraintviolation<object>> result;\n        try {\n            // 方法入参校验，最终还是委托给 hibernate validator 来校验\n            result = execval.validateparameters(\n                invocation.getthis(), methodtovalidate, invocation.getarguments(), groups);\n        }\n        catch (illegalargumentexception ex) {\n            ...\n        }\n        // 有异常直接抛出\n        if (!result.isempty()) {\n            throw new constraintviolationexception(result);\n        }\n        // 真正的方法调用\n        object returnvalue = invocation.proceed();\n        // 对返回值做校验，最终还是委托给hibernate validator来校验\n        result = execval.validatereturnvalue(invocation.getthis(), methodtovalidate, returnvalue, groups);\n        // 有异常直接抛出\n        if (!result.isempty()) {\n            throw new constraintviolationexception(result);\n        }\n        return returnvalue;\n    }\n}\n\n\n实际上，不管是 requestbody 参数校验还是方法级别的校验，最终都是调用 hibernate validator 执行校验，spring validation 只是做了一层封装。\n\n\n# 问题\n\nspring 有哪些校验核心组件？\n\n * 检验器：org.springframework.validation.validator\n * 错误收集器：org.springframework.validation.errors\n * java bean 错误描述：org.springframework.validation.objecterror\n * java bean 属性错误描述：org.springframework.validation.fielderror\n * bean validation 适配：org.springframework.validation.beanvalidation.localvalidatorfactorybean\n\n\n# 参考资料\n\n * spring 官方文档之 core technologies\n * 《小马哥讲 spring 核心编程思想》\n * https://juejin.cn/post/6856541106626363399',charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Spring 数据绑定",frontmatter:{title:"Spring 数据绑定",date:"2022-12-22T19:26:57.000Z",order:22,categories:["Java","框架","Spring","Spring核心"],tags:["Java","框架","Spring","数据绑定"],permalink:"/pages/267b4c/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/01.Spring%E6%A0%B8%E5%BF%83/22.Spring%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A.html",relativePath:"01.Java/13.框架/01.Spring/01.Spring核心/22.Spring数据绑定.md",key:"v-32d028da",path:"/pages/267b4c/",headers:[{level:2,title:"快速入门",slug:"快速入门",normalizedTitle:"快速入门",charIndex:201},{level:2,title:"Spring 数据绑定使用场景",slug:"spring-数据绑定使用场景",normalizedTitle:"spring 数据绑定使用场景",charIndex:848},{level:2,title:"DataBinder",slug:"databinder",normalizedTitle:"databinder",charIndex:120},{level:2,title:"Spring 数据绑定元数据",slug:"spring-数据绑定元数据",normalizedTitle:"spring 数据绑定元数据",charIndex:1607},{level:2,title:"Spring 数据绑定控制参数",slug:"spring-数据绑定控制参数",normalizedTitle:"spring 数据绑定控制参数",charIndex:1996},{level:3,title:"DataBinder 绑定控制参数",slug:"databinder-绑定控制参数",normalizedTitle:"databinder 绑定控制参数",charIndex:2303},{level:2,title:"BeanWrapper 的使用场景",slug:"beanwrapper-的使用场景",normalizedTitle:"beanwrapper 的使用场景",charIndex:2563},{level:2,title:"Spring 底层 Java Beans 替换实现",slug:"spring-底层-java-beans-替换实现",normalizedTitle:"spring 底层 java beans 替换实现",charIndex:2796},{level:2,title:"DataBinder 数据校验",slug:"databinder-数据校验",normalizedTitle:"databinder 数据校验",charIndex:3082},{level:2,title:"问题",slug:"问题",normalizedTitle:"问题",charIndex:3212},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:3573}],headersStr:"快速入门 Spring 数据绑定使用场景 DataBinder Spring 数据绑定元数据 Spring 数据绑定控制参数 DataBinder 绑定控制参数 BeanWrapper 的使用场景 Spring 底层 Java Beans 替换实现 DataBinder 数据校验 问题 参考资料",content:'# Spring 数据绑定\n\nSpring 数据绑定(Data Binding)的作用是将用户的输入动态绑定到 JavaBean。换句话说，Spring 数据绑定机制是将属性值设置到目标对象中。\n\n在 Spring 中，数据绑定功能主要由 DataBinder 类实现。此外，BeanWrapper 也具有类似的功能，但 DataBinder 额外支持字段验证、字段格式化和绑定结果分析。\n\n\n\n\n# 快速入门\n\n定义一个用于测试的 JavaBean\n\npublic class TestBean {\n\n    private int num;\n\n    public int getNum() {\n        return num;\n    }\n\n    public void setNum(int num) {\n        this.num = num;\n    }\n\n    @Override\n    public String toString() {\n        return "TestBean{" + "num=" + num + \'}\';\n    }\n\n}\n\n\n数据绑定示例\n\npublic class DataBindingDemo {\n\n    public static void main(String[] args) {\n\n        MutablePropertyValues mpv = new MutablePropertyValues();\n        mpv.add("num", "10");\n\n        TestBean testBean = new TestBean();\n        DataBinder db = new DataBinder(testBean);\n\n        db.bind(mpv);\n        System.out.println(testBean);\n    }\n\n}\n\n\n\n# Spring 数据绑定使用场景\n\n * Spring BeanDefinition 到 Bean 实例创建\n * Spring 数据绑定（DataBinder）\n * Spring Web 参数绑定（WebDataBinder）\n\n\n# DataBinder\n\n在 Spring 中，DataBinder 类是数据绑定功能的基类。WebDataBinder 是 DataBinder 的子类，主要用于 Spring Web 数据绑定，此外，还有一些 WebDataBinder 的扩展子类，其类族如下图所示：\n\n\n\nDataBinder 核心属性：\n\n属性                     说明\ntarget                 关联目标 Bean\nobjectName             目标 Bean 名称\nbindingResult          属性绑定结果\ntypeConverter          类型转换器\nconversionService      类型转换服务\nmessageCodesResolver   校验错误文案 Code 处理器\nvalidators             关联的 Bean Validator 实例集合\n\nDataBinder 类的核心方法是 bind(PropertyValues)：将 PropertyValues Key-Value 内容映射到关联 Bean（target）中的属性上\n\n * 假设 PropertyValues 中包含 name=dunwu 的键值对时, 同时 Bean 对象 User 中存在 name 属性, 当 bind 方法执行时, User 对象中的 name 属性值将被绑定为 dunwu\n\n\n# Spring 数据绑定元数据\n\nDataBinder 元数据 - PropertyValues\n\n特征         说明\n数据来源       BeanDefinition，主要来源 XML 资源配置 BeanDefinition\n数据结构       由一个或多个 PropertyValue 组成\n成员结构       PropertyValue 包含属性名称，以及属性值（包括原始值、类型转换后的值）\n常见实现       MutablePropertyValues\nWeb 扩展实现   ServletConfigPropertyValues、ServletRequestParameterPropertyValues\n相关生命周期     InstantiationAwareBeanPostProcessor#postProcessProperties\n\n\n# Spring 数据绑定控制参数\n\nDataBinder 绑定特殊场景分析\n\n * 当 PropertyValues 中包含名称 x 的 PropertyValue，目标对象 B 不存在 x 属性，当 bind 方法执 行时，会发生什么？\n * 当 PropertyValues 中包含名称 x 的 PropertyValue，目标对象 B 中存在 x 属性，当 bind 方法执 行时，如何避免 B 属性 x 不被绑定？\n * 当 PropertyValues 中包含名称 x.y 的 PropertyValue，目标对象 B 中存在 x 属性（嵌套 y 属性） ，当 bind 方法执行时，会发生什么？\n\n\n# DataBinder 绑定控制参数\n\n参数名称                  说明\nignoreUnknownFields   是否忽略未知字段，默认值：true\nignoreInvalidFields   是否忽略非法字段，默认值：false\nautoGrowNestedPaths   是否自动增加嵌套路径，默认值：true\nallowedFields         绑定字段白名单\ndisallowedFields      绑定字段黑名单\nrequiredFields        必须绑定字段\n\n\n# BeanWrapper 的使用场景\n\n * Spring 底层 JavaBeans 基础设施的中心化接口\n * 通常不会直接使用，间接用于 BeanFactory 和 DataBinder\n * 提供标准 JavaBeans 分析和操作，能够单独或批量存储 Java Bean 的属性（properties）\n * 支持嵌套属性路径（nested path）\n * 实现类 org.springframework.beans.BeanWrapperImpl\n\n\n# Spring 底层 Java Beans 替换实现\n\nJavaBeans 核心实现 - java.beans.BeanInfo\n\n * 属性（Property）\n   * java.beans.PropertyEditor\n * 方法（Method）\n * 事件（Event）\n * 表达式（Expression）\n\nSpring 替代实现 - org.springframework.beans.BeanWrapper\n\n * 属性（Property）\n   * java.beans.PropertyEditor\n * 嵌套属性路径（nested path）\n\n\n# DataBinder 数据校验\n\nDataBinder 与 BeanWrapper\n\n * bind 方法生成 BeanPropertyBindingResult\n * BeanPropertyBindingResult 关联 BeanWrapper\n\n\n# 问题\n\n标准 JavaBeans 是如何操作属性的？\n\nAPI                             说明\njava.beans.Introspector         Java Beans 内省 API\njava.beans.BeanInfo             Java Bean 元信息 API\njava.beans.BeanDescriptor       Java Bean 信息描述符\njava.beans.PropertyDescriptor   Java Bean 属性描述符\njava.beans.MethodDescriptor     Java Bean 方法描述符\njava.beans.EventSetDescriptor   Java Bean 事件集合描述符\n\n\n# 参考资料\n\n * Spring 官方文档之 Core Technologies\n * 《小马哥讲 Spring 核心编程思想》',normalizedContent:'# spring 数据绑定\n\nspring 数据绑定(data binding)的作用是将用户的输入动态绑定到 javabean。换句话说，spring 数据绑定机制是将属性值设置到目标对象中。\n\n在 spring 中，数据绑定功能主要由 databinder 类实现。此外，beanwrapper 也具有类似的功能，但 databinder 额外支持字段验证、字段格式化和绑定结果分析。\n\n\n\n\n# 快速入门\n\n定义一个用于测试的 javabean\n\npublic class testbean {\n\n    private int num;\n\n    public int getnum() {\n        return num;\n    }\n\n    public void setnum(int num) {\n        this.num = num;\n    }\n\n    @override\n    public string tostring() {\n        return "testbean{" + "num=" + num + \'}\';\n    }\n\n}\n\n\n数据绑定示例\n\npublic class databindingdemo {\n\n    public static void main(string[] args) {\n\n        mutablepropertyvalues mpv = new mutablepropertyvalues();\n        mpv.add("num", "10");\n\n        testbean testbean = new testbean();\n        databinder db = new databinder(testbean);\n\n        db.bind(mpv);\n        system.out.println(testbean);\n    }\n\n}\n\n\n\n# spring 数据绑定使用场景\n\n * spring beandefinition 到 bean 实例创建\n * spring 数据绑定（databinder）\n * spring web 参数绑定（webdatabinder）\n\n\n# databinder\n\n在 spring 中，databinder 类是数据绑定功能的基类。webdatabinder 是 databinder 的子类，主要用于 spring web 数据绑定，此外，还有一些 webdatabinder 的扩展子类，其类族如下图所示：\n\n\n\ndatabinder 核心属性：\n\n属性                     说明\ntarget                 关联目标 bean\nobjectname             目标 bean 名称\nbindingresult          属性绑定结果\ntypeconverter          类型转换器\nconversionservice      类型转换服务\nmessagecodesresolver   校验错误文案 code 处理器\nvalidators             关联的 bean validator 实例集合\n\ndatabinder 类的核心方法是 bind(propertyvalues)：将 propertyvalues key-value 内容映射到关联 bean（target）中的属性上\n\n * 假设 propertyvalues 中包含 name=dunwu 的键值对时, 同时 bean 对象 user 中存在 name 属性, 当 bind 方法执行时, user 对象中的 name 属性值将被绑定为 dunwu\n\n\n# spring 数据绑定元数据\n\ndatabinder 元数据 - propertyvalues\n\n特征         说明\n数据来源       beandefinition，主要来源 xml 资源配置 beandefinition\n数据结构       由一个或多个 propertyvalue 组成\n成员结构       propertyvalue 包含属性名称，以及属性值（包括原始值、类型转换后的值）\n常见实现       mutablepropertyvalues\nweb 扩展实现   servletconfigpropertyvalues、servletrequestparameterpropertyvalues\n相关生命周期     instantiationawarebeanpostprocessor#postprocessproperties\n\n\n# spring 数据绑定控制参数\n\ndatabinder 绑定特殊场景分析\n\n * 当 propertyvalues 中包含名称 x 的 propertyvalue，目标对象 b 不存在 x 属性，当 bind 方法执 行时，会发生什么？\n * 当 propertyvalues 中包含名称 x 的 propertyvalue，目标对象 b 中存在 x 属性，当 bind 方法执 行时，如何避免 b 属性 x 不被绑定？\n * 当 propertyvalues 中包含名称 x.y 的 propertyvalue，目标对象 b 中存在 x 属性（嵌套 y 属性） ，当 bind 方法执行时，会发生什么？\n\n\n# databinder 绑定控制参数\n\n参数名称                  说明\nignoreunknownfields   是否忽略未知字段，默认值：true\nignoreinvalidfields   是否忽略非法字段，默认值：false\nautogrownestedpaths   是否自动增加嵌套路径，默认值：true\nallowedfields         绑定字段白名单\ndisallowedfields      绑定字段黑名单\nrequiredfields        必须绑定字段\n\n\n# beanwrapper 的使用场景\n\n * spring 底层 javabeans 基础设施的中心化接口\n * 通常不会直接使用，间接用于 beanfactory 和 databinder\n * 提供标准 javabeans 分析和操作，能够单独或批量存储 java bean 的属性（properties）\n * 支持嵌套属性路径（nested path）\n * 实现类 org.springframework.beans.beanwrapperimpl\n\n\n# spring 底层 java beans 替换实现\n\njavabeans 核心实现 - java.beans.beaninfo\n\n * 属性（property）\n   * java.beans.propertyeditor\n * 方法（method）\n * 事件（event）\n * 表达式（expression）\n\nspring 替代实现 - org.springframework.beans.beanwrapper\n\n * 属性（property）\n   * java.beans.propertyeditor\n * 嵌套属性路径（nested path）\n\n\n# databinder 数据校验\n\ndatabinder 与 beanwrapper\n\n * bind 方法生成 beanpropertybindingresult\n * beanpropertybindingresult 关联 beanwrapper\n\n\n# 问题\n\n标准 javabeans 是如何操作属性的？\n\napi                             说明\njava.beans.introspector         java beans 内省 api\njava.beans.beaninfo             java bean 元信息 api\njava.beans.beandescriptor       java bean 信息描述符\njava.beans.propertydescriptor   java bean 属性描述符\njava.beans.methoddescriptor     java bean 方法描述符\njava.beans.eventsetdescriptor   java bean 事件集合描述符\n\n\n# 参考资料\n\n * spring 官方文档之 core technologies\n * 《小马哥讲 spring 核心编程思想》',charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Spring EL 表达式",frontmatter:{title:"Spring EL 表达式",date:"2023-01-12T20:26:46.000Z",order:24,categories:["Java","框架","Spring","Spring核心"],tags:["Java","框架","Spring"],permalink:"/pages/1f743f/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/01.Spring%E6%A0%B8%E5%BF%83/24.SpringEL.html",relativePath:"01.Java/13.框架/01.Spring/01.Spring核心/24.SpringEL.md",key:"v-16ce6423",path:"/pages/1f743f/",headers:[{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:20}],headersStr:"参考资料",content:"# Spring EL 表达式\n\n\n# 参考资料\n\n * Spring 官方文档之 Core Technologies\n * 《小马哥讲 Spring 核心编程思想》",normalizedContent:"# spring el 表达式\n\n\n# 参考资料\n\n * spring 官方文档之 core technologies\n * 《小马哥讲 spring 核心编程思想》",charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Spring 类型转换",frontmatter:{title:"Spring 类型转换",date:"2022-12-22T19:43:59.000Z",order:23,categories:["Java","框架","Spring","Spring核心"],tags:["Java","框架","Spring"],permalink:"/pages/6662dc/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/01.Spring%E6%A0%B8%E5%BF%83/23.Spring%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.html",relativePath:"01.Java/13.框架/01.Spring/01.Spring核心/23.Spring类型转换.md",key:"v-3a6d09bb",path:"/pages/6662dc/",headers:[{level:2,title:"Spring 类型转换的实现",slug:"spring-类型转换的实现",normalizedTitle:"spring 类型转换的实现",charIndex:18},{level:2,title:"使用场景",slug:"使用场景",normalizedTitle:"使用场景",charIndex:127},{level:2,title:"基于 JavaBeans 接口的类型转换",slug:"基于-javabeans-接口的类型转换",normalizedTitle:"基于 javabeans 接口的类型转换",charIndex:37},{level:2,title:"Spring 內建 PropertyEditor 扩展",slug:"spring-內建-propertyeditor-扩展",normalizedTitle:"spring 內建 propertyeditor 扩展",charIndex:711},{level:2,title:"自定义 PropertyEditor 扩展",slug:"自定义-propertyeditor-扩展",normalizedTitle:"自定义 propertyeditor 扩展",charIndex:1326},{level:2,title:"Spring PropertyEditor 的设计缺陷",slug:"spring-propertyeditor-的设计缺陷",normalizedTitle:"spring propertyeditor 的设计缺陷",charIndex:1792},{level:2,title:"Spring 3 通用类型转换接口",slug:"spring-3-通用类型转换接口",normalizedTitle:"spring 3 通用类型转换接口",charIndex:2044},{level:2,title:"Spring 內建类型转换器",slug:"spring-內建类型转换器",normalizedTitle:"spring 內建类型转换器",charIndex:2448},{level:2,title:"Converter 接口的局限性",slug:"converter-接口的局限性",normalizedTitle:"converter 接口的局限性",charIndex:2681},{level:2,title:"GenericConverter 接口",slug:"genericconverter-接口",normalizedTitle:"genericconverter 接口",charIndex:2930},{level:2,title:"优化 GenericConverter 接口",slug:"优化-genericconverter-接口",normalizedTitle:"优化 genericconverter 接口",charIndex:3309},{level:2,title:"扩展 Spring 类型转换器",slug:"扩展-spring-类型转换器",normalizedTitle:"扩展 spring 类型转换器",charIndex:3608},{level:2,title:"统一类型转换服务",slug:"统一类型转换服务",normalizedTitle:"统一类型转换服务",charIndex:3938},{level:2,title:"ConversionService 作为依赖",slug:"conversionservice-作为依赖",normalizedTitle:"conversionservice 作为依赖",charIndex:4480},{level:2,title:"问题",slug:"问题",normalizedTitle:"问题",charIndex:5315},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:5723}],headersStr:"Spring 类型转换的实现 使用场景 基于 JavaBeans 接口的类型转换 Spring 內建 PropertyEditor 扩展 自定义 PropertyEditor 扩展 Spring PropertyEditor 的设计缺陷 Spring 3 通用类型转换接口 Spring 內建类型转换器 Converter 接口的局限性 GenericConverter 接口 优化 GenericConverter 接口 扩展 Spring 类型转换器 统一类型转换服务 ConversionService 作为依赖 问题 参考资料",content:"# Spring 类型转换\n\n\n# Spring 类型转换的实现\n\n * 基于 JavaBeans 接口的类型转换实现\n   * 基于 java.beans.PropertyEditor 接口扩展\n * Spring 3.0+ 通用类型转换实现\n\n\n# 使用场景\n\n场景            基于 JAVABEANS 接口的类型转换实现   SPRING 3.0+ 通用类型转换实现\n数据绑定          YES                      YES\nBeanWrapper   YES                      YES\nBean 属性类型转换   YES                      YES\n外部化属性类型转换     NO                       YES\n\n\n# 基于 JavaBeans 接口的类型转换\n\n核心职责\n\n * 将 String 类型的内容转化为目标类型的对象\n\n扩展原理\n\n * Spring 框架将文本内容传递到 PropertyEditor 实现的 setAsText(String) 方法\n * PropertyEditor#setAsText(String) 方法实现将 String 类型转化为目标类型的对象\n * 将目标类型的对象传入 PropertyEditor#setValue(Object) 方法\n * PropertyEditor#setValue(Object) 方法实现需要临时存储传入对象\n * Spring 框架将通过 PropertyEditor#getValue() 获取类型转换后的对象\n\n\n# Spring 內建 PropertyEditor 扩展\n\n內建扩展（org.springframework.beans.propertyeditors 包下）\n\n转换场景                 实现类\nString -> Byte 数组    org.springframework.beans.propertyeditors.ByteArrayPropertyEditor\nString -> Char       org.springframework.beans.propertyeditors.CharacterEditor\nString -> Char 数组    org.springframework.beans.propertyeditors.CharArrayPropertyEditor\nString -> Charset    org.springframework.beans.propertyeditors.CharsetEditor\nString -> Class      org.springframework.beans.propertyeditors.ClassEditor\nString -> Currency   org.springframework.beans.propertyeditors.CurrencyEditor\n                     \n\n\n# 自定义 PropertyEditor 扩展\n\n扩展模式\n\n * 扩展 java.beans.PropertyEditorSupport 类\n\n实现 org.springframework.beans.PropertyEditorRegistrar\n\n * 实现 registerCustomEditors(org.springframework.beans.PropertyEditorRegistry) 方法\n * 将 PropertyEditorRegistrar 实现注册为 Spring Bean\n\n向 org.springframework.beans.PropertyEditorRegistry 注册自定义 PropertyEditor 实现\n\n * 通用类型实现 registerCustomEditor(Class<?>, PropertyEditor)\n * Java Bean 属性类型实现：registerCustomEditor(Class<?>, String, PropertyEditor)\n\n\n# Spring PropertyEditor 的设计缺陷\n\n违反职责单一原则\n\n * java.beans.PropertyEditor 接口职责太多，除了类型转换，还包括 Java Beans 事件和 Java GUI 交 互\n\njava.beans.PropertyEditor 实现类型局限\n\n * 来源类型只能为 java.lang.String 类型\n\njava.beans.PropertyEditor 实现缺少类型安全\n\n * 除了实现类命名可以表达语义，实现类无法感知目标转换类型\n\n\n# Spring 3 通用类型转换接口\n\n类型转换接口 - org.springframework.core.convert.converter.Converter<S,T>\n\n * 泛型参数 S：来源类型，参数 T：目标类型\n * 核心方法：T convert(S)\n\n通用类型转换接口 - org.springframework.core.convert.converter.GenericConverter\n\n * 核心方法：convert(Object,TypeDescriptor,TypeDescriptor)\n * 配对类型：org.springframework.core.convert.converter.GenericConverter.ConvertiblePair\n * 类型描述：org.springframework.core.convert.TypeDescriptor\n\n\n# Spring 內建类型转换器\n\n內建扩展\n\n转换场景             实现类所在包名（PACKAGE）\n日期/时间相关          org.springframework.format.datetime\nJava 8 日期/时间相关   org.springframework.format.datetime.standard\n通用实现             org.springframework.core.convert.support\n\n\n# Converter 接口的局限性\n\n局限一：缺少 Source Type 和 Target Type 前置判断\n\n * 应对：增加 org.springframework.core.convert.converter.ConditionalConverter 实现\n\n局限二：仅能转换单一的 Source Type 和 Target Type\n\n * 应对：使用 org.springframework.core.convert.converter.GenericConverter 代替\n\n\n# GenericConverter 接口\n\norg.springframework.core.convert.converter.GenericConverter\n\n核心要素   说明\n使用场景   用于“复合”类型转换场景，比如 Collection、Map、数组等\n转换范围   Set<ConvertiblePair> getConvertibleTypes()\n配对类型   org.springframework.core.convert.converter.GenericConverter.ConvertiblePair\n转换方法   convert(Object,TypeDescriptor,TypeDescriptor)\n类型描述   org.springframework.core.convert.TypeDescriptor\n\n\n# 优化 GenericConverter 接口\n\nGenericConverter 局限性\n\n * 缺少 Source Type 和 Target Type 前置判断\n * 单一类型转换实现复杂\n\nGenericConverter 优化接口 - ConditionalGenericConverter\n\n * 复合类型转换：org.springframework.core.convert.converter.GenericConverter\n * 类型条件判断：org.springframework.core.convert.converter.ConditionalConverter\n\n\n# 扩展 Spring 类型转换器\n\n实现转换器接口\n\n * org.springframework.core.convert.converter.Converter\n * org.springframework.core.convert.converter.ConverterFactory\n * org.springframework.core.convert.converter.GenericConverter\n\n注册转换器实现\n\n * 通过 ConversionServiceFactoryBean Spring Bean\n * 通过 org.springframework.core.convert.ConversionService API\n\n\n# 统一类型转换服务\n\norg.springframework.core.convert.ConversionService\n\n实现类型                                 说明\nGenericConversionService             通用 ConversionService 模板实现，不内置转化器实现\nDefaultConversionService             基础 ConversionService 实现，内置常用转化器实现\nFormattingConversionService          通用 Formatter + GenericConversionService 实现，不内置转化器和 Formatter\n                                     实现\nDefaultFormattingConversionService   DefaultConversionService + 格式化 实现（如：JSR-354 Money &\n                                     Currency, JSR-310 Date-Time）\n\n\n# ConversionService 作为依赖\n\n类型转换器底层接口 - org.springframework.beans.TypeConverter\n\n * 起始版本：Spring 2.0\n * 核心方法 - convertIfNecessary 重载方法\n * 抽象实现 - org.springframework.beans.TypeConverterSupport\n * 简单实现 - org.springframework.beans.SimpleTypeConverter\n\n类型转换器底层抽象实现 - org.springframework.beans.TypeConverterSupport\n\n * 实现接口 - org.springframework.beans.TypeConverter\n * 扩展实现 - org.springframework.beans.PropertyEditorRegistrySupport\n * 委派实现 - org.springframework.beans.TypeConverterDelegate\n\n类型转换器底层委派实现 - org.springframework.beans.TypeConverterDelegate\n\n * 构造来源 - org.springframework.beans.AbstractNestablePropertyAccessor 实现\n   * org.springframework.beans.BeanWrapperImpl\n * 依赖 - java.beans.PropertyEditor 实现\n   * 默认內建实现 - PropertyEditorRegistrySupport#registerDefaultEditors\n * 可选依赖 - org.springframework.core.convert.ConversionService 实现\n\n\n# 问题\n\nSpring 类型转换实现有哪些？\n\n * 基于 JavaBeans PropertyEditor 接口实现\n * Spring 3.0+ 通用类型转换实现\n\nSpring 类型转换器接口有哪些？\n\n * 类型转换接口 - org.springframework.core.convert.converter.Converter\n * 通用类型转换接口 - org.springframework.core.convert.converter.GenericConverter\n * 类型条件接口 - org.springframework.core.convert.converter.ConditionalConverter\n * 综合类型转换接口 - org.springframework.core.convert.converter.ConditionalGenericConverter\n\n\n# 参考资料\n\n * Spring 官方文档之 Core Technologies\n * 《小马哥讲 Spring 核心编程思想》",normalizedContent:"# spring 类型转换\n\n\n# spring 类型转换的实现\n\n * 基于 javabeans 接口的类型转换实现\n   * 基于 java.beans.propertyeditor 接口扩展\n * spring 3.0+ 通用类型转换实现\n\n\n# 使用场景\n\n场景            基于 javabeans 接口的类型转换实现   spring 3.0+ 通用类型转换实现\n数据绑定          yes                      yes\nbeanwrapper   yes                      yes\nbean 属性类型转换   yes                      yes\n外部化属性类型转换     no                       yes\n\n\n# 基于 javabeans 接口的类型转换\n\n核心职责\n\n * 将 string 类型的内容转化为目标类型的对象\n\n扩展原理\n\n * spring 框架将文本内容传递到 propertyeditor 实现的 setastext(string) 方法\n * propertyeditor#setastext(string) 方法实现将 string 类型转化为目标类型的对象\n * 将目标类型的对象传入 propertyeditor#setvalue(object) 方法\n * propertyeditor#setvalue(object) 方法实现需要临时存储传入对象\n * spring 框架将通过 propertyeditor#getvalue() 获取类型转换后的对象\n\n\n# spring 內建 propertyeditor 扩展\n\n內建扩展（org.springframework.beans.propertyeditors 包下）\n\n转换场景                 实现类\nstring -> byte 数组    org.springframework.beans.propertyeditors.bytearraypropertyeditor\nstring -> char       org.springframework.beans.propertyeditors.charactereditor\nstring -> char 数组    org.springframework.beans.propertyeditors.chararraypropertyeditor\nstring -> charset    org.springframework.beans.propertyeditors.charseteditor\nstring -> class      org.springframework.beans.propertyeditors.classeditor\nstring -> currency   org.springframework.beans.propertyeditors.currencyeditor\n                     \n\n\n# 自定义 propertyeditor 扩展\n\n扩展模式\n\n * 扩展 java.beans.propertyeditorsupport 类\n\n实现 org.springframework.beans.propertyeditorregistrar\n\n * 实现 registercustomeditors(org.springframework.beans.propertyeditorregistry) 方法\n * 将 propertyeditorregistrar 实现注册为 spring bean\n\n向 org.springframework.beans.propertyeditorregistry 注册自定义 propertyeditor 实现\n\n * 通用类型实现 registercustomeditor(class<?>, propertyeditor)\n * java bean 属性类型实现：registercustomeditor(class<?>, string, propertyeditor)\n\n\n# spring propertyeditor 的设计缺陷\n\n违反职责单一原则\n\n * java.beans.propertyeditor 接口职责太多，除了类型转换，还包括 java beans 事件和 java gui 交 互\n\njava.beans.propertyeditor 实现类型局限\n\n * 来源类型只能为 java.lang.string 类型\n\njava.beans.propertyeditor 实现缺少类型安全\n\n * 除了实现类命名可以表达语义，实现类无法感知目标转换类型\n\n\n# spring 3 通用类型转换接口\n\n类型转换接口 - org.springframework.core.convert.converter.converter<s,t>\n\n * 泛型参数 s：来源类型，参数 t：目标类型\n * 核心方法：t convert(s)\n\n通用类型转换接口 - org.springframework.core.convert.converter.genericconverter\n\n * 核心方法：convert(object,typedescriptor,typedescriptor)\n * 配对类型：org.springframework.core.convert.converter.genericconverter.convertiblepair\n * 类型描述：org.springframework.core.convert.typedescriptor\n\n\n# spring 內建类型转换器\n\n內建扩展\n\n转换场景             实现类所在包名（package）\n日期/时间相关          org.springframework.format.datetime\njava 8 日期/时间相关   org.springframework.format.datetime.standard\n通用实现             org.springframework.core.convert.support\n\n\n# converter 接口的局限性\n\n局限一：缺少 source type 和 target type 前置判断\n\n * 应对：增加 org.springframework.core.convert.converter.conditionalconverter 实现\n\n局限二：仅能转换单一的 source type 和 target type\n\n * 应对：使用 org.springframework.core.convert.converter.genericconverter 代替\n\n\n# genericconverter 接口\n\norg.springframework.core.convert.converter.genericconverter\n\n核心要素   说明\n使用场景   用于“复合”类型转换场景，比如 collection、map、数组等\n转换范围   set<convertiblepair> getconvertibletypes()\n配对类型   org.springframework.core.convert.converter.genericconverter.convertiblepair\n转换方法   convert(object,typedescriptor,typedescriptor)\n类型描述   org.springframework.core.convert.typedescriptor\n\n\n# 优化 genericconverter 接口\n\ngenericconverter 局限性\n\n * 缺少 source type 和 target type 前置判断\n * 单一类型转换实现复杂\n\ngenericconverter 优化接口 - conditionalgenericconverter\n\n * 复合类型转换：org.springframework.core.convert.converter.genericconverter\n * 类型条件判断：org.springframework.core.convert.converter.conditionalconverter\n\n\n# 扩展 spring 类型转换器\n\n实现转换器接口\n\n * org.springframework.core.convert.converter.converter\n * org.springframework.core.convert.converter.converterfactory\n * org.springframework.core.convert.converter.genericconverter\n\n注册转换器实现\n\n * 通过 conversionservicefactorybean spring bean\n * 通过 org.springframework.core.convert.conversionservice api\n\n\n# 统一类型转换服务\n\norg.springframework.core.convert.conversionservice\n\n实现类型                                 说明\ngenericconversionservice             通用 conversionservice 模板实现，不内置转化器实现\ndefaultconversionservice             基础 conversionservice 实现，内置常用转化器实现\nformattingconversionservice          通用 formatter + genericconversionservice 实现，不内置转化器和 formatter\n                                     实现\ndefaultformattingconversionservice   defaultconversionservice + 格式化 实现（如：jsr-354 money &\n                                     currency, jsr-310 date-time）\n\n\n# conversionservice 作为依赖\n\n类型转换器底层接口 - org.springframework.beans.typeconverter\n\n * 起始版本：spring 2.0\n * 核心方法 - convertifnecessary 重载方法\n * 抽象实现 - org.springframework.beans.typeconvertersupport\n * 简单实现 - org.springframework.beans.simpletypeconverter\n\n类型转换器底层抽象实现 - org.springframework.beans.typeconvertersupport\n\n * 实现接口 - org.springframework.beans.typeconverter\n * 扩展实现 - org.springframework.beans.propertyeditorregistrysupport\n * 委派实现 - org.springframework.beans.typeconverterdelegate\n\n类型转换器底层委派实现 - org.springframework.beans.typeconverterdelegate\n\n * 构造来源 - org.springframework.beans.abstractnestablepropertyaccessor 实现\n   * org.springframework.beans.beanwrapperimpl\n * 依赖 - java.beans.propertyeditor 实现\n   * 默认內建实现 - propertyeditorregistrysupport#registerdefaulteditors\n * 可选依赖 - org.springframework.core.convert.conversionservice 实现\n\n\n# 问题\n\nspring 类型转换实现有哪些？\n\n * 基于 javabeans propertyeditor 接口实现\n * spring 3.0+ 通用类型转换实现\n\nspring 类型转换器接口有哪些？\n\n * 类型转换接口 - org.springframework.core.convert.converter.converter\n * 通用类型转换接口 - org.springframework.core.convert.converter.genericconverter\n * 类型条件接口 - org.springframework.core.convert.converter.conditionalconverter\n * 综合类型转换接口 - org.springframework.core.convert.converter.conditionalgenericconverter\n\n\n# 参考资料\n\n * spring 官方文档之 core technologies\n * 《小马哥讲 spring 核心编程思想》",charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Spring 国际化",frontmatter:{title:"Spring 国际化",date:"2022-12-22T11:44:54.000Z",order:26,categories:["Java","框架","Spring","Spring核心"],tags:["Java","框架","Spring"],permalink:"/pages/b5b8ad/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/01.Spring%E6%A0%B8%E5%BF%83/26.Spring%E5%9B%BD%E9%99%85%E5%8C%96.html",relativePath:"01.Java/13.框架/01.Spring/01.Spring核心/26.Spring国际化.md",key:"v-375fe748",path:"/pages/b5b8ad/",headers:[{level:2,title:"Spring 国际化使用场景",slug:"spring-国际化使用场景",normalizedTitle:"spring 国际化使用场景",charIndex:17},{level:2,title:"Spring 国际化接口",slug:"spring-国际化接口",normalizedTitle:"spring 国际化接口",charIndex:107},{level:2,title:"层次性 MessageSource",slug:"层次性-messagesource",normalizedTitle:"层次性 messagesource",charIndex:235},{level:2,title:"Java 国际化标准实现",slug:"java-国际化标准实现",normalizedTitle:"java 国际化标准实现",charIndex:530},{level:2,title:"Java 文本格式化",slug:"java-文本格式化",normalizedTitle:"java 文本格式化",charIndex:871},{level:2,title:"MessageSource 开箱即用实现",slug:"messagesource-开箱即用实现",normalizedTitle:"messagesource 开箱即用实现",charIndex:1288},{level:2,title:"MessageSource 內建依赖",slug:"messagesource-內建依赖",normalizedTitle:"messagesource 內建依赖",charIndex:1569},{level:2,title:"问题",slug:"问题",normalizedTitle:"问题",charIndex:1740},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:2541}],headersStr:"Spring 国际化使用场景 Spring 国际化接口 层次性 MessageSource Java 国际化标准实现 Java 文本格式化 MessageSource 开箱即用实现 MessageSource 內建依赖 问题 参考资料",content:"# Spring 国际化\n\n\n# Spring 国际化使用场景\n\n * 普通国际化文案\n * Bean Validation 校验国际化文案\n * Web 站点页面渲染\n * Web MVC 错误消息提示\n\n\n# Spring 国际化接口\n\n * 核心接口：org.springframework.context.MessageSource\n * 主要概念\n   * 文案模板编码（code）\n   * 文案模板参数（args）\n   * 区域（Locale）\n\n\n# 层次性 MessageSource\n\n * Spring 层次性接口回顾\n   * org.springframework.beans.factory.HierarchicalBeanFactory\n   * org.springframework.context.ApplicationContext\n   * org.springframework.beans.factory.config.BeanDefinition\n * Spring 层次性国际化接口\n   * org.springframework.context.HierarchicalMessageSource\n\n\n# Java 国际化标准实现\n\n核心接口：\n\n * 抽象实现 - java.util.ResourceBundle\n * Properties 资源实现 - java.util.PropertyResourceBundle\n * 例举实现 - java.util.ListResourceBundle\n\nResourceBundle 核心特性\n\n * Key-Value 设计\n * 层次性设计\n * 缓存设计\n * 字符编码控制 - java.util.ResourceBundle.Control（@since 1.6）\n * Control SPI 扩展 - java.util.spi.ResourceBundleControlProvider（@since 1.8）\n\n\n# Java 文本格式化\n\n * 核心接口\n   * java.text.MessageFormat\n * 基本用法\n   * 设置消息格式模式- new MessageFormat(...)\n   * 格式化 - format(new Object[]{...})\n * 消息格式模式\n   * 格式元素：{ArgumentIndex (,FormatType,(FormatStyle))}\n   * FormatType：消息格式类型，可选项，每种类型在 number、date、time 和 choice 类型选其一\n   * FormatStyle：消息格式风格，可选项，包括：short、medium、long、full、integer、currency、 percent\n * 高级特性\n   * 重置消息格式模式\n   * 重置 java.util.Locale\n   * 重置 java.text.Format\n\n\n# MessageSource 开箱即用实现\n\n * 基于 ResourceBundle + MessageFormat 组合 MessageSource 实现\n * org.springframework.context.support.ResourceBundleMessageSource\n * 可重载 Properties + MessageFormat 组合 MessageSource 实现\n * org.springframework.context.support.ReloadableResourceBundleMessageSource\n\n\n# MessageSource 內建依赖\n\n * MessageSource 內建 Bean 可能来源\n * 预注册 Bean 名称为：“messageSource”，类型为：MessageSource Bean\n * 默认內建实现 - DelegatingMessageSource\n * 层次性查找 MessageSource 对象\n\n\n# 问题\n\nSpring Boot 为什么要新建 MessageSource Bean？\n\n * AbstractApplicationContext 的实现决定了 MessageSource 內建实现\n * Spring Boot 通过外部化配置简化 MessageSource Bean 构建\n * Spring Boot 基于 Bean Validation 校验非常普遍\n\nSpring 国际化接口有哪些？\n\n * 核心接口 - MessageSource\n * 层次性接口 - org.springframework.context.HierarchicalMessageSource\n\nSpring 有哪些 MessageSource 內建实现？\n\n * org.springframework.context.support.ResourceBundleMessageSource\n * org.springframework.context.support.ReloadableResourceBundleMessageSource\n * org.springframework.context.support.StaticMessageSource\n * org.springframework.context.support.DelegatingMessageSource\n\n如何实现配置自动更新 MessageSource？\n\n主要技术\n\n * Java NIO 2：java.nio.file.WatchService\n * Java Concurrency : java.util.concurrent.ExecutorService\n * Spring：org.springframework.context.support.AbstractMessageSource\n\n\n# 参考资料\n\n * Spring 官方文档之 Core Technologies\n * 《小马哥讲 Spring 核心编程思想》",normalizedContent:"# spring 国际化\n\n\n# spring 国际化使用场景\n\n * 普通国际化文案\n * bean validation 校验国际化文案\n * web 站点页面渲染\n * web mvc 错误消息提示\n\n\n# spring 国际化接口\n\n * 核心接口：org.springframework.context.messagesource\n * 主要概念\n   * 文案模板编码（code）\n   * 文案模板参数（args）\n   * 区域（locale）\n\n\n# 层次性 messagesource\n\n * spring 层次性接口回顾\n   * org.springframework.beans.factory.hierarchicalbeanfactory\n   * org.springframework.context.applicationcontext\n   * org.springframework.beans.factory.config.beandefinition\n * spring 层次性国际化接口\n   * org.springframework.context.hierarchicalmessagesource\n\n\n# java 国际化标准实现\n\n核心接口：\n\n * 抽象实现 - java.util.resourcebundle\n * properties 资源实现 - java.util.propertyresourcebundle\n * 例举实现 - java.util.listresourcebundle\n\nresourcebundle 核心特性\n\n * key-value 设计\n * 层次性设计\n * 缓存设计\n * 字符编码控制 - java.util.resourcebundle.control（@since 1.6）\n * control spi 扩展 - java.util.spi.resourcebundlecontrolprovider（@since 1.8）\n\n\n# java 文本格式化\n\n * 核心接口\n   * java.text.messageformat\n * 基本用法\n   * 设置消息格式模式- new messageformat(...)\n   * 格式化 - format(new object[]{...})\n * 消息格式模式\n   * 格式元素：{argumentindex (,formattype,(formatstyle))}\n   * formattype：消息格式类型，可选项，每种类型在 number、date、time 和 choice 类型选其一\n   * formatstyle：消息格式风格，可选项，包括：short、medium、long、full、integer、currency、 percent\n * 高级特性\n   * 重置消息格式模式\n   * 重置 java.util.locale\n   * 重置 java.text.format\n\n\n# messagesource 开箱即用实现\n\n * 基于 resourcebundle + messageformat 组合 messagesource 实现\n * org.springframework.context.support.resourcebundlemessagesource\n * 可重载 properties + messageformat 组合 messagesource 实现\n * org.springframework.context.support.reloadableresourcebundlemessagesource\n\n\n# messagesource 內建依赖\n\n * messagesource 內建 bean 可能来源\n * 预注册 bean 名称为：“messagesource”，类型为：messagesource bean\n * 默认內建实现 - delegatingmessagesource\n * 层次性查找 messagesource 对象\n\n\n# 问题\n\nspring boot 为什么要新建 messagesource bean？\n\n * abstractapplicationcontext 的实现决定了 messagesource 內建实现\n * spring boot 通过外部化配置简化 messagesource bean 构建\n * spring boot 基于 bean validation 校验非常普遍\n\nspring 国际化接口有哪些？\n\n * 核心接口 - messagesource\n * 层次性接口 - org.springframework.context.hierarchicalmessagesource\n\nspring 有哪些 messagesource 內建实现？\n\n * org.springframework.context.support.resourcebundlemessagesource\n * org.springframework.context.support.reloadableresourcebundlemessagesource\n * org.springframework.context.support.staticmessagesource\n * org.springframework.context.support.delegatingmessagesource\n\n如何实现配置自动更新 messagesource？\n\n主要技术\n\n * java nio 2：java.nio.file.watchservice\n * java concurrency : java.util.concurrent.executorservice\n * spring：org.springframework.context.support.abstractmessagesource\n\n\n# 参考资料\n\n * spring 官方文档之 core technologies\n * 《小马哥讲 spring 核心编程思想》",charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Spring 事件",frontmatter:{title:"Spring 事件",date:"2022-12-22T20:31:02.000Z",order:25,categories:["Java","框架","Spring","Spring核心"],tags:["Java","框架","Spring"],permalink:"/pages/cca414/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/01.Spring%E6%A0%B8%E5%BF%83/25.Spring%E4%BA%8B%E4%BB%B6.html",relativePath:"01.Java/13.框架/01.Spring/01.Spring核心/25.Spring事件.md",key:"v-68aff9b6",path:"/pages/cca414/",headers:[{level:2,title:"Java 事件/监听器编程模型",slug:"java-事件-监听器编程模型",normalizedTitle:"java 事件/监听器编程模型",charIndex:16},{level:2,title:"面向接口的事件/监听器设计模式",slug:"面向接口的事件-监听器设计模式",normalizedTitle:"面向接口的事件/监听器设计模式",charIndex:195},{level:2,title:"面向注解的事件/监听器设计模式",slug:"面向注解的事件-监听器设计模式",normalizedTitle:"面向注解的事件/监听器设计模式",charIndex:659},{level:2,title:"Spring 标准事件 - ApplicationEvent",slug:"spring-标准事件-applicationevent",normalizedTitle:"spring 标准事件 - applicationevent",charIndex:1030},{level:2,title:"基于接口的 Spring 事件监听器",slug:"基于接口的-spring-事件监听器",normalizedTitle:"基于接口的 spring 事件监听器",charIndex:1458},{level:2,title:"基于注解的 Spring 事件监听器",slug:"基于注解的-spring-事件监听器",normalizedTitle:"基于注解的 spring 事件监听器",charIndex:1696},{level:2,title:"注册 Spring ApplicationListener",slug:"注册-spring-applicationlistener",normalizedTitle:"注册 spring applicationlistener",charIndex:1921},{level:2,title:"Spring 事件发布器",slug:"spring-事件发布器",normalizedTitle:"spring 事件发布器",charIndex:2049},{level:2,title:"Spring 层次性上下文事件传播",slug:"spring-层次性上下文事件传播",normalizedTitle:"spring 层次性上下文事件传播",charIndex:2273},{level:2,title:"Spring 内建事件",slug:"spring-内建事件",normalizedTitle:"spring 内建事件",charIndex:2536},{level:2,title:"Spring 4.2 Payload 事件",slug:"spring-4-2-payload-事件",normalizedTitle:"spring 4.2 payload 事件",charIndex:2748},{level:2,title:"自定义 Spring 事件",slug:"自定义-spring-事件",normalizedTitle:"自定义 spring 事件",charIndex:2944},{level:2,title:"依赖注入 ApplicationEventPublisher",slug:"依赖注入-applicationeventpublisher",normalizedTitle:"依赖注入 applicationeventpublisher",charIndex:3122},{level:2,title:"依赖查找 ApplicationEventMulticaster",slug:"依赖查找-applicationeventmulticaster",normalizedTitle:"依赖查找 applicationeventmulticaster",charIndex:3243},{level:2,title:"ApplicationEventPublisher 底层实现",slug:"applicationeventpublisher-底层实现",normalizedTitle:"applicationeventpublisher 底层实现",charIndex:3401},{level:2,title:"同步和异步 Spring 事件广播",slug:"同步和异步-spring-事件广播",normalizedTitle:"同步和异步 spring 事件广播",charIndex:3657},{level:2,title:"Spring 4.1 事件异常处理",slug:"spring-4-1-事件异常处理",normalizedTitle:"spring 4.1 事件异常处理",charIndex:4063},{level:2,title:"Spring 事件/监听器实现原理",slug:"spring-事件-监听器实现原理",normalizedTitle:"spring 事件/监听器实现原理",charIndex:4396},{level:2,title:"问题",slug:"问题",normalizedTitle:"问题",charIndex:4761},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:6092}],headersStr:"Java 事件/监听器编程模型 面向接口的事件/监听器设计模式 面向注解的事件/监听器设计模式 Spring 标准事件 - ApplicationEvent 基于接口的 Spring 事件监听器 基于注解的 Spring 事件监听器 注册 Spring ApplicationListener Spring 事件发布器 Spring 层次性上下文事件传播 Spring 内建事件 Spring 4.2 Payload 事件 自定义 Spring 事件 依赖注入 ApplicationEventPublisher 依赖查找 ApplicationEventMulticaster ApplicationEventPublisher 底层实现 同步和异步 Spring 事件广播 Spring 4.1 事件异常处理 Spring 事件/监听器实现原理 问题 参考资料",content:'# Spring 事件\n\n\n# Java 事件/监听器编程模型\n\n设计模式 - 观察者模式扩展\n\n * 可观者对象（消息发送者） - java.util.Observable\n * 观察者 - java.util.Observer\n\n标准化接口\n\n * 事件对象 - java.util.EventObject\n * 事件监听器 - java.util.EventListener\n\n\n# 面向接口的事件/监听器设计模式\n\n事件/监听器场景举例\n\nJAVA 技术规范         事件接口                                    监听器接口\nJavaBeans         java.beans.PropertyChangeEvent          java.beans.PropertyChangeListener\nJava AWT          java.awt.event.MouseEvent               java.awt.event.MouseListener\nJava Swing        javax.swing.event.MenuEvent             javax.swing.event.MenuListener\nJava Preference   java.util.prefs.PreferenceChangeEvent   java.util.prefs.PreferenceChangeListener\n\n\n# 面向注解的事件/监听器设计模式\n\n事件/监听器注解场景举例\n\nJAVA 技术规范      事件注解                             监听器注解\nServlet 3.0+                                    @javax.servlet.annotation.WebListener\nJPA 1.0+       @javax.persistence.PostPersist   \nJava Common    @PostConstruct                   \nEJB 3.0+       @javax.ejb.PrePassivate          \nJSF 2.0+       @javax.faces.event.ListenerFor   \n\n\n# Spring 标准事件 - ApplicationEvent\n\nJava 标准事件 java.util.EventObject 扩展\n\n * 扩展特性：事件发生事件戳\n * Spring 应用上下文 ApplicationEvent 扩展 - ApplicationContextEvent\n * Spring 应用上下文（ApplicationContext）作为事件源\n\n具体实现：\n\n * org.springframework.context.event.ContextClosedEvent\n * org.springframework.context.event.ContextRefreshedEvent\n * org.springframework.context.event.ContextStartedEvent\n * org.springframework.context.event.ContextStoppedEvent\n\n\n# 基于接口的 Spring 事件监听器\n\nJava 标准事件监听器 java.util.EventListener 扩展\n\n * 扩展接口 - org.springframework.context.ApplicationListener\n * 设计特点：单一类型事件处理\n * 处理方法：onApplicationEvent(ApplicationEvent)\n * 事件类型：org.springframework.context.ApplicationEvent\n\n\n# 基于注解的 Spring 事件监听器\n\nSpring 注解 - @org.springframework.context.event.EventListener\n\n特性           说明\n设计特点         支持多 ApplicationEvent 类型，无需接口约束\n注解目标         方法\n是否支持异步执行     支持\n是否支持泛型类型事件   支持\n是指支持顺序控制     支持，配合 @Order 注解控制\n\n\n# 注册 Spring ApplicationListener\n\n * 方法一：ApplicationListener 作为 Spring Bean 注册\n * 方法二：通过 ConfigurableApplicationContext API 注册\n\n\n# Spring 事件发布器\n\n * 方法一：通过 ApplicationEventPublisher 发布 Spring 事件\n   * 获取 ApplicationEventPublisher\n     * 依赖注入\n * 方法二：通过 ApplicationEventMulticaster 发布 Spring 事件\n   * 获取 ApplicationEventMulticaster\n     * 依赖注入\n     * 依赖查找\n\n\n# Spring 层次性上下文事件传播\n\n * 发生说明\n * 当 Spring 应用出现多层次 Spring 应用上下文（ApplicationContext）时，如 Spring WebMVC、Spring Boot 或 Spring Cloud 场景下，由子 ApplicationContext 发起 Spring 事件可能会传递到其 Parent ApplicationContext（直到 Root）的过程\n * 如何避免\n * 定位 Spring 事件源（ApplicationContext）进行过滤处理\n\n\n# Spring 内建事件\n\nApplicationContextEvent 派生事件\n\n * ContextRefreshedEvent ：Spring 应用上下文就绪事件\n * ContextStartedEvent ：Spring 应用上下文启动事件\n * ContextStoppedEvent ：Spring 应用上下文停止事件\n * ContextClosedEvent ：Spring 应用上下文关闭事件\n\n\n# Spring 4.2 Payload 事件\n\nSpring Payload 事件 - org.springframework.context.PayloadApplicationEvent\n\n * 使用场景：简化 Spring 事件发送，关注事件源主体\n * 发送方法：ApplicationEventPublisher#publishEvent(java.lang.Object)\n\n\n# 自定义 Spring 事件\n\n * 扩展 org.springframework.context.ApplicationEvent\n * 实现 org.springframework.context.ApplicationListener\n * 注册 org.springframework.context.ApplicationListener\n\n\n# 依赖注入 ApplicationEventPublisher\n\n * 通过 ApplicationEventPublisherAware 回调接口\n * 通过 @Autowired ApplicationEventPublisher\n\n\n# 依赖查找 ApplicationEventMulticaster\n\n查找条件\n\n * Bean 名称："applicationEventMulticaster"\n * Bean 类型：org.springframework.context.event.ApplicationEventMulticaster\n\n\n# ApplicationEventPublisher 底层实现\n\n * 接口：org.springframework.context.event.ApplicationEventMulticaster\n * 抽象类：org.springframework.context.event.AbstractApplicationEventMulticaster\n * 实现类：org.springframework.context.event.SimpleApplicationEventMulticaster\n\n\n# 同步和异步 Spring 事件广播\n\n基于实现类 - org.springframework.context.event.SimpleApplicationEventMulticaster\n\n * 模式切换：setTaskExecutor(java.util.concurrent.Executor) 方法\n   * 默认模式：同步\n   * 异步模式：如 java.util.concurrent.ThreadPoolExecutor\n * 设计缺陷：非基于接口契约编程\n\n基于注解 - @org.springframework.context.event.EventListener\n\n * 模式切换\n   * 默认模式：同步\n   * 异步模式：标注 @org.springframework.scheduling.annotation.Async\n * 实现限制：无法直接实现同步/异步动态切换\n\n\n# Spring 4.1 事件异常处理\n\nSpring 3.0 错误处理接口 - org.springframework.util.ErrorHandler\n\n使用场景\n\n * Spring 事件（Events）\n   * SimpleApplicationEventMulticaster Spring 4.1 开始支持\n * Spring 本地调度（Scheduling）\n   * org.springframework.scheduling.concurrent.ConcurrentTaskScheduler\n   * org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler\n\n\n# Spring 事件/监听器实现原理\n\n核心类 - org.springframework.context.event.SimpleApplicationEventMulticaster\n\n * 设计模式：观察者模式扩展\n   * 被观察者 - org.springframework.context.ApplicationListener\n     * API 添加\n     * 依赖查找\n   * 通知对象 - org.springframework.context.ApplicationEvent\n * 执行模式：同步/异步\n * 异常处理：org.springframework.util.ErrorHandler\n * 泛型处理：org.springframework.core.ResolvableType\n\n\n# 问题\n\nSpring Boot 事件\n\n事件类型                                  发生时机\nApplicationStartingEvent              当 Spring Boot 应用已启动时\nApplicationStartedEvent               当 Spring Boot 应用已启动时\nApplicationEnvironmentPreparedEvent   当 Spring Boot Environment 实例已准备时\nApplicationPreparedEvent              当 Spring Boot 应用预备时\nApplicationReadyEvent                 当 Spring Boot 应用完全可用时\nApplicationFailedEvent                当 Spring Boot 应用启动失败时\n\nSpring Cloud 事件\n\n事件类型                         发生时机\nEnvironmentChangeEvent       当 Environment 示例配置属性发生变化时\nHeartbeatEvent               当 DiscoveryClient 客户端发送心跳时\nInstancePreRegisteredEvent   当服务实例注册前\nInstanceRegisteredEvent      当服务实例注册后\nRefreshEvent                 当 RefreshEndpoint 被调用时\nRefreshScopeRefreshedEvent   当 Refresh Scope Bean 刷新后\n\nSpring 事件核心接口/组件？\n\n * Spring 事件 - org.springframework.context.ApplicationEvent\n * Spring 事件监听器 - org.springframework.context.ApplicationListener\n * Spring 事件发布器 - org.springframework.context.ApplicationEventPublisher\n * Spring 事件广播器 - org.springframework.context.event.ApplicationEventMulticaster\n\nSpring 同步和异步事件处理的使用场景？\n\n * Spring 同步事件 - 绝大多数 Spring 使用场景，如 ContextRefreshedEvent\n * Spring 异步事件 - 主要 @EventListener 与 @Async 配合，实现异步处理，不阻塞主线程，比如长时间的数据计算任务等。不要轻易调整 SimpleApplicationEventMulticaster 中关联的 taskExecutor 对象，除非使用者非常了解 Spring 事件机制，否则容易出现异常行为。\n\n\n# 参考资料\n\n * Spring 官方文档之 Core Technologies\n * 《小马哥讲 Spring 核心编程思想》',normalizedContent:'# spring 事件\n\n\n# java 事件/监听器编程模型\n\n设计模式 - 观察者模式扩展\n\n * 可观者对象（消息发送者） - java.util.observable\n * 观察者 - java.util.observer\n\n标准化接口\n\n * 事件对象 - java.util.eventobject\n * 事件监听器 - java.util.eventlistener\n\n\n# 面向接口的事件/监听器设计模式\n\n事件/监听器场景举例\n\njava 技术规范         事件接口                                    监听器接口\njavabeans         java.beans.propertychangeevent          java.beans.propertychangelistener\njava awt          java.awt.event.mouseevent               java.awt.event.mouselistener\njava swing        javax.swing.event.menuevent             javax.swing.event.menulistener\njava preference   java.util.prefs.preferencechangeevent   java.util.prefs.preferencechangelistener\n\n\n# 面向注解的事件/监听器设计模式\n\n事件/监听器注解场景举例\n\njava 技术规范      事件注解                             监听器注解\nservlet 3.0+                                    @javax.servlet.annotation.weblistener\njpa 1.0+       @javax.persistence.postpersist   \njava common    @postconstruct                   \nejb 3.0+       @javax.ejb.prepassivate          \njsf 2.0+       @javax.faces.event.listenerfor   \n\n\n# spring 标准事件 - applicationevent\n\njava 标准事件 java.util.eventobject 扩展\n\n * 扩展特性：事件发生事件戳\n * spring 应用上下文 applicationevent 扩展 - applicationcontextevent\n * spring 应用上下文（applicationcontext）作为事件源\n\n具体实现：\n\n * org.springframework.context.event.contextclosedevent\n * org.springframework.context.event.contextrefreshedevent\n * org.springframework.context.event.contextstartedevent\n * org.springframework.context.event.contextstoppedevent\n\n\n# 基于接口的 spring 事件监听器\n\njava 标准事件监听器 java.util.eventlistener 扩展\n\n * 扩展接口 - org.springframework.context.applicationlistener\n * 设计特点：单一类型事件处理\n * 处理方法：onapplicationevent(applicationevent)\n * 事件类型：org.springframework.context.applicationevent\n\n\n# 基于注解的 spring 事件监听器\n\nspring 注解 - @org.springframework.context.event.eventlistener\n\n特性           说明\n设计特点         支持多 applicationevent 类型，无需接口约束\n注解目标         方法\n是否支持异步执行     支持\n是否支持泛型类型事件   支持\n是指支持顺序控制     支持，配合 @order 注解控制\n\n\n# 注册 spring applicationlistener\n\n * 方法一：applicationlistener 作为 spring bean 注册\n * 方法二：通过 configurableapplicationcontext api 注册\n\n\n# spring 事件发布器\n\n * 方法一：通过 applicationeventpublisher 发布 spring 事件\n   * 获取 applicationeventpublisher\n     * 依赖注入\n * 方法二：通过 applicationeventmulticaster 发布 spring 事件\n   * 获取 applicationeventmulticaster\n     * 依赖注入\n     * 依赖查找\n\n\n# spring 层次性上下文事件传播\n\n * 发生说明\n * 当 spring 应用出现多层次 spring 应用上下文（applicationcontext）时，如 spring webmvc、spring boot 或 spring cloud 场景下，由子 applicationcontext 发起 spring 事件可能会传递到其 parent applicationcontext（直到 root）的过程\n * 如何避免\n * 定位 spring 事件源（applicationcontext）进行过滤处理\n\n\n# spring 内建事件\n\napplicationcontextevent 派生事件\n\n * contextrefreshedevent ：spring 应用上下文就绪事件\n * contextstartedevent ：spring 应用上下文启动事件\n * contextstoppedevent ：spring 应用上下文停止事件\n * contextclosedevent ：spring 应用上下文关闭事件\n\n\n# spring 4.2 payload 事件\n\nspring payload 事件 - org.springframework.context.payloadapplicationevent\n\n * 使用场景：简化 spring 事件发送，关注事件源主体\n * 发送方法：applicationeventpublisher#publishevent(java.lang.object)\n\n\n# 自定义 spring 事件\n\n * 扩展 org.springframework.context.applicationevent\n * 实现 org.springframework.context.applicationlistener\n * 注册 org.springframework.context.applicationlistener\n\n\n# 依赖注入 applicationeventpublisher\n\n * 通过 applicationeventpublisheraware 回调接口\n * 通过 @autowired applicationeventpublisher\n\n\n# 依赖查找 applicationeventmulticaster\n\n查找条件\n\n * bean 名称："applicationeventmulticaster"\n * bean 类型：org.springframework.context.event.applicationeventmulticaster\n\n\n# applicationeventpublisher 底层实现\n\n * 接口：org.springframework.context.event.applicationeventmulticaster\n * 抽象类：org.springframework.context.event.abstractapplicationeventmulticaster\n * 实现类：org.springframework.context.event.simpleapplicationeventmulticaster\n\n\n# 同步和异步 spring 事件广播\n\n基于实现类 - org.springframework.context.event.simpleapplicationeventmulticaster\n\n * 模式切换：settaskexecutor(java.util.concurrent.executor) 方法\n   * 默认模式：同步\n   * 异步模式：如 java.util.concurrent.threadpoolexecutor\n * 设计缺陷：非基于接口契约编程\n\n基于注解 - @org.springframework.context.event.eventlistener\n\n * 模式切换\n   * 默认模式：同步\n   * 异步模式：标注 @org.springframework.scheduling.annotation.async\n * 实现限制：无法直接实现同步/异步动态切换\n\n\n# spring 4.1 事件异常处理\n\nspring 3.0 错误处理接口 - org.springframework.util.errorhandler\n\n使用场景\n\n * spring 事件（events）\n   * simpleapplicationeventmulticaster spring 4.1 开始支持\n * spring 本地调度（scheduling）\n   * org.springframework.scheduling.concurrent.concurrenttaskscheduler\n   * org.springframework.scheduling.concurrent.threadpooltaskscheduler\n\n\n# spring 事件/监听器实现原理\n\n核心类 - org.springframework.context.event.simpleapplicationeventmulticaster\n\n * 设计模式：观察者模式扩展\n   * 被观察者 - org.springframework.context.applicationlistener\n     * api 添加\n     * 依赖查找\n   * 通知对象 - org.springframework.context.applicationevent\n * 执行模式：同步/异步\n * 异常处理：org.springframework.util.errorhandler\n * 泛型处理：org.springframework.core.resolvabletype\n\n\n# 问题\n\nspring boot 事件\n\n事件类型                                  发生时机\napplicationstartingevent              当 spring boot 应用已启动时\napplicationstartedevent               当 spring boot 应用已启动时\napplicationenvironmentpreparedevent   当 spring boot environment 实例已准备时\napplicationpreparedevent              当 spring boot 应用预备时\napplicationreadyevent                 当 spring boot 应用完全可用时\napplicationfailedevent                当 spring boot 应用启动失败时\n\nspring cloud 事件\n\n事件类型                         发生时机\nenvironmentchangeevent       当 environment 示例配置属性发生变化时\nheartbeatevent               当 discoveryclient 客户端发送心跳时\ninstancepreregisteredevent   当服务实例注册前\ninstanceregisteredevent      当服务实例注册后\nrefreshevent                 当 refreshendpoint 被调用时\nrefreshscoperefreshedevent   当 refresh scope bean 刷新后\n\nspring 事件核心接口/组件？\n\n * spring 事件 - org.springframework.context.applicationevent\n * spring 事件监听器 - org.springframework.context.applicationlistener\n * spring 事件发布器 - org.springframework.context.applicationeventpublisher\n * spring 事件广播器 - org.springframework.context.event.applicationeventmulticaster\n\nspring 同步和异步事件处理的使用场景？\n\n * spring 同步事件 - 绝大多数 spring 使用场景，如 contextrefreshedevent\n * spring 异步事件 - 主要 @eventlistener 与 @async 配合，实现异步处理，不阻塞主线程，比如长时间的数据计算任务等。不要轻易调整 simpleapplicationeventmulticaster 中关联的 taskexecutor 对象，除非使用者非常了解 spring 事件机制，否则容易出现异常行为。\n\n\n# 参考资料\n\n * spring 官方文档之 core technologies\n * 《小马哥讲 spring 核心编程思想》',charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Spring 泛型处理",frontmatter:{title:"Spring 泛型处理",date:"2022-12-22T20:11:52.000Z",order:27,categories:["Java","框架","Spring","Spring核心"],tags:["Java","框架","Spring"],permalink:"/pages/175cbd/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/01.Spring%E6%A0%B8%E5%BF%83/27.Spring%E6%B3%9B%E5%9E%8B%E5%A4%84%E7%90%86.html",relativePath:"01.Java/13.框架/01.Spring/01.Spring核心/27.Spring泛型处理.md",key:"v-fe2fd7e0",path:"/pages/175cbd/",headers:[{level:2,title:"Java 泛型基础",slug:"java-泛型基础",normalizedTitle:"java 泛型基础",charIndex:18},{level:2,title:"Java 5 类型接口",slug:"java-5-类型接口",normalizedTitle:"java 5 类型接口",charIndex:332},{level:2,title:"Spring 泛型类型辅助类",slug:"spring-泛型类型辅助类",normalizedTitle:"spring 泛型类型辅助类",charIndex:1075},{level:2,title:"Spring 泛型集合类型辅助类",slug:"spring-泛型集合类型辅助类",normalizedTitle:"spring 泛型集合类型辅助类",charIndex:1400},{level:2,title:"Spring 方法参数封装 - MethodParameter",slug:"spring-方法参数封装-methodparameter",normalizedTitle:"spring 方法参数封装 - methodparameter",charIndex:1654},{level:2,title:"Spring 4.0 泛型优化实现 - ResolvableType",slug:"spring-4-0-泛型优化实现-resolvabletype",normalizedTitle:"spring 4.0 泛型优化实现 - resolvabletype",charIndex:1980},{level:2,title:"ResolvableType 的局限性",slug:"resolvabletype-的局限性",normalizedTitle:"resolvabletype 的局限性",charIndex:2202},{level:2,title:"问题",slug:"问题",normalizedTitle:"问题",charIndex:2308},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:2682}],headersStr:"Java 泛型基础 Java 5 类型接口 Spring 泛型类型辅助类 Spring 泛型集合类型辅助类 Spring 方法参数封装 - MethodParameter Spring 4.0 泛型优化实现 - ResolvableType ResolvableType 的局限性 问题 参考资料",content:"# Spring 泛型处理\n\n\n# Java 泛型基础\n\n泛型类型\n\n * 泛型类型是在类型上参数化的泛型类或接口\n\n泛型使用场景\n\n * 编译时强类型检查\n * 避免类型强转\n * 实现通用算法\n\n泛型类型擦写\n\n * 泛型被引入到 Java 语言中，以便在编译时提供更严格的类型检查并支持泛型编程。类型擦除确保不会 为参数化类型创建新类；因此，泛型不会产生运行时开销。为了实现泛型，编译器将类型擦除应用于：\n   * 将泛型类型中的所有类型参数替换为其边界，如果类型参数是无边界的，则将其替换为 “Object”。因此，生成的字节码只包含普通类、接口和方法\n   * 必要时插入类型转换以保持类型安全\n   * 生成桥方法以保留扩展泛型类型中的多态性\n\n\n# Java 5 类型接口\n\nJava 5 类型接口 - java.lang.reflect.Type\n\n派生类或接口                                说明\njava.lang.Class                       Java 类 API，如 java.lang.String\njava.lang.reflect.GenericArrayType    泛型数组类型\njava.lang.reflect.ParameterizedType   泛型参数类型\njava.lang.reflect.TypeVariable        泛型类型变量，如 Collection<E> 中的 E\njava.lang.reflect.WildcardType        泛型通配类型\n\nJava 泛型反射 API\n\n类型                           API\n泛型信息（Generics Info）          java.lang.Class#getGenericInfo()\n泛型参数（Parameters）             java.lang.reflect.ParameterizedType\n泛型父类（Super Classes）          java.lang.Class#getGenericSuperclass()\n泛型接口（Interfaces）             java.lang.Class#getGenericInterfaces()\n泛型声明（Generics Declaration）   java.lang.reflect.GenericDeclaration\n\n\n# Spring 泛型类型辅助类\n\n核心 API - org.springframework.core.GenericTypeResolver\n\n * 版本支持：[2.5.2 , )\n * 处理类型相关（Type）相关方法\n   * resolveReturnType\n   * resolveType\n * 处理泛型参数类型（ParameterizedType）相关方法\n   * resolveReturnTypeArgument\n   * resolveTypeArgument\n   * resolveTypeArguments\n * 处理泛型类型变量（TypeVariable）相关方法\n   * getTypeVariableMap\n\n\n# Spring 泛型集合类型辅助类\n\n核心 API - org.springframework.core.GenericCollectionTypeResolver\n\n * 版本支持：[2.0 , 4.3]\n * 替换实现：org.springframework.core.ResolvableType\n * 处理 Collection 相关\n   * getCollection*Type\n * 处理 Map 相关\n   * getMapKey*Type\n   * getMapValue*Type\n\n\n# Spring 方法参数封装 - MethodParameter\n\n核心 API - org.springframework.core.MethodParameter\n\n * 起始版本：[2.0 , )\n * 元信息\n   * 关联的方法 - Method\n   * 关联的构造器 - Constructor\n   * 构造器或方法参数索引 - parameterIndex\n   * 构造器或方法参数类型 - parameterType\n   * 构造器或方法参数泛型类型 - genericParameterType\n   * 构造器或方法参数参数名称 - parameterName\n   * 所在的类 - containingClass\n\n\n# Spring 4.0 泛型优化实现 - ResolvableType\n\n核心 API - org.springframework.core.ResolvableType\n\n * 起始版本：[4.0 , )\n * 扮演角色：GenericTypeResolver 和 GenericCollectionTypeResolver 替代者\n * 工厂方法：for* 方法\n * 转换方法：as* 方法\n * 处理方法：resolve* 方法\n\n\n# ResolvableType 的局限性\n\n * 局限一：ResolvableType 无法处理泛型擦写\n * 局限二：ResolvableType 无法处理非具体化的 ParameterizedType\n\n\n# 问题\n\nJava 泛型擦写发生在编译时还是运行时？\n\n运行时\n\n请介绍 Java 5 Type 类型的派生类或接口\n\n * java.lang.Class\n * java.lang.reflect.GenericArrayType\n * java.lang.reflect.ParameterizedType\n * java.lang.reflect.TypeVariable\n * java.lang.reflect.WildcardType\n\n请说明 ResolvableType 的设计优势？\n\n * 简化 Java 5 Type API 开发，屏蔽复杂 API 的运用，如 ParameterizedType\n * 不变性设计（Immutability）\n * Fluent API 设计（Builder 模式），链式（流式）编程\n\n\n# 参考资料\n\n * Spring 官方文档之 Core Technologies\n * 《小马哥讲 Spring 核心编程思想》",normalizedContent:"# spring 泛型处理\n\n\n# java 泛型基础\n\n泛型类型\n\n * 泛型类型是在类型上参数化的泛型类或接口\n\n泛型使用场景\n\n * 编译时强类型检查\n * 避免类型强转\n * 实现通用算法\n\n泛型类型擦写\n\n * 泛型被引入到 java 语言中，以便在编译时提供更严格的类型检查并支持泛型编程。类型擦除确保不会 为参数化类型创建新类；因此，泛型不会产生运行时开销。为了实现泛型，编译器将类型擦除应用于：\n   * 将泛型类型中的所有类型参数替换为其边界，如果类型参数是无边界的，则将其替换为 “object”。因此，生成的字节码只包含普通类、接口和方法\n   * 必要时插入类型转换以保持类型安全\n   * 生成桥方法以保留扩展泛型类型中的多态性\n\n\n# java 5 类型接口\n\njava 5 类型接口 - java.lang.reflect.type\n\n派生类或接口                                说明\njava.lang.class                       java 类 api，如 java.lang.string\njava.lang.reflect.genericarraytype    泛型数组类型\njava.lang.reflect.parameterizedtype   泛型参数类型\njava.lang.reflect.typevariable        泛型类型变量，如 collection<e> 中的 e\njava.lang.reflect.wildcardtype        泛型通配类型\n\njava 泛型反射 api\n\n类型                           api\n泛型信息（generics info）          java.lang.class#getgenericinfo()\n泛型参数（parameters）             java.lang.reflect.parameterizedtype\n泛型父类（super classes）          java.lang.class#getgenericsuperclass()\n泛型接口（interfaces）             java.lang.class#getgenericinterfaces()\n泛型声明（generics declaration）   java.lang.reflect.genericdeclaration\n\n\n# spring 泛型类型辅助类\n\n核心 api - org.springframework.core.generictyperesolver\n\n * 版本支持：[2.5.2 , )\n * 处理类型相关（type）相关方法\n   * resolvereturntype\n   * resolvetype\n * 处理泛型参数类型（parameterizedtype）相关方法\n   * resolvereturntypeargument\n   * resolvetypeargument\n   * resolvetypearguments\n * 处理泛型类型变量（typevariable）相关方法\n   * gettypevariablemap\n\n\n# spring 泛型集合类型辅助类\n\n核心 api - org.springframework.core.genericcollectiontyperesolver\n\n * 版本支持：[2.0 , 4.3]\n * 替换实现：org.springframework.core.resolvabletype\n * 处理 collection 相关\n   * getcollection*type\n * 处理 map 相关\n   * getmapkey*type\n   * getmapvalue*type\n\n\n# spring 方法参数封装 - methodparameter\n\n核心 api - org.springframework.core.methodparameter\n\n * 起始版本：[2.0 , )\n * 元信息\n   * 关联的方法 - method\n   * 关联的构造器 - constructor\n   * 构造器或方法参数索引 - parameterindex\n   * 构造器或方法参数类型 - parametertype\n   * 构造器或方法参数泛型类型 - genericparametertype\n   * 构造器或方法参数参数名称 - parametername\n   * 所在的类 - containingclass\n\n\n# spring 4.0 泛型优化实现 - resolvabletype\n\n核心 api - org.springframework.core.resolvabletype\n\n * 起始版本：[4.0 , )\n * 扮演角色：generictyperesolver 和 genericcollectiontyperesolver 替代者\n * 工厂方法：for* 方法\n * 转换方法：as* 方法\n * 处理方法：resolve* 方法\n\n\n# resolvabletype 的局限性\n\n * 局限一：resolvabletype 无法处理泛型擦写\n * 局限二：resolvabletype 无法处理非具体化的 parameterizedtype\n\n\n# 问题\n\njava 泛型擦写发生在编译时还是运行时？\n\n运行时\n\n请介绍 java 5 type 类型的派生类或接口\n\n * java.lang.class\n * java.lang.reflect.genericarraytype\n * java.lang.reflect.parameterizedtype\n * java.lang.reflect.typevariable\n * java.lang.reflect.wildcardtype\n\n请说明 resolvabletype 的设计优势？\n\n * 简化 java 5 type api 开发，屏蔽复杂 api 的运用，如 parameterizedtype\n * 不变性设计（immutability）\n * fluent api 设计（builder 模式），链式（流式）编程\n\n\n# 参考资料\n\n * spring 官方文档之 core technologies\n * 《小马哥讲 spring 核心编程思想》",charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Spring 注解",frontmatter:{title:"Spring 注解",date:"2022-12-23T09:08:15.000Z",order:28,categories:["Java","框架","Spring","Spring核心"],tags:["Java","框架","Spring"],permalink:"/pages/b6556f/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/01.Spring%E6%A0%B8%E5%BF%83/28.Spring%E6%B3%A8%E8%A7%A3.html",relativePath:"01.Java/13.框架/01.Spring/01.Spring核心/28.Spring注解.md",key:"v-11d62c46",path:"/pages/b6556f/",headers:[{level:2,title:"Spring 注解驱动编程发展历程",slug:"spring-注解驱动编程发展历程",normalizedTitle:"spring 注解驱动编程发展历程",charIndex:16},{level:2,title:"Spring 核心注解场景分类",slug:"spring-核心注解场景分类",normalizedTitle:"spring 核心注解场景分类",charIndex:204},{level:2,title:"Spring 注解编程模型",slug:"spring-注解编程模型",normalizedTitle:"spring 注解编程模型",charIndex:807},{level:2,title:"Spring 元注解（Meta-Annotations）",slug:"spring-元注解-meta-annotations",normalizedTitle:"spring 元注解（meta-annotations）",charIndex:980},{level:2,title:"Spring 模式注解（Stereotype Annotations）",slug:"spring-模式注解-stereotype-annotations",normalizedTitle:"spring 模式注解（stereotype annotations）",charIndex:850},{level:2,title:"Spring 组合注解（Composed Annotations）",slug:"spring-组合注解-composed-annotations",normalizedTitle:"spring 组合注解（composed annotations）",charIndex:889},{level:2,title:"Spring 注解属性别名（Attribute Aliases）",slug:"spring-注解属性别名-attribute-aliases",normalizedTitle:"spring 注解属性别名（attribute aliases）",charIndex:2312},{level:2,title:"Spring 注解属性覆盖（Attribute Overrides）",slug:"spring-注解属性覆盖-attribute-overrides",normalizedTitle:"spring 注解属性覆盖（attribute overrides）",charIndex:2349},{level:2,title:"Spring @Enable 模块驱动",slug:"spring-enable-模块驱动",normalizedTitle:"spring @enable 模块驱动",charIndex:2388},{level:2,title:"Spring 条件注解",slug:"spring-条件注解",normalizedTitle:"spring 条件注解",charIndex:2844},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:3564}],headersStr:"Spring 注解驱动编程发展历程 Spring 核心注解场景分类 Spring 注解编程模型 Spring 元注解（Meta-Annotations） Spring 模式注解（Stereotype Annotations） Spring 组合注解（Composed Annotations） Spring 注解属性别名（Attribute Aliases） Spring 注解属性覆盖（Attribute Overrides） Spring @Enable 模块驱动 Spring 条件注解 参考资料",content:"# Spring 注解\n\n\n# Spring 注解驱动编程发展历程\n\n * 注解驱动启蒙时代：Spring Framework 1.x\n * 注解驱动过渡时代：Spring Framework 2.x\n * 注解驱动黄金时代：Spring Framework 3.x\n * 注解驱动完善时代：Spring Framework 4.x\n * 注解驱动当下时代：Spring Framework 5.x\n\n\n# Spring 核心注解场景分类\n\nSpring 模式注解\n\nSPRING 注解        场景说明          起始版本\n@Repository      数据仓储模式注解      2.0\n@Component       通用组件模式注解      2.5\n@Service         服务模式注解        2.5\n@Controller      Web 控制器模式注解   2.5\n@Configuration   配置类模式注解       3.0\n\n装配注解\n\nSPRING 注解         场景说明                             起始版本\n@ImportResource   替换 XML 元素 <import>               2.5\n@Import           导入 Configuration 类               2.5\n@ComponentScan    扫描指定 package 下标注 Spring 模式注解的类   3.1\n\n依赖注入注解\n\nSPRING 注解    场景说明                   起始版本\n@Autowired   Bean 依赖注入，支持多种依赖查找方式   2.5\n@Qualifier   细粒度的 @Autowired 依赖查找   2.5\n\n\n# Spring 注解编程模型\n\n * 元注解（Meta-Annotations）\n * Spring 模式注解（Stereotype Annotations）\n * Spring 组合注解（Composed Annotations）\n * Spring 注解属性别名和覆盖（Attribute Aliases and Overrides）\n\n\n# Spring 元注解（Meta-Annotations）\n\n * java.lang.annotation.Documented\n * java.lang.annotation.Inherited\n * java.lang.annotation.Repeatable\n\n\n# Spring 模式注解（Stereotype Annotations）\n\n理解 @Component “派⽣性”：元标注 @Component 的注解在 XML 元素 context:component-scan 或注解 @ComponentScan 扫描中“派生”了 @Component 的特性，并且从 Spring Framework 4.0 开始支持多层次“派⽣性”。\n\n举例说明：\n\n * @Repository\n * @Service\n * @Controller\n * @Configuration\n * @SpringBootConfiguration（Spring Boot）\n\n@Component “派⽣性”原理\n\n * 核心组件 - org.springframework.context.annotation.ClassPathBeanDefinitionScanner\n * org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider\n * 资源处理 - org.springframework.core.io.support.ResourcePatternResolver\n * 资源-类元信息\n * org.springframework.core.type.classreading.MetadataReaderFactory\n * 类元信息 - org.springframework.core.type.ClassMetadata\n * ASM 实现 - org.springframework.core.type.classreading.ClassMetadataReadingVisitor\n * 反射实现 - org.springframework.core.type.StandardAnnotationMetadata\n * 注解元信息 - org.springframework.core.type.AnnotationMetadata\n * ASM 实现 - org.springframework.core.type.classreading.AnnotationMetadataReadingVisitor\n * 反射实现 - org.springframework.core.type.StandardAnnotationMetadata\n\n\n# Spring 组合注解（Composed Annotations）\n\nSpring 组合注解（Composed Annotations）中的元注允许是 Spring 模式注解（Stereotype Annotation）与其他 Spring 功能性注解的任意组合。\n\n\n# Spring 注解属性别名（Attribute Aliases）\n\n\n# Spring 注解属性覆盖（Attribute Overrides）\n\n\n# Spring @Enable 模块驱动\n\n@Enable 模块驱动\n\n@Enable 模块驱动是以 @Enable 为前缀的注解驱动编程模型。所谓“模块”是指具备相同领域的功能组件集合，组合所形成⼀个独⽴的单元。⽐如 Web MVC 模块、AspectJ 代理模块、Caching（缓存）模块、JMX（Java 管理扩展）模块、Async（异步处理）模块等。\n\n举例说明\n\n * @EnableWebMvc\n * @EnableTransactionManagement\n * @EnableCaching\n * @EnableMBeanExport\n * @EnableAsync\n\n@Enable 模块驱动编程模式\n\n * 驱动注解：@EnableXXX\n * 导入注解：@Import 具体实现\n * 具体实现\n * 基于 Configuration Class\n * 基于 ImportSelector 接口实现\n * 基于 ImportBeanDefinitionRegistrar 接口实现\n\n\n# Spring 条件注解\n\n基于配置条件注解 - @org.springframework.context.annotation.Profile\n\n * 关联对象 - org.springframework.core.env.Environment 中的 Profiles\n * 实现变化：从 Spring 4.0 开始，@Profile 基于 @Conditional 实现\n\n基于编程条件注解 - @org.springframework.context.annotation.Conditional\n\n * 关联对象 - org.springframework.context.annotation.Condition 具体实现\n\n@Conditional 实现原理\n\n * 上下文对象 - org.springframework.context.annotation.ConditionContext\n * 条件判断 - org.springframework.context.annotation.ConditionEvaluator\n * 配置阶段 - org.springframework.context.annotation.ConfigurationCondition.ConfigurationPhase\n * 判断入口\n   * org.springframework.context.annotation.ConfigurationClassPostProcessor\n   * org.springframework.context.annotation.ConfigurationClassParser\n\n\n# 参考资料\n\n * Spring 官方文档之 Core Technologies\n * 《小马哥讲 Spring 核心编程思想》",normalizedContent:"# spring 注解\n\n\n# spring 注解驱动编程发展历程\n\n * 注解驱动启蒙时代：spring framework 1.x\n * 注解驱动过渡时代：spring framework 2.x\n * 注解驱动黄金时代：spring framework 3.x\n * 注解驱动完善时代：spring framework 4.x\n * 注解驱动当下时代：spring framework 5.x\n\n\n# spring 核心注解场景分类\n\nspring 模式注解\n\nspring 注解        场景说明          起始版本\n@repository      数据仓储模式注解      2.0\n@component       通用组件模式注解      2.5\n@service         服务模式注解        2.5\n@controller      web 控制器模式注解   2.5\n@configuration   配置类模式注解       3.0\n\n装配注解\n\nspring 注解         场景说明                             起始版本\n@importresource   替换 xml 元素 <import>               2.5\n@import           导入 configuration 类               2.5\n@componentscan    扫描指定 package 下标注 spring 模式注解的类   3.1\n\n依赖注入注解\n\nspring 注解    场景说明                   起始版本\n@autowired   bean 依赖注入，支持多种依赖查找方式   2.5\n@qualifier   细粒度的 @autowired 依赖查找   2.5\n\n\n# spring 注解编程模型\n\n * 元注解（meta-annotations）\n * spring 模式注解（stereotype annotations）\n * spring 组合注解（composed annotations）\n * spring 注解属性别名和覆盖（attribute aliases and overrides）\n\n\n# spring 元注解（meta-annotations）\n\n * java.lang.annotation.documented\n * java.lang.annotation.inherited\n * java.lang.annotation.repeatable\n\n\n# spring 模式注解（stereotype annotations）\n\n理解 @component “派⽣性”：元标注 @component 的注解在 xml 元素 context:component-scan 或注解 @componentscan 扫描中“派生”了 @component 的特性，并且从 spring framework 4.0 开始支持多层次“派⽣性”。\n\n举例说明：\n\n * @repository\n * @service\n * @controller\n * @configuration\n * @springbootconfiguration（spring boot）\n\n@component “派⽣性”原理\n\n * 核心组件 - org.springframework.context.annotation.classpathbeandefinitionscanner\n * org.springframework.context.annotation.classpathscanningcandidatecomponentprovider\n * 资源处理 - org.springframework.core.io.support.resourcepatternresolver\n * 资源-类元信息\n * org.springframework.core.type.classreading.metadatareaderfactory\n * 类元信息 - org.springframework.core.type.classmetadata\n * asm 实现 - org.springframework.core.type.classreading.classmetadatareadingvisitor\n * 反射实现 - org.springframework.core.type.standardannotationmetadata\n * 注解元信息 - org.springframework.core.type.annotationmetadata\n * asm 实现 - org.springframework.core.type.classreading.annotationmetadatareadingvisitor\n * 反射实现 - org.springframework.core.type.standardannotationmetadata\n\n\n# spring 组合注解（composed annotations）\n\nspring 组合注解（composed annotations）中的元注允许是 spring 模式注解（stereotype annotation）与其他 spring 功能性注解的任意组合。\n\n\n# spring 注解属性别名（attribute aliases）\n\n\n# spring 注解属性覆盖（attribute overrides）\n\n\n# spring @enable 模块驱动\n\n@enable 模块驱动\n\n@enable 模块驱动是以 @enable 为前缀的注解驱动编程模型。所谓“模块”是指具备相同领域的功能组件集合，组合所形成⼀个独⽴的单元。⽐如 web mvc 模块、aspectj 代理模块、caching（缓存）模块、jmx（java 管理扩展）模块、async（异步处理）模块等。\n\n举例说明\n\n * @enablewebmvc\n * @enabletransactionmanagement\n * @enablecaching\n * @enablembeanexport\n * @enableasync\n\n@enable 模块驱动编程模式\n\n * 驱动注解：@enablexxx\n * 导入注解：@import 具体实现\n * 具体实现\n * 基于 configuration class\n * 基于 importselector 接口实现\n * 基于 importbeandefinitionregistrar 接口实现\n\n\n# spring 条件注解\n\n基于配置条件注解 - @org.springframework.context.annotation.profile\n\n * 关联对象 - org.springframework.core.env.environment 中的 profiles\n * 实现变化：从 spring 4.0 开始，@profile 基于 @conditional 实现\n\n基于编程条件注解 - @org.springframework.context.annotation.conditional\n\n * 关联对象 - org.springframework.context.annotation.condition 具体实现\n\n@conditional 实现原理\n\n * 上下文对象 - org.springframework.context.annotation.conditioncontext\n * 条件判断 - org.springframework.context.annotation.conditionevaluator\n * 配置阶段 - org.springframework.context.annotation.configurationcondition.configurationphase\n * 判断入口\n   * org.springframework.context.annotation.configurationclasspostprocessor\n   * org.springframework.context.annotation.configurationclassparser\n\n\n# 参考资料\n\n * spring 官方文档之 core technologies\n * 《小马哥讲 spring 核心编程思想》",charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Spring Environment 抽象",frontmatter:{title:"Spring Environment 抽象",date:"2022-12-23T09:27:44.000Z",order:29,categories:["Java","框架","Spring","Spring核心"],tags:["Java","框架","Spring"],permalink:"/pages/03d838/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/01.Spring%E6%A0%B8%E5%BF%83/29.SpringEnvironment%E6%8A%BD%E8%B1%A1.html",relativePath:"01.Java/13.框架/01.Spring/01.Spring核心/29.SpringEnvironment抽象.md",key:"v-121f4bfb",path:"/pages/03d838/",headers:[{level:2,title:"理解 Spring Environment 抽象",slug:"理解-spring-environment-抽象",normalizedTitle:"理解 spring environment 抽象",charIndex:28},{level:2,title:"Spring Environment 接口使用场景",slug:"spring-environment-接口使用场景",normalizedTitle:"spring environment 接口使用场景",charIndex:295},{level:2,title:"Environment 占位符处理",slug:"environment-占位符处理",normalizedTitle:"environment 占位符处理",charIndex:419},{level:2,title:"理解条件配置 Spring Profiles",slug:"理解条件配置-spring-profiles",normalizedTitle:"理解条件配置 spring profiles",charIndex:758},{level:2,title:"Spring 4 重构 @Profile",slug:"spring-4-重构-profile",normalizedTitle:"spring 4 重构 @profile",charIndex:1120},{level:2,title:"依赖注入 Environment",slug:"依赖注入-environment",normalizedTitle:"依赖注入 environment",charIndex:1269},{level:2,title:"依赖查找 Environment",slug:"依赖查找-environment",normalizedTitle:"依赖查找 environment",charIndex:1442},{level:2,title:"依赖注入 @Value",slug:"依赖注入-value",normalizedTitle:"依赖注入 @value",charIndex:1648},{level:2,title:"Spring 类型转换在 Environment 中的运用",slug:"spring-类型转换在-environment-中的运用",normalizedTitle:"spring 类型转换在 environment 中的运用",charIndex:1765},{level:2,title:"Spring 类型转换在 @Value 中的运用",slug:"spring-类型转换在-value-中的运用",normalizedTitle:"spring 类型转换在 @value 中的运用",charIndex:2074},{level:2,title:"Spring 配置属性源 PropertySource",slug:"spring-配置属性源-propertysource",normalizedTitle:"spring 配置属性源 propertysource",charIndex:2504},{level:2,title:"Spring 內建的配置属性源",slug:"spring-內建的配置属性源",normalizedTitle:"spring 內建的配置属性源",charIndex:2962},{level:2,title:"基于注解扩展 Spring 配置属性源",slug:"基于注解扩展-spring-配置属性源",normalizedTitle:"基于注解扩展 spring 配置属性源",charIndex:3584},{level:2,title:"基于 API 扩展 Spring 配置属性源",slug:"基于-api-扩展-spring-配置属性源",normalizedTitle:"基于 api 扩展 spring 配置属性源",charIndex:4024},{level:2,title:"问题",slug:"问题",normalizedTitle:"问题",charIndex:4124},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:4376}],headersStr:"理解 Spring Environment 抽象 Spring Environment 接口使用场景 Environment 占位符处理 理解条件配置 Spring Profiles Spring 4 重构 @Profile 依赖注入 Environment 依赖查找 Environment 依赖注入 @Value Spring 类型转换在 Environment 中的运用 Spring 类型转换在 @Value 中的运用 Spring 配置属性源 PropertySource Spring 內建的配置属性源 基于注解扩展 Spring 配置属性源 基于 API 扩展 Spring 配置属性源 问题 参考资料",content:"# Spring Environment 抽象\n\n\n# 理解 Spring Environment 抽象\n\n统一的 Spring 配置属性管理\n\nSpring Framework 3.1 开始引入 Environment 抽象，它统一 Spring 配置属性的存储，包括占位符处理和类型转换，不仅完整地替换 PropertyPlaceholderConfigurer，而且还支持更丰富的配置属性源（PropertySource）\n\n条件化 Spring Bean 装配管理\n\n通过 Environment Profiles 信息，帮助 Spring 容器提供条件化地装配 Bean\n\n\n# Spring Environment 接口使用场景\n\n * ⽤于属性占位符处理\n * 用于转换 Spring 配置属性类型\n * 用于存储 Spring 配置属性源（PropertySource）\n * 用于 Profiles 状态的维护\n\n\n# Environment 占位符处理\n\nSpring 3.1 前占位符处理\n\n * 组件：org.springframework.beans.factory.config.PropertyPlaceholderConfigurer\n * 接口：org.springframework.util.StringValueResolver\n\nSpring 3.1 + 占位符处理\n\n * 组件：org.springframework.context.support.PropertySourcesPlaceholderConfigurer\n * 接口：org.springframework.beans.factory.config.EmbeddedValueResolver\n\n\n# 理解条件配置 Spring Profiles\n\nSpring 3.1 条件配置\n\n * API：org.springframework.core.env.ConfigurableEnvironment\n * 修改：addActiveProfile(String)、setActiveProfiles(String...) 和 setDefaultProfiles(String...)\n * 获取：getActiveProfiles() 和 getDefaultProfiles()\n * 匹配：#acceptsProfiles(String...) 和 acceptsProfiles(Profiles)\n * 注解：@org.springframework.context.annotation.Profile\n\n\n# Spring 4 重构 @Profile\n\n基于 Spring 4 org.springframework.context.annotation.Condition 接口实现\n\norg.springframework.context.annotation.ProfileCondition\n\n\n# 依赖注入 Environment\n\n直接依赖注入\n\n * 通过 EnvironmentAware 接口回调\n * 通过 @Autowired 注入 Environment\n\n间接依赖注入\n\n * 通过 ApplicationContextAware 接口回调\n * 通过 @Autowired 注入 ApplicationContext\n\n\n# 依赖查找 Environment\n\n直接依赖查找\n\n * 通过 org.springframework.context.ConfigurableApplicationContext#ENVIRONMENT_BEAN_NAME\n\n间接依赖查找\n\n * 通过 org.springframework.context.ConfigurableApplicationContext#getEnvironment\n\n\n# 依赖注入 @Value\n\n通过注入 @Value\n\n实现 - org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor\n\n\n# Spring 类型转换在 Environment 中的运用\n\nEnvironment 底层实现\n\n * 底层实现 - org.springframework.core.env.PropertySourcesPropertyResolver\n * 核心方法 - convertValueIfNecessary(Object,Class)\n * 底层服务 - org.springframework.core.convert.ConversionService\n * 默认实现 - org.springframework.core.convert.support.DefaultConversionService\n\n\n# Spring 类型转换在 @Value 中的运用\n\n@Value 底层实现\n\n * 底层实现 - org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor\n   * org.springframework.beans.factory.support.DefaultListableBeanFactory#doResolveDependency\n * 底层服务 - org.springframework.beans.TypeConverter\n   * 默认实现 - org.springframework.beans.TypeConverterDelegate\n     * java.beans.PropertyEditor\n     * org.springframework.core.convert.ConversionService\n\n\n# Spring 配置属性源 PropertySource\n\n * API\n   * 单配置属性源 - org.springframework.core.env.PropertySource\n   * 多配置属性源 - org.springframework.core.env.PropertySources\n * 注解\n   * 单配置属性源 - @org.springframework.context.annotation.PropertySource\n   * 多配置属性源 - @org.springframework.context.annotation.PropertySources\n * 关联\n   * 存储对象 - org.springframework.core.env.MutablePropertySources\n   * 关联方法 - org.springframework.core.env.ConfigurableEnvironment#getPropertySources()\n\n\n# Spring 內建的配置属性源\n\n內建 PropertySource\n\nPROPERTYSOURCE 类型                                                      说明\norg.springframework.core.env.CommandLinePropertySource                 命令行配置属性源\norg.springframework.jndi.JndiPropertySource                            JDNI 配置属性源\norg.springframework.core.env.PropertiesPropertySource                  Properties 配置属性源\norg.springframework.web.context.support.ServletConfigPropertySource    Servlet 配置属性源\norg.springframework.web.context.support.ServletContextPropertySource   ServletContext 配置属性源\norg.springframework.core.env.SystemEnvironmentPropertySource           环境变量配置属性源\n\n\n# 基于注解扩展 Spring 配置属性源\n\n@org.springframework.context.annotation.PropertySource 实现原理\n\n * 入口 - org.springframework.context.annotation.ConfigurationClassParser#doProcessConfigurationClass\n   * org.springframework.context.annotation.ConfigurationClassParser#processPropertySource\n * 4.3 新增语义\n   * 配置属性字符编码 - encoding\n   * org.springframework.core.io.support.PropertySourceFactory\n * 适配对象 - org.springframework.core.env.CompositePropertySource\n\n\n# 基于 API 扩展 Spring 配置属性源\n\n * Spring 应用上下文启动前装配 PropertySource\n * Spring 应用上下文启动后装配 PropertySource\n\n\n# 问题\n\n简单介绍 Spring Environment 接口？\n\n * 核心接口 - org.springframework.core.env.Environment\n * 父接口 - org.springframework.core.env.PropertyResolver\n * 可配置接口 - org.springframework.core.env.ConfigurableEnvironment\n * 职责：\n   * 管理 Spring 配置属性源\n   * 管理 Profiles\n\n\n# 参考资料\n\n * Spring 官方文档之 Core Technologies\n * 《小马哥讲 Spring 核心编程思想》",normalizedContent:"# spring environment 抽象\n\n\n# 理解 spring environment 抽象\n\n统一的 spring 配置属性管理\n\nspring framework 3.1 开始引入 environment 抽象，它统一 spring 配置属性的存储，包括占位符处理和类型转换，不仅完整地替换 propertyplaceholderconfigurer，而且还支持更丰富的配置属性源（propertysource）\n\n条件化 spring bean 装配管理\n\n通过 environment profiles 信息，帮助 spring 容器提供条件化地装配 bean\n\n\n# spring environment 接口使用场景\n\n * ⽤于属性占位符处理\n * 用于转换 spring 配置属性类型\n * 用于存储 spring 配置属性源（propertysource）\n * 用于 profiles 状态的维护\n\n\n# environment 占位符处理\n\nspring 3.1 前占位符处理\n\n * 组件：org.springframework.beans.factory.config.propertyplaceholderconfigurer\n * 接口：org.springframework.util.stringvalueresolver\n\nspring 3.1 + 占位符处理\n\n * 组件：org.springframework.context.support.propertysourcesplaceholderconfigurer\n * 接口：org.springframework.beans.factory.config.embeddedvalueresolver\n\n\n# 理解条件配置 spring profiles\n\nspring 3.1 条件配置\n\n * api：org.springframework.core.env.configurableenvironment\n * 修改：addactiveprofile(string)、setactiveprofiles(string...) 和 setdefaultprofiles(string...)\n * 获取：getactiveprofiles() 和 getdefaultprofiles()\n * 匹配：#acceptsprofiles(string...) 和 acceptsprofiles(profiles)\n * 注解：@org.springframework.context.annotation.profile\n\n\n# spring 4 重构 @profile\n\n基于 spring 4 org.springframework.context.annotation.condition 接口实现\n\norg.springframework.context.annotation.profilecondition\n\n\n# 依赖注入 environment\n\n直接依赖注入\n\n * 通过 environmentaware 接口回调\n * 通过 @autowired 注入 environment\n\n间接依赖注入\n\n * 通过 applicationcontextaware 接口回调\n * 通过 @autowired 注入 applicationcontext\n\n\n# 依赖查找 environment\n\n直接依赖查找\n\n * 通过 org.springframework.context.configurableapplicationcontext#environment_bean_name\n\n间接依赖查找\n\n * 通过 org.springframework.context.configurableapplicationcontext#getenvironment\n\n\n# 依赖注入 @value\n\n通过注入 @value\n\n实现 - org.springframework.beans.factory.annotation.autowiredannotationbeanpostprocessor\n\n\n# spring 类型转换在 environment 中的运用\n\nenvironment 底层实现\n\n * 底层实现 - org.springframework.core.env.propertysourcespropertyresolver\n * 核心方法 - convertvalueifnecessary(object,class)\n * 底层服务 - org.springframework.core.convert.conversionservice\n * 默认实现 - org.springframework.core.convert.support.defaultconversionservice\n\n\n# spring 类型转换在 @value 中的运用\n\n@value 底层实现\n\n * 底层实现 - org.springframework.beans.factory.annotation.autowiredannotationbeanpostprocessor\n   * org.springframework.beans.factory.support.defaultlistablebeanfactory#doresolvedependency\n * 底层服务 - org.springframework.beans.typeconverter\n   * 默认实现 - org.springframework.beans.typeconverterdelegate\n     * java.beans.propertyeditor\n     * org.springframework.core.convert.conversionservice\n\n\n# spring 配置属性源 propertysource\n\n * api\n   * 单配置属性源 - org.springframework.core.env.propertysource\n   * 多配置属性源 - org.springframework.core.env.propertysources\n * 注解\n   * 单配置属性源 - @org.springframework.context.annotation.propertysource\n   * 多配置属性源 - @org.springframework.context.annotation.propertysources\n * 关联\n   * 存储对象 - org.springframework.core.env.mutablepropertysources\n   * 关联方法 - org.springframework.core.env.configurableenvironment#getpropertysources()\n\n\n# spring 內建的配置属性源\n\n內建 propertysource\n\npropertysource 类型                                                      说明\norg.springframework.core.env.commandlinepropertysource                 命令行配置属性源\norg.springframework.jndi.jndipropertysource                            jdni 配置属性源\norg.springframework.core.env.propertiespropertysource                  properties 配置属性源\norg.springframework.web.context.support.servletconfigpropertysource    servlet 配置属性源\norg.springframework.web.context.support.servletcontextpropertysource   servletcontext 配置属性源\norg.springframework.core.env.systemenvironmentpropertysource           环境变量配置属性源\n\n\n# 基于注解扩展 spring 配置属性源\n\n@org.springframework.context.annotation.propertysource 实现原理\n\n * 入口 - org.springframework.context.annotation.configurationclassparser#doprocessconfigurationclass\n   * org.springframework.context.annotation.configurationclassparser#processpropertysource\n * 4.3 新增语义\n   * 配置属性字符编码 - encoding\n   * org.springframework.core.io.support.propertysourcefactory\n * 适配对象 - org.springframework.core.env.compositepropertysource\n\n\n# 基于 api 扩展 spring 配置属性源\n\n * spring 应用上下文启动前装配 propertysource\n * spring 应用上下文启动后装配 propertysource\n\n\n# 问题\n\n简单介绍 spring environment 接口？\n\n * 核心接口 - org.springframework.core.env.environment\n * 父接口 - org.springframework.core.env.propertyresolver\n * 可配置接口 - org.springframework.core.env.configurableenvironment\n * 职责：\n   * 管理 spring 配置属性源\n   * 管理 profiles\n\n\n# 参考资料\n\n * spring 官方文档之 core technologies\n * 《小马哥讲 spring 核心编程思想》",charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"SpringBoot 之快速入门",frontmatter:{title:"SpringBoot 之快速入门",date:"2021-12-10T18:22:26.000Z",order:31,categories:["Java","框架","Spring","Spring核心"],tags:["Java","框架","Spring","SpringBoot"],permalink:"/pages/950e4d/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/01.Spring%E6%A0%B8%E5%BF%83/31.SpringBoot%E4%B9%8B%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8.html",relativePath:"01.Java/13.框架/01.Spring/01.Spring核心/31.SpringBoot之快速入门.md",key:"v-e0b3a04c",path:"/pages/950e4d/",headers:[{level:2,title:"Spring Boot 简介",slug:"spring-boot-简介",normalizedTitle:"spring boot 简介",charIndex:23},{level:2,title:"Spring Boot 系统要求",slug:"spring-boot-系统要求",normalizedTitle:"spring boot 系统要求",charIndex:211},{level:2,title:"部署第一个 Spring Boot 项目",slug:"部署第一个-spring-boot-项目",normalizedTitle:"部署第一个 spring boot 项目",charIndex:466},{level:3,title:"环境检查",slug:"环境检查",normalizedTitle:"环境检查",charIndex:589},{level:3,title:"创建 pom",slug:"创建-pom",normalizedTitle:"创建 pom",charIndex:1043},{level:3,title:"添加依赖",slug:"添加依赖",normalizedTitle:"添加依赖",charIndex:1779},{level:3,title:"编写代码",slug:"编写代码",normalizedTitle:"编写代码",charIndex:2522},{level:3,title:"运行示例",slug:"运行示例",normalizedTitle:"运行示例",charIndex:3485},{level:3,title:"创建可执行 jar",slug:"创建可执行-jar",normalizedTitle:"创建可执行 jar",charIndex:4145},{level:2,title:"通过 SPRING INITIALIZR 创建 Spring Boot 项目",slug:"通过-spring-initializr-创建-spring-boot-项目",normalizedTitle:"通过 spring initializr 创建 spring boot 项目",charIndex:5952},{level:3,title:"创建项目",slug:"创建项目",normalizedTitle:"创建项目",charIndex:5995},{level:3,title:"项目说明",slug:"项目说明",normalizedTitle:"项目说明",charIndex:6250},{level:3,title:"编写 REST 服务",slug:"编写-rest-服务",normalizedTitle:"编写 rest 服务",charIndex:7790},{level:3,title:"编写单元测试用例",slug:"编写单元测试用例",normalizedTitle:"编写单元测试用例",charIndex:8129},{level:3,title:"示例源码",slug:"示例源码",normalizedTitle:"示例源码",charIndex:9205},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:9249}],headersStr:"Spring Boot 简介 Spring Boot 系统要求 部署第一个 Spring Boot 项目 环境检查 创建 pom 添加依赖 编写代码 运行示例 创建可执行 jar 通过 SPRING INITIALIZR 创建 Spring Boot 项目 创建项目 项目说明 编写 REST 服务 编写单元测试用例 示例源码 参考资料",content:'# SpringBoot 之快速入门\n\n\n# Spring Boot 简介\n\nSpring Boot 可以让使用者非常方便的创建 Spring 应用。\n\nSpring Boot 的目标是：\n\n * 为所有 Spring 开发者提供更快且可广泛访问的入门体验。\n * 开箱即用\n * 提供一系列通用的非功能特性（例如嵌入式服务、安全、指标、健康检查和外部化配置）\n * 完全不需要代码生成，也不需要 XML 配置。\n\n\n# Spring Boot 系统要求\n\nSpring Boot 的构建工具要求：\n\nBUILD TOOL   VERSION\nMaven        3.5+\nGradle       6.8.x, 6.9.x, and 7.x\n\nSpring Boot 支持的 Servlet 容器：\n\nNAME           SERVLET VERSION\nTomcat 9.0     4.0\nJetty 9.4      3.1\nJetty 10.0     4.0\nUndertow 2.0   4.0\n\n\n# 部署第一个 Spring Boot 项目\n\n> 本节介绍如何开发一个小的“Hello World!” web 应用示例，来展示 Spring Boot 的一些关键功能。我们使用 Maven 来构建这个项目，因为大多数 IDE 都支持它。\n\n\n# 环境检查\n\nSpring Boot 项目依赖于 Java 环境和 Mave，开始项目之前需要先检查一下环境。\n\n本地是否已安装 Java：\n\n$ java -version\njava version "1.8.0_102"\nJava(TM) SE Runtime Environment (build 1.8.0_102-b14)\nJava HotSpot(TM) 64-Bit Server VM (build 25.102-b14, mixed mode)\n\n\n本地是否已安装 Maven：\n\n$ mvn -v\nApache Maven 3.5.4 (1edded0938998edf8bf061f1ceb3cfdeccf443fe; 2018-06-17T14:33:14-04:00)\nMaven home: /usr/local/Cellar/maven/3.3.9/libexec\nJava version: 1.8.0_102, vendor: Oracle Corporation\n\n\n\n# 创建 pom\n\n我们需要从创建 Maven pom.xml 文件开始。 pom.xml 是 Maven 用于构建项目的配置文件。\n\n<?xml version="1.0" encoding="UTF-8"?>\n<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.example</groupId>\n    <artifactId>myproject</artifactId>\n    <version>0.0.1-SNAPSHOT</version>\n\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.6.1</version>\n    </parent>\n\n    \x3c!-- Additional lines to be added here... --\x3e\n\n</project>\n\n\n使用者可以通过运行 mvn package 来测试它\n\n\n# 添加依赖\n\nSpring Boot 提供了许多启动器（Starters）以应对不同的使用场景。使用者可将 jars 添加到类路径中。我们的示例程序在 POM 的 parent 使用 spring-boot-starter-parent。 spring-boot-starter-parent 是一个特殊的启动器，提供有用的 Maven 默认值。它还提供了一个依赖项的版本管理，可以让使用者使用时不必显示指定版本。\n\n其他启动器（Starters）提供了各种针对不同使用场景的功能。比如，我们需要开发一个 Web 应用程序，就可以添加了一个 spring-boot-starter-web 依赖项。在此之前，我们可以通过运行以下命令来查看我们当前拥有的 maven 依赖：\n\n$ mvn dependency:tree\n\n[INFO] com.example:myproject:jar:0.0.1-SNAPSHOT\n\n\nmvn dependency:tree 命令打印项目依赖项的层级结构。可以看到 spring-boot-starter-parent 本身没有提供任何依赖。要添加必要的依赖，需要编辑 pom.xml 并在 <dependencies> 部分添加 spring-boot-starter-web 依赖项：\n\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n</dependencies>\n\n\n\n# 编写代码\n\n要运行应用程序，我们需要创建一个启动类。默认情况下，Maven 从 src/main/java 编译源代码，因此您需要创建该目录结构，然后添加一个名为 src/main/java/MyApplication.java 的文件以包含以下代码：\n\n@RestController\n@EnableAutoConfiguration\npublic class MyApplication {\n\n    @RequestMapping("/")\n    String home() {\n        return "Hello World!";\n    }\n\n    public static void main(String[] args) {\n        SpringApplication.run(MyApplication.class, args);\n    }\n\n}\n\n\n说明：\n\n@RestController 注解告诉 Spring，这个类是用来处理 Rest 请求的。\n\n@RequestMapping 注解提供了“路由”信息。它告诉 Spring 任何带有 / 路径的 HTTP 请求都应该映射到 home 方法。 @RestController 注解告诉 Spring 将结果字符串直接呈现给调用者。\n\n@EnableAutoConfiguration 注解告诉 Spring Boot 根据你添加的 jar 依赖去自动装配 Spring。\n\n> 自动配置旨在与“Starters”配合使用，但这两个概念并没有直接联系。您可以自由选择 starters 之外的 jar 依赖项。 Spring Boot 仍然尽力自动配置您的应用程序。\n\nSpring Boot 的 main 方法通过调用 run 委托给 Spring Boot 的 SpringApplication 类。 SpringApplication 引导我们的应用程序，启动 Spring，进而启动自动配置的 Tomcat Web 服务器。我们需要将 MyApplication.class 作为参数传递给 run 方法，以告诉 SpringApplication 哪个是入口类。还传递 args 数组以公开任何命令行参数。\n\n\n# 运行示例\n\n此时，您的应用程序应该可以工作了。由于您使用了 spring-boot-starter-parent POM，因此您有一个有用的运行目标，可用于启动应用程序。从项目根目录键入 mvn spring-boot:run 以启动应用程序。您应该会看到类似于以下内容的输出：\n\n$ mvn spring-boot:run\n\n  .   ____          _            __ _ _\n /\\\\ / ___\'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\\n( ( )\\___ | \'_ | \'_| | \'_ \\/ _` | \\ \\ \\ \\\n \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )\n  \'  |____| .__|_| |_|_| |_\\__, | / / / /\n =========|_|==============|___/=/_/_/_/\n :: Spring Boot ::  (v2.6.1)\n....... . . .\n....... . . . (log output here)\n....... . . .\n........ Started MyApplication in 2.222 seconds (JVM running for 6.514)\n\n\n如果您打开 Web 浏览器访问 localhost:8080，您应该会看到以下输出：\n\nHello World!\n\n\n要正常退出应用程序，请按 ctrl-c。\n\n\n# 创建可执行 jar\n\n要创建一个可执行的 jar，我们需要将 spring-boot-maven-plugin 添加到我们的 pom.xml 中。为此，请在依赖项部分下方插入以下行：\n\n<build>\n    <plugins>\n        <plugin>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-maven-plugin</artifactId>\n        </plugin>\n    </plugins>\n</build>\n\n\n保存 pom.xml 并从命令行运行 mvn package，如下所示：\n\n$ mvn package\n\n[INFO] Scanning for projects...\n[INFO]\n[INFO] ------------------------------------------------------------------------\n[INFO] Building myproject 0.0.1-SNAPSHOT\n[INFO] ------------------------------------------------------------------------\n[INFO] .... ..\n[INFO] --- maven-jar-plugin:2.4:jar (default-jar) @ myproject ---\n[INFO] Building jar: /Users/developer/example/spring-boot-example/target/myproject-0.0.1-SNAPSHOT.jar\n[INFO]\n[INFO] --- spring-boot-maven-plugin:2.6.1:repackage (default) @ myproject ---\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n\n\n如果您查看 target 目录，应该会看到 myproject-0.0.1-SNAPSHOT.jar。该文件的大小应约为 10 MB。如果想看里面，可以使用 jar tvf，如下：\n\n$ jar tvf target/myproject-0.0.1-SNAPSHOT.jar\n\n\n您还应该在目标目录中看到一个更小的名为 myproject-0.0.1-SNAPSHOT.jar.original 的文件。这是 Maven 在 Spring Boot 重新打包之前创建的原始 jar 文件。\n\n要运行该应用程序，请使用 java -jar 命令，如下所示：\n\n$ java -jar target/myproject-0.0.1-SNAPSHOT.jar\n\n  .   ____          _            __ _ _\n /\\\\ / ___\'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\\n( ( )\\___ | \'_ | \'_| | \'_ \\/ _` | \\ \\ \\ \\\n \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )\n  \'  |____| .__|_| |_|_| |_\\__, | / / / /\n =========|_|==============|___/=/_/_/_/\n :: Spring Boot ::  (v2.6.1)\n....... . . .\n....... . . . (log output here)\n....... . . .\n........ Started MyApplication in 2.536 seconds (JVM running for 2.864)\n\n\n和以前一样，要退出应用程序，请按 ctrl-c。\n\n\n# 通过 SPRING INITIALIZR 创建 Spring Boot 项目\n\n\n# 创建项目\n\n通过 SPRING INITIALIZR 工具产生基础项目\n\n 1. 访问：http://start.spring.io/\n 2. 选择构建工具Maven Project、Spring Boot 版本 1.5.10 以及一些工程基本信息，可参考下图所示：\n\n\n\n 3. 点击Generate Project下载项目压缩包\n 4. 解压压缩包，包中已是一个完整的项目。\n\n如果你使用 Intellij 作为 IDE，那么你可以直接使用 SPRING INITIALIZR，参考下图操作：\n\n\n\n\n# 项目说明\n\n重要文件\n\n * src/main/java 路径下的 Chapter1Application 类 ：程序入口\n * src/main/resources 路径下的 application.properties ：项目配置文件\n * src/test/java 路径下的 Chapter01ApplicationTests ：程序测试入口\n\npom.xml\n\npom 中指定 parent 为以下内容，表示此项目继承了 spring-boot-starter-parent 的 maven 配置（主要是指定了常用依赖、插件的版本）。\n\n<parent>\n <groupId>org.springframework.boot</groupId>\n <artifactId>spring-boot-starter-parent</artifactId>\n <version>1.5.10.RELEASE</version>\n <relativePath/> \x3c!-- lookup parent from repository --\x3e\n</parent>\n\n\n此外，pom 中默认引入两个依赖包，和一个插件。\n\n<dependencies>\n <dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-web</artifactId>\n </dependency>\n\n <dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-test</artifactId>\n  <scope>test</scope>\n </dependency>\n</dependencies>\n\n<build>\n <plugins>\n  <plugin>\n   <groupId>org.springframework.boot</groupId>\n   <artifactId>spring-boot-maven-plugin</artifactId>\n  </plugin>\n </plugins>\n</build>\n\n\n * spring-boot-starter-web：核心模块，包括自动配置支持、日志和 YAML。\n * spring-boot-starter-test：测试模块，包括 JUnit、Hamcrest、Mockito。\n * spring-boot-maven-plugin：spring boot 插件， 提供了一系列 spring boot 相关的 maven 操作。\n   * spring-boot:build-info，生成 Actuator 使用的构建信息文件 build-info.properties\n   * spring-boot:repackage，默认 goal。在 mvn package 之后，再次打包可执行的 jar/war，同时保留 mvn package 生成的 jar/war 为.origin\n   * spring-boot:run，运行 Spring Boot 应用\n   * spring-boot:start，在 mvn integration-test 阶段，进行 Spring Boot 应用生命周期的管理\n   * spring-boot:stop，在 mvn integration-test 阶段，进行 Spring Boot 应用生命周期的管理\n\n\n# 编写 REST 服务\n\n * 创建 package ，名为 io.github.zp.springboot.chapter1.web（根据项目情况修改）\n * 创建 HelloController 类，内容如下：\n\n@RestController\npublic class HelloController {\n\n    @RequestMapping("/hello")\n    public String index() {\n        return "Hello World";\n    }\n\n}\n\n\n * 启动主程序 XXXApplication，打开浏览器访问http://localhost:8080/hello ，可以看到页面输出Hello World\n\n\n# 编写单元测试用例\n\n在 XXXApplicationTests 类中编写一个简单的单元测试来模拟 HTTP 请求，具体如下：\n\n@RunWith(SpringJUnit4ClassRunner.class)\n@SpringApplicationConfiguration(classes = MockServletContext.class)\n@WebAppConfiguration\npublic class SpringBootHelloWorldApplicationTest {\n\n\tprivate MockMvc mvc;\n\n\t@Before\n\tpublic void setUp() {\n\t\tmvc = MockMvcBuilders.standaloneSetup(new HelloController()).build();\n\t}\n\n\t@Test\n\tpublic void getHello() throws Exception {\n\t\tmvc.perform(MockMvcRequestBuilders.get("/hello").accept(MediaType.APPLICATION_JSON))\n\t\t\t\t.andExpect(status().isOk())\n\t\t\t\t.andExpect(content().string(equalTo("Hello World")));\n\t}\n\n}\n\n\n使用MockServletContext来构建一个空的WebApplicationContext，这样我们创建的HelloController就可以在@Before函数中创建并传递到MockMvcBuilders.standaloneSetup（）函数中。\n\n * 注意引入下面内容，让status、content、equalTo函数可用\n\nimport static org.hamcrest.Matchers.equalTo;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n\n\n至此已完成目标，通过 Maven 构建了一个空白 Spring Boot 项目，再通过引入 web 模块实现了一个简单的请求处理。\n\n\n# 示例源码\n\n> 示例源码：spring-boot-web-helloworld\n\n\n# 参考资料\n\n * Spring Boot 官方文档之 Getting Started',normalizedContent:'# springboot 之快速入门\n\n\n# spring boot 简介\n\nspring boot 可以让使用者非常方便的创建 spring 应用。\n\nspring boot 的目标是：\n\n * 为所有 spring 开发者提供更快且可广泛访问的入门体验。\n * 开箱即用\n * 提供一系列通用的非功能特性（例如嵌入式服务、安全、指标、健康检查和外部化配置）\n * 完全不需要代码生成，也不需要 xml 配置。\n\n\n# spring boot 系统要求\n\nspring boot 的构建工具要求：\n\nbuild tool   version\nmaven        3.5+\ngradle       6.8.x, 6.9.x, and 7.x\n\nspring boot 支持的 servlet 容器：\n\nname           servlet version\ntomcat 9.0     4.0\njetty 9.4      3.1\njetty 10.0     4.0\nundertow 2.0   4.0\n\n\n# 部署第一个 spring boot 项目\n\n> 本节介绍如何开发一个小的“hello world!” web 应用示例，来展示 spring boot 的一些关键功能。我们使用 maven 来构建这个项目，因为大多数 ide 都支持它。\n\n\n# 环境检查\n\nspring boot 项目依赖于 java 环境和 mave，开始项目之前需要先检查一下环境。\n\n本地是否已安装 java：\n\n$ java -version\njava version "1.8.0_102"\njava(tm) se runtime environment (build 1.8.0_102-b14)\njava hotspot(tm) 64-bit server vm (build 25.102-b14, mixed mode)\n\n\n本地是否已安装 maven：\n\n$ mvn -v\napache maven 3.5.4 (1edded0938998edf8bf061f1ceb3cfdeccf443fe; 2018-06-17t14:33:14-04:00)\nmaven home: /usr/local/cellar/maven/3.3.9/libexec\njava version: 1.8.0_102, vendor: oracle corporation\n\n\n\n# 创建 pom\n\n我们需要从创建 maven pom.xml 文件开始。 pom.xml 是 maven 用于构建项目的配置文件。\n\n<?xml version="1.0" encoding="utf-8"?>\n<project xmlns="http://maven.apache.org/pom/4.0.0" xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n    xsi:schemalocation="http://maven.apache.org/pom/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">\n    <modelversion>4.0.0</modelversion>\n\n    <groupid>com.example</groupid>\n    <artifactid>myproject</artifactid>\n    <version>0.0.1-snapshot</version>\n\n    <parent>\n        <groupid>org.springframework.boot</groupid>\n        <artifactid>spring-boot-starter-parent</artifactid>\n        <version>2.6.1</version>\n    </parent>\n\n    \x3c!-- additional lines to be added here... --\x3e\n\n</project>\n\n\n使用者可以通过运行 mvn package 来测试它\n\n\n# 添加依赖\n\nspring boot 提供了许多启动器（starters）以应对不同的使用场景。使用者可将 jars 添加到类路径中。我们的示例程序在 pom 的 parent 使用 spring-boot-starter-parent。 spring-boot-starter-parent 是一个特殊的启动器，提供有用的 maven 默认值。它还提供了一个依赖项的版本管理，可以让使用者使用时不必显示指定版本。\n\n其他启动器（starters）提供了各种针对不同使用场景的功能。比如，我们需要开发一个 web 应用程序，就可以添加了一个 spring-boot-starter-web 依赖项。在此之前，我们可以通过运行以下命令来查看我们当前拥有的 maven 依赖：\n\n$ mvn dependency:tree\n\n[info] com.example:myproject:jar:0.0.1-snapshot\n\n\nmvn dependency:tree 命令打印项目依赖项的层级结构。可以看到 spring-boot-starter-parent 本身没有提供任何依赖。要添加必要的依赖，需要编辑 pom.xml 并在 <dependencies> 部分添加 spring-boot-starter-web 依赖项：\n\n<dependencies>\n    <dependency>\n        <groupid>org.springframework.boot</groupid>\n        <artifactid>spring-boot-starter-web</artifactid>\n    </dependency>\n</dependencies>\n\n\n\n# 编写代码\n\n要运行应用程序，我们需要创建一个启动类。默认情况下，maven 从 src/main/java 编译源代码，因此您需要创建该目录结构，然后添加一个名为 src/main/java/myapplication.java 的文件以包含以下代码：\n\n@restcontroller\n@enableautoconfiguration\npublic class myapplication {\n\n    @requestmapping("/")\n    string home() {\n        return "hello world!";\n    }\n\n    public static void main(string[] args) {\n        springapplication.run(myapplication.class, args);\n    }\n\n}\n\n\n说明：\n\n@restcontroller 注解告诉 spring，这个类是用来处理 rest 请求的。\n\n@requestmapping 注解提供了“路由”信息。它告诉 spring 任何带有 / 路径的 http 请求都应该映射到 home 方法。 @restcontroller 注解告诉 spring 将结果字符串直接呈现给调用者。\n\n@enableautoconfiguration 注解告诉 spring boot 根据你添加的 jar 依赖去自动装配 spring。\n\n> 自动配置旨在与“starters”配合使用，但这两个概念并没有直接联系。您可以自由选择 starters 之外的 jar 依赖项。 spring boot 仍然尽力自动配置您的应用程序。\n\nspring boot 的 main 方法通过调用 run 委托给 spring boot 的 springapplication 类。 springapplication 引导我们的应用程序，启动 spring，进而启动自动配置的 tomcat web 服务器。我们需要将 myapplication.class 作为参数传递给 run 方法，以告诉 springapplication 哪个是入口类。还传递 args 数组以公开任何命令行参数。\n\n\n# 运行示例\n\n此时，您的应用程序应该可以工作了。由于您使用了 spring-boot-starter-parent pom，因此您有一个有用的运行目标，可用于启动应用程序。从项目根目录键入 mvn spring-boot:run 以启动应用程序。您应该会看到类似于以下内容的输出：\n\n$ mvn spring-boot:run\n\n  .   ____          _            __ _ _\n /\\\\ / ___\'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\\n( ( )\\___ | \'_ | \'_| | \'_ \\/ _` | \\ \\ \\ \\\n \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )\n  \'  |____| .__|_| |_|_| |_\\__, | / / / /\n =========|_|==============|___/=/_/_/_/\n :: spring boot ::  (v2.6.1)\n....... . . .\n....... . . . (log output here)\n....... . . .\n........ started myapplication in 2.222 seconds (jvm running for 6.514)\n\n\n如果您打开 web 浏览器访问 localhost:8080，您应该会看到以下输出：\n\nhello world!\n\n\n要正常退出应用程序，请按 ctrl-c。\n\n\n# 创建可执行 jar\n\n要创建一个可执行的 jar，我们需要将 spring-boot-maven-plugin 添加到我们的 pom.xml 中。为此，请在依赖项部分下方插入以下行：\n\n<build>\n    <plugins>\n        <plugin>\n            <groupid>org.springframework.boot</groupid>\n            <artifactid>spring-boot-maven-plugin</artifactid>\n        </plugin>\n    </plugins>\n</build>\n\n\n保存 pom.xml 并从命令行运行 mvn package，如下所示：\n\n$ mvn package\n\n[info] scanning for projects...\n[info]\n[info] ------------------------------------------------------------------------\n[info] building myproject 0.0.1-snapshot\n[info] ------------------------------------------------------------------------\n[info] .... ..\n[info] --- maven-jar-plugin:2.4:jar (default-jar) @ myproject ---\n[info] building jar: /users/developer/example/spring-boot-example/target/myproject-0.0.1-snapshot.jar\n[info]\n[info] --- spring-boot-maven-plugin:2.6.1:repackage (default) @ myproject ---\n[info] ------------------------------------------------------------------------\n[info] build success\n[info] ------------------------------------------------------------------------\n\n\n如果您查看 target 目录，应该会看到 myproject-0.0.1-snapshot.jar。该文件的大小应约为 10 mb。如果想看里面，可以使用 jar tvf，如下：\n\n$ jar tvf target/myproject-0.0.1-snapshot.jar\n\n\n您还应该在目标目录中看到一个更小的名为 myproject-0.0.1-snapshot.jar.original 的文件。这是 maven 在 spring boot 重新打包之前创建的原始 jar 文件。\n\n要运行该应用程序，请使用 java -jar 命令，如下所示：\n\n$ java -jar target/myproject-0.0.1-snapshot.jar\n\n  .   ____          _            __ _ _\n /\\\\ / ___\'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\\n( ( )\\___ | \'_ | \'_| | \'_ \\/ _` | \\ \\ \\ \\\n \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )\n  \'  |____| .__|_| |_|_| |_\\__, | / / / /\n =========|_|==============|___/=/_/_/_/\n :: spring boot ::  (v2.6.1)\n....... . . .\n....... . . . (log output here)\n....... . . .\n........ started myapplication in 2.536 seconds (jvm running for 2.864)\n\n\n和以前一样，要退出应用程序，请按 ctrl-c。\n\n\n# 通过 spring initializr 创建 spring boot 项目\n\n\n# 创建项目\n\n通过 spring initializr 工具产生基础项目\n\n 1. 访问：http://start.spring.io/\n 2. 选择构建工具maven project、spring boot 版本 1.5.10 以及一些工程基本信息，可参考下图所示：\n\n\n\n 3. 点击generate project下载项目压缩包\n 4. 解压压缩包，包中已是一个完整的项目。\n\n如果你使用 intellij 作为 ide，那么你可以直接使用 spring initializr，参考下图操作：\n\n\n\n\n# 项目说明\n\n重要文件\n\n * src/main/java 路径下的 chapter1application 类 ：程序入口\n * src/main/resources 路径下的 application.properties ：项目配置文件\n * src/test/java 路径下的 chapter01applicationtests ：程序测试入口\n\npom.xml\n\npom 中指定 parent 为以下内容，表示此项目继承了 spring-boot-starter-parent 的 maven 配置（主要是指定了常用依赖、插件的版本）。\n\n<parent>\n <groupid>org.springframework.boot</groupid>\n <artifactid>spring-boot-starter-parent</artifactid>\n <version>1.5.10.release</version>\n <relativepath/> \x3c!-- lookup parent from repository --\x3e\n</parent>\n\n\n此外，pom 中默认引入两个依赖包，和一个插件。\n\n<dependencies>\n <dependency>\n  <groupid>org.springframework.boot</groupid>\n  <artifactid>spring-boot-starter-web</artifactid>\n </dependency>\n\n <dependency>\n  <groupid>org.springframework.boot</groupid>\n  <artifactid>spring-boot-starter-test</artifactid>\n  <scope>test</scope>\n </dependency>\n</dependencies>\n\n<build>\n <plugins>\n  <plugin>\n   <groupid>org.springframework.boot</groupid>\n   <artifactid>spring-boot-maven-plugin</artifactid>\n  </plugin>\n </plugins>\n</build>\n\n\n * spring-boot-starter-web：核心模块，包括自动配置支持、日志和 yaml。\n * spring-boot-starter-test：测试模块，包括 junit、hamcrest、mockito。\n * spring-boot-maven-plugin：spring boot 插件， 提供了一系列 spring boot 相关的 maven 操作。\n   * spring-boot:build-info，生成 actuator 使用的构建信息文件 build-info.properties\n   * spring-boot:repackage，默认 goal。在 mvn package 之后，再次打包可执行的 jar/war，同时保留 mvn package 生成的 jar/war 为.origin\n   * spring-boot:run，运行 spring boot 应用\n   * spring-boot:start，在 mvn integration-test 阶段，进行 spring boot 应用生命周期的管理\n   * spring-boot:stop，在 mvn integration-test 阶段，进行 spring boot 应用生命周期的管理\n\n\n# 编写 rest 服务\n\n * 创建 package ，名为 io.github.zp.springboot.chapter1.web（根据项目情况修改）\n * 创建 hellocontroller 类，内容如下：\n\n@restcontroller\npublic class hellocontroller {\n\n    @requestmapping("/hello")\n    public string index() {\n        return "hello world";\n    }\n\n}\n\n\n * 启动主程序 xxxapplication，打开浏览器访问http://localhost:8080/hello ，可以看到页面输出hello world\n\n\n# 编写单元测试用例\n\n在 xxxapplicationtests 类中编写一个简单的单元测试来模拟 http 请求，具体如下：\n\n@runwith(springjunit4classrunner.class)\n@springapplicationconfiguration(classes = mockservletcontext.class)\n@webappconfiguration\npublic class springboothelloworldapplicationtest {\n\n\tprivate mockmvc mvc;\n\n\t@before\n\tpublic void setup() {\n\t\tmvc = mockmvcbuilders.standalonesetup(new hellocontroller()).build();\n\t}\n\n\t@test\n\tpublic void gethello() throws exception {\n\t\tmvc.perform(mockmvcrequestbuilders.get("/hello").accept(mediatype.application_json))\n\t\t\t\t.andexpect(status().isok())\n\t\t\t\t.andexpect(content().string(equalto("hello world")));\n\t}\n\n}\n\n\n使用mockservletcontext来构建一个空的webapplicationcontext，这样我们创建的hellocontroller就可以在@before函数中创建并传递到mockmvcbuilders.standalonesetup（）函数中。\n\n * 注意引入下面内容，让status、content、equalto函数可用\n\nimport static org.hamcrest.matchers.equalto;\nimport static org.springframework.test.web.servlet.result.mockmvcresultmatchers.content;\nimport static org.springframework.test.web.servlet.result.mockmvcresultmatchers.status;\n\n\n至此已完成目标，通过 maven 构建了一个空白 spring boot 项目，再通过引入 web 模块实现了一个简单的请求处理。\n\n\n# 示例源码\n\n> 示例源码：spring-boot-web-helloworld\n\n\n# 参考资料\n\n * spring boot 官方文档之 getting started',charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"SpringBoot 之属性加载详解",frontmatter:{title:"SpringBoot 之属性加载详解",date:"2019-01-10T11:55:54.000Z",order:32,categories:["Java","框架","Spring","Spring核心"],tags:["Java","框架","Spring","SpringBoot"],permalink:"/pages/0fb992/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/01.Spring%E6%A0%B8%E5%BF%83/32.SpringBoot%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A0%E8%BD%BD.html",relativePath:"01.Java/13.框架/01.Spring/01.Spring核心/32.SpringBoot之属性加载.md",key:"v-50b7250c",path:"/pages/0fb992/",headers:[{level:2,title:"加载 property 顺序",slug:"加载-property-顺序",normalizedTitle:"加载 property 顺序",charIndex:25},{level:2,title:"随机属性",slug:"随机属性",normalizedTitle:"随机属性",charIndex:839},{level:2,title:"命令行属性",slug:"命令行属性",normalizedTitle:"命令行属性",charIndex:1080},{level:2,title:"Application 属性文件",slug:"application-属性文件",normalizedTitle:"application 属性文件",charIndex:1267},{level:2,title:"Profile 特定属性",slug:"profile-特定属性",normalizedTitle:"profile 特定属性",charIndex:1837},{level:2,title:"属性中的占位符",slug:"属性中的占位符",normalizedTitle:"属性中的占位符",charIndex:2026},{level:2,title:"YAML 属性",slug:"yaml-属性",normalizedTitle:"yaml 属性",charIndex:2262},{level:3,title:"访问属性",slug:"访问属性",normalizedTitle:"访问属性",charIndex:2889},{level:3,title:"多 profile 配置",slug:"多-profile-配置",normalizedTitle:"多 profile 配置",charIndex:3036},{level:3,title:"YAML 的缺点",slug:"yaml-的缺点",normalizedTitle:"yaml 的缺点",charIndex:3234},{level:2,title:"属性前缀",slug:"属性前缀",normalizedTitle:"属性前缀",charIndex:3323},{level:2,title:"属性松散绑定规则",slug:"属性松散绑定规则",normalizedTitle:"属性松散绑定规则",charIndex:4709},{level:2,title:"属性转换",slug:"属性转换",normalizedTitle:"属性转换",charIndex:4969},{level:3,title:"时间单位转换",slug:"时间单位转换",normalizedTitle:"时间单位转换",charIndex:5158},{level:3,title:"数据大小转换",slug:"数据大小转换",normalizedTitle:"数据大小转换",charIndex:5978},{level:2,title:"校验属性",slug:"校验属性",normalizedTitle:"校验属性",charIndex:6650},{level:2,title:"示例源码",slug:"示例源码",normalizedTitle:"示例源码",charIndex:7071},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:7109}],headersStr:"加载 property 顺序 随机属性 命令行属性 Application 属性文件 Profile 特定属性 属性中的占位符 YAML 属性 访问属性 多 profile 配置 YAML 的缺点 属性前缀 属性松散绑定规则 属性转换 时间单位转换 数据大小转换 校验属性 示例源码 参考资料",content:'# SpringBoot 之属性加载详解\n\n\n# 加载 property 顺序\n\nSpring Boot 加载 property 顺序如下：\n\n 1.  Devtools 全局配置 (当 devtools 被激活 ~/.spring-boot-devtools.properties).\n 2.  测试环境中的 @TestPropertySource 注解配置\n 3.  测试环境中的属性 properties：@SpringBootTest 和 测试注解.\n 4.  命令行参数\n 5.  SPRING_APPLICATION_JSON 属性\n 6.  ServletConfig 初始化参数\n 7.  ServletContext 初始化参数\n 8.  JNDI attributes from 通过 java:comp/env 配置的 JNDI 属性\n 9.  Java 系统属性 (System.getProperties())\n 10. 操作系统环境比那里\n 11. RandomValuePropertySource 加载 random.* 形式的属性\n 12. jar 包外的 application-{profile}.properties 或 application-{profile}.yml 配置\n 13. jar 包内的 application-{profile}.properties 或 application-{profile}.yml 配置\n 14. jar 包外的 application.properties 或 application.yml 配置\n 15. jar 包内的 application.properties 或 application.yml 配置\n 16. @PropertySource 绑定的配置\n 17. 默认属性 (通过 SpringApplication.setDefaultProperties 指定)\n\n\n# 随机属性\n\nRandomValuePropertySource 类用于配置随机值。\n\n示例：\n\nmy.secret=${random.value}\nmy.number=${random.int}\nmy.bignumber=${random.long}\nmy.uuid=${random.uuid}\nmy.number.less.than.ten=${random.int(10)}\nmy.number.in.range=${random.int[1024,65536]}\n\n\n\n# 命令行属性\n\n默认情况下， SpringApplication 会获取 -- 参数（例如 --server.port=9000 ），并将这个 property 添加到 Spring 的 Environment 中。\n\n如果不想加载命令行属性，可以通过 SpringApplication.setAddCommandLineProperties(false) 禁用。\n\n\n# Application 属性文件\n\nSpringApplication 会自动加载以下路径下的 application.properties 配置文件，将其中的属性读到 Spring 的 Environment 中。\n\n 1. 当前目录的 /config 子目录\n 2. 当前目录\n 3. classpath 路径下的 /config package\n 4. classpath 根路径\n\n> 注：\n> \n> 以上列表的配置文件会根据顺序，后序的配置会覆盖前序的配置。\n> \n> 你可以选择 YAML(yml) 配置文件替换 properties 配置文件。\n\n如果不喜欢 application.properties 作为配置文件名，可以使用 spring.config.name 环境变量替换：\n\n$ java -jar myproject.jar --spring.config.name=myproject\n\n\n可以使用 spring.config.location 环境变量指定配置文件路径：\n\n$ java -jar myproject.jar --spring.config.location=classpath:/default.properties,classpath:/override.properties\n\n\n\n# Profile 特定属性\n\n如果定义 application-{profile}.properties 形式的配置文件，将被视为 profile 环境下的特定配置。\n\n可以通过 spring.profiles.active 参数来激活 profile，如果没有激活的 profile,默认会加载 application-default.properties 中的配置。\n\n\n# 属性中的占位符\n\napplication.properties 中的值会被 Environment 过滤，所以，可以引用之前定义的属性。\n\napp.name=MyApp\napp.description=${app.name} is a Spring Boot application\n\n\n> 注：你可以使用此技术来创建 Spring Boot 属性变量。请参考： Section 77.4, “Use ‘Short’ Command Line Arguments\n\n\n# YAML 属性\n\nSpring 框架有两个类支持加载 YAML 文件。\n\n * YamlPropertiesFactoryBean 将 YAML 文件的配置加载为 Properties 。\n * YamlMapFactoryBean 将 YAML 文件的配置加载为 Map 。\n\n示例 1\n\nenvironments:\n\tdev:\n\t\turl: http://dev.example.com\n\t\tname: Developer Setup\n\tprod:\n\t\turl: http://another.example.com\n\t\tname: My Cool App\n\n\n等价于：\n\nenvironments.dev.url=http://dev.example.com\nenvironments.dev.name=Developer Setup\nenvironments.prod.url=http://another.example.com\nenvironments.prod.name=My Cool App\n\n\nYAML 支持列表形式，等价于 property 中的 [index] ：\n\nmy:\nservers:\n\t- dev.example.com\n\t- another.example.com\n\n\n等价于\n\nmy.servers[0]=dev.example.com\nmy.servers[1]=another.example.com\n\n\n\n# 访问属性\n\nYamlPropertySourceLoader 类会将 YAML 配置转化为 Spring Environment 类中的 PropertySource 。然后，你可以如同 properties 文件中的属性一样，使用 @Value 注解来访问 YAML 中配置的属性。\n\n\n# 多 profile 配置\n\nserver:\n  address: 192.168.1.100\n---\nspring:\n  profiles: development\nserver:\n  address: 127.0.0.1\n---\nspring:\n  profiles: production & eu-central\nserver:\n  address: 192.168.1.120\n\n\n\n# YAML 的缺点\n\n注：YAML 注解中的属性不能通过 @PropertySource 注解来访问。所以，如果你的项目中使用了一些自定义属性文件，建议不要用 YAML。\n\n\n# 属性前缀\n\npackage com.example;\n\nimport java.net.InetAddress;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\nimport org.springframework.boot.context.properties.ConfigurationProperties;\n\n@ConfigurationProperties(prefix="acme")\npublic class AcmeProperties {\n\n\tprivate boolean enabled;\n\n\tprivate InetAddress remoteAddress;\n\n\tprivate final Security security = new Security();\n\n\tpublic boolean isEnabled() { ... }\n\n\tpublic void setEnabled(boolean enabled) { ... }\n\n\tpublic InetAddress getRemoteAddress() { ... }\n\n\tpublic void setRemoteAddress(InetAddress remoteAddress) { ... }\n\n\tpublic Security getSecurity() { ... }\n\n\tpublic static class Security {\n\n\t\tprivate String username;\n\n\t\tprivate String password;\n\n\t\tprivate List<String> roles = new ArrayList<>(Collections.singleton("USER"));\n\n\t\tpublic String getUsername() { ... }\n\n\t\tpublic void setUsername(String username) { ... }\n\n\t\tpublic String getPassword() { ... }\n\n\t\tpublic void setPassword(String password) { ... }\n\n\t\tpublic List<String> getRoles() { ... }\n\n\t\tpublic void setRoles(List<String> roles) { ... }\n\n\t}\n}\n\n\n相当于支持配置以下属性：\n\n * acme.enabled\n * acme.remote-address\n * acme.security.username\n * acme.security.password\n * acme.security.roles\n\n然后，你需要使用 @EnableConfigurationProperties 注解将属性类注入配置类中。\n\n@Configuration\n@EnableConfigurationProperties(AcmeProperties.class)\npublic class MyConfiguration {\n}\n\n\n\n# 属性松散绑定规则\n\nSpring Boot 属性名绑定比较松散。\n\n以下属性 key 都是等价的：\n\nPROPERTY                            NOTE\nacme.my-project.person.first-name   - 分隔\nacme.myProject.person.firstName     驼峰命名\nacme.my_project.person.first_name   _ 分隔\nACME_MYPROJECT_PERSON_FIRSTNAME     大写字母\n\n\n# 属性转换\n\n如果需要类型转换，你可以提供一个 ConversionService bean (一个名叫 conversionService 的 bean) 或自定义属性配置 (一个 CustomEditorConfigurer bean) 或自定义的 Converters (被 @ConfigurationPropertiesBinding 注解修饰的 bena)。\n\n\n# 时间单位转换\n\nSpring 使用 java.time.Duration 类代表时间大小，以下场景适用：\n\n * 除非指定 @DurationUnit ，否则一个 long 代表的时间为毫秒。\n * ISO-8601 标准格式（ java.time.Duration 的实现就是参照此标准）\n * 你也可以使用以下支持的单位：\n   * ns - 纳秒\n   * us - 微秒\n   * ms - 毫秒\n   * s - 秒\n   * m - 分\n   * h - 时\n   * d - 天\n\n示例：\n\n@ConfigurationProperties("app.system")\npublic class AppSystemProperties {\n\n\t@DurationUnit(ChronoUnit.SECONDS)\n\tprivate Duration sessionTimeout = Duration.ofSeconds(30);\n\n\tprivate Duration readTimeout = Duration.ofMillis(1000);\n\n\tpublic Duration getSessionTimeout() {\n\t\treturn this.sessionTimeout;\n\t}\n\n\tpublic void setSessionTimeout(Duration sessionTimeout) {\n\t\tthis.sessionTimeout = sessionTimeout;\n\t}\n\n\tpublic Duration getReadTimeout() {\n\t\treturn this.readTimeout;\n\t}\n\n\tpublic void setReadTimeout(Duration readTimeout) {\n\t\tthis.readTimeout = readTimeout;\n\t}\n\n}\n\n\n\n# 数据大小转换\n\nSpring 使用 DataSize 类代表数据大小，以下场景适用：\n\n * long 值（默认视为 byte）\n * 你也可以使用以下支持的单位：\n   * B\n   * KB\n   * MB\n   * GB\n   * TB\n\n示例：\n\n@ConfigurationProperties("app.io")\npublic class AppIoProperties {\n\n\t@DataSizeUnit(DataUnit.MEGABYTES)\n\tprivate DataSize bufferSize = DataSize.ofMegabytes(2);\n\n\tprivate DataSize sizeThreshold = DataSize.ofBytes(512);\n\n\tpublic DataSize getBufferSize() {\n\t\treturn this.bufferSize;\n\t}\n\n\tpublic void setBufferSize(DataSize bufferSize) {\n\t\tthis.bufferSize = bufferSize;\n\t}\n\n\tpublic DataSize getSizeThreshold() {\n\t\treturn this.sizeThreshold;\n\t}\n\n\tpublic void setSizeThreshold(DataSize sizeThreshold) {\n\t\tthis.sizeThreshold = sizeThreshold;\n\t}\n\n}\n\n\n\n# 校验属性\n\n@ConfigurationProperties(prefix="acme")\n@Validated\npublic class AcmeProperties {\n\n\t@NotNull\n\tprivate InetAddress remoteAddress;\n\n\t@Valid\n\tprivate final Security security = new Security();\n\n\t// ... getters and setters\n\n\tpublic static class Security {\n\n\t\t@NotEmpty\n\t\tpublic String username;\n\n\t\t// ... getters and setters\n\n\t}\n\n}\n\n\n你也可以自定义一个名为 configurationPropertiesValidator 的校验器 Bean。获取这个 @Bean 的方法必须声明为 static。\n\n\n# 示例源码\n\n> 示例源码：spring-boot-property\n\n\n# 参考资料\n\n * Spring Boot 官方文档之 boot-features-external-config',normalizedContent:'# springboot 之属性加载详解\n\n\n# 加载 property 顺序\n\nspring boot 加载 property 顺序如下：\n\n 1.  devtools 全局配置 (当 devtools 被激活 ~/.spring-boot-devtools.properties).\n 2.  测试环境中的 @testpropertysource 注解配置\n 3.  测试环境中的属性 properties：@springboottest 和 测试注解.\n 4.  命令行参数\n 5.  spring_application_json 属性\n 6.  servletconfig 初始化参数\n 7.  servletcontext 初始化参数\n 8.  jndi attributes from 通过 java:comp/env 配置的 jndi 属性\n 9.  java 系统属性 (system.getproperties())\n 10. 操作系统环境比那里\n 11. randomvaluepropertysource 加载 random.* 形式的属性\n 12. jar 包外的 application-{profile}.properties 或 application-{profile}.yml 配置\n 13. jar 包内的 application-{profile}.properties 或 application-{profile}.yml 配置\n 14. jar 包外的 application.properties 或 application.yml 配置\n 15. jar 包内的 application.properties 或 application.yml 配置\n 16. @propertysource 绑定的配置\n 17. 默认属性 (通过 springapplication.setdefaultproperties 指定)\n\n\n# 随机属性\n\nrandomvaluepropertysource 类用于配置随机值。\n\n示例：\n\nmy.secret=${random.value}\nmy.number=${random.int}\nmy.bignumber=${random.long}\nmy.uuid=${random.uuid}\nmy.number.less.than.ten=${random.int(10)}\nmy.number.in.range=${random.int[1024,65536]}\n\n\n\n# 命令行属性\n\n默认情况下， springapplication 会获取 -- 参数（例如 --server.port=9000 ），并将这个 property 添加到 spring 的 environment 中。\n\n如果不想加载命令行属性，可以通过 springapplication.setaddcommandlineproperties(false) 禁用。\n\n\n# application 属性文件\n\nspringapplication 会自动加载以下路径下的 application.properties 配置文件，将其中的属性读到 spring 的 environment 中。\n\n 1. 当前目录的 /config 子目录\n 2. 当前目录\n 3. classpath 路径下的 /config package\n 4. classpath 根路径\n\n> 注：\n> \n> 以上列表的配置文件会根据顺序，后序的配置会覆盖前序的配置。\n> \n> 你可以选择 yaml(yml) 配置文件替换 properties 配置文件。\n\n如果不喜欢 application.properties 作为配置文件名，可以使用 spring.config.name 环境变量替换：\n\n$ java -jar myproject.jar --spring.config.name=myproject\n\n\n可以使用 spring.config.location 环境变量指定配置文件路径：\n\n$ java -jar myproject.jar --spring.config.location=classpath:/default.properties,classpath:/override.properties\n\n\n\n# profile 特定属性\n\n如果定义 application-{profile}.properties 形式的配置文件，将被视为 profile 环境下的特定配置。\n\n可以通过 spring.profiles.active 参数来激活 profile，如果没有激活的 profile,默认会加载 application-default.properties 中的配置。\n\n\n# 属性中的占位符\n\napplication.properties 中的值会被 environment 过滤，所以，可以引用之前定义的属性。\n\napp.name=myapp\napp.description=${app.name} is a spring boot application\n\n\n> 注：你可以使用此技术来创建 spring boot 属性变量。请参考： section 77.4, “use ‘short’ command line arguments\n\n\n# yaml 属性\n\nspring 框架有两个类支持加载 yaml 文件。\n\n * yamlpropertiesfactorybean 将 yaml 文件的配置加载为 properties 。\n * yamlmapfactorybean 将 yaml 文件的配置加载为 map 。\n\n示例 1\n\nenvironments:\n\tdev:\n\t\turl: http://dev.example.com\n\t\tname: developer setup\n\tprod:\n\t\turl: http://another.example.com\n\t\tname: my cool app\n\n\n等价于：\n\nenvironments.dev.url=http://dev.example.com\nenvironments.dev.name=developer setup\nenvironments.prod.url=http://another.example.com\nenvironments.prod.name=my cool app\n\n\nyaml 支持列表形式，等价于 property 中的 [index] ：\n\nmy:\nservers:\n\t- dev.example.com\n\t- another.example.com\n\n\n等价于\n\nmy.servers[0]=dev.example.com\nmy.servers[1]=another.example.com\n\n\n\n# 访问属性\n\nyamlpropertysourceloader 类会将 yaml 配置转化为 spring environment 类中的 propertysource 。然后，你可以如同 properties 文件中的属性一样，使用 @value 注解来访问 yaml 中配置的属性。\n\n\n# 多 profile 配置\n\nserver:\n  address: 192.168.1.100\n---\nspring:\n  profiles: development\nserver:\n  address: 127.0.0.1\n---\nspring:\n  profiles: production & eu-central\nserver:\n  address: 192.168.1.120\n\n\n\n# yaml 的缺点\n\n注：yaml 注解中的属性不能通过 @propertysource 注解来访问。所以，如果你的项目中使用了一些自定义属性文件，建议不要用 yaml。\n\n\n# 属性前缀\n\npackage com.example;\n\nimport java.net.inetaddress;\nimport java.util.arraylist;\nimport java.util.collections;\nimport java.util.list;\n\nimport org.springframework.boot.context.properties.configurationproperties;\n\n@configurationproperties(prefix="acme")\npublic class acmeproperties {\n\n\tprivate boolean enabled;\n\n\tprivate inetaddress remoteaddress;\n\n\tprivate final security security = new security();\n\n\tpublic boolean isenabled() { ... }\n\n\tpublic void setenabled(boolean enabled) { ... }\n\n\tpublic inetaddress getremoteaddress() { ... }\n\n\tpublic void setremoteaddress(inetaddress remoteaddress) { ... }\n\n\tpublic security getsecurity() { ... }\n\n\tpublic static class security {\n\n\t\tprivate string username;\n\n\t\tprivate string password;\n\n\t\tprivate list<string> roles = new arraylist<>(collections.singleton("user"));\n\n\t\tpublic string getusername() { ... }\n\n\t\tpublic void setusername(string username) { ... }\n\n\t\tpublic string getpassword() { ... }\n\n\t\tpublic void setpassword(string password) { ... }\n\n\t\tpublic list<string> getroles() { ... }\n\n\t\tpublic void setroles(list<string> roles) { ... }\n\n\t}\n}\n\n\n相当于支持配置以下属性：\n\n * acme.enabled\n * acme.remote-address\n * acme.security.username\n * acme.security.password\n * acme.security.roles\n\n然后，你需要使用 @enableconfigurationproperties 注解将属性类注入配置类中。\n\n@configuration\n@enableconfigurationproperties(acmeproperties.class)\npublic class myconfiguration {\n}\n\n\n\n# 属性松散绑定规则\n\nspring boot 属性名绑定比较松散。\n\n以下属性 key 都是等价的：\n\nproperty                            note\nacme.my-project.person.first-name   - 分隔\nacme.myproject.person.firstname     驼峰命名\nacme.my_project.person.first_name   _ 分隔\nacme_myproject_person_firstname     大写字母\n\n\n# 属性转换\n\n如果需要类型转换，你可以提供一个 conversionservice bean (一个名叫 conversionservice 的 bean) 或自定义属性配置 (一个 customeditorconfigurer bean) 或自定义的 converters (被 @configurationpropertiesbinding 注解修饰的 bena)。\n\n\n# 时间单位转换\n\nspring 使用 java.time.duration 类代表时间大小，以下场景适用：\n\n * 除非指定 @durationunit ，否则一个 long 代表的时间为毫秒。\n * iso-8601 标准格式（ java.time.duration 的实现就是参照此标准）\n * 你也可以使用以下支持的单位：\n   * ns - 纳秒\n   * us - 微秒\n   * ms - 毫秒\n   * s - 秒\n   * m - 分\n   * h - 时\n   * d - 天\n\n示例：\n\n@configurationproperties("app.system")\npublic class appsystemproperties {\n\n\t@durationunit(chronounit.seconds)\n\tprivate duration sessiontimeout = duration.ofseconds(30);\n\n\tprivate duration readtimeout = duration.ofmillis(1000);\n\n\tpublic duration getsessiontimeout() {\n\t\treturn this.sessiontimeout;\n\t}\n\n\tpublic void setsessiontimeout(duration sessiontimeout) {\n\t\tthis.sessiontimeout = sessiontimeout;\n\t}\n\n\tpublic duration getreadtimeout() {\n\t\treturn this.readtimeout;\n\t}\n\n\tpublic void setreadtimeout(duration readtimeout) {\n\t\tthis.readtimeout = readtimeout;\n\t}\n\n}\n\n\n\n# 数据大小转换\n\nspring 使用 datasize 类代表数据大小，以下场景适用：\n\n * long 值（默认视为 byte）\n * 你也可以使用以下支持的单位：\n   * b\n   * kb\n   * mb\n   * gb\n   * tb\n\n示例：\n\n@configurationproperties("app.io")\npublic class appioproperties {\n\n\t@datasizeunit(dataunit.megabytes)\n\tprivate datasize buffersize = datasize.ofmegabytes(2);\n\n\tprivate datasize sizethreshold = datasize.ofbytes(512);\n\n\tpublic datasize getbuffersize() {\n\t\treturn this.buffersize;\n\t}\n\n\tpublic void setbuffersize(datasize buffersize) {\n\t\tthis.buffersize = buffersize;\n\t}\n\n\tpublic datasize getsizethreshold() {\n\t\treturn this.sizethreshold;\n\t}\n\n\tpublic void setsizethreshold(datasize sizethreshold) {\n\t\tthis.sizethreshold = sizethreshold;\n\t}\n\n}\n\n\n\n# 校验属性\n\n@configurationproperties(prefix="acme")\n@validated\npublic class acmeproperties {\n\n\t@notnull\n\tprivate inetaddress remoteaddress;\n\n\t@valid\n\tprivate final security security = new security();\n\n\t// ... getters and setters\n\n\tpublic static class security {\n\n\t\t@notempty\n\t\tpublic string username;\n\n\t\t// ... getters and setters\n\n\t}\n\n}\n\n\n你也可以自定义一个名为 configurationpropertiesvalidator 的校验器 bean。获取这个 @bean 的方法必须声明为 static。\n\n\n# 示例源码\n\n> 示例源码：spring-boot-property\n\n\n# 参考资料\n\n * spring boot 官方文档之 boot-features-external-config',charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"SpringBoot 之 Profile",frontmatter:{title:"SpringBoot 之 Profile",date:"2019-11-18T14:55:01.000Z",order:33,categories:["Java","框架","Spring","Spring核心"],tags:["Java","框架","Spring","SpringBoot"],permalink:"/pages/cb598e/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/01.Spring%E6%A0%B8%E5%BF%83/33.SpringBoot%E4%B9%8BProfile.html",relativePath:"01.Java/13.框架/01.Spring/01.Spring核心/33.SpringBoot之Profile.md",key:"v-10fbaa3f",path:"/pages/cb598e/",headers:[{level:2,title:"区分环境的配置",slug:"区分环境的配置",normalizedTitle:"区分环境的配置",charIndex:129},{level:3,title:"properties 配置",slug:"properties-配置",normalizedTitle:"properties 配置",charIndex:141},{level:3,title:"yml 配置",slug:"yml-配置",normalizedTitle:"yml 配置",charIndex:441},{level:2,title:"区分环境的代码",slug:"区分环境的代码",normalizedTitle:"区分环境的代码",charIndex:1110},{level:3,title:"修饰类",slug:"修饰类",normalizedTitle:"修饰类",charIndex:1164},{level:3,title:"修饰注解",slug:"修饰注解",normalizedTitle:"修饰注解",charIndex:1450},{level:3,title:"修饰方法",slug:"修饰方法",normalizedTitle:"修饰方法",charIndex:1579},{level:2,title:"激活 profile",slug:"激活-profile",normalizedTitle:"激活 profile",charIndex:393},{level:3,title:"插件激活 profile",slug:"插件激活-profile",normalizedTitle:"插件激活 profile",charIndex:2238},{level:3,title:"main 方法激活 profile",slug:"main-方法激活-profile",normalizedTitle:"main 方法激活 profile",charIndex:2293},{level:3,title:"jar 激活 profile",slug:"jar-激活-profile",normalizedTitle:"jar 激活 profile",charIndex:2347},{level:3,title:"在 Java 代码中激活 profile",slug:"在-java-代码中激活-profile",normalizedTitle:"在 java 代码中激活 profile",charIndex:2414},{level:2,title:"示例源码",slug:"示例源码",normalizedTitle:"示例源码",charIndex:2779},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:2816}],headersStr:"区分环境的配置 properties 配置 yml 配置 区分环境的代码 修饰类 修饰注解 修饰方法 激活 profile 插件激活 profile main 方法激活 profile jar 激活 profile 在 Java 代码中激活 profile 示例源码 参考资料",content:'# SpringBoot 之 Profile\n\n> 一个应用为了在不同的环境下工作，常常会有不同的配置，代码逻辑处理。Spring Boot 对此提供了简便的支持。\n> \n> 关键词： @Profile、spring.profiles.active\n\n\n# 区分环境的配置\n\n\n# properties 配置\n\n假设，一个应用的工作环境有：dev、test、prod\n\n那么，我们可以添加 4 个配置文件：\n\n * applcation.properties - 公共配置\n * application-dev.properties - 开发环境配置\n * application-test.properties - 测试环境配置\n * application-prod.properties - 生产环境配置\n\n在 applcation.properties 文件中可以通过以下配置来激活 profile：\n\nspring.profiles.active = test\n\n\n\n# yml 配置\n\n与 properties 文件类似，我们也可以添加 4 个配置文件：\n\n * applcation.yml - 公共配置\n * application-dev.yml - 开发环境配置\n * application-test.yml - 测试环境配置\n * application-prod.yml - 生产环境配置\n\n在 applcation.yml 文件中可以通过以下配置来激活 profile：\n\nspring:\n  profiles:\n    active: prod\n\n\n此外，yml 文件也可以在一个文件中完成所有 profile 的配置：\n\n# 激活 prod\nspring:\n  profiles:\n    active: prod\n# 也可以同时激活多个 profile\n# spring.profiles.active: prod,proddb,prodlog\n---\n# dev 配置\nspring:\n  profiles: dev\n\n# 略去配置\n\n---\nspring:\n  profiles: test\n\n# 略去配置\n\n---\nspring.profiles: prod\nspring.profiles.include:\n  - proddb\n  - prodlog\n\n---\nspring:\n  profiles: proddb\n\n# 略去配置\n\n---\nspring:\n  profiles: prodlog\n# 略去配置\n\n\n注意：不同 profile 之间通过 --- 分割\n\n\n# 区分环境的代码\n\n使用 @Profile 注解可以指定类或方法在特定的 Profile 环境生效。\n\n\n# 修饰类\n\n@Configuration\n@Profile("production")\npublic class JndiDataConfig {\n\n    @Bean(destroyMethod="")\n    public DataSource dataSource() throws Exception {\n        Context ctx = new InitialContext();\n        return (DataSource) ctx.lookup("java:comp/env/jdbc/datasource");\n    }\n}\n\n\n\n# 修饰注解\n\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Profile("production")\npublic @interface Production {\n}\n\n\n\n# 修饰方法\n\n@Configuration\npublic class AppConfig {\n\n    @Bean("dataSource")\n    @Profile("development")\n    public DataSource standaloneDataSource() {\n        return new EmbeddedDatabaseBuilder()\n            .setType(EmbeddedDatabaseType.HSQL)\n            .addScript("classpath:com/bank/config/sql/schema.sql")\n            .addScript("classpath:com/bank/config/sql/test-data.sql")\n            .build();\n    }\n\n    @Bean("dataSource")\n    @Profile("production")\n    public DataSource jndiDataSource() throws Exception {\n        Context ctx = new InitialContext();\n        return (DataSource) ctx.lookup("java:comp/env/jdbc/datasource");\n    }\n}\n\n\n\n# 激活 profile\n\n\n# 插件激活 profile\n\nspring-boot:run -Drun.profiles=prod\n\n\n\n# main 方法激活 profile\n\n--spring.profiles.active=prod\n\n\n\n# jar 激活 profile\n\njava -jar -Dspring.profiles.active=prod *.jar\n\n\n\n# 在 Java 代码中激活 profile\n\n直接指定环境变量来激活 profile：\n\nSystem.setProperty("spring.profiles.active", "test");\n\n\n在 Spring 容器中激活 profile：\n\nAnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();\nctx.getEnvironment().setActiveProfiles("development");\nctx.register(SomeConfig.class, StandaloneDataConfig.class, JndiDataConfig.class);\nctx.refresh();\n\n\n\n# 示例源码\n\n> 示例源码：spring-boot-profile\n\n\n# 参考资料\n\n * Spring 官方文档之 Bean Definition Profiles\n * Spring Boot 官方文档之 boot-features-profiles',normalizedContent:'# springboot 之 profile\n\n> 一个应用为了在不同的环境下工作，常常会有不同的配置，代码逻辑处理。spring boot 对此提供了简便的支持。\n> \n> 关键词： @profile、spring.profiles.active\n\n\n# 区分环境的配置\n\n\n# properties 配置\n\n假设，一个应用的工作环境有：dev、test、prod\n\n那么，我们可以添加 4 个配置文件：\n\n * applcation.properties - 公共配置\n * application-dev.properties - 开发环境配置\n * application-test.properties - 测试环境配置\n * application-prod.properties - 生产环境配置\n\n在 applcation.properties 文件中可以通过以下配置来激活 profile：\n\nspring.profiles.active = test\n\n\n\n# yml 配置\n\n与 properties 文件类似，我们也可以添加 4 个配置文件：\n\n * applcation.yml - 公共配置\n * application-dev.yml - 开发环境配置\n * application-test.yml - 测试环境配置\n * application-prod.yml - 生产环境配置\n\n在 applcation.yml 文件中可以通过以下配置来激活 profile：\n\nspring:\n  profiles:\n    active: prod\n\n\n此外，yml 文件也可以在一个文件中完成所有 profile 的配置：\n\n# 激活 prod\nspring:\n  profiles:\n    active: prod\n# 也可以同时激活多个 profile\n# spring.profiles.active: prod,proddb,prodlog\n---\n# dev 配置\nspring:\n  profiles: dev\n\n# 略去配置\n\n---\nspring:\n  profiles: test\n\n# 略去配置\n\n---\nspring.profiles: prod\nspring.profiles.include:\n  - proddb\n  - prodlog\n\n---\nspring:\n  profiles: proddb\n\n# 略去配置\n\n---\nspring:\n  profiles: prodlog\n# 略去配置\n\n\n注意：不同 profile 之间通过 --- 分割\n\n\n# 区分环境的代码\n\n使用 @profile 注解可以指定类或方法在特定的 profile 环境生效。\n\n\n# 修饰类\n\n@configuration\n@profile("production")\npublic class jndidataconfig {\n\n    @bean(destroymethod="")\n    public datasource datasource() throws exception {\n        context ctx = new initialcontext();\n        return (datasource) ctx.lookup("java:comp/env/jdbc/datasource");\n    }\n}\n\n\n\n# 修饰注解\n\n@target(elementtype.type)\n@retention(retentionpolicy.runtime)\n@profile("production")\npublic @interface production {\n}\n\n\n\n# 修饰方法\n\n@configuration\npublic class appconfig {\n\n    @bean("datasource")\n    @profile("development")\n    public datasource standalonedatasource() {\n        return new embeddeddatabasebuilder()\n            .settype(embeddeddatabasetype.hsql)\n            .addscript("classpath:com/bank/config/sql/schema.sql")\n            .addscript("classpath:com/bank/config/sql/test-data.sql")\n            .build();\n    }\n\n    @bean("datasource")\n    @profile("production")\n    public datasource jndidatasource() throws exception {\n        context ctx = new initialcontext();\n        return (datasource) ctx.lookup("java:comp/env/jdbc/datasource");\n    }\n}\n\n\n\n# 激活 profile\n\n\n# 插件激活 profile\n\nspring-boot:run -drun.profiles=prod\n\n\n\n# main 方法激活 profile\n\n--spring.profiles.active=prod\n\n\n\n# jar 激活 profile\n\njava -jar -dspring.profiles.active=prod *.jar\n\n\n\n# 在 java 代码中激活 profile\n\n直接指定环境变量来激活 profile：\n\nsystem.setproperty("spring.profiles.active", "test");\n\n\n在 spring 容器中激活 profile：\n\nannotationconfigapplicationcontext ctx = new annotationconfigapplicationcontext();\nctx.getenvironment().setactiveprofiles("development");\nctx.register(someconfig.class, standalonedataconfig.class, jndidataconfig.class);\nctx.refresh();\n\n\n\n# 示例源码\n\n> 示例源码：spring-boot-profile\n\n\n# 参考资料\n\n * spring 官方文档之 bean definition profiles\n * spring boot 官方文档之 boot-features-profiles',charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Spring 核心",frontmatter:{title:"Spring 核心",date:"2020-02-26T23:47:47.000Z",categories:["Java","框架","Spring","Spring核心"],tags:["Java","框架","Spring","SpringBoot"],permalink:"/pages/5e7c20/",hidden:!0,index:!1},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/01.Spring%E6%A0%B8%E5%BF%83/",relativePath:"01.Java/13.框架/01.Spring/01.Spring核心/README.md",key:"v-7144da80",path:"/pages/5e7c20/",headers:[{level:2,title:"📖 内容",slug:"📖-内容",normalizedTitle:"📖 内容",charIndex:99},{level:2,title:"📚 资料",slug:"📚-资料",normalizedTitle:"📚 资料",charIndex:453},{level:2,title:"🚪 传送",slug:"🚪-传送",normalizedTitle:"🚪 传送",charIndex:632}],headersStr:"📖 内容 📚 资料 🚪 传送",content:"# Spring 核心\n\n> 章节主要针对：Spring & Spring Boot 框架的核心技术。如；Spring Bean、IoC、依赖查找、依赖注入、AOP、数据绑定、资源管理等。\n\n\n# 📖 内容\n\n * Spring Bean\n * Spring IoC\n * Spring 依赖查找\n * Spring 依赖注入\n * Spring IoC 依赖来源\n * Spring Bean 作用域\n * Spring Bean 生命周期\n * Spring 配置元数据\n * Spring AOP\n * Spring 资源管理\n * Spring 校验\n * Spring 数据绑定\n * Spring 类型转换\n * Spring EL 表达式\n * Spring 事件\n * Spring 国际化\n * Spring 泛型处理\n * Spring 注解\n * SpringBoot 教程之快速入门\n * SpringBoot 之属性加载\n * SpringBoot 之 Profile\n\n\n# 📚 资料\n\n * 官方\n   * Spring 官网\n   * Spring Framework 官方文档\n   * Spring Github\n * 书籍\n   * 《Spring In Action》\n * 教程\n   * 《小马哥讲 Spring 核心编程思想》\n   * geekbang-lessons\n   * 跟我学 Spring3\n\n\n# 🚪 传送\n\n◾ 💧 钝悟的 IT 知识图谱 ◾ 🎯 我的博客 ◾",normalizedContent:"# spring 核心\n\n> 章节主要针对：spring & spring boot 框架的核心技术。如；spring bean、ioc、依赖查找、依赖注入、aop、数据绑定、资源管理等。\n\n\n# 📖 内容\n\n * spring bean\n * spring ioc\n * spring 依赖查找\n * spring 依赖注入\n * spring ioc 依赖来源\n * spring bean 作用域\n * spring bean 生命周期\n * spring 配置元数据\n * spring aop\n * spring 资源管理\n * spring 校验\n * spring 数据绑定\n * spring 类型转换\n * spring el 表达式\n * spring 事件\n * spring 国际化\n * spring 泛型处理\n * spring 注解\n * springboot 教程之快速入门\n * springboot 之属性加载\n * springboot 之 profile\n\n\n# 📚 资料\n\n * 官方\n   * spring 官网\n   * spring framework 官方文档\n   * spring github\n * 书籍\n   * 《spring in action》\n * 教程\n   * 《小马哥讲 spring 核心编程思想》\n   * geekbang-lessons\n   * 跟我学 spring3\n\n\n# 🚪 传送\n\n◾ 💧 钝悟的 it 知识图谱 ◾ 🎯 我的博客 ◾",charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Spring 之数据源",frontmatter:{title:"Spring 之数据源",date:"2017-10-20T09:27:55.000Z",order:1,categories:["Java","框架","Spring","Spring数据"],tags:["Java","框架","Spring","SpringBoot","数据库","DataSource"],permalink:"/pages/1b774c/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/02.Spring%E6%95%B0%E6%8D%AE/01.Spring%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%BA%90.html",relativePath:"01.Java/13.框架/01.Spring/02.Spring数据/01.Spring之数据源.md",key:"v-6feaabf6",path:"/pages/1b774c/",headers:[{level:2,title:"Spring Boot 数据源基本配置",slug:"spring-boot-数据源基本配置",normalizedTitle:"spring boot 数据源基本配置",charIndex:48},{level:2,title:"Spring Boot 连接嵌入式数据源",slug:"spring-boot-连接嵌入式数据源",normalizedTitle:"spring boot 连接嵌入式数据源",charIndex:601},{level:2,title:"Spring Boot 连接池化数据源",slug:"spring-boot-连接池化数据源",normalizedTitle:"spring boot 连接池化数据源",charIndex:1467},{level:3,title:"引入 Spring Boot 依赖",slug:"引入-spring-boot-依赖",normalizedTitle:"引入 spring boot 依赖",charIndex:2883},{level:3,title:"测试单数据源连接",slug:"测试单数据源连接",normalizedTitle:"测试单数据源连接",charIndex:3238},{level:2,title:"Spring Boot 连接多数据源",slug:"spring-boot-连接多数据源",normalizedTitle:"spring boot 连接多数据源",charIndex:4696},{level:3,title:"多数据源配置",slug:"多数据源配置",normalizedTitle:"多数据源配置",charIndex:4986},{level:3,title:"测试多数据源连接",slug:"测试多数据源连接",normalizedTitle:"测试多数据源连接",charIndex:6930},{level:2,title:"Spring 之数据源",slug:"spring-之数据源-2",normalizedTitle:"spring 之数据源",charIndex:2},{level:3,title:"引入 Spring 依赖",slug:"引入-spring-依赖",normalizedTitle:"引入 spring 依赖",charIndex:10151},{level:3,title:"Spring 配置数据源",slug:"spring-配置数据源",normalizedTitle:"spring 配置数据源",charIndex:10948},{level:4,title:"使用 JNDI 数据源",slug:"使用-jndi-数据源",normalizedTitle:"使用 jndi 数据源",charIndex:10991},{level:4,title:"使用数据库连接池",slug:"使用数据库连接池",normalizedTitle:"使用数据库连接池",charIndex:11868},{level:4,title:"基于 JDBC 驱动的数据源",slug:"基于-jdbc-驱动的数据源",normalizedTitle:"基于 jdbc 驱动的数据源",charIndex:13361},{level:2,title:"SpringBoot 数据源配置",slug:"springboot-数据源配置",normalizedTitle:"springboot 数据源配置",charIndex:13696},{level:2,title:"DataSourceAutoConfiguration 类",slug:"datasourceautoconfiguration-类",normalizedTitle:"datasourceautoconfiguration 类",charIndex:4934},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:17118}],headersStr:"Spring Boot 数据源基本配置 Spring Boot 连接嵌入式数据源 Spring Boot 连接池化数据源 引入 Spring Boot 依赖 测试单数据源连接 Spring Boot 连接多数据源 多数据源配置 测试多数据源连接 Spring 之数据源 引入 Spring 依赖 Spring 配置数据源 使用 JNDI 数据源 使用数据库连接池 基于 JDBC 驱动的数据源 SpringBoot 数据源配置 DataSourceAutoConfiguration 类 参考资料",content:'# Spring 之数据源\n\n> 本文基于 Spring Boot 2.7.3 版本。\n\n\n# Spring Boot 数据源基本配置\n\nSpring Boot 提供了一系列 spring.datasource.* 配置来控制 DataSource 的配置。用户可以在 application.properties 或 application.yml 文件中指定数据源配置。这些配置项维护在 DataSourceProperties 。\n\n下面是一个最基本的 mysql 数据源配置示例（都是必填项）：\n\n# 数据库访问地址\nspring.datasource.url = jdbc:mysql://localhost:3306/spring_tutorial?serverTimezone=UTC&useUnicode=true&characterEncoding=utf8\n# 数据库驱动类，必须保证驱动类是可加载的\nspring.datasource.driver-class-name = com.mysql.cj.jdbc.Driver\n# 数据库账号\nspring.datasource.username = root\n# 数据库账号密码\nspring.datasource.password = root\n\n\n需要根据实际情况，替换 url、username、password。\n\n\n# Spring Boot 连接嵌入式数据源\n\n使用内存嵌入式数据库开发应用程序通常很方便。显然，内存数据库不提供持久存储。使用者需要在应用程序启动时填充数据库，并准备在应用程序结束时丢弃数据。\n\nSpring Boot 可以自动配置嵌入式数据库 H2、HSQL 和 Derby。使用者无需提供任何连接 URL，只需要包含对要使用的嵌入式数据库的构建依赖项。如果类路径上有多个嵌入式数据库，需要设置 spring.datasource.embedded-database-connection 配置属性来控制使用哪一个。将该属性设置为 none 会禁用嵌入式数据库的自动配置。\n\n> 注意：如果在测试中使用此功能，无论使用多少应用程序上下文，整个测试套件都会重用同一个数据库。如果要确保每个上下文都有一个单独的嵌入式数据库，则应将 spring.datasource.generate-unique-name 设置为 true。\n\n下面，通过一个实例展示如何连接 H2 嵌入式数据库。\n\n（1）在 pom.xml 中引入所需要的依赖：\n\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-data-jdbc</artifactId>\n</dependency>\n<dependency>\n  <groupId>com.h2database</groupId>\n  <artifactId>h2</artifactId>\n</dependency>\n\n\n（2）数据源配置\n\nspring.datasource.jdbc-url = jdbc:h2:mem:test\nspring.datasource.driver-class-name = org.h2.Driver\nspring.datasource.username = sa\nspring.datasource.password =\n\n\n\n# Spring Boot 连接池化数据源\n\n> 完整示例：spring-boot-data-jdbc\n\n在生产环境中，出于性能考虑，一般会通过数据库连接池连接数据源。\n\n除了 DataSourceProperties 中的数据源通用配置以外，Spring Boot 还支持通过使用类似spring.datasource.hikari.*、spring.datasource.tomcat.*、spring.datasource.dbcp2.* 和 spring.datasource.oracleucp.* 的前缀来配置指定的数据库连接池属性。\n\n下面，就是一份 hikari 的连接池配置示例：\n\n# 连接池名称\nspring.datasource.hikari.pool-name = SpringTutorialHikariPool\n# 最大连接数，小于等于 0 会被重置为默认值 10；大于零小于 1 会被重置为 minimum-idle 的值\nspring.datasource.hikari.maximum-pool-size = 10\n# 最小空闲连接，默认值10，小于 0 或大于 maximum-pool-size，都会重置为 maximum-pool-size\nspring.datasource.hikari.minimum-idle = 10\n# 连接超时时间（单位：毫秒），小于 250 毫秒，会被重置为默认值 30 秒\nspring.datasource.hikari.connection-timeout = 60000\n# 空闲连接超时时间，默认值 600000（10分钟），大于等于 max-lifetime 且 max-lifetime>0，会被重置为0；不等于 0 且小于 10 秒，会被重置为 10 秒\n# 只有空闲连接数大于最大连接数且空闲时间超过该值，才会被释放\nspring.datasource.hikari.idle-timeout = 600000\n# 连接最大存活时间，不等于 0 且小于 30 秒，会被重置为默认值 30 分钟。该值应该比数据库所设置的超时时间短\nspring.datasource.hikari.max-lifetime = 540000\n\n\nSpring Boot 会按以下顺序检测连接池是否可用，如果可用就选择对应的池化 DataSource：\n\nHikariCP -> Tomcat pooling DataSource -> DBCP2 -> Oracle UCP\n\n用户也可以通过 spring.datasource.type 来指定数据源类型。\n\n此外，也可以使用 DataSourceBuilder 手动配置其他连接池。如果自定义 DataSource bean，则不会发生自动配置。 DataSourceBuilder 支持以下连接池：\n\n * HikariCP\n * Tomcat pooling Datasource\n * Commons DBCP2\n * Oracle UCP & OracleDataSource\n * Spring Framework’s SimpleDriverDataSource\n * H2 JdbcDataSource\n * PostgreSQL PGSimpleDataSource\n * C3P0\n\n\n# 引入 Spring Boot 依赖\n\n你可以通过 Spring Boot 官方的初始化器（Spring Initializr）选择需要的组件来创建一个 Spring Boot 工程。或者，直接在 pom.xml 中引入所需要的依赖：\n\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-data-jdbc</artifactId>\n</dependency>\n<dependency>\n  <groupId>mysql</groupId>\n  <artifactId>mysql-connector-java</artifactId>\n</dependency>\n\n\n\n# 测试单数据源连接\n\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.boot.CommandLineRunner;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.jdbc.core.JdbcTemplate;\n\nimport java.sql.Connection;\nimport javax.sql.DataSource;\n\n@Slf4j\n@SpringBootApplication\npublic class SpringBootDataJdbcApplication implements CommandLineRunner {\n\n    private final JdbcTemplate jdbcTemplate;\n\n    public SpringBootDataJdbcApplication(JdbcTemplate jdbcTemplate) {\n        this.jdbcTemplate = jdbcTemplate;\n    }\n\n    public static void main(String[] args) {\n        SpringApplication.run(SpringBootDataJdbcApplication.class, args);\n    }\n\n    @Override\n    public void run(String... args) throws Exception {\n        DataSource dataSource = jdbcTemplate.getDataSource();\n\n        Connection connection;\n        if (dataSource != null) {\n            connection = dataSource.getConnection();\n        } else {\n            log.error("连接数据源失败！");\n            return;\n        }\n\n        if (connection != null) {\n            log.info("数据源 Url: {}", connection.getMetaData().getURL());\n        } else {\n            log.error("连接数据源失败！");\n        }\n    }\n\n}\n\n\n运行 main 方法后，控制台会输出以下内容，表示数据源连接成功：\n\n20:50:18.449 [main] [INFO ] i.g.d.s.d.SpringBootDataJdbcApplication.run - 数据源 Url: jdbc:mysql://localhost:3306/spring_tutorial?serverTimezone=UTC&useUnicode=true&characterEncoding=utf8\n\n\n\n# Spring Boot 连接多数据源\n\n> 完整示例：spring-boot-data-jdbc-multi-datasource\n\nSpring Boot 连接多数据源所需要的依赖并无不同，主要差异在于数据源的配置。Spring Boot 默认的数据源配置类为 org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration。使用者只要指定一些必要的 spring.datasource 配置，DataSourceAutoConfiguration 类就会自动完成剩下的数据源实例化工作。\n\n\n# 多数据源配置\n\n下面的示例中，自定义了一个数据源配置类，通过读取不同的 spring.datasource.xxx 来完成对于不同数据源的实例化工作。对于 JDBC 来说，最重要的，就是实例化 DataSource 和 JdbcTemplate。\n\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.boot.context.properties.ConfigurationProperties;\nimport org.springframework.boot.jdbc.DataSourceBuilder;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.Primary;\nimport org.springframework.jdbc.core.JdbcTemplate;\n\n@Configuration\npublic class DataSourceConfig {\n\n    @Primary\n    @Bean("mysqlDataSource")\n    @ConfigurationProperties(prefix = "spring.datasource.mysql")\n    public DataSource mysqlDataSource() {\n        return DataSourceBuilder.create().build();\n    }\n\n    @Primary\n    @Bean("mysqlJdbcTemplate")\n    public JdbcTemplate mysqlJdbcTemplate(@Qualifier("mysqlDataSource") DataSource dataSource) {\n        return new JdbcTemplate(dataSource);\n    }\n\n    @Bean("h2DataSource")\n    @ConfigurationProperties(prefix = "spring.datasource.h2")\n    public DataSource h2DataSource() {\n        return DataSourceBuilder.create().build();\n    }\n\n    @Bean(name = "h2JdbcTemplate")\n    public JdbcTemplate h2JdbcTemplate(@Qualifier("h2DataSource") DataSource dataSource) {\n        return new JdbcTemplate(dataSource);\n    }\n\n}\n\n\napplication.properties 或 application.yml 配置文件中也必须以 @ConfigurationProperties 所指定的配置前缀进行配置：\n\n# 数据源一：Mysql\nspring.datasource.mysql.jdbc-url = jdbc:mysql://localhost:3306/spring_tutorial?serverTimezone=UTC&useUnicode=true&characterEncoding=utf8&useSSL=false\nspring.datasource.mysql.driver-class-name = com.mysql.cj.jdbc.Driver\nspring.datasource.mysql.username = root\nspring.datasource.mysql.password = root\n# 数据源一：H2\nspring.datasource.h2.jdbc-url = jdbc:h2:mem:test\nspring.datasource.h2.driver-class-name = org.h2.Driver\nspring.datasource.h2.username = sa\nspring.datasource.h2.password =\n\n\n\n# 测试多数据源连接\n\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.boot.CommandLineRunner;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.jdbc.core.JdbcTemplate;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport javax.sql.DataSource;\n\n@SpringBootApplication\npublic class SpringBootDataJdbcMultiDataSourceApplication implements CommandLineRunner {\n\n    private static final Logger log = LoggerFactory.getLogger(SpringBootDataJdbcMultiDataSourceApplication.class);\n\n    private final UserDao mysqlUserDao;\n\n    private final UserDao h2UserDao;\n\n    public SpringBootDataJdbcMultiDataSourceApplication(@Qualifier("mysqlUserDao") UserDao mysqlUserDao,\n        @Qualifier("h2UserDao") UserDao h2UserDao) {\n        this.mysqlUserDao = mysqlUserDao;\n        this.h2UserDao = h2UserDao;\n    }\n\n    public static void main(String[] args) {\n        SpringApplication.run(SpringBootDataJdbcMultiDataSourceApplication.class, args);\n    }\n\n    @Override\n    public void run(String... args) throws Exception {\n\n        if (mysqlUserDao != null && mysqlUserDao.getJdbcTemplate() != null) {\n            printDataSourceInfo(mysqlUserDao.getJdbcTemplate());\n            log.info("Connect to mysql datasource success.");\n        } else {\n            log.error("Connect to mysql datasource failed!");\n            return;\n        }\n\n        if (h2UserDao != null) {\n            printDataSourceInfo(h2UserDao.getJdbcTemplate());\n            log.info("Connect to h2 datasource success.");\n        } else {\n            log.error("Connect to h2 datasource failed!");\n            return;\n        }\n\n        // 主数据源执行 JDBC SQL\n        mysqlUserDao.recreateTable();\n\n        // 次数据源执行 JDBC SQL\n        h2UserDao.recreateTable();\n    }\n\n    private void printDataSourceInfo(JdbcTemplate jdbcTemplate) throws SQLException {\n\n        DataSource dataSource = jdbcTemplate.getDataSource();\n\n        Connection connection;\n        if (dataSource != null) {\n            connection = dataSource.getConnection();\n        } else {\n            log.error("Get dataSource failed!");\n            return;\n        }\n\n        if (connection != null) {\n            log.info("DataSource Url: {}", connection.getMetaData().getURL());\n        } else {\n            log.error("Connect to datasource failed!");\n        }\n    }\n\n}\n\n\n运行 main 方法后，控制台会输出以下内容，表示数据源连接成功：\n\n21:16:44.654 [main] [INFO ] i.g.d.s.d.SpringBootDataJdbcMultiDataSourceApplication.printDataSourceInfo - DataSource Url: jdbc:mysql://localhost:3306/spring_tutorial?serverTimezone=UTC&useUnicode=true&characterEncoding=utf8&useSSL=false\n21:16:44.654 [main] [INFO ] i.g.d.s.d.SpringBootDataJdbcMultiDataSourceApplication.run - Connect to mysql datasource success.\n\n21:16:44.726 [main] [INFO ] i.g.d.s.d.SpringBootDataJdbcMultiDataSourceApplication.printDataSourceInfo - DataSource Url: jdbc:h2:mem:test\n21:16:44.726 [main] [INFO ] i.g.d.s.d.SpringBootDataJdbcMultiDataSourceApplication.run - Connect to h2 datasource success.\n\n\n\n# Spring 之数据源\n\n如果你的项目是传统的 Spring 项目，当然也可以轻松建立数据源连接，只是需要自行设置的配置更多一些。\n\n\n# 引入 Spring 依赖\n\n在 pom.xml 中引入所需要的依赖：\n\n    <dependencies>\n        <dependency>\n            <groupId>com.alibaba</groupId>\n            <artifactId>druid</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n        </dependency>\n\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-context-support</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-jdbc</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-tx</artifactId>\n        </dependency>\n    </dependencies>\n</project>\n\n\n\n# Spring 配置数据源\n\nSpring 配置数据源有多种方式，下面一一列举：\n\n# 使用 JNDI 数据源\n\n如果 Spring 应用部署在支持 JNDI 的 WEB 服务器上（如 WebSphere、JBoss、Tomcat 等），就可以使用 JNDI 获取数据源。\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n  xmlns:jee="http://www.springframework.org/schema/jee"\n  xsi:schemaLocation="http://www.springframework.org/schema/beans\n            http://www.springframework.org/schema/beans/spring-beans-3.2.xsd\nhttp://www.springframework.org/schema/jee\nhttp://www.springframework.org/schema/jee/spring-jee-3.2.xsd">\n\n  \x3c!-- 1.使用bean配置jndi数据源 --\x3e\n  <bean id="dataSource" class="org.springframework.jndi.JndiObjectFactoryBean">\n    <property name="jndiName" value="java:comp/env/jdbc/orclight" />\n  </bean>\n\n  \x3c!-- 2.使用jee标签配置jndi数据源，与1等价，但是需要引入命名空间 --\x3e\n  <jee:jndi-lookup id="dataSource" jndi-name=" java:comp/env/jdbc/orclight" />\n</beans>\n\n\n# 使用数据库连接池\n\nSpring 本身并没有提供数据库连接池的实现，需要自行选择合适的数据库连接池。下面是一个使用 Druid 作为数据库连接池的示例：\n\n<bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource"\n        init-method="init" destroy-method="close">\n    <property name="driverClassName" value="${jdbc.driver}"/>\n    <property name="url" value="${jdbc.url}"/>\n    <property name="username" value="${jdbc.username}"/>\n    <property name="password" value="${jdbc.password}"/>\n\n    \x3c!-- 配置初始化大小、最小、最大 --\x3e\n    <property name="initialSize" value="1"/>\n    <property name="minIdle" value="1"/>\n    <property name="maxActive" value="10"/>\n\n    \x3c!-- 配置获取连接等待超时的时间 --\x3e\n    <property name="maxWait" value="10000"/>\n\n    \x3c!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --\x3e\n    <property name="timeBetweenEvictionRunsMillis" value="60000"/>\n\n    \x3c!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --\x3e\n    <property name="minEvictableIdleTimeMillis" value="300000"/>\n\n    <property name="testWhileIdle" value="true"/>\n\n    \x3c!-- 这里建议配置为TRUE，防止取到的连接不可用 --\x3e\n    <property name="testOnBorrow" value="true"/>\n    <property name="testOnReturn" value="false"/>\n\n    \x3c!-- 打开PSCache，并且指定每个连接上PSCache的大小 --\x3e\n    <property name="poolPreparedStatements" value="true"/>\n    <property name="maxPoolPreparedStatementPerConnectionSize"\n              value="20"/>\n\n    \x3c!-- 这里配置提交方式，默认就是TRUE，可以不用配置 --\x3e\n\n    <property name="defaultAutoCommit" value="true"/>\n\n    \x3c!-- 验证连接有效与否的SQL，不同的数据配置不同 --\x3e\n    <property name="validationQuery" value="select 1 "/>\n    <property name="filters" value="stat"/>\n  </bean>\n\n\n# 基于 JDBC 驱动的数据源\n\n<bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">\n  <property name="driverClassName" value="${jdbc.driver}"/>\n  <property name="url" value="${jdbc.url}"/>\n  <property name="username" value="${jdbc.username}"/>\n  <property name="password" value="${jdbc.password}"/>\n</bean>\n\n\n\n# SpringBoot 数据源配置\n\n> Spring Boot 数据库配置官方文档：https://docs.spring.io/spring-boot/docs/current/reference/html/data.html#data.sql\n\n通过前面的实战，我们已经知道了 Spring、Spring Boot 是如何连接数据源，并通过 JDBC 方式访问数据库。\n\nSpringBoot 数据源的配置方式是在 application.properties 或 application.yml 文件中指定 spring.datasource.* 的配置。\n\n（1）数据源基本配置方式是指定 url、用户名、密码\n\nspring.datasource.url=jdbc:mysql://localhost/test\nspring.datasource.username=dbuser\nspring.datasource.password=dbpass\n\n\n（2）配置 JNDI\n\n如果想要通过 JNDI 方式连接数据源，可以采用如下方式：\n\nspring.datasource.jndi-name=java:jboss/datasources/customers\n\n\n\n# DataSourceAutoConfiguration 类\n\n显而易见，Spring Boot 的配置更加简化，那么， Spring Boot 做了哪些工作，使得接入更加便捷呢？奥秘就在于 spring-boot-autoconfigure jar 包，其中定义了大量的 Spring Boot 自动配置类。其中，与数据库访问相关的比较核心的配置类有：\n\n * DataSourceAutoConfiguration：数据源自动配置类\n * JdbcTemplateAutoConfiguration：JdbcTemplate 自动配置类\n * DataSourceTransactionManagerAutoConfiguration：数据源事务管理自动配置类\n * JndiDataSourceAutoConfiguration：JNDI 数据源自动配置类\n * EmbeddedDataSourceConfiguration：嵌入式数据库数据源自动配置类\n * 等等\n\n这些自动配置类会根据各种条件控制核心类的实例化。\n\nDataSourceAutoConfiguration 是数据源自动配置类，它负责实例化 DataSource。\n\nDataSourceAutoConfiguration 的源码如下（省略部分代码）：\n\n@AutoConfiguration(before = SqlInitializationAutoConfiguration.class)\n@ConditionalOnClass({ DataSource.class, EmbeddedDatabaseType.class })\n@ConditionalOnMissingBean(type = "io.r2dbc.spi.ConnectionFactory")\n@EnableConfigurationProperties(DataSourceProperties.class)\n@Import(DataSourcePoolMetadataProvidersConfiguration.class)\npublic class DataSourceAutoConfiguration {\n\n\t@Configuration(proxyBeanMethods = false)\n\t@Conditional(EmbeddedDatabaseCondition.class)\n\t@ConditionalOnMissingBean({ DataSource.class, XADataSource.class })\n\t@Import(EmbeddedDataSourceConfiguration.class)\n\tprotected static class EmbeddedDatabaseConfiguration {\n\t}\n\n\t@Configuration(proxyBeanMethods = false)\n\t@Conditional(PooledDataSourceCondition.class)\n\t@ConditionalOnMissingBean({ DataSource.class, XADataSource.class })\n\t@Import({ DataSourceConfiguration.Hikari.class, DataSourceConfiguration.Tomcat.class,\n\t\t\tDataSourceConfiguration.Dbcp2.class, DataSourceConfiguration.OracleUcp.class,\n\t\t\tDataSourceConfiguration.Generic.class, DataSourceJmxConfiguration.class })\n\tprotected static class PooledDataSourceConfiguration {\n  }\n\n\tstatic class PooledDataSourceCondition extends AnyNestedCondition {\n    // 略\n\t}\n\n\tstatic class PooledDataSourceAvailableCondition extends SpringBootCondition {\n    // 略\n\t}\n\n\tstatic class EmbeddedDatabaseCondition extends SpringBootCondition {\n    // 略\n\t}\n}\n\n\nDataSourceAutoConfiguration 类的源码解读：\n\n * DataSourceProperties 是 DataSourceAutoConfiguration 的配置选项类，允许使用者通过设置选项控制 DataSource 初始化行为。\n * DataSourceAutoConfiguration 通过 @Import 注解引入 DataSourcePoolMetadataProvidersConfiguration 类。\n * DataSourceAutoConfiguration 中定义了两个内部类：嵌入式数据源配置类 EmbeddedDatabaseConfiguration 和 池化数据源配置类 PooledDataSourceConfiguration，分别标记了不同的实例化条件。\n   * 当满足 EmbeddedDatabaseConfiguration 的示例化条件时，将引入 EmbeddedDataSourceConfiguration 类初始化数据源，这个类实际上是加载嵌入式数据源驱动的 ClassLoader 去进行初始化。\n   * 当满足 PooledDataSourceConfiguration 的示例化条件时，将引入 DataSourceConfiguration.Hikari.class、DataSourceConfiguration.Tomcat.class、DataSourceConfiguration.Dbcp2.class、DataSourceConfiguration.OracleUcp.class、DataSourceConfiguration.Generic.class、DataSourceJmxConfiguration.class 这些配置类，分别对应不同的数据库连接池方式。具体选用哪种数据库连接池，可以通过 spring.datasource.type 配置指定。其中，Hikari 是 Spring Boot 默认的数据库连接池，spring-boot-starter-data-jdbc 中内置了 Hikari 连接池驱动包。如果想要替换其他数据库连接池，前提是必须先手动引入对应的连接池驱动包。\n\n\n# 参考资料\n\n * Spring 官网\n * Spring Framework 官方文档\n * Spring Boot 官方文档',normalizedContent:'# spring 之数据源\n\n> 本文基于 spring boot 2.7.3 版本。\n\n\n# spring boot 数据源基本配置\n\nspring boot 提供了一系列 spring.datasource.* 配置来控制 datasource 的配置。用户可以在 application.properties 或 application.yml 文件中指定数据源配置。这些配置项维护在 datasourceproperties 。\n\n下面是一个最基本的 mysql 数据源配置示例（都是必填项）：\n\n# 数据库访问地址\nspring.datasource.url = jdbc:mysql://localhost:3306/spring_tutorial?servertimezone=utc&useunicode=true&characterencoding=utf8\n# 数据库驱动类，必须保证驱动类是可加载的\nspring.datasource.driver-class-name = com.mysql.cj.jdbc.driver\n# 数据库账号\nspring.datasource.username = root\n# 数据库账号密码\nspring.datasource.password = root\n\n\n需要根据实际情况，替换 url、username、password。\n\n\n# spring boot 连接嵌入式数据源\n\n使用内存嵌入式数据库开发应用程序通常很方便。显然，内存数据库不提供持久存储。使用者需要在应用程序启动时填充数据库，并准备在应用程序结束时丢弃数据。\n\nspring boot 可以自动配置嵌入式数据库 h2、hsql 和 derby。使用者无需提供任何连接 url，只需要包含对要使用的嵌入式数据库的构建依赖项。如果类路径上有多个嵌入式数据库，需要设置 spring.datasource.embedded-database-connection 配置属性来控制使用哪一个。将该属性设置为 none 会禁用嵌入式数据库的自动配置。\n\n> 注意：如果在测试中使用此功能，无论使用多少应用程序上下文，整个测试套件都会重用同一个数据库。如果要确保每个上下文都有一个单独的嵌入式数据库，则应将 spring.datasource.generate-unique-name 设置为 true。\n\n下面，通过一个实例展示如何连接 h2 嵌入式数据库。\n\n（1）在 pom.xml 中引入所需要的依赖：\n\n<dependency>\n  <groupid>org.springframework.boot</groupid>\n  <artifactid>spring-boot-starter-data-jdbc</artifactid>\n</dependency>\n<dependency>\n  <groupid>com.h2database</groupid>\n  <artifactid>h2</artifactid>\n</dependency>\n\n\n（2）数据源配置\n\nspring.datasource.jdbc-url = jdbc:h2:mem:test\nspring.datasource.driver-class-name = org.h2.driver\nspring.datasource.username = sa\nspring.datasource.password =\n\n\n\n# spring boot 连接池化数据源\n\n> 完整示例：spring-boot-data-jdbc\n\n在生产环境中，出于性能考虑，一般会通过数据库连接池连接数据源。\n\n除了 datasourceproperties 中的数据源通用配置以外，spring boot 还支持通过使用类似spring.datasource.hikari.*、spring.datasource.tomcat.*、spring.datasource.dbcp2.* 和 spring.datasource.oracleucp.* 的前缀来配置指定的数据库连接池属性。\n\n下面，就是一份 hikari 的连接池配置示例：\n\n# 连接池名称\nspring.datasource.hikari.pool-name = springtutorialhikaripool\n# 最大连接数，小于等于 0 会被重置为默认值 10；大于零小于 1 会被重置为 minimum-idle 的值\nspring.datasource.hikari.maximum-pool-size = 10\n# 最小空闲连接，默认值10，小于 0 或大于 maximum-pool-size，都会重置为 maximum-pool-size\nspring.datasource.hikari.minimum-idle = 10\n# 连接超时时间（单位：毫秒），小于 250 毫秒，会被重置为默认值 30 秒\nspring.datasource.hikari.connection-timeout = 60000\n# 空闲连接超时时间，默认值 600000（10分钟），大于等于 max-lifetime 且 max-lifetime>0，会被重置为0；不等于 0 且小于 10 秒，会被重置为 10 秒\n# 只有空闲连接数大于最大连接数且空闲时间超过该值，才会被释放\nspring.datasource.hikari.idle-timeout = 600000\n# 连接最大存活时间，不等于 0 且小于 30 秒，会被重置为默认值 30 分钟。该值应该比数据库所设置的超时时间短\nspring.datasource.hikari.max-lifetime = 540000\n\n\nspring boot 会按以下顺序检测连接池是否可用，如果可用就选择对应的池化 datasource：\n\nhikaricp -> tomcat pooling datasource -> dbcp2 -> oracle ucp\n\n用户也可以通过 spring.datasource.type 来指定数据源类型。\n\n此外，也可以使用 datasourcebuilder 手动配置其他连接池。如果自定义 datasource bean，则不会发生自动配置。 datasourcebuilder 支持以下连接池：\n\n * hikaricp\n * tomcat pooling datasource\n * commons dbcp2\n * oracle ucp & oracledatasource\n * spring framework’s simpledriverdatasource\n * h2 jdbcdatasource\n * postgresql pgsimpledatasource\n * c3p0\n\n\n# 引入 spring boot 依赖\n\n你可以通过 spring boot 官方的初始化器（spring initializr）选择需要的组件来创建一个 spring boot 工程。或者，直接在 pom.xml 中引入所需要的依赖：\n\n<dependency>\n  <groupid>org.springframework.boot</groupid>\n  <artifactid>spring-boot-starter-data-jdbc</artifactid>\n</dependency>\n<dependency>\n  <groupid>mysql</groupid>\n  <artifactid>mysql-connector-java</artifactid>\n</dependency>\n\n\n\n# 测试单数据源连接\n\nimport lombok.extern.slf4j.slf4j;\nimport org.springframework.boot.commandlinerunner;\nimport org.springframework.boot.springapplication;\nimport org.springframework.boot.autoconfigure.springbootapplication;\nimport org.springframework.jdbc.core.jdbctemplate;\n\nimport java.sql.connection;\nimport javax.sql.datasource;\n\n@slf4j\n@springbootapplication\npublic class springbootdatajdbcapplication implements commandlinerunner {\n\n    private final jdbctemplate jdbctemplate;\n\n    public springbootdatajdbcapplication(jdbctemplate jdbctemplate) {\n        this.jdbctemplate = jdbctemplate;\n    }\n\n    public static void main(string[] args) {\n        springapplication.run(springbootdatajdbcapplication.class, args);\n    }\n\n    @override\n    public void run(string... args) throws exception {\n        datasource datasource = jdbctemplate.getdatasource();\n\n        connection connection;\n        if (datasource != null) {\n            connection = datasource.getconnection();\n        } else {\n            log.error("连接数据源失败！");\n            return;\n        }\n\n        if (connection != null) {\n            log.info("数据源 url: {}", connection.getmetadata().geturl());\n        } else {\n            log.error("连接数据源失败！");\n        }\n    }\n\n}\n\n\n运行 main 方法后，控制台会输出以下内容，表示数据源连接成功：\n\n20:50:18.449 [main] [info ] i.g.d.s.d.springbootdatajdbcapplication.run - 数据源 url: jdbc:mysql://localhost:3306/spring_tutorial?servertimezone=utc&useunicode=true&characterencoding=utf8\n\n\n\n# spring boot 连接多数据源\n\n> 完整示例：spring-boot-data-jdbc-multi-datasource\n\nspring boot 连接多数据源所需要的依赖并无不同，主要差异在于数据源的配置。spring boot 默认的数据源配置类为 org.springframework.boot.autoconfigure.jdbc.datasourceautoconfiguration。使用者只要指定一些必要的 spring.datasource 配置，datasourceautoconfiguration 类就会自动完成剩下的数据源实例化工作。\n\n\n# 多数据源配置\n\n下面的示例中，自定义了一个数据源配置类，通过读取不同的 spring.datasource.xxx 来完成对于不同数据源的实例化工作。对于 jdbc 来说，最重要的，就是实例化 datasource 和 jdbctemplate。\n\nimport org.springframework.beans.factory.annotation.qualifier;\nimport org.springframework.boot.context.properties.configurationproperties;\nimport org.springframework.boot.jdbc.datasourcebuilder;\nimport org.springframework.context.annotation.bean;\nimport org.springframework.context.annotation.configuration;\nimport org.springframework.context.annotation.primary;\nimport org.springframework.jdbc.core.jdbctemplate;\n\n@configuration\npublic class datasourceconfig {\n\n    @primary\n    @bean("mysqldatasource")\n    @configurationproperties(prefix = "spring.datasource.mysql")\n    public datasource mysqldatasource() {\n        return datasourcebuilder.create().build();\n    }\n\n    @primary\n    @bean("mysqljdbctemplate")\n    public jdbctemplate mysqljdbctemplate(@qualifier("mysqldatasource") datasource datasource) {\n        return new jdbctemplate(datasource);\n    }\n\n    @bean("h2datasource")\n    @configurationproperties(prefix = "spring.datasource.h2")\n    public datasource h2datasource() {\n        return datasourcebuilder.create().build();\n    }\n\n    @bean(name = "h2jdbctemplate")\n    public jdbctemplate h2jdbctemplate(@qualifier("h2datasource") datasource datasource) {\n        return new jdbctemplate(datasource);\n    }\n\n}\n\n\napplication.properties 或 application.yml 配置文件中也必须以 @configurationproperties 所指定的配置前缀进行配置：\n\n# 数据源一：mysql\nspring.datasource.mysql.jdbc-url = jdbc:mysql://localhost:3306/spring_tutorial?servertimezone=utc&useunicode=true&characterencoding=utf8&usessl=false\nspring.datasource.mysql.driver-class-name = com.mysql.cj.jdbc.driver\nspring.datasource.mysql.username = root\nspring.datasource.mysql.password = root\n# 数据源一：h2\nspring.datasource.h2.jdbc-url = jdbc:h2:mem:test\nspring.datasource.h2.driver-class-name = org.h2.driver\nspring.datasource.h2.username = sa\nspring.datasource.h2.password =\n\n\n\n# 测试多数据源连接\n\n\nimport org.slf4j.logger;\nimport org.slf4j.loggerfactory;\nimport org.springframework.beans.factory.annotation.qualifier;\nimport org.springframework.boot.commandlinerunner;\nimport org.springframework.boot.springapplication;\nimport org.springframework.boot.autoconfigure.springbootapplication;\nimport org.springframework.jdbc.core.jdbctemplate;\n\nimport java.sql.connection;\nimport java.sql.sqlexception;\nimport javax.sql.datasource;\n\n@springbootapplication\npublic class springbootdatajdbcmultidatasourceapplication implements commandlinerunner {\n\n    private static final logger log = loggerfactory.getlogger(springbootdatajdbcmultidatasourceapplication.class);\n\n    private final userdao mysqluserdao;\n\n    private final userdao h2userdao;\n\n    public springbootdatajdbcmultidatasourceapplication(@qualifier("mysqluserdao") userdao mysqluserdao,\n        @qualifier("h2userdao") userdao h2userdao) {\n        this.mysqluserdao = mysqluserdao;\n        this.h2userdao = h2userdao;\n    }\n\n    public static void main(string[] args) {\n        springapplication.run(springbootdatajdbcmultidatasourceapplication.class, args);\n    }\n\n    @override\n    public void run(string... args) throws exception {\n\n        if (mysqluserdao != null && mysqluserdao.getjdbctemplate() != null) {\n            printdatasourceinfo(mysqluserdao.getjdbctemplate());\n            log.info("connect to mysql datasource success.");\n        } else {\n            log.error("connect to mysql datasource failed!");\n            return;\n        }\n\n        if (h2userdao != null) {\n            printdatasourceinfo(h2userdao.getjdbctemplate());\n            log.info("connect to h2 datasource success.");\n        } else {\n            log.error("connect to h2 datasource failed!");\n            return;\n        }\n\n        // 主数据源执行 jdbc sql\n        mysqluserdao.recreatetable();\n\n        // 次数据源执行 jdbc sql\n        h2userdao.recreatetable();\n    }\n\n    private void printdatasourceinfo(jdbctemplate jdbctemplate) throws sqlexception {\n\n        datasource datasource = jdbctemplate.getdatasource();\n\n        connection connection;\n        if (datasource != null) {\n            connection = datasource.getconnection();\n        } else {\n            log.error("get datasource failed!");\n            return;\n        }\n\n        if (connection != null) {\n            log.info("datasource url: {}", connection.getmetadata().geturl());\n        } else {\n            log.error("connect to datasource failed!");\n        }\n    }\n\n}\n\n\n运行 main 方法后，控制台会输出以下内容，表示数据源连接成功：\n\n21:16:44.654 [main] [info ] i.g.d.s.d.springbootdatajdbcmultidatasourceapplication.printdatasourceinfo - datasource url: jdbc:mysql://localhost:3306/spring_tutorial?servertimezone=utc&useunicode=true&characterencoding=utf8&usessl=false\n21:16:44.654 [main] [info ] i.g.d.s.d.springbootdatajdbcmultidatasourceapplication.run - connect to mysql datasource success.\n\n21:16:44.726 [main] [info ] i.g.d.s.d.springbootdatajdbcmultidatasourceapplication.printdatasourceinfo - datasource url: jdbc:h2:mem:test\n21:16:44.726 [main] [info ] i.g.d.s.d.springbootdatajdbcmultidatasourceapplication.run - connect to h2 datasource success.\n\n\n\n# spring 之数据源\n\n如果你的项目是传统的 spring 项目，当然也可以轻松建立数据源连接，只是需要自行设置的配置更多一些。\n\n\n# 引入 spring 依赖\n\n在 pom.xml 中引入所需要的依赖：\n\n    <dependencies>\n        <dependency>\n            <groupid>com.alibaba</groupid>\n            <artifactid>druid</artifactid>\n        </dependency>\n        <dependency>\n            <groupid>mysql</groupid>\n            <artifactid>mysql-connector-java</artifactid>\n        </dependency>\n\n        <dependency>\n            <groupid>org.springframework</groupid>\n            <artifactid>spring-context-support</artifactid>\n        </dependency>\n        <dependency>\n            <groupid>org.springframework</groupid>\n            <artifactid>spring-jdbc</artifactid>\n        </dependency>\n        <dependency>\n            <groupid>org.springframework</groupid>\n            <artifactid>spring-tx</artifactid>\n        </dependency>\n    </dependencies>\n</project>\n\n\n\n# spring 配置数据源\n\nspring 配置数据源有多种方式，下面一一列举：\n\n# 使用 jndi 数据源\n\n如果 spring 应用部署在支持 jndi 的 web 服务器上（如 websphere、jboss、tomcat 等），就可以使用 jndi 获取数据源。\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n  xmlns:jee="http://www.springframework.org/schema/jee"\n  xsi:schemalocation="http://www.springframework.org/schema/beans\n            http://www.springframework.org/schema/beans/spring-beans-3.2.xsd\nhttp://www.springframework.org/schema/jee\nhttp://www.springframework.org/schema/jee/spring-jee-3.2.xsd">\n\n  \x3c!-- 1.使用bean配置jndi数据源 --\x3e\n  <bean id="datasource" class="org.springframework.jndi.jndiobjectfactorybean">\n    <property name="jndiname" value="java:comp/env/jdbc/orclight" />\n  </bean>\n\n  \x3c!-- 2.使用jee标签配置jndi数据源，与1等价，但是需要引入命名空间 --\x3e\n  <jee:jndi-lookup id="datasource" jndi-name=" java:comp/env/jdbc/orclight" />\n</beans>\n\n\n# 使用数据库连接池\n\nspring 本身并没有提供数据库连接池的实现，需要自行选择合适的数据库连接池。下面是一个使用 druid 作为数据库连接池的示例：\n\n<bean id="datasource" class="com.alibaba.druid.pool.druiddatasource"\n        init-method="init" destroy-method="close">\n    <property name="driverclassname" value="${jdbc.driver}"/>\n    <property name="url" value="${jdbc.url}"/>\n    <property name="username" value="${jdbc.username}"/>\n    <property name="password" value="${jdbc.password}"/>\n\n    \x3c!-- 配置初始化大小、最小、最大 --\x3e\n    <property name="initialsize" value="1"/>\n    <property name="minidle" value="1"/>\n    <property name="maxactive" value="10"/>\n\n    \x3c!-- 配置获取连接等待超时的时间 --\x3e\n    <property name="maxwait" value="10000"/>\n\n    \x3c!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --\x3e\n    <property name="timebetweenevictionrunsmillis" value="60000"/>\n\n    \x3c!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --\x3e\n    <property name="minevictableidletimemillis" value="300000"/>\n\n    <property name="testwhileidle" value="true"/>\n\n    \x3c!-- 这里建议配置为true，防止取到的连接不可用 --\x3e\n    <property name="testonborrow" value="true"/>\n    <property name="testonreturn" value="false"/>\n\n    \x3c!-- 打开pscache，并且指定每个连接上pscache的大小 --\x3e\n    <property name="poolpreparedstatements" value="true"/>\n    <property name="maxpoolpreparedstatementperconnectionsize"\n              value="20"/>\n\n    \x3c!-- 这里配置提交方式，默认就是true，可以不用配置 --\x3e\n\n    <property name="defaultautocommit" value="true"/>\n\n    \x3c!-- 验证连接有效与否的sql，不同的数据配置不同 --\x3e\n    <property name="validationquery" value="select 1 "/>\n    <property name="filters" value="stat"/>\n  </bean>\n\n\n# 基于 jdbc 驱动的数据源\n\n<bean id="datasource" class="org.springframework.jdbc.datasource.drivermanagerdatasource">\n  <property name="driverclassname" value="${jdbc.driver}"/>\n  <property name="url" value="${jdbc.url}"/>\n  <property name="username" value="${jdbc.username}"/>\n  <property name="password" value="${jdbc.password}"/>\n</bean>\n\n\n\n# springboot 数据源配置\n\n> spring boot 数据库配置官方文档：https://docs.spring.io/spring-boot/docs/current/reference/html/data.html#data.sql\n\n通过前面的实战，我们已经知道了 spring、spring boot 是如何连接数据源，并通过 jdbc 方式访问数据库。\n\nspringboot 数据源的配置方式是在 application.properties 或 application.yml 文件中指定 spring.datasource.* 的配置。\n\n（1）数据源基本配置方式是指定 url、用户名、密码\n\nspring.datasource.url=jdbc:mysql://localhost/test\nspring.datasource.username=dbuser\nspring.datasource.password=dbpass\n\n\n（2）配置 jndi\n\n如果想要通过 jndi 方式连接数据源，可以采用如下方式：\n\nspring.datasource.jndi-name=java:jboss/datasources/customers\n\n\n\n# datasourceautoconfiguration 类\n\n显而易见，spring boot 的配置更加简化，那么， spring boot 做了哪些工作，使得接入更加便捷呢？奥秘就在于 spring-boot-autoconfigure jar 包，其中定义了大量的 spring boot 自动配置类。其中，与数据库访问相关的比较核心的配置类有：\n\n * datasourceautoconfiguration：数据源自动配置类\n * jdbctemplateautoconfiguration：jdbctemplate 自动配置类\n * datasourcetransactionmanagerautoconfiguration：数据源事务管理自动配置类\n * jndidatasourceautoconfiguration：jndi 数据源自动配置类\n * embeddeddatasourceconfiguration：嵌入式数据库数据源自动配置类\n * 等等\n\n这些自动配置类会根据各种条件控制核心类的实例化。\n\ndatasourceautoconfiguration 是数据源自动配置类，它负责实例化 datasource。\n\ndatasourceautoconfiguration 的源码如下（省略部分代码）：\n\n@autoconfiguration(before = sqlinitializationautoconfiguration.class)\n@conditionalonclass({ datasource.class, embeddeddatabasetype.class })\n@conditionalonmissingbean(type = "io.r2dbc.spi.connectionfactory")\n@enableconfigurationproperties(datasourceproperties.class)\n@import(datasourcepoolmetadataprovidersconfiguration.class)\npublic class datasourceautoconfiguration {\n\n\t@configuration(proxybeanmethods = false)\n\t@conditional(embeddeddatabasecondition.class)\n\t@conditionalonmissingbean({ datasource.class, xadatasource.class })\n\t@import(embeddeddatasourceconfiguration.class)\n\tprotected static class embeddeddatabaseconfiguration {\n\t}\n\n\t@configuration(proxybeanmethods = false)\n\t@conditional(pooleddatasourcecondition.class)\n\t@conditionalonmissingbean({ datasource.class, xadatasource.class })\n\t@import({ datasourceconfiguration.hikari.class, datasourceconfiguration.tomcat.class,\n\t\t\tdatasourceconfiguration.dbcp2.class, datasourceconfiguration.oracleucp.class,\n\t\t\tdatasourceconfiguration.generic.class, datasourcejmxconfiguration.class })\n\tprotected static class pooleddatasourceconfiguration {\n  }\n\n\tstatic class pooleddatasourcecondition extends anynestedcondition {\n    // 略\n\t}\n\n\tstatic class pooleddatasourceavailablecondition extends springbootcondition {\n    // 略\n\t}\n\n\tstatic class embeddeddatabasecondition extends springbootcondition {\n    // 略\n\t}\n}\n\n\ndatasourceautoconfiguration 类的源码解读：\n\n * datasourceproperties 是 datasourceautoconfiguration 的配置选项类，允许使用者通过设置选项控制 datasource 初始化行为。\n * datasourceautoconfiguration 通过 @import 注解引入 datasourcepoolmetadataprovidersconfiguration 类。\n * datasourceautoconfiguration 中定义了两个内部类：嵌入式数据源配置类 embeddeddatabaseconfiguration 和 池化数据源配置类 pooleddatasourceconfiguration，分别标记了不同的实例化条件。\n   * 当满足 embeddeddatabaseconfiguration 的示例化条件时，将引入 embeddeddatasourceconfiguration 类初始化数据源，这个类实际上是加载嵌入式数据源驱动的 classloader 去进行初始化。\n   * 当满足 pooleddatasourceconfiguration 的示例化条件时，将引入 datasourceconfiguration.hikari.class、datasourceconfiguration.tomcat.class、datasourceconfiguration.dbcp2.class、datasourceconfiguration.oracleucp.class、datasourceconfiguration.generic.class、datasourcejmxconfiguration.class 这些配置类，分别对应不同的数据库连接池方式。具体选用哪种数据库连接池，可以通过 spring.datasource.type 配置指定。其中，hikari 是 spring boot 默认的数据库连接池，spring-boot-starter-data-jdbc 中内置了 hikari 连接池驱动包。如果想要替换其他数据库连接池，前提是必须先手动引入对应的连接池驱动包。\n\n\n# 参考资料\n\n * spring 官网\n * spring framework 官方文档\n * spring boot 官方文档',charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Spring 之 JDBC",frontmatter:{title:"Spring 之 JDBC",date:"2019-02-18T14:33:55.000Z",order:2,categories:["Java","框架","Spring","Spring数据"],tags:["Java","框架","Spring","SpringBoot","JDBC","JdbcTemplate"],permalink:"/pages/cf19fd/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/02.Spring%E6%95%B0%E6%8D%AE/02.Spring%E4%B9%8BJDBC.html",relativePath:"01.Java/13.框架/01.Spring/02.Spring数据/02.Spring之JDBC.md",key:"v-21c80e99",path:"/pages/cf19fd/",headers:[{level:2,title:"JDBC 入门示例",slug:"jdbc-入门示例",normalizedTitle:"jdbc 入门示例",charIndex:78},{level:3,title:"定义实体",slug:"定义实体",normalizedTitle:"定义实体",charIndex:996},{level:3,title:"定义 DAO 接口",slug:"定义-dao-接口",normalizedTitle:"定义 dao 接口",charIndex:1348},{level:3,title:"定义 DAO 实现类",slug:"定义-dao-实现类",normalizedTitle:"定义 dao 实现类",charIndex:2078},{level:3,title:"测试类",slug:"测试类",normalizedTitle:"测试类",charIndex:5742},{level:2,title:"Spring Boot JDBC",slug:"spring-boot-jdbc",normalizedTitle:"spring boot jdbc",charIndex:8153},{level:3,title:"引入 Spring Boot 依赖",slug:"引入-spring-boot-依赖",normalizedTitle:"引入 spring boot 依赖",charIndex:8204},{level:3,title:"配置数据源",slug:"配置数据源",normalizedTitle:"配置数据源",charIndex:8783},{level:3,title:"测试",slug:"测试",normalizedTitle:"测试",charIndex:5742},{level:2,title:"Spring JDBC",slug:"spring-jdbc",normalizedTitle:"spring jdbc",charIndex:10623},{level:3,title:"引入 Spring 依赖",slug:"引入-spring-依赖",normalizedTitle:"引入 spring 依赖",charIndex:10739},{level:3,title:"基于 JDBC 驱动的数据源配置",slug:"基于-jdbc-驱动的数据源配置",normalizedTitle:"基于 jdbc 驱动的数据源配置",charIndex:11536},{level:3,title:"测试",slug:"测试-2",normalizedTitle:"测试",charIndex:5742},{level:2,title:"JdbcTemplate API",slug:"jdbctemplate-api",normalizedTitle:"jdbctemplate api",charIndex:14871},{level:3,title:"execute 方法",slug:"execute-方法",normalizedTitle:"execute 方法",charIndex:15360},{level:3,title:"update 方法",slug:"update-方法",normalizedTitle:"update 方法",charIndex:15405},{level:3,title:"query 方法",slug:"query-方法",normalizedTitle:"query 方法",charIndex:15486},{level:2,title:"SpringBoot JDBC 配置",slug:"springboot-jdbc-配置",normalizedTitle:"springboot jdbc 配置",charIndex:17896},{level:3,title:"JdbcTemplateAutoConfiguration 类",slug:"jdbctemplateautoconfiguration-类",normalizedTitle:"jdbctemplateautoconfiguration 类",charIndex:17919},{level:3,title:"JdbcTemplateConfiguration 类",slug:"jdbctemplateconfiguration-类",normalizedTitle:"jdbctemplateconfiguration 类",charIndex:18947},{level:3,title:"NamedParameterJdbcTemplateConfiguration 类",slug:"namedparameterjdbctemplateconfiguration-类",normalizedTitle:"namedparameterjdbctemplateconfiguration 类",charIndex:19729},{level:2,title:"spring-data-jdbc",slug:"spring-data-jdbc",normalizedTitle:"spring-data-jdbc",charIndex:10643},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:20696}],headersStr:"JDBC 入门示例 定义实体 定义 DAO 接口 定义 DAO 实现类 测试类 Spring Boot JDBC 引入 Spring Boot 依赖 配置数据源 测试 Spring JDBC 引入 Spring 依赖 基于 JDBC 驱动的数据源配置 测试 JdbcTemplate API execute 方法 update 方法 query 方法 SpringBoot JDBC 配置 JdbcTemplateAutoConfiguration 类 JdbcTemplateConfiguration 类 NamedParameterJdbcTemplateConfiguration 类 spring-data-jdbc 参考资料",content:'# Spring 之 JDBC\n\nJDBC 是 Java 语言中用来规范客户端程序如何访问数据库的应用程序接口，提供了增、删、改、查数据库的方法。\n\n\n# JDBC 入门示例\n\nJDBC 的工作步骤大致如下：\n\n 1. 创建实体类。\n 2. 声明数据库读写接口的 DAO 接口。定义 DAO 的好处在于对于数据层上层的业务，调用 DAO 时仅关注对外暴露的读写方法，而不考虑底层的具体持久化方式。这样，便于替换持久化方式。\n 3. 创建一个 DAO 接口的实现类，使用 Spring 的 JDBC 模板去实现接口。\n 4. 最后，定义一个 DAO 接口的实现类的 JavaBean，并将数据源注入进去。\n\n假设，我们要通过 Spring + JDBC 访问一张 Mysql 数据表 user，user 表的数据结构如下：\n\n-- 创建用户表\nCREATE TABLE `user` (\n    `id`      BIGINT(20) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT \'ID\',\n    `name`    VARCHAR(255)        NOT NULL DEFAULT \'\' COMMENT \'用户名\',\n    `age`     INT(3)              NOT NULL DEFAULT 0 COMMENT \'年龄\',\n    `address` VARCHAR(255)        NOT NULL DEFAULT \'\' COMMENT \'地址\',\n    `email`   VARCHAR(255)        NOT NULL DEFAULT \'\' COMMENT \'邮件\',\n    PRIMARY KEY (`id`),\n    UNIQUE (`name`)\n) COMMENT = \'用户表\';\n\nINSERT INTO `user` (`name`, `age`, `address`, `email`)\nVALUES (\'张三\', 18, \'北京\', \'xxx@163.com\');\nINSERT INTO `user` (`name`, `age`, `address`, `email`)\nVALUES (\'李四\', 19, \'上海\', \'xxx@163.com\');\n\n\n\n# 定义实体\n\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\nimport lombok.ToString;\n\nimport java.util.Objects;\n\n@Data\n@ToString\n@NoArgsConstructor\n@AllArgsConstructor\npublic class User {\n    private Long id;\n    private String name;\n    private Integer age;\n    private String address;\n    private String email;\n}\n\n\n\n# 定义 DAO 接口\n\nimport org.springframework.jdbc.core.JdbcTemplate;\n\nimport java.util.List;\n\n/**\n * user 表 Dao 接口\n *\n * @author <a href="mailto:forbreak@163.com">Zhang Peng</a>\n * @since 2019-11-18\n */\npublic interface UserDao {\n\n    // DML\n    // -------------------------------------------------------------------\n    void insert(User user);\n\n    void batchInsert(List<User> users);\n\n    void deleteByName(String name);\n\n    void deleteAll();\n\n    void update(User user);\n\n    Integer count();\n\n    List<User> list();\n\n    User queryByName(String name);\n\n    JdbcTemplate getJdbcTemplate();\n\n    // DDL\n    // -------------------------------------------------------------------\n    void truncate();\n\n    void recreateTable();\n\n}\n\n\n\n# 定义 DAO 实现类\n\n通过 JdbcTemplate 执行对应数据源符合语法的 SQL，即可完成各种数据库访问。\n\npackage io.github.dunwu.springboot.core.data.jdbc;\n\nimport org.springframework.dao.EmptyResultDataAccessException;\nimport org.springframework.jdbc.core.BeanPropertyRowMapper;\nimport org.springframework.jdbc.core.JdbcTemplate;\nimport org.springframework.stereotype.Repository;\nimport org.springframework.transaction.annotation.Transactional;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * user 表 Dao 接口实现类\n *\n * @author <a href="mailto:forbreak@163.com">Zhang Peng</a>\n * @since 2019-11-18\n */\n@Repository\npublic class UserDaoImpl implements UserDao {\n\n    private JdbcTemplate jdbcTemplate;\n\n    public UserDaoImpl(JdbcTemplate jdbcTemplate) {\n        this.jdbcTemplate = jdbcTemplate;\n    }\n\n    @Override\n    public void insert(User user) {\n        jdbcTemplate.update("INSERT INTO user(name, age, address, email) VALUES(?, ?, ?, ?)",\n            user.getName(), user.getAge(), user.getAddress(), user.getEmail());\n    }\n\n    @Override\n    @Transactional(rollbackFor = Exception.class)\n    public void batchInsert(List<User> users) {\n        String sql = "INSERT INTO user(name, age, address, email) VALUES(?, ?, ?, ?)";\n\n        List<Object[]> params = new ArrayList<>();\n\n        users.forEach(user -> {\n            params.add(new Object[] { user.getName(), user.getAge(), user.getAddress(), user.getEmail() });\n        });\n        jdbcTemplate.batchUpdate(sql, params);\n    }\n\n    @Override\n    public void deleteByName(String name) {\n        jdbcTemplate.update("DELETE FROM user WHERE name = ?", name);\n    }\n\n    @Override\n    @Transactional(rollbackFor = Exception.class)\n    public void deleteAll() {\n        jdbcTemplate.execute("DELETE FROM user");\n    }\n\n    @Override\n    public void update(User user) {\n        jdbcTemplate.update("UPDATE user SET name=?, age=?, address=?, email=? WHERE id=?",\n            user.getName(), user.getAge(), user.getAddress(), user.getEmail(), user.getId());\n    }\n\n    @Override\n    public Integer count() {\n        try {\n            return jdbcTemplate.queryForObject("SELECT COUNT(*) FROM user", Integer.class);\n        } catch (EmptyResultDataAccessException e) {\n            return null;\n        }\n    }\n\n    @Override\n    public List<User> list() {\n        return jdbcTemplate.query("SELECT * FROM user", new BeanPropertyRowMapper<>(User.class));\n    }\n\n    @Override\n    public User queryByName(String name) {\n        try {\n            return jdbcTemplate.queryForObject("SELECT * FROM user WHERE name = ?",\n                new BeanPropertyRowMapper<>(User.class), name);\n        } catch (EmptyResultDataAccessException e) {\n            return null;\n        }\n    }\n\n    @Override\n    public JdbcTemplate getJdbcTemplate() {\n        return jdbcTemplate;\n    }\n\n    @Override\n    public void truncate() {\n        jdbcTemplate.execute("TRUNCATE TABLE user");\n    }\n\n    @Override\n    public void recreateTable() {\n        jdbcTemplate.execute("DROP TABLE IF EXISTS user");\n\n        String sqlStatement =\n            "CREATE TABLE IF NOT EXISTS user (\\n"\n                + "    id      BIGINT(10) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT \'Id\',\\n"\n                + "    name    VARCHAR(255)         NOT NULL DEFAULT \'\' COMMENT \'用户名\',\\n"\n                + "    age     INT(3)              NOT NULL DEFAULT 0 COMMENT \'年龄\',\\n"\n                + "    address VARCHAR(255)         NOT NULL DEFAULT \'\' COMMENT \'地址\',\\n"\n                + "    email   VARCHAR(255)         NOT NULL DEFAULT \'\' COMMENT \'邮件\',\\n"\n                + "    PRIMARY KEY (id)\\n"\n                + ") COMMENT = \'用户表\';";\n        jdbcTemplate.execute(sqlStatement);\n    }\n\n}\n\n\n\n# 测试类\n\nimport lombok.extern.slf4j.Slf4j;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.test.annotation.Rollback;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\n@Slf4j\n@Rollback\n@SpringBootTest(classes = { SpringBootDataJdbcApplication.class })\npublic class DataJdbcMysqlDataSourceTest {\n\n    @Autowired\n    private UserDao userDAO;\n\n    @BeforeEach\n    public void before() {\n        userDAO.truncate();\n    }\n\n    @Test\n    public void insert() {\n        userDAO.insert(new User("张三", 18, "北京", "user1@163.com"));\n        User linda = userDAO.queryByName("张三");\n        assertThat(linda).isNotNull();\n    }\n\n    @Test\n    public void batchInsert() {\n        List<User> users = new ArrayList<>();\n        users.add(new User("张三", 18, "北京", "user1@163.com"));\n        users.add(new User("李四", 19, "上海", "user1@163.com"));\n        users.add(new User("王五", 18, "南京", "user1@163.com"));\n        users.add(new User("赵六", 20, "武汉", "user1@163.com"));\n\n        userDAO.batchInsert(users);\n        int count = userDAO.count();\n        assertThat(count).isEqualTo(4);\n\n        List<User> list = userDAO.list();\n        assertThat(list).isNotEmpty().hasSize(4);\n        list.forEach(user -> {\n            log.info(user.toString());\n        });\n    }\n\n    @Test\n    public void delete() {\n        List<User> users = new ArrayList<>();\n        users.add(new User("张三", 18, "北京", "user1@163.com"));\n        users.add(new User("李四", 19, "上海", "user1@163.com"));\n        users.add(new User("王五", 18, "南京", "user1@163.com"));\n        users.add(new User("赵六", 20, "武汉", "user1@163.com"));\n        userDAO.batchInsert(users);\n\n        userDAO.deleteByName("张三");\n        User user = userDAO.queryByName("张三");\n        assertThat(user).isNull();\n\n        userDAO.deleteAll();\n        List<User> list = userDAO.list();\n        assertThat(list).isEmpty();\n    }\n\n    @Test\n    public void update() {\n        userDAO.insert(new User("张三", 18, "北京", "user1@163.com"));\n        User oldUser = userDAO.queryByName("张三");\n        oldUser.setName("张三丰");\n        userDAO.update(oldUser);\n        User newUser = userDAO.queryByName("张三丰");\n        assertThat(newUser).isNotNull();\n    }\n\n}\n\n\n\n# Spring Boot JDBC\n\n> 完整示例：spring-boot-data-jdbc\n\n\n# 引入 Spring Boot 依赖\n\n你可以通过 Spring Boot 官方的初始化器（Spring Initializr）选择需要的组件来创建一个 Spring Boot 工程。或者，直接在 pom.xml 中引入所需要的依赖：\n\n  <parent>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-parent</artifactId>\n    <version>2.7.7</version>\n  </parent>\n\n  <dependencies>\n    <dependency>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter-data-jdbc</artifactId>\n    </dependency>\n    <dependency>\n      <groupId>mysql</groupId>\n      <artifactId>mysql-connector-java</artifactId>\n    </dependency>\n  </dependencies>\n\n\n\n# 配置数据源\n\n引入依赖后，需要在 application.properties 或 application.yml 文件中指定数据源配置。\n\n下面是一个最基本的数据源配置示例：\n\nspring.datasource.url = jdbc:mysql://localhost:3306/spring_tutorial?serverTimezone=UTC&useUnicode=true&characterEncoding=utf8\nspring.datasource.driver-class-name = com.mysql.cj.jdbc.Driver\nspring.datasource.username = root\nspring.datasource.password = root\n\n\n需要根据实际情况，替换 url、username、password。\n\n\n# 测试\n\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.boot.CommandLineRunner;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.jdbc.core.JdbcTemplate;\n\nimport java.sql.Connection;\nimport javax.sql.DataSource;\n\n@Slf4j\n@SpringBootApplication\npublic class SpringBootDataJdbcApplication implements CommandLineRunner {\n\n    private final JdbcTemplate jdbcTemplate;\n\n    public SpringBootDataJdbcApplication(JdbcTemplate jdbcTemplate) {\n        this.jdbcTemplate = jdbcTemplate;\n    }\n\n    public static void main(String[] args) {\n        SpringApplication.run(SpringBootDataJdbcApplication.class, args);\n    }\n\n    @Override\n    public void run(String... args) throws Exception {\n        DataSource dataSource = jdbcTemplate.getDataSource();\n\n        Connection connection;\n        if (dataSource != null) {\n            connection = dataSource.getConnection();\n        } else {\n            log.error("连接数据源失败！");\n            return;\n        }\n\n        if (connection != null) {\n            log.info("数据源 Url: {}", connection.getMetaData().getURL());\n        } else {\n            log.error("连接数据源失败！");\n        }\n    }\n\n}\n\n\n运行 main 方法后，控制台会输出以下内容，表示数据源连接成功：\n\n20:50:18.449 [main] [INFO ] i.g.d.s.d.SpringBootDataJdbcApplication.run - 数据源 Url: jdbc:mysql://localhost:3306/spring_tutorial?serverTimezone=UTC&useUnicode=true&characterEncoding=utf8\n\n\n\n# Spring JDBC\n\n> 完整示例：spring-data-jdbc\n\nspring-boot-starter-data-jdbc 引入了 spring-jdbc ，其 JDBC 特性就是基于 spring-jdbc。\n\n\n# 引入 Spring 依赖\n\n在 pom.xml 中引入所需要的依赖：\n\n    <dependencies>\n        <dependency>\n            <groupId>com.alibaba</groupId>\n            <artifactId>druid</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n        </dependency>\n\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-context-support</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-jdbc</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-tx</artifactId>\n        </dependency>\n    </dependencies>\n</project>\n\n\n\n# 基于 JDBC 驱动的数据源配置\n\n下面是一个 mysql 的 JDBC 数据源配置实例：\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n    xmlns:context="http://www.springframework.org/schema/context"\n    xmlns:jdbc="http://www.springframework.org/schema/jdbc"\n    xmlns="http://www.springframework.org/schema/beans"\n    xsi:schemaLocation="http://www.springframework.org/schema/beans\n            http://www.springframework.org/schema/beans/spring-beans.xsd\n            http://www.springframework.org/schema/context\n            http://www.springframework.org/schema/context/spring-context.xsd\n            http://www.springframework.org/schema/jdbc\n            http://www.springframework.org/schema/jdbc/spring-jdbc.xsd">\n\n    \x3c!-- 引入配置文件 --\x3e\n    <context:property-placeholder location="classpath:properties/mysql.properties" />\n\n    \x3c!-- 使用JDBC驱动的数据源 --\x3e\n    \x3c!-- (1)在每个连接请求时都会返回一个新建的连接。性能不高 --\x3e\n    <bean id="dataSource1" class="org.springframework.jdbc.datasource.DriverManagerDataSource">\n        <property name="driverClassName" value="${jdbc.driver}" />\n        <property name="url" value="${jdbc.url}" />\n        <property name="username" value="${jdbc.username}" />\n        <property name="password" value="${jdbc.password}" />\n    </bean>\n\n    \x3c!-- (2)在每个连接请求时都会返回同一个连接。不适用于多线程 --\x3e\n    <bean id="dataSource2" class="org.springframework.jdbc.datasource.SingleConnectionDataSource">\n        <property name="driverClassName" value="${jdbc.driver}" />\n        <property name="url" value="${jdbc.url}" />\n        <property name="username" value="${jdbc.username}" />\n        <property name="password" value="${jdbc.password}" />\n    </bean>\n\n    \x3c!-- JDBC模板 --\x3e\n    <bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">\n        <constructor-arg ref="dataSource1" />\n    </bean>\n    <bean id="userDao" class="io.github.dunwu.springboot.data.jdbc.UserDaoImpl">\n        <constructor-arg ref="jdbcTemplate" />\n    </bean>\n\n    \x3c!-- 初始化数据表结构 --\x3e\n    <jdbc:initialize-database data-source="dataSource1" ignore-failures="ALL">\n        <jdbc:script location="classpath:sql/schema.sql" />\n        <jdbc:script location="classpath:sql/data.sql" />\n    </jdbc:initialize-database>\n</beans>\n\n\n\n# 测试\n\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\nimport org.springframework.test.context.ContextConfiguration;\nimport org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n\nimport java.io.IOException;\nimport java.sql.SQLException;\n\n@SuppressWarnings("all")\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(locations = { "classpath:data/spring-mysql.xml" })\npublic class MysqlJdbcTest {\n\n    @Autowired\n    private ApplicationContext ctx;\n\n    @Before\n    public void before() {\n        ctx = JdbcDemo.getMysqlApplicationContext();\n    }\n\n    @Test\n    public void testExecJdbcOper() throws SQLException, IOException {\n        UserDao userDao = (UserDaoImpl) ctx.getBean("userDao");\n        JdbcDemo.execJdbcOper(userDao);\n    }\n\n    @After\n    public void after() {\n        ((ClassPathXmlApplicationContext) ctx).close();\n    }\n\n}\n\n\n\n# JdbcTemplate API\n\nSpring 将数据访问的样板式代码提取到模板类中。Spring 提供了 3 个 JDBC 模板类：\n\n * JdbcTemplate：最基本的 Spring JDBC 模板，这个模板支持最简单的 JDBC 数据库访问功能以及简单的索引参数查询。\n * SimpleJdbcTemplate：改模板类利用 Java 5 的一些特性，如自动装箱、泛型以及可变参数列表来简化 JDBC 模板的使用。\n * NamedParameterJdbcTemplate：使用该模板类执行查询时，可以将查询值以命名参数的形式绑定到 SQL 中，而不是使用简单的索引参数。\n\nspring-jdbc 最核心的 API 无疑就是 JdbcTemplate，可以说所有的 JDBC 数据访问，几乎都是围绕着这个类去工作的。Spring 对数据库的操作在 Jdbc 层面做了深层次的封装，利用依赖注入，把数据源配置装配到 JdbcTemplate 中，再由 JdbcTemplate 负责具体的数据访问。\n\nJdbcTemplate 主要提供以下几类方法：\n\n * execute 方法：可以用于执行任何 SQL 语句，一般用于执行 DDL 语句；\n * update 方法及 batchUpdate 方法：update 方法用于执行新增、修改、删除等语句；batchUpdate 方法用于执行批处理相关语句；\n * query 方法及 queryForXXX 方法：用于执行查询相关语句；\n * call 方法：用于执行存储过程、函数相关语句。\n\n为了方便演示，以下增删改查操作都围绕一个名为 user 的表（该表的主键 id 是自增序列）进行，该表的数据实体如下：\n\npublic class User {\n    private Integer id;\n    private String name;\n    private Integer age;\n\n    // 省略 getter/setter\n}\n\n\n数据实体只要是一个纯粹的 Java Bean 即可，无需任何注解修饰。\n\n\n# execute 方法\n\n使用 execute 执行 DDL 语句，创建一个名为 test 的数据库，并在此数据库下新建一个名为 user 的表。\n\npublic void recreateTable() {\n    jdbcTemplate.execute("DROP DATABASE IF EXISTS test");\n    jdbcTemplate.execute("CREATE DATABASE test");\n    jdbcTemplate.execute("USE test");\n    jdbcTemplate.execute("DROP TABLE if EXISTS user");\n    jdbcTemplate.execute("DROP TABLE if EXISTS user");\n    // @formatter:off\n    StringBuilder sb = new StringBuilder();\n    sb.append("CREATE TABLE user (id int (10) unsigned NOT NULL AUTO_INCREMENT,\\n")\n        .append("name varchar (64) NOT NULL DEFAULT \'\',\\n")\n        .append("age tinyint (3) NOT NULL DEFAULT 0,\\n")\n        .append("PRIMARY KEY (ID));\\n");\n    // @formatter:on\n    jdbcTemplate.execute(sb.toString());\n}\n\n\n\n# update 方法\n\n新增数据\n\npublic void insert(String name, Integer age) {\n    jdbcTemplate.update("INSERT INTO user(name, age) VALUES(?, ?)", name, age);\n}\n\n\n删除数据\n\npublic void delete(String name) {\n    jdbcTemplate.update("DELETE FROM user WHERE name = ?", name);\n}\n\n\n修改数据\n\npublic void update(User user) {\n    jdbcTemplate.update("UPDATE USER SET name=?, age=? WHERE id=?", user.getName(), user.getAge(), user.getId());\n}\n\n\n批处理\n\npublic void batchInsert(List<User> users) {\n    String sql = "INSERT INTO user(name, age) VALUES(?, ?)";\n\n    List<Object[]> params = new ArrayList<>();\n\n    users.forEach(item -> {\n        params.add(new Object[] {item.getName(), item.getAge()});\n    });\n    jdbcTemplate.batchUpdate(sql, params);\n}\n\n\n\n# query 方法\n\n查单个对象\n\npublic User queryByName(String name) {\n    try {\n        return jdbcTemplate\n            .queryForObject("SELECT * FROM user WHERE name = ?", new BeanPropertyRowMapper<>(User.class), name);\n    } catch (EmptyResultDataAccessException e) {\n        return null;\n    }\n}\n\n\n查多个对象\n\npublic List<User> list() {\n    return jdbcTemplate.query("select * from USER", new BeanPropertyRowMapper(User.class));\n}\n\n\n获取某个记录某列或者 count、avg、sum 等函数返回唯一值\n\npublic Integer count() {\n    try {\n        return jdbcTemplate.queryForObject("SELECT COUNT(*) FROM user", Integer.class);\n    } catch (EmptyResultDataAccessException e) {\n        return null;\n    }\n}\n\n\n\n# SpringBoot JDBC 配置\n\n\n# JdbcTemplateAutoConfiguration 类\n\nJdbcTemplateAutoConfiguration 是 JdbcTemplate 自动配置类，它负责实例化 JdbcTemplate。\n\n@Configuration(proxyBeanMethods = false)\n@ConditionalOnClass({ DataSource.class, JdbcTemplate.class })\n@ConditionalOnSingleCandidate(DataSource.class)\n@AutoConfigureAfter(DataSourceAutoConfiguration.class)\n@EnableConfigurationProperties(JdbcProperties.class)\n@Import({ JdbcTemplateConfiguration.class, NamedParameterJdbcTemplateConfiguration.class })\npublic class JdbcTemplateAutoConfiguration {\n\n}\n\n\nJdbcTemplateAutoConfiguration 类的源码解读：\n\n * @AutoConfigureAfter(DataSourceAutoConfiguration.class) 表明 JdbcTemplateAutoConfiguration 必须在 DataSourceAutoConfiguration 执行完之后才开始工作，这意味着：JdbcTemplate 的初始化必须在 DataSource 初始化之后。\n * JdbcProperties 是 JdbcTemplateAutoConfiguration 的配置选项类，允许使用者通过设置选项控制 JdbcTemplate 初始化行为。\n * @Import({ JdbcTemplateConfiguration.class, NamedParameterJdbcTemplateConfiguration.class }) 表明引入 JdbcTemplateConfiguration、NamedParameterJdbcTemplateConfiguration 两个配置类，具体的实例化 JdbcTemplate 的工作也是放在这两个配置中完成。\n\n\n# JdbcTemplateConfiguration 类\n\nJdbcTemplateConfiguration 源码如下：\n\n@Configuration(proxyBeanMethods = false)\n@ConditionalOnMissingBean(JdbcOperations.class)\nclass JdbcTemplateConfiguration {\n\n\t@Bean\n\t@Primary\n\tJdbcTemplate jdbcTemplate(DataSource dataSource, JdbcProperties properties) {\n\t\tJdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);\n\t\tJdbcProperties.Template template = properties.getTemplate();\n\t\tjdbcTemplate.setFetchSize(template.getFetchSize());\n\t\tjdbcTemplate.setMaxRows(template.getMaxRows());\n\t\tif (template.getQueryTimeout() != null) {\n\t\t\tjdbcTemplate.setQueryTimeout((int) template.getQueryTimeout().getSeconds());\n\t\t}\n\t\treturn jdbcTemplate;\n\t}\n\n}\n\n\nJdbcTemplateConfiguration 源码解读：JdbcTemplateConfiguration 中根据 DataSource 和 JdbcProperties 实例化了一个 JdbcTemplate。\n\n\n# NamedParameterJdbcTemplateConfiguration 类\n\nNamedParameterJdbcTemplateConfiguration 源码如下：\n\n@Configuration(proxyBeanMethods = false)\n@ConditionalOnSingleCandidate(JdbcTemplate.class)\n@ConditionalOnMissingBean(NamedParameterJdbcOperations.class)\nclass NamedParameterJdbcTemplateConfiguration {\n\n\t@Bean\n\t@Primary\n\tNamedParameterJdbcTemplate namedParameterJdbcTemplate(JdbcTemplate jdbcTemplate) {\n\t\treturn new NamedParameterJdbcTemplate(jdbcTemplate);\n\t}\n\n}\n\n\nNamedParameterJdbcTemplateConfiguration 源码解读：NamedParameterJdbcTemplateConfiguration 中根据 JdbcTemplate 实例化了一个 NamedParameterJdbcTemplate。\n\n\n# spring-data-jdbc\n\nSpring Data 项目包含了对 JDBC 的存储库支持，并将自动为 CrudRepository 上的方法生成 SQL。对于更高级的查询，提供了 @Query 注解。\n\n当 classpath 上存在必要的依赖项时，Spring Boot 将自动配置 Spring Data 的 JDBC 存储库。它们可以通过 spring-boot-starter-data-jdbc 的单一依赖项添加到项目中。如有必要，可以通过将 @EnableJdbcRepositories 批注或 JdbcConfiguration 子类添加到应用程序来控制 Spring Data JDBC 的配置。\n\n> 更多 Spring Data JDBC 细节，可以参考 Spring Data JDBC 官方文档。\n\n\n# 参考资料\n\n * Spring 官网\n * Spring Framework 官方文档\n * Spring Boot 官方文档',normalizedContent:'# spring 之 jdbc\n\njdbc 是 java 语言中用来规范客户端程序如何访问数据库的应用程序接口，提供了增、删、改、查数据库的方法。\n\n\n# jdbc 入门示例\n\njdbc 的工作步骤大致如下：\n\n 1. 创建实体类。\n 2. 声明数据库读写接口的 dao 接口。定义 dao 的好处在于对于数据层上层的业务，调用 dao 时仅关注对外暴露的读写方法，而不考虑底层的具体持久化方式。这样，便于替换持久化方式。\n 3. 创建一个 dao 接口的实现类，使用 spring 的 jdbc 模板去实现接口。\n 4. 最后，定义一个 dao 接口的实现类的 javabean，并将数据源注入进去。\n\n假设，我们要通过 spring + jdbc 访问一张 mysql 数据表 user，user 表的数据结构如下：\n\n-- 创建用户表\ncreate table `user` (\n    `id`      bigint(20) unsigned not null auto_increment comment \'id\',\n    `name`    varchar(255)        not null default \'\' comment \'用户名\',\n    `age`     int(3)              not null default 0 comment \'年龄\',\n    `address` varchar(255)        not null default \'\' comment \'地址\',\n    `email`   varchar(255)        not null default \'\' comment \'邮件\',\n    primary key (`id`),\n    unique (`name`)\n) comment = \'用户表\';\n\ninsert into `user` (`name`, `age`, `address`, `email`)\nvalues (\'张三\', 18, \'北京\', \'xxx@163.com\');\ninsert into `user` (`name`, `age`, `address`, `email`)\nvalues (\'李四\', 19, \'上海\', \'xxx@163.com\');\n\n\n\n# 定义实体\n\nimport lombok.allargsconstructor;\nimport lombok.data;\nimport lombok.noargsconstructor;\nimport lombok.tostring;\n\nimport java.util.objects;\n\n@data\n@tostring\n@noargsconstructor\n@allargsconstructor\npublic class user {\n    private long id;\n    private string name;\n    private integer age;\n    private string address;\n    private string email;\n}\n\n\n\n# 定义 dao 接口\n\nimport org.springframework.jdbc.core.jdbctemplate;\n\nimport java.util.list;\n\n/**\n * user 表 dao 接口\n *\n * @author <a href="mailto:forbreak@163.com">zhang peng</a>\n * @since 2019-11-18\n */\npublic interface userdao {\n\n    // dml\n    // -------------------------------------------------------------------\n    void insert(user user);\n\n    void batchinsert(list<user> users);\n\n    void deletebyname(string name);\n\n    void deleteall();\n\n    void update(user user);\n\n    integer count();\n\n    list<user> list();\n\n    user querybyname(string name);\n\n    jdbctemplate getjdbctemplate();\n\n    // ddl\n    // -------------------------------------------------------------------\n    void truncate();\n\n    void recreatetable();\n\n}\n\n\n\n# 定义 dao 实现类\n\n通过 jdbctemplate 执行对应数据源符合语法的 sql，即可完成各种数据库访问。\n\npackage io.github.dunwu.springboot.core.data.jdbc;\n\nimport org.springframework.dao.emptyresultdataaccessexception;\nimport org.springframework.jdbc.core.beanpropertyrowmapper;\nimport org.springframework.jdbc.core.jdbctemplate;\nimport org.springframework.stereotype.repository;\nimport org.springframework.transaction.annotation.transactional;\n\nimport java.util.arraylist;\nimport java.util.list;\n\n/**\n * user 表 dao 接口实现类\n *\n * @author <a href="mailto:forbreak@163.com">zhang peng</a>\n * @since 2019-11-18\n */\n@repository\npublic class userdaoimpl implements userdao {\n\n    private jdbctemplate jdbctemplate;\n\n    public userdaoimpl(jdbctemplate jdbctemplate) {\n        this.jdbctemplate = jdbctemplate;\n    }\n\n    @override\n    public void insert(user user) {\n        jdbctemplate.update("insert into user(name, age, address, email) values(?, ?, ?, ?)",\n            user.getname(), user.getage(), user.getaddress(), user.getemail());\n    }\n\n    @override\n    @transactional(rollbackfor = exception.class)\n    public void batchinsert(list<user> users) {\n        string sql = "insert into user(name, age, address, email) values(?, ?, ?, ?)";\n\n        list<object[]> params = new arraylist<>();\n\n        users.foreach(user -> {\n            params.add(new object[] { user.getname(), user.getage(), user.getaddress(), user.getemail() });\n        });\n        jdbctemplate.batchupdate(sql, params);\n    }\n\n    @override\n    public void deletebyname(string name) {\n        jdbctemplate.update("delete from user where name = ?", name);\n    }\n\n    @override\n    @transactional(rollbackfor = exception.class)\n    public void deleteall() {\n        jdbctemplate.execute("delete from user");\n    }\n\n    @override\n    public void update(user user) {\n        jdbctemplate.update("update user set name=?, age=?, address=?, email=? where id=?",\n            user.getname(), user.getage(), user.getaddress(), user.getemail(), user.getid());\n    }\n\n    @override\n    public integer count() {\n        try {\n            return jdbctemplate.queryforobject("select count(*) from user", integer.class);\n        } catch (emptyresultdataaccessexception e) {\n            return null;\n        }\n    }\n\n    @override\n    public list<user> list() {\n        return jdbctemplate.query("select * from user", new beanpropertyrowmapper<>(user.class));\n    }\n\n    @override\n    public user querybyname(string name) {\n        try {\n            return jdbctemplate.queryforobject("select * from user where name = ?",\n                new beanpropertyrowmapper<>(user.class), name);\n        } catch (emptyresultdataaccessexception e) {\n            return null;\n        }\n    }\n\n    @override\n    public jdbctemplate getjdbctemplate() {\n        return jdbctemplate;\n    }\n\n    @override\n    public void truncate() {\n        jdbctemplate.execute("truncate table user");\n    }\n\n    @override\n    public void recreatetable() {\n        jdbctemplate.execute("drop table if exists user");\n\n        string sqlstatement =\n            "create table if not exists user (\\n"\n                + "    id      bigint(10) unsigned not null auto_increment comment \'id\',\\n"\n                + "    name    varchar(255)         not null default \'\' comment \'用户名\',\\n"\n                + "    age     int(3)              not null default 0 comment \'年龄\',\\n"\n                + "    address varchar(255)         not null default \'\' comment \'地址\',\\n"\n                + "    email   varchar(255)         not null default \'\' comment \'邮件\',\\n"\n                + "    primary key (id)\\n"\n                + ") comment = \'用户表\';";\n        jdbctemplate.execute(sqlstatement);\n    }\n\n}\n\n\n\n# 测试类\n\nimport lombok.extern.slf4j.slf4j;\nimport org.junit.jupiter.api.beforeeach;\nimport org.junit.jupiter.api.test;\nimport org.springframework.beans.factory.annotation.autowired;\nimport org.springframework.boot.test.context.springboottest;\nimport org.springframework.test.annotation.rollback;\n\nimport java.util.arraylist;\nimport java.util.list;\n\nimport static org.assertj.core.api.assertions.assertthat;\n\n@slf4j\n@rollback\n@springboottest(classes = { springbootdatajdbcapplication.class })\npublic class datajdbcmysqldatasourcetest {\n\n    @autowired\n    private userdao userdao;\n\n    @beforeeach\n    public void before() {\n        userdao.truncate();\n    }\n\n    @test\n    public void insert() {\n        userdao.insert(new user("张三", 18, "北京", "user1@163.com"));\n        user linda = userdao.querybyname("张三");\n        assertthat(linda).isnotnull();\n    }\n\n    @test\n    public void batchinsert() {\n        list<user> users = new arraylist<>();\n        users.add(new user("张三", 18, "北京", "user1@163.com"));\n        users.add(new user("李四", 19, "上海", "user1@163.com"));\n        users.add(new user("王五", 18, "南京", "user1@163.com"));\n        users.add(new user("赵六", 20, "武汉", "user1@163.com"));\n\n        userdao.batchinsert(users);\n        int count = userdao.count();\n        assertthat(count).isequalto(4);\n\n        list<user> list = userdao.list();\n        assertthat(list).isnotempty().hassize(4);\n        list.foreach(user -> {\n            log.info(user.tostring());\n        });\n    }\n\n    @test\n    public void delete() {\n        list<user> users = new arraylist<>();\n        users.add(new user("张三", 18, "北京", "user1@163.com"));\n        users.add(new user("李四", 19, "上海", "user1@163.com"));\n        users.add(new user("王五", 18, "南京", "user1@163.com"));\n        users.add(new user("赵六", 20, "武汉", "user1@163.com"));\n        userdao.batchinsert(users);\n\n        userdao.deletebyname("张三");\n        user user = userdao.querybyname("张三");\n        assertthat(user).isnull();\n\n        userdao.deleteall();\n        list<user> list = userdao.list();\n        assertthat(list).isempty();\n    }\n\n    @test\n    public void update() {\n        userdao.insert(new user("张三", 18, "北京", "user1@163.com"));\n        user olduser = userdao.querybyname("张三");\n        olduser.setname("张三丰");\n        userdao.update(olduser);\n        user newuser = userdao.querybyname("张三丰");\n        assertthat(newuser).isnotnull();\n    }\n\n}\n\n\n\n# spring boot jdbc\n\n> 完整示例：spring-boot-data-jdbc\n\n\n# 引入 spring boot 依赖\n\n你可以通过 spring boot 官方的初始化器（spring initializr）选择需要的组件来创建一个 spring boot 工程。或者，直接在 pom.xml 中引入所需要的依赖：\n\n  <parent>\n    <groupid>org.springframework.boot</groupid>\n    <artifactid>spring-boot-starter-parent</artifactid>\n    <version>2.7.7</version>\n  </parent>\n\n  <dependencies>\n    <dependency>\n      <groupid>org.springframework.boot</groupid>\n      <artifactid>spring-boot-starter-data-jdbc</artifactid>\n    </dependency>\n    <dependency>\n      <groupid>mysql</groupid>\n      <artifactid>mysql-connector-java</artifactid>\n    </dependency>\n  </dependencies>\n\n\n\n# 配置数据源\n\n引入依赖后，需要在 application.properties 或 application.yml 文件中指定数据源配置。\n\n下面是一个最基本的数据源配置示例：\n\nspring.datasource.url = jdbc:mysql://localhost:3306/spring_tutorial?servertimezone=utc&useunicode=true&characterencoding=utf8\nspring.datasource.driver-class-name = com.mysql.cj.jdbc.driver\nspring.datasource.username = root\nspring.datasource.password = root\n\n\n需要根据实际情况，替换 url、username、password。\n\n\n# 测试\n\nimport lombok.extern.slf4j.slf4j;\nimport org.springframework.boot.commandlinerunner;\nimport org.springframework.boot.springapplication;\nimport org.springframework.boot.autoconfigure.springbootapplication;\nimport org.springframework.jdbc.core.jdbctemplate;\n\nimport java.sql.connection;\nimport javax.sql.datasource;\n\n@slf4j\n@springbootapplication\npublic class springbootdatajdbcapplication implements commandlinerunner {\n\n    private final jdbctemplate jdbctemplate;\n\n    public springbootdatajdbcapplication(jdbctemplate jdbctemplate) {\n        this.jdbctemplate = jdbctemplate;\n    }\n\n    public static void main(string[] args) {\n        springapplication.run(springbootdatajdbcapplication.class, args);\n    }\n\n    @override\n    public void run(string... args) throws exception {\n        datasource datasource = jdbctemplate.getdatasource();\n\n        connection connection;\n        if (datasource != null) {\n            connection = datasource.getconnection();\n        } else {\n            log.error("连接数据源失败！");\n            return;\n        }\n\n        if (connection != null) {\n            log.info("数据源 url: {}", connection.getmetadata().geturl());\n        } else {\n            log.error("连接数据源失败！");\n        }\n    }\n\n}\n\n\n运行 main 方法后，控制台会输出以下内容，表示数据源连接成功：\n\n20:50:18.449 [main] [info ] i.g.d.s.d.springbootdatajdbcapplication.run - 数据源 url: jdbc:mysql://localhost:3306/spring_tutorial?servertimezone=utc&useunicode=true&characterencoding=utf8\n\n\n\n# spring jdbc\n\n> 完整示例：spring-data-jdbc\n\nspring-boot-starter-data-jdbc 引入了 spring-jdbc ，其 jdbc 特性就是基于 spring-jdbc。\n\n\n# 引入 spring 依赖\n\n在 pom.xml 中引入所需要的依赖：\n\n    <dependencies>\n        <dependency>\n            <groupid>com.alibaba</groupid>\n            <artifactid>druid</artifactid>\n        </dependency>\n        <dependency>\n            <groupid>mysql</groupid>\n            <artifactid>mysql-connector-java</artifactid>\n        </dependency>\n\n        <dependency>\n            <groupid>org.springframework</groupid>\n            <artifactid>spring-context-support</artifactid>\n        </dependency>\n        <dependency>\n            <groupid>org.springframework</groupid>\n            <artifactid>spring-jdbc</artifactid>\n        </dependency>\n        <dependency>\n            <groupid>org.springframework</groupid>\n            <artifactid>spring-tx</artifactid>\n        </dependency>\n    </dependencies>\n</project>\n\n\n\n# 基于 jdbc 驱动的数据源配置\n\n下面是一个 mysql 的 jdbc 数据源配置实例：\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n    xmlns:context="http://www.springframework.org/schema/context"\n    xmlns:jdbc="http://www.springframework.org/schema/jdbc"\n    xmlns="http://www.springframework.org/schema/beans"\n    xsi:schemalocation="http://www.springframework.org/schema/beans\n            http://www.springframework.org/schema/beans/spring-beans.xsd\n            http://www.springframework.org/schema/context\n            http://www.springframework.org/schema/context/spring-context.xsd\n            http://www.springframework.org/schema/jdbc\n            http://www.springframework.org/schema/jdbc/spring-jdbc.xsd">\n\n    \x3c!-- 引入配置文件 --\x3e\n    <context:property-placeholder location="classpath:properties/mysql.properties" />\n\n    \x3c!-- 使用jdbc驱动的数据源 --\x3e\n    \x3c!-- (1)在每个连接请求时都会返回一个新建的连接。性能不高 --\x3e\n    <bean id="datasource1" class="org.springframework.jdbc.datasource.drivermanagerdatasource">\n        <property name="driverclassname" value="${jdbc.driver}" />\n        <property name="url" value="${jdbc.url}" />\n        <property name="username" value="${jdbc.username}" />\n        <property name="password" value="${jdbc.password}" />\n    </bean>\n\n    \x3c!-- (2)在每个连接请求时都会返回同一个连接。不适用于多线程 --\x3e\n    <bean id="datasource2" class="org.springframework.jdbc.datasource.singleconnectiondatasource">\n        <property name="driverclassname" value="${jdbc.driver}" />\n        <property name="url" value="${jdbc.url}" />\n        <property name="username" value="${jdbc.username}" />\n        <property name="password" value="${jdbc.password}" />\n    </bean>\n\n    \x3c!-- jdbc模板 --\x3e\n    <bean id="jdbctemplate" class="org.springframework.jdbc.core.jdbctemplate">\n        <constructor-arg ref="datasource1" />\n    </bean>\n    <bean id="userdao" class="io.github.dunwu.springboot.data.jdbc.userdaoimpl">\n        <constructor-arg ref="jdbctemplate" />\n    </bean>\n\n    \x3c!-- 初始化数据表结构 --\x3e\n    <jdbc:initialize-database data-source="datasource1" ignore-failures="all">\n        <jdbc:script location="classpath:sql/schema.sql" />\n        <jdbc:script location="classpath:sql/data.sql" />\n    </jdbc:initialize-database>\n</beans>\n\n\n\n# 测试\n\n\nimport org.junit.after;\nimport org.junit.before;\nimport org.junit.test;\nimport org.junit.runner.runwith;\nimport org.springframework.beans.factory.annotation.autowired;\nimport org.springframework.context.applicationcontext;\nimport org.springframework.context.support.classpathxmlapplicationcontext;\nimport org.springframework.test.context.contextconfiguration;\nimport org.springframework.test.context.junit4.springjunit4classrunner;\n\nimport java.io.ioexception;\nimport java.sql.sqlexception;\n\n@suppresswarnings("all")\n@runwith(springjunit4classrunner.class)\n@contextconfiguration(locations = { "classpath:data/spring-mysql.xml" })\npublic class mysqljdbctest {\n\n    @autowired\n    private applicationcontext ctx;\n\n    @before\n    public void before() {\n        ctx = jdbcdemo.getmysqlapplicationcontext();\n    }\n\n    @test\n    public void testexecjdbcoper() throws sqlexception, ioexception {\n        userdao userdao = (userdaoimpl) ctx.getbean("userdao");\n        jdbcdemo.execjdbcoper(userdao);\n    }\n\n    @after\n    public void after() {\n        ((classpathxmlapplicationcontext) ctx).close();\n    }\n\n}\n\n\n\n# jdbctemplate api\n\nspring 将数据访问的样板式代码提取到模板类中。spring 提供了 3 个 jdbc 模板类：\n\n * jdbctemplate：最基本的 spring jdbc 模板，这个模板支持最简单的 jdbc 数据库访问功能以及简单的索引参数查询。\n * simplejdbctemplate：改模板类利用 java 5 的一些特性，如自动装箱、泛型以及可变参数列表来简化 jdbc 模板的使用。\n * namedparameterjdbctemplate：使用该模板类执行查询时，可以将查询值以命名参数的形式绑定到 sql 中，而不是使用简单的索引参数。\n\nspring-jdbc 最核心的 api 无疑就是 jdbctemplate，可以说所有的 jdbc 数据访问，几乎都是围绕着这个类去工作的。spring 对数据库的操作在 jdbc 层面做了深层次的封装，利用依赖注入，把数据源配置装配到 jdbctemplate 中，再由 jdbctemplate 负责具体的数据访问。\n\njdbctemplate 主要提供以下几类方法：\n\n * execute 方法：可以用于执行任何 sql 语句，一般用于执行 ddl 语句；\n * update 方法及 batchupdate 方法：update 方法用于执行新增、修改、删除等语句；batchupdate 方法用于执行批处理相关语句；\n * query 方法及 queryforxxx 方法：用于执行查询相关语句；\n * call 方法：用于执行存储过程、函数相关语句。\n\n为了方便演示，以下增删改查操作都围绕一个名为 user 的表（该表的主键 id 是自增序列）进行，该表的数据实体如下：\n\npublic class user {\n    private integer id;\n    private string name;\n    private integer age;\n\n    // 省略 getter/setter\n}\n\n\n数据实体只要是一个纯粹的 java bean 即可，无需任何注解修饰。\n\n\n# execute 方法\n\n使用 execute 执行 ddl 语句，创建一个名为 test 的数据库，并在此数据库下新建一个名为 user 的表。\n\npublic void recreatetable() {\n    jdbctemplate.execute("drop database if exists test");\n    jdbctemplate.execute("create database test");\n    jdbctemplate.execute("use test");\n    jdbctemplate.execute("drop table if exists user");\n    jdbctemplate.execute("drop table if exists user");\n    // @formatter:off\n    stringbuilder sb = new stringbuilder();\n    sb.append("create table user (id int (10) unsigned not null auto_increment,\\n")\n        .append("name varchar (64) not null default \'\',\\n")\n        .append("age tinyint (3) not null default 0,\\n")\n        .append("primary key (id));\\n");\n    // @formatter:on\n    jdbctemplate.execute(sb.tostring());\n}\n\n\n\n# update 方法\n\n新增数据\n\npublic void insert(string name, integer age) {\n    jdbctemplate.update("insert into user(name, age) values(?, ?)", name, age);\n}\n\n\n删除数据\n\npublic void delete(string name) {\n    jdbctemplate.update("delete from user where name = ?", name);\n}\n\n\n修改数据\n\npublic void update(user user) {\n    jdbctemplate.update("update user set name=?, age=? where id=?", user.getname(), user.getage(), user.getid());\n}\n\n\n批处理\n\npublic void batchinsert(list<user> users) {\n    string sql = "insert into user(name, age) values(?, ?)";\n\n    list<object[]> params = new arraylist<>();\n\n    users.foreach(item -> {\n        params.add(new object[] {item.getname(), item.getage()});\n    });\n    jdbctemplate.batchupdate(sql, params);\n}\n\n\n\n# query 方法\n\n查单个对象\n\npublic user querybyname(string name) {\n    try {\n        return jdbctemplate\n            .queryforobject("select * from user where name = ?", new beanpropertyrowmapper<>(user.class), name);\n    } catch (emptyresultdataaccessexception e) {\n        return null;\n    }\n}\n\n\n查多个对象\n\npublic list<user> list() {\n    return jdbctemplate.query("select * from user", new beanpropertyrowmapper(user.class));\n}\n\n\n获取某个记录某列或者 count、avg、sum 等函数返回唯一值\n\npublic integer count() {\n    try {\n        return jdbctemplate.queryforobject("select count(*) from user", integer.class);\n    } catch (emptyresultdataaccessexception e) {\n        return null;\n    }\n}\n\n\n\n# springboot jdbc 配置\n\n\n# jdbctemplateautoconfiguration 类\n\njdbctemplateautoconfiguration 是 jdbctemplate 自动配置类，它负责实例化 jdbctemplate。\n\n@configuration(proxybeanmethods = false)\n@conditionalonclass({ datasource.class, jdbctemplate.class })\n@conditionalonsinglecandidate(datasource.class)\n@autoconfigureafter(datasourceautoconfiguration.class)\n@enableconfigurationproperties(jdbcproperties.class)\n@import({ jdbctemplateconfiguration.class, namedparameterjdbctemplateconfiguration.class })\npublic class jdbctemplateautoconfiguration {\n\n}\n\n\njdbctemplateautoconfiguration 类的源码解读：\n\n * @autoconfigureafter(datasourceautoconfiguration.class) 表明 jdbctemplateautoconfiguration 必须在 datasourceautoconfiguration 执行完之后才开始工作，这意味着：jdbctemplate 的初始化必须在 datasource 初始化之后。\n * jdbcproperties 是 jdbctemplateautoconfiguration 的配置选项类，允许使用者通过设置选项控制 jdbctemplate 初始化行为。\n * @import({ jdbctemplateconfiguration.class, namedparameterjdbctemplateconfiguration.class }) 表明引入 jdbctemplateconfiguration、namedparameterjdbctemplateconfiguration 两个配置类，具体的实例化 jdbctemplate 的工作也是放在这两个配置中完成。\n\n\n# jdbctemplateconfiguration 类\n\njdbctemplateconfiguration 源码如下：\n\n@configuration(proxybeanmethods = false)\n@conditionalonmissingbean(jdbcoperations.class)\nclass jdbctemplateconfiguration {\n\n\t@bean\n\t@primary\n\tjdbctemplate jdbctemplate(datasource datasource, jdbcproperties properties) {\n\t\tjdbctemplate jdbctemplate = new jdbctemplate(datasource);\n\t\tjdbcproperties.template template = properties.gettemplate();\n\t\tjdbctemplate.setfetchsize(template.getfetchsize());\n\t\tjdbctemplate.setmaxrows(template.getmaxrows());\n\t\tif (template.getquerytimeout() != null) {\n\t\t\tjdbctemplate.setquerytimeout((int) template.getquerytimeout().getseconds());\n\t\t}\n\t\treturn jdbctemplate;\n\t}\n\n}\n\n\njdbctemplateconfiguration 源码解读：jdbctemplateconfiguration 中根据 datasource 和 jdbcproperties 实例化了一个 jdbctemplate。\n\n\n# namedparameterjdbctemplateconfiguration 类\n\nnamedparameterjdbctemplateconfiguration 源码如下：\n\n@configuration(proxybeanmethods = false)\n@conditionalonsinglecandidate(jdbctemplate.class)\n@conditionalonmissingbean(namedparameterjdbcoperations.class)\nclass namedparameterjdbctemplateconfiguration {\n\n\t@bean\n\t@primary\n\tnamedparameterjdbctemplate namedparameterjdbctemplate(jdbctemplate jdbctemplate) {\n\t\treturn new namedparameterjdbctemplate(jdbctemplate);\n\t}\n\n}\n\n\nnamedparameterjdbctemplateconfiguration 源码解读：namedparameterjdbctemplateconfiguration 中根据 jdbctemplate 实例化了一个 namedparameterjdbctemplate。\n\n\n# spring-data-jdbc\n\nspring data 项目包含了对 jdbc 的存储库支持，并将自动为 crudrepository 上的方法生成 sql。对于更高级的查询，提供了 @query 注解。\n\n当 classpath 上存在必要的依赖项时，spring boot 将自动配置 spring data 的 jdbc 存储库。它们可以通过 spring-boot-starter-data-jdbc 的单一依赖项添加到项目中。如有必要，可以通过将 @enablejdbcrepositories 批注或 jdbcconfiguration 子类添加到应用程序来控制 spring data jdbc 的配置。\n\n> 更多 spring data jdbc 细节，可以参考 spring data jdbc 官方文档。\n\n\n# 参考资料\n\n * spring 官网\n * spring framework 官方文档\n * spring boot 官方文档',charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Spring 之事务",frontmatter:{title:"Spring 之事务",date:"2022-09-22T07:46:49.000Z",order:3,categories:["Java","框架","Spring","Spring数据"],tags:["Java","框架","Spring","SpringBoot","事务"],permalink:"/pages/128c54/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/02.Spring%E6%95%B0%E6%8D%AE/03.Spring%E4%B9%8B%E4%BA%8B%E5%8A%A1.html",relativePath:"01.Java/13.框架/01.Spring/02.Spring数据/03.Spring之事务.md",key:"v-69fe3d9a",path:"/pages/128c54/",headers:[{level:2,title:"理解事务",slug:"理解事务",normalizedTitle:"理解事务",charIndex:234},{level:3,title:"事务的特性",slug:"事务的特性",normalizedTitle:"事务的特性",charIndex:360},{level:3,title:"全局事务",slug:"全局事务",normalizedTitle:"全局事务",charIndex:334},{level:3,title:"本地事务",slug:"本地事务",normalizedTitle:"本地事务",charIndex:339},{level:3,title:"Spring 对事务的支持",slug:"spring-对事务的支持",normalizedTitle:"spring 对事务的支持",charIndex:1371},{level:3,title:"Spring 事务的优点",slug:"spring-事务的优点",normalizedTitle:"spring 事务的优点",charIndex:1727},{level:2,title:"核心 API",slug:"核心-api",normalizedTitle:"核心 api",charIndex:1950},{level:3,title:"TransactionManager",slug:"transactionmanager",normalizedTitle:"transactionmanager",charIndex:1961},{level:4,title:"PlatformTransactionManager",slug:"platformtransactionmanager",normalizedTitle:"platformtransactionmanager",charIndex:2078},{level:4,title:"JDBC 事务",slug:"jdbc-事务",normalizedTitle:"jdbc 事务",charIndex:3408},{level:4,title:"Hibernate 事务",slug:"hibernate-事务",normalizedTitle:"hibernate 事务",charIndex:3858},{level:4,title:"Java 持久化 API 事务（JPA）",slug:"java-持久化-api-事务-jpa",normalizedTitle:"java 持久化 api 事务（jpa）",charIndex:4402},{level:4,title:"Java 原生 API 事务（JTA）",slug:"java-原生-api-事务-jta",normalizedTitle:"java 原生 api 事务（jta）",charIndex:4907},{level:4,title:"ReactiveTransactionManager",slug:"reactivetransactionmanager",normalizedTitle:"reactivetransactionmanager",charIndex:2151},{level:3,title:"TransactionDefinition",slug:"transactiondefinition",normalizedTitle:"transactiondefinition",charIndex:2371},{level:4,title:"传播行为",slug:"传播行为",normalizedTitle:"传播行为",charIndex:6300},{level:4,title:"隔离级别",slug:"隔离级别",normalizedTitle:"隔离级别",charIndex:6342},{level:4,title:"只读",slug:"只读",normalizedTitle:"只读",charIndex:6451},{level:4,title:"事务超时",slug:"事务超时",normalizedTitle:"事务超时",charIndex:15e3},{level:4,title:"回滚规则",slug:"回滚规则",normalizedTitle:"回滚规则",charIndex:15126},{level:3,title:"TransactionStatus",slug:"transactionstatus",normalizedTitle:"transactionstatus",charIndex:2338},{level:3,title:"TransactionTemplate",slug:"transactiontemplate",normalizedTitle:"transactiontemplate",charIndex:15827},{level:2,title:"声明式事务管理",slug:"声明式事务管理",normalizedTitle:"声明式事务管理",charIndex:936},{level:3,title:"Spring 声明式事务管理的实现",slug:"spring-声明式事务管理的实现",normalizedTitle:"spring 声明式事务管理的实现",charIndex:17682},{level:3,title:"声明式事务示例",slug:"声明式事务示例",normalizedTitle:"声明式事务示例",charIndex:18398},{level:3,title:"回滚一个声明性事务",slug:"回滚一个声明性事务",normalizedTitle:"回滚一个声明性事务",charIndex:23170},{level:3,title:"为不同的 Bean 配置不同的事务语义",slug:"为不同的-bean-配置不同的事务语义",normalizedTitle:"为不同的 bean 配置不同的事务语义",charIndex:25286},{level:3,title:"<tx:advice/> 配置",slug:"tx-advice-配置",normalizedTitle:'<routerlink to="./tx:advice/">tx:advice/</routerlink> 配置',charIndex:null},{level:3,title:"使用 @Transactional 注解",slug:"使用-transactional-注解",normalizedTitle:"使用 @transactional 注解",charIndex:29784},{level:4,title:"@Transactional 配置",slug:"transactional-配置",normalizedTitle:"@transactional 配置",charIndex:31864},{level:4,title:"多事务管理器场景下使用 @Transactional",slug:"多事务管理器场景下使用-transactional",normalizedTitle:"多事务管理器场景下使用 @transactional",charIndex:34797},{level:4,title:"自定义组合注解",slug:"自定义组合注解",normalizedTitle:"自定义组合注解",charIndex:36024},{level:4,title:"事务传播",slug:"事务传播",normalizedTitle:"事务传播",charIndex:13015},{level:2,title:"JDBC 异常抽象",slug:"jdbc-异常抽象",normalizedTitle:"jdbc 异常抽象",charIndex:37551},{level:2,title:"Spring 事务最佳实践",slug:"spring-事务最佳实践",normalizedTitle:"spring 事务最佳实践",charIndex:37710},{level:3,title:"Spring 事务未生效",slug:"spring-事务未生效",normalizedTitle:"spring 事务未生效",charIndex:37730},{level:4,title:"@Transactional 方法必须是 public",slug:"transactional-方法必须是-public",normalizedTitle:"@transactional 方法必须是 public",charIndex:37821},{level:4,title:"必须通过 Spring 注入的 Bean 进行调用",slug:"必须通过-spring-注入的-bean-进行调用",normalizedTitle:"必须通过 spring 注入的 bean 进行调用",charIndex:38538},{level:3,title:"事务虽然生效但未回滚",slug:"事务虽然生效但未回滚",normalizedTitle:"事务虽然生效但未回滚",charIndex:39195},{level:3,title:"细化事务传播方式",slug:"细化事务传播方式",normalizedTitle:"细化事务传播方式",charIndex:41141},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:41582}],headersStr:"理解事务 事务的特性 全局事务 本地事务 Spring 对事务的支持 Spring 事务的优点 核心 API TransactionManager PlatformTransactionManager JDBC 事务 Hibernate 事务 Java 持久化 API 事务（JPA） Java 原生 API 事务（JTA） ReactiveTransactionManager TransactionDefinition 传播行为 隔离级别 只读 事务超时 回滚规则 TransactionStatus TransactionTemplate 声明式事务管理 Spring 声明式事务管理的实现 声明式事务示例 回滚一个声明性事务 为不同的 Bean 配置不同的事务语义 <tx:advice/> 配置 使用 @Transactional 注解 @Transactional 配置 多事务管理器场景下使用 @Transactional 自定义组合注解 事务传播 JDBC 异常抽象 Spring 事务最佳实践 Spring 事务未生效 @Transactional 方法必须是 public 必须通过 Spring 注入的 Bean 进行调用 事务虽然生效但未回滚 细化事务传播方式 参考资料",content:'# Spring 之事务\n\nSpring 针对 Java Transaction API (JTA)、JDBC、Hibernate 和 Java Persistence API(JPA) 等事务 API，实现了一致的编程模型，而 Spring 的声明式事务功能更是提供了极其方便的事务配置方式，配合 Spring Boot 的自动配置，大多数 Spring Boot 项目只需要在方法上标记 @Transactional 注解，即可一键开启方法的事务性配置。\n\n\n# 理解事务\n\n在软件开发领域，全有或全无的操作被称为事务（transaction）。事务允许你将几个操作组合成一个要么全部发生要么全部不发生的工作单元。传统上 Java EE 开发对事务管理有两种选择：全局事务或本地事务，两者都有很大的局限性。\n\n\n# 事务的特性\n\n事务应该具有 4 个属性：原子性、一致性、隔离性、持久性。这四个属性通常称为 ACID。\n\n * 原子性（Atomic）：一个事务是一个不可分割的工作单位，事务中包括的诸操作要么都做，要么都不做。\n * 一致性（Consistent）：事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。\n * 隔离性（Isolated）：一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。\n * 持久性（Durable）：持久性也称永久性（permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。\n\n\n# 全局事务\n\n全局事务允许您使用多个事务资源，通常是关系数据库和消息队列。应用服务器通过 JTA 管理全局事务，这是一个繁琐的 API（部分原因在于其异常模型）。此外，JTA UserTransaction 通常需要来自 JNDI，这意味着您还需要使用 JNDI 才能使用 JTA。全局事务的使用限制了应用程序代码的任何潜在重用，因为 JTA 通常仅在应用程序服务器环境中可用。\n\n以前，使用全局事务的首选方式是通过 EJB CMT（容器管理事务）。 CMT 是一种声明式事务管理（不同于程序化事务管理）。 EJB CMT 消除了对与事务相关的 JNDI 查找的需要，尽管使用 EJB 本身就需要使用 JNDI。它消除了大部分（但不是全部）编写 Java 代码来控制事务的需要。其明显的缺点是 CMT 与 JTA 和应用程序服务器环境相关联。此外，它仅在选择在 EJB 中实现业务逻辑（或至少在事务性 EJB 外观之后）时才可用。一般来说，EJB 的负面影响是如此之大，以至于这不是一个有吸引力的提议，尤其是在面对声明式事务管理的引人注目的替代方案时。\n\n\n# 本地事务\n\n本地事务是指定资源的，例如与 JDBC 连接关联的事务。本地事务可能更容易使用，但有一个明显的缺点：它们不能跨多个事务资源工作。例如，使用 JDBC 连接管理事务的代码不能在全局 JTA 事务中运行。因为应用服务器不参与事务管理，它不能确保跨多个资源的正确性（值得注意的是，大多数应用程序使用单个事务资源。）。另一个缺点是本地事务对编程模型具有侵入性。\n\n\n# Spring 对事务的支持\n\nSpring 通过回调机制将实际的事务实现从事务性的代码中抽象出来。Spring 解决了全局和本地事务的缺点。它允许开发人员在任何环境中使用一致的编程模型。您只需编写一次代码，它就可以从不同环境中的不同事务管理策略中受益。Spring 提供了对编码式和声明式事务管理的支持，大多数情况下都推荐使用声明式事务管理。\n\n * 编码式事务允许用户在代码中精确定义事务的边界\n * 声明式事务（基于 AOP）有助于用户将操作与事务规则进行解耦\n\n通过程序化事务管理，开发人员可以使用 Spring 事务抽象，它可以在任何底层事务基础上运行。使用首选的声明性模型，开发人员通常编写很少或根本不编写与事务管理相关的代码，因此不依赖 Spring 事务 API 或任何其他事务 API。\n\n\n# Spring 事务的优点\n\nSpring 框架为事务管理提供了一致的抽象，具有以下好处：\n\n * 跨不同事务 API 的一致编程模型，例如 Java Transaction API (JTA)、JDBC、Hibernate 和 Java Persistence API (JPA)。\n * 支持声明式事务管理。\n * 用于编程事务管理的 API 比复杂事务 API（如 JTA）更简单。\n * 与 Spring 的数据访问抽象完美集成。\n\n\n# 核心 API\n\n\n# TransactionManager\n\nSpring 事务抽象的关键是事务策略的概念。事务策略由 TransactionManager 定义，特别是用于命令式事务管理的 org.springframework.transaction.PlatformTransactionManager 接口和用于响应式事务管理的 org.springframework.transaction.ReactiveTransactionManager 接口。\n\n\n\n# PlatformTransactionManager\n\n以下清单显示了 PlatformTransactionManager API 的定义：\n\npublic interface PlatformTransactionManager extends TransactionManager {\n\n    TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException;\n\n    void commit(TransactionStatus status) throws TransactionException;\n\n    void rollback(TransactionStatus status) throws TransactionException;\n}\n\n\nPlatformTransactionManager 是一个 SPI 接口，所以使用者可以以编程方式使用它。因为 PlatformTransactionManager 是一个接口，所以可以根据需要轻松地 MOCK 或存根。它不依赖于查找策略，例如 JNDI。 PlatformTransactionManager 实现的定义与 Spring IoC 容器中的任何其他对象（或 bean）一样。仅此一项优势就使 Spring 事务成为有价值的抽象，即使您使用 JTA 也是如此。与直接使用 JTA 相比，您可以更轻松地测试事务代码。\n\n同样，为了与 Spring 的理念保持一致，任何 PlatformTransactionManager 接口的方法可以抛出的 TransactionException 都是未经检查的（也就是说，它扩展了 java.lang.RuntimeException 类）。事务架构故障几乎总是致命的。极少数情况下，应用程序可以从事务失败中恢复，开发人员可以选择捕获和处理 TransactionException。重点是开发人员并非被迫这样做。\n\ngetTransaction(..) 方法根据 TransactionDefinition 参数返回一个 TransactionStatus 对象。如果当前调用堆栈中存在匹配的事务，则返回的 TransactionStatus 可能表示新事务或可以表示现有事务。后一种情况的含义是，与 Java EE 事务上下文一样，TransactionStatus 与执行线程相关联。\n\n从以上可以看出，具体的事务管理机制对 Spring 来说是透明的，它并不关心那些，那些是对应各个平台需要关心的，所以 Spring 事务管理的一个优点就是为不同的事务 API 提供一致的编程模型，如 JTA、JDBC、Hibernate、JPA。下面分别介绍各个平台框架实现事务管理的机制。\n\n# JDBC 事务\n\n如果应用程序中直接使用 JDBC 来进行持久化，DataSourceTransactionManager 会为你处理事务边界。为了使用 DataSourceTransactionManager，你需要使用如下的 XML 将其装配到应用程序的上下文定义中：\n\n<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">\n  <property name="dataSource" ref="dataSource" />\n</bean>\n\n\n实际上，DataSourceTransactionManager 是通过调用 java.sql.Connection 来管理事务，而后者是通过 DataSource 获取到的。通过调用连接的 commit() 方法来提交事务，同样，事务失败则通过调用 rollback() 方法进行回滚。\n\n# Hibernate 事务\n\n如果应用程序的持久化是通过 Hibernate 实现的，那么你需要使用 HibernateTransactionManager。对于 Hibernate3，需要在 Spring 上下文定义中添加如下的 bean 声明：\n\n<bean id="transactionManager" class="org.springframework.orm.hibernate3.HibernateTransactionManager">\n  <property name="sessionFactory" ref="sessionFactory" />\n</bean>\n\n\nsessionFactory 属性需要装配一个 Hibernate 的 session 工厂，HibernateTransactionManager 的实现细节是它将事务管理的职责委托给 org.hibernate.Transaction 对象，而后者是从 Hibernate Session 中获取到的。当事务成功完成时，HibernateTransactionManager 将会调用 Transaction 对象的 commit() 方法，反之，将会调用 rollback() 方法。\n\n# Java 持久化 API 事务（JPA）\n\nHibernate 多年来一直是事实上的 Java 持久化标准，但是现在 Java 持久化 API 作为真正的 Java 持久化标准进入大家的视野。如果你计划使用 JPA 的话，那你需要使用 Spring 的 JpaTransactionManager 来处理事务。你需要在 Spring 中这样配置 JpaTransactionManager：\n\n<bean id="transactionManager" class="org.springframework.orm.jpa.JpaTransactionManager">\n  <property name="sessionFactory" ref="sessionFactory" />\n</bean>\n\n\nJpaTransactionManager 只需要装配一个 JPA 实体管理工厂（javax.persistence.EntityManagerFactory 接口的任意实现）。JpaTransactionManager 将与由工厂所产生的 JPA EntityManager 合作来构建事务。\n\n# Java 原生 API 事务（JTA）\n\n如果你没有使用以上所述的事务管理，或者是跨越了多个事务管理源（比如两个或者是多个不同的数据源），你就需要使用JtaTransactionManager：\n\n<bean id="transactionManager" class="org.springframework.transaction.jta.JtaTransactionManager">\n  <property name="transactionManagerName" value="java:/TransactionManager" />\n</bean>\n\n\nJtaTransactionManager 将事务管理的责任委托给 javax.transaction.UserTransaction 和 javax.transaction.TransactionManager 对象，其中事务成功完成通过 UserTransaction.commit() 方法提交，事务失败通过 UserTransaction.rollback() 方法回滚。\n\n# ReactiveTransactionManager\n\nSpring 还为使用响应式类型或 Kotlin 协程的响应式应用程序提供了事务管理抽象。以下清单显示了 org.springframework.transaction.ReactiveTransactionManager 定义的事务策略：\n\npublic interface ReactiveTransactionManager extends TransactionManager {\n\n    Mono<ReactiveTransaction> getReactiveTransaction(TransactionDefinition definition) throws TransactionException;\n\n    Mono<Void> commit(ReactiveTransaction status) throws TransactionException;\n\n    Mono<Void> rollback(ReactiveTransaction status) throws TransactionException;\n}\n\n\n响应式事务管理器主要是一个 SPI，所以使用者可以以编程方式使用它。因为 ReactiveTransactionManager 是一个接口，所以可以根据需要轻松地 MOCK 或存根。\n\n\n# TransactionDefinition\n\nPlatformTransactionManager 通过 getTransaction(TransactionDefinition definition) 方法来得到事务，这个方法里面的参数是 TransactionDefinition 类，这个类就定义了一些基本的事务属性。事务属性可以理解成事务的一些基本配置，描述了事务策略如何应用到方法上。\n\nTransactionDefinition 接口内容如下：\n\npublic interface TransactionDefinition {\n    int getPropagationBehavior(); // 返回事务的传播行为\n    int getIsolationLevel(); // 返回事务的隔离级别，事务管理器根据它来控制另外一个事务可以看到本事务内的哪些数据\n    int getTimeout();  // 返回事务必须在多少秒内完成\n    boolean isReadOnly(); // 事务是否只读，事务管理器能够根据这个返回值进行优化，确保事务是只读的\n}\n\n\n我们可以发现 TransactionDefinition 正好用来定义事务属性，下面详细介绍一下各个事务属性。\n\n# 传播行为\n\n事务的传播行为（propagation behavior）是指：当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。Spring 定义了七种传播行为：\n\n传播行为                        含义\nPROPAGATION_REQUIRED        表示当前方法必须运行在事务中。如果当前事务存在，方法将会在该事务中运行。否则，会启动一个新的事务\nPROPAGATION_SUPPORTS        表示当前方法不需要事务上下文，但是如果存在当前事务的话，那么该方法会在这个事务中运行\nPROPAGATION_MANDATORY       表示该方法必须在事务中运行，如果当前事务不存在，则会抛出一个异常\nPROPAGATION_REQUIRED_NEW    表示当前方法必须运行在它自己的事务中。一个新的事务将被启动。如果存在当前事务，在该方法执行期间，当前事务会被挂起。如果使用\n                            JTATransactionManager 的话，则需要访问 TransactionManager\nPROPAGATION_NOT_SUPPORTED   表示该方法不应该运行在事务中。如果存在当前事务，在该方法运行期间，当前事务将被挂起。如果使用\n                            JTATransactionManager 的话，则需要访问 TransactionManager\nPROPAGATION_NEVER           表示当前方法不应该运行在事务上下文中。如果当前正有一个事务在运行，则会抛出异常\nPROPAGATION_NESTED          表示如果当前已经存在一个事务，那么该方法将会在嵌套事务中运行。嵌套的事务可以独立于当前事务进行单独地提交或回滚。如果当前事务不存在，那么其行为与\n                            PROPAGATION_REQUIRED\n                            一样。注意各厂商对这种传播行为的支持是有所差异的。可以参考资源管理器的文档来确认它们是否支持嵌套事务\n\n注：以下具体讲解传播行为的内容参考自 Spring 事务机制详解\n\n 1. PROPAGATION_REQUIRED 如果存在一个事务，则支持当前事务。如果没有事务则开启一个新的事务。\n\n// 事务属性 PROPAGATION_REQUIRED\nmethodA {\n    ……\n    methodB();\n    ……\n}\n\n\n// 事务属性 PROPAGATION_REQUIRED\nmethodB {\n   ……\n}\n\n\n使用 spring 声明式事务，spring 使用 AOP 来支持声明式事务，会根据事务属性，自动在方法调用之前决定是否开启一个事务，并在方法执行之后决定事务提交或回滚事务。\n\n单独调用 methodB 方法：\n\nmain {\n    metodB();\n}\n\n\n相当于\n\nMain {\n    Connection con=null;\n    try{\n        con = getConnection();\n        con.setAutoCommit(false);\n\n        //方法调用\n        methodB();\n\n        //提交事务\n        con.commit();\n    } Catch(RuntimeException ex) {\n        //回滚事务\n        con.rollback();\n    } finally {\n        //释放资源\n        closeCon();\n    }\n}\n\n\nSpring 保证在 methodB 方法中所有的调用都获得到一个相同的连接。在调用 methodB 时，没有一个存在的事务，所以获得一个新的连接，开启了一个新的事务。 单独调用 MethodA 时，在 MethodA 内又会调用 MethodB.\n\n执行效果相当于：\n\nmain{\n    Connection con = null;\n    try{\n        con = getConnection();\n        methodA();\n        con.commit();\n    } catch(RuntimeException ex) {\n        con.rollback();\n    } finally {\n        closeCon();\n    }\n}\n\n\n调用 MethodA 时，环境中没有事务，所以开启一个新的事务.当在 MethodA 中调用 MethodB 时，环境中已经有了一个事务，所以 methodB 就加入当前事务。\n\n 2. PROPAGATION_SUPPORTS 如果存在一个事务，支持当前事务。如果没有事务，则非事务的执行。但是对于事务同步的事务管理器，PROPAGATION_SUPPORTS 与不使用事务有少许不同。\n\n//事务属性 PROPAGATION_REQUIRED\nmethodA(){\n  methodB();\n}\n\n//事务属性 PROPAGATION_SUPPORTS\nmethodB(){\n  ……\n}\n\n\n单纯的调用 methodB 时，methodB 方法是非事务的执行的。当调用 methdA 时,methodB 则加入了 methodA 的事务中,事务地执行。\n\n 3. PROPAGATION_MANDATORY 如果已经存在一个事务，支持当前事务。如果没有一个活动的事务，则抛出异常。\n\n//事务属性 PROPAGATION_REQUIRED\nmethodA(){\n    methodB();\n}\n\n//事务属性 PROPAGATION_MANDATORY\n    methodB(){\n    ……\n}\n\n\n当单独调用 methodB 时，因为当前没有一个活动的事务，则会抛出异常 throw new IllegalTransactionStateException(“Transaction propagation ‘mandatory’ but no existing transaction found”);当调用 methodA 时，methodB 则加入到 methodA 的事务中，事务地执行。\n\n 4. PROPAGATION_REQUIRES_NEW 总是开启一个新的事务。如果一个事务已经存在，则将这个存在的事务挂起。\n\n//事务属性 PROPAGATION_REQUIRED\nmethodA(){\n    doSomeThingA();\n    methodB();\n    doSomeThingB();\n}\n\n//事务属性 PROPAGATION_REQUIRES_NEW\nmethodB(){\n    ……\n}\n\n\n调用 A 方法：\n\nmain(){\n    methodA();\n}\n\n\n相当于\n\nmain(){\n    TransactionManager tm = null;\n    try{\n        //获得一个JTA事务管理器\n        tm = getTransactionManager();\n        tm.begin();//开启一个新的事务\n        Transaction ts1 = tm.getTransaction();\n        doSomeThing();\n        tm.suspend();//挂起当前事务\n        try{\n            tm.begin();//重新开启第二个事务\n            Transaction ts2 = tm.getTransaction();\n            methodB();\n            ts2.commit();//提交第二个事务\n        } Catch(RunTimeException ex) {\n            ts2.rollback();//回滚第二个事务\n        } finally {\n            //释放资源\n        }\n        //methodB执行完后，恢复第一个事务\n        tm.resume(ts1);\n        doSomeThingB();\n        ts1.commit();//提交第一个事务\n    } catch(RunTimeException ex) {\n        ts1.rollback();//回滚第一个事务\n    } finally {\n        //释放资源\n    }\n}\n\n\n在这里，我把 ts1 称为外层事务，ts2 称为内层事务。从上面的代码可以看出，ts2 与 ts1 是两个独立的事务，互不相干。Ts2 是否成功并不依赖于 ts1。如果 methodA 方法在调用 methodB 方法后的 doSomeThingB 方法失败了，而 methodB 方法所做的结果依然被提交。而除了 methodB 之外的其它代码导致的结果却被回滚了。使用 PROPAGATION_REQUIRES_NEW,需要使用 JtaTransactionManager 作为事务管理器。\n\n 5. PROPAGATION_NOT_SUPPORTED 总是非事务地执行，并挂起任何存在的事务。使用 PROPAGATION_NOT_SUPPORTED,也需要使用 JtaTransactionManager 作为事务管理器。（代码示例同上，可同理推出）\n 6. PROPAGATION_NEVER 总是非事务地执行，如果存在一个活动事务，则抛出异常。\n 7. PROPAGATION_NESTED 如果一个活动的事务存在，则运行在一个嵌套的事务中. 如果没有活动事务, 则按 TransactionDefinition.PROPAGATION_REQUIRED 属性执行。这是一个嵌套事务,使用 JDBC 3.0 驱动时,仅仅支持 DataSourceTransactionManager 作为事务管理器。需要 JDBC 驱动的 java.sql.Savepoint 类。有一些 JTA 的事务管理器实现可能也提供了同样的功能。使用 PROPAGATION_NESTED，还需要把 PlatformTransactionManager 的 nestedTransactionAllowed 属性设为 true;而 nestedTransactionAllowed 属性值默认为 false。\n\n//事务属性 PROPAGATION_REQUIRED\nmethodA(){\n    doSomeThingA();\n    methodB();\n    doSomeThingB();\n}\n\n//事务属性 PROPAGATION_NESTED\nmethodB(){\n    ……\n}\n\n\n如果单独调用 methodB 方法，则按 REQUIRED 属性执行。如果调用 methodA 方法，相当于下面的效果：\n\nmain(){\n    Connection con = null;\n    Savepoint savepoint = null;\n    try{\n        con = getConnection();\n        con.setAutoCommit(false);\n        doSomeThingA();\n        savepoint = con2.setSavepoint();\n        try{\n            methodB();\n        } catch(RuntimeException ex) {\n            con.rollback(savepoint);\n        } finally {\n            //释放资源\n        }\n        doSomeThingB();\n        con.commit();\n    } catch(RuntimeException ex) {\n        con.rollback();\n    } finally {\n        //释放资源\n    }\n}\n\n\n当 methodB 方法调用之前，调用 setSavepoint 方法，保存当前的状态到 savepoint。如果 methodB 方法调用失败，则恢复到之前保存的状态。但是需要注意的是，这时的事务并没有进行提交，如果后续的代码(doSomeThingB()方法)调用失败，则回滚包括 methodB 方法的所有操作。\n\n嵌套事务一个非常重要的概念就是内层事务依赖于外层事务。外层事务失败时，会回滚内层事务所做的动作。而内层事务操作失败并不会引起外层事务的回滚。\n\nPROPAGATION_NESTED 与 PROPAGATION_REQUIRES_NEW 的区别:它们非常类似,都像一个嵌套事务，如果不存在一个活动的事务，都会开启一个新的事务。使用 PROPAGATION_REQUIRES_NEW 时，内层事务与外层事务就像两个独立的事务一样，一旦内层事务进行了提交后，外层事务不能对其进行回滚。两个事务互不影响。两个事务不是一个真正的嵌套事务。同时它需要 JTA 事务管理器的支持。\n\n使用 PROPAGATION_NESTED 时，外层事务的回滚可以引起内层事务的回滚。而内层事务的异常并不会导致外层事务的回滚，它是一个真正的嵌套事务。DataSourceTransactionManager 使用 savepoint 支持 PROPAGATION_NESTED 时，需要 JDBC 3.0 以上驱动及 1.4 以上的 JDK 版本支持。其它的 JTA TrasactionManager 实现可能有不同的支持方式。\n\nPROPAGATION_REQUIRES_NEW 启动一个新的, 不依赖于环境的 “内部” 事务. 这个事务将被完全 commited 或 rolled back 而不依赖于外部事务, 它拥有自己的隔离范围, 自己的锁, 等等. 当内部事务开始执行时, 外部事务将被挂起, 内务事务结束时, 外部事务将继续执行。\n\n另一方面, PROPAGATION_NESTED 开始一个 “嵌套的” 事务, 它是已经存在事务的一个真正的子事务. 潜套事务开始执行时, 它将取得一个 savepoint. 如果这个嵌套事务失败, 我们将回滚到此 savepoint. 潜套事务是外部事务的一部分, 只有外部事务结束后它才会被提交。\n\n由此可见, PROPAGATION_REQUIRES_NEW 和 PROPAGATION_NESTED 的最大区别在于, PROPAGATION_REQUIRES_NEW 完全是一个新的事务, 而 PROPAGATION_NESTED 则是外部事务的子事务, 如果外部事务 commit, 嵌套事务也会被 commit, 这个规则同样适用于 roll back.\n\nPROPAGATION_REQUIRED 应该是我们首先的事务传播行为。它能够满足我们大多数的事务需求。\n\n# 隔离级别\n\n事务的第二个维度就是隔离级别（isolation level）。隔离级别定义了一个事务可能受其他并发事务影响的程度。\n\n 1. 并发事务引起的问题\n\n在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务。并发虽然是必须的，但可能会导致一下的问题。\n\n * 脏读（Dirty reads）——脏读发生在一个事务读取了另一个事务改写但尚未提交的数据时。如果改写在稍后被回滚了，那么第一个事务获取的数据就是无效的。\n * 不可重复读（Nonrepeatable read）——不可重复读发生在一个事务执行相同的查询两次或两次以上，但是每次都得到不同的数据时。这通常是因为另一个并发事务在两次查询期间进行了更新。\n * 幻读（Phantom read）——幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录。\n\n不可重复读与幻读的区别\n\n不可重复读的重点是修改: 同样的条件, 你读取过的数据, 再次读取出来发现值不一样了 例如：在事务 1 中，Mary 读取了自己的工资为 1000,操作并没有完成\n\n    con1 = getConnection();\n    select salary from employee empId ="Mary";\n\n\n在事务 2 中，这时财务人员修改了 Mary 的工资为 2000,并提交了事务.\n\n    con2 = getConnection();\n    update employee set salary = 2000;\n    con2.commit();\n\n\n在事务 1 中，Mary 再次读取自己的工资时，工资变为了 2000\n\n    //con1\n    select salary from employee empId ="Mary";\n\n\n在一个事务中前后两次读取的结果并不一致，导致了不可重复读。\n\n幻读的重点在于新增或者删除： 同样的条件, 第 1 次和第 2 次读出来的记录数不一样 例如：目前工资为 1000 的员工有 10 人。事务 1,读取所有工资为 1000 的员工。\n\n    con1 = getConnection();\n    Select * from employee where salary =1000;\n\n\n共读取 10 条记录\n\n这时另一个事务向 employee 表插入了一条员工记录，工资也为 1000\n\n    con2 = getConnection();\n    Insert into employee(empId,salary) values("Lili",1000);\n    con2.commit();\n\n\n事务 1 再次读取所有工资为 1000 的员工\n\n    //con1\n    select * from employee where salary =1000;\n\n\n共读取到了 11 条记录，这就产生了幻像读。\n\n从总的结果来看, 似乎不可重复读和幻读都表现为两次读取的结果不一致。但如果你从控制的角度来看, 两者的区别就比较大。 对于前者, 只需要锁住满足条件的记录。 对于后者, 要锁住满足条件及其相近的记录。\n\n 2. 隔离级别\n\n隔离级别                         含义\nISOLATION_DEFAULT            使用后端数据库默认的隔离级别\nISOLATION_READ_UNCOMMITTED   最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读\nISOLATION_READ_COMMITTED     允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生\nISOLATION_REPEATABLE_READ    对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生\nISOLATION_SERIALIZABLE       最高的隔离级别，完全服从 ACID\n                             的隔离级别，确保阻止脏读、不可重复读以及幻读，也是最慢的事务隔离级别，因为它通常是通过完全锁定事务相关的数据库表来实现的\n\n# 只读\n\n事务的第三个特性是它是否为只读事务。如果事务只对后端的数据库进行该操作，数据库可以利用事务的只读特性来进行一些特定的优化。通过将事务设置为只读，你就可以给数据库一个机会，让它应用它认为合适的优化措施。\n\n# 事务超时\n\n为了使应用程序很好地运行，事务不能运行太长的时间。因为事务可能涉及对后端数据库的锁定，所以长时间的事务会不必要的占用数据库资源。事务超时就是事务的一个定时器，在特定时间内事务如果没有执行完毕，那么就会自动回滚，而不是一直等待其结束。\n\n# 回滚规则\n\n事务五边形的最后一个方面是一组规则，这些规则定义了哪些异常会导致事务回滚而哪些不会。默认情况下，事务只有遇到运行期异常时才会回滚，而在遇到检查型异常时不会回滚（这一行为与 EJB 的回滚行为是一致的） 但是你可以声明事务在遇到特定的检查型异常时像遇到运行期异常那样回滚。同样，你还可以声明事务遇到特定的异常不回滚，即使这些异常是运行期异常。\n\n\n# TransactionStatus\n\nTransactionStatus 接口为事务代码提供了一种简单的方式来控制事务执行和查询事务状态。这些概念应该很熟悉，因为它们对所有事务 API 都是通用的。以下清单显示了 TransactionStatus 接口：\n\npublic interface TransactionStatus extends TransactionExecution, SavepointManager, Flushable {\n\n    @Override\n    boolean isNewTransaction();\n\n    boolean hasSavepoint();\n\n    @Override\n    void setRollbackOnly();\n\n    @Override\n    boolean isRollbackOnly();\n\n    void flush();\n\n    @Override\n    boolean isCompleted();\n}\n\n\n可以发现这个接口描述的是一些处理事务提供简单的控制事务执行和查询事务状态的方法，在回滚或提交的时候需要应用对应的事务状态。\n\n\n# TransactionTemplate\n\nSpring 提供了对编程式事务和声明式事务的支持。编程式事务允许用户在代码中精确定义事务的边界，而声明式事务（基于 AOP）有助于用户将操作与事务规则进行解耦。TransactionTemplate 就是用于支持编程式事务的核心 API。\n\n采用 TransactionTemplate 和采用其他 Spring 模板，如 JdbcTempalte 和 HibernateTemplate 是一样的方法。它使用回调方法，把应用程序从处理取得和释放资源中解脱出来。如同其他模板，TransactionTemplate 是线程安全的。代码片段：\n\n    TransactionTemplate tt = new TransactionTemplate(); // 新建一个TransactionTemplate\n    Object result = tt.execute(\n        new TransactionCallback(){\n            public Object doTransaction(TransactionStatus status){\n                updateOperation();\n                return resultOfUpdateOperation();\n            }\n    }); // 执行execute方法进行事务管理\n\n\n使用 TransactionCallback()可以返回一个值。如果使用 TransactionCallbackWithoutResult 则没有返回值。\n\n\n# 声明式事务管理\n\n> 大多数 Spring 用户选择声明式事务管理。此选项对应用程序代码的影响最小，因此最符合非侵入式轻量级容器的理想。\n\nSpring 框架的声明式事务管理是通过 Spring AOP 实现的。然而，由于事务方面代码随 Spring 发行版一起提供并且可以以样板方式使用，因此通常不必理解 AOP 概念即可有效地使用此代码。\n\nSpring 框架的声明式事务管理类似于 EJB CMT，因为您可以指定事务行为（或缺少它）到单个方法级别。如有必要，您可以在事务上下文中进行 setRollbackOnly() 调用。两种类型的事务管理之间的区别是：\n\n * 与绑定到 JTA 的 EJB CMT 不同，Spring 框架的声明式事务管理适用于任何环境。通过调整配置文件，它可以使用 JDBC、JPA 或 Hibernate 处理 JTA 事务或本地事务。\n * 您可以将 Spring 声明式事务管理应用于任何类，而不仅仅是诸如 EJB 之类的特殊类。\n * Spring 提供声明性回滚规则，这是一个没有 EJB 等效功能的特性。提供了对回滚规则的编程和声明性支持。\n * Spring 允许您使用 AOP 自定义事务行为。例如，您可以在事务回滚的情况下插入自定义行为。您还可以添加任意 advice 以及事务性 advice。使用 EJB CMT，您无法影响容器的事务管理，除非使用 setRollbackOnly()。\n * Spring 不像高端应用服务器那样支持跨远程调用传播事务上下文。如果您需要此功能，我们建议您使用 EJB。但是，在使用这种特性之前要仔细考虑，因为通常情况下，不希望事务跨越远程调用。\n\n回滚规则的概念很重要。它们让您指定哪些异常（和 throwable）应该导致自动回滚。您可以在配置中以声明方式指定它，而不是在 Java 代码中。因此，尽管您仍然可以在 TransactionStatus 对象上调用 setRollbackOnly() 来回滚当前事务，但通常您可以指定 MyApplicationException 必须始终导致回滚的规则。此选项的显着优势是业务对象不依赖于事务基础架构。例如，它们通常不需要导入 Spring 事务 API 或其他 Spring API。\n\n尽管 EJB 容器默认行为会在系统异常（通常是运行时异常）上自动回滚事务，但 EJB CMT 不会在应用程序异常（即除 java.rmi.RemoteException 之外的检查异常）上自动回滚事务。虽然声明式事务管理的 Spring 默认行为遵循 EJB 约定（回滚仅在未经检查的异常上自动），但自定义此行为通常很有用。\n\n\n# Spring 声明式事务管理的实现\n\n关于 Spring 框架的声明式事务支持，最重要的概念是这种支持是通过 AOP 代理启用的，并且事务 advice 是由元数据驱动的（目前是基于 XML 或基于注释的）。 AOP 与事务元数据的结合产生了一个 AOP 代理，它使用 TransactionInterceptor 和适当的 TransactionManager 实现来驱动围绕方法调用的事务。\n\nSpring 的 TransactionInterceptor 为命令式和响应式编程模型提供事务管理。拦截器通过检查方法返回类型来检测所需的事务管理风格。返回响应式类型的方法，例如 Publisher 或 Kotlin Flow（或它们的子类型）有资格进行响应式事务管理。包括 void 在内的所有其他返回类型都使用代码路径进行命令式事务管理。\n\n事务管理风格会影响需要哪个事务管理器。命令式事务需要 PlatformTransactionManager，而响应式事务使用 ReactiveTransactionManager 实现。\n\n> @Transactional 通常与 PlatformTransactionManager 管理的线程绑定事务一起使用，将事务公开给当前执行线程中的所有数据访问操作。注意：这不会传播到方法中新启动的线程。\n> \n> 由 ReactiveTransactionManager 管理的反应式事务使用 Reactor 上下文而不是线程本地属性。因此，所有参与的数据访问操作都需要在同一个反应式管道中的同一个 Reactor 上下文中执行。\n\n下图显示了在事务代理上调用方法的概念视图：\n\n\n\n\n# 声明式事务示例\n\n考虑以下接口及其伴随的实现。此示例使用 Foo 和 Bar 类作为占位符，以便您可以专注于事务使用，而无需关注特定的域模型。就本示例而言，DefaultFooService 类在每个已实现方法的主体中抛出 UnsupportedOperationException 实例这一事实很好。该行为使您可以看到正在创建的事务，然后回滚以响应 UnsupportedOperationException 实例。\n\n以下清单显示了 FooService 接口：\n\n// the service interface that we want to make transactional\n\npackage x.y.service;\n\npublic interface FooService {\n\n    Foo getFoo(String fooName);\n\n    Foo getFoo(String fooName, String barName);\n\n    void insertFoo(Foo foo);\n\n    void updateFoo(Foo foo);\n\n}\n\n\n以下示例显示了上述接口的实现：\n\npackage x.y.service;\n\npublic class DefaultFooService implements FooService {\n\n    @Override\n    public Foo getFoo(String fooName) {\n        // ...\n    }\n\n    @Override\n    public Foo getFoo(String fooName, String barName) {\n        // ...\n    }\n\n    @Override\n    public void insertFoo(Foo foo) {\n        // ...\n    }\n\n    @Override\n    public void updateFoo(Foo foo) {\n        // ...\n    }\n}\n\n\n假设 FooService 接口的前两个方法 getFoo(String) 和 getFoo(String, String) 必须在具有只读语义的事务上下文中运行，并且其他方法 insertFoo(Foo) 和 updateFoo(Foo )，必须在具有读写语义的事务上下文中运行。以下配置将在接下来的几段中详细说明：\n\n\x3c!-- from the file \'context.xml\' --\x3e\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n    xmlns:aop="http://www.springframework.org/schema/aop"\n    xmlns:tx="http://www.springframework.org/schema/tx"\n    xsi:schemaLocation="\n        http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/tx\n        https://www.springframework.org/schema/tx/spring-tx.xsd\n        http://www.springframework.org/schema/aop\n        https://www.springframework.org/schema/aop/spring-aop.xsd">\n\n    \x3c!-- this is the service object that we want to make transactional --\x3e\n    <bean id="fooService" class="x.y.service.DefaultFooService"/>\n\n    \x3c!-- the transactional advice (what \'happens\'; see the <aop:advisor/> bean below) --\x3e\n    <tx:advice id="txAdvice" transaction-manager="txManager">\n        \x3c!-- the transactional semantics... --\x3e\n        <tx:attributes>\n            \x3c!-- all methods starting with \'get\' are read-only --\x3e\n            <tx:method name="get*" read-only="true"/>\n            \x3c!-- other methods use the default transaction settings (see below) --\x3e\n            <tx:method name="*"/>\n        </tx:attributes>\n    </tx:advice>\n\n    \x3c!-- ensure that the above transactional advice runs for any execution\n        of an operation defined by the FooService interface --\x3e\n    <aop:config>\n        <aop:pointcut id="fooServiceOperation" expression="execution(* x.y.service.FooService.*(..))"/>\n        <aop:advisor advice-ref="txAdvice" pointcut-ref="fooServiceOperation"/>\n    </aop:config>\n\n    \x3c!-- don\'t forget the DataSource --\x3e\n    <bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">\n        <property name="driverClassName" value="oracle.jdbc.driver.OracleDriver"/>\n        <property name="url" value="jdbc:oracle:thin:@rj-t42:1521:elvis"/>\n        <property name="username" value="scott"/>\n        <property name="password" value="tiger"/>\n    </bean>\n\n    \x3c!-- similarly, don\'t forget the TransactionManager --\x3e\n    <bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">\n        <property name="dataSource" ref="dataSource"/>\n    </bean>\n\n    \x3c!-- other <bean/> definitions here --\x3e\n\n</beans>\n\n\n检查前面的配置。它假定您要使服务对象 fooService bean 具有事务性。要应用的事务语义封装在 <tx:advice/> 定义中。<tx:advice/> 定义读作“所有以 get 开头的方法都将在只读事务的上下文中运行，所有其他方法都将以默认事务语义运行”。<tx:advice/> 标签的 transaction-manager 属性设置为将驱动事务的 TransactionManager bean 的名称（在本例中为 txManager bean）。\n\n> 如果要连接的 TransactionManager 的 bean 名称具有名称 transactionManager，则可以省略事务 advice (tx:advice/) 中的 transaction-manager 属性。如果要连接的 TransactionManager bean 有任何其他名称，则必须显式使用 transaction-manager 属性，如前面的示例所示。\n\n<aop:config/> 定义确保由 txAdvice bean 定义的事务性建议在程序中的适当位置运行。首先，您定义一个切入点，该切入点与 FooService 接口 (fooServiceOperation) 中定义的任何操作的执行相匹配。然后，您使用一个 adviser 将切入点与 txAdvice 相关联。结果表明，在执行 fooServiceOperation 时，会运行 txAdvice 定义的建议。\n\n一个常见的要求是使整个服务层具有事务性。最好的方法是更改切入点表达式以匹配服务层中的任何操作。以下示例显示了如何执行此操作：\n\n<aop:config>\n    <aop:pointcut id="fooServiceMethods" expression="execution(* x.y.service.*.*(..))"/>\n    <aop:advisor advice-ref="txAdvice" pointcut-ref="fooServiceMethods"/>\n</aop:config>\n\n\n前面显示的配置用于围绕从 fooService bean 定义创建的对象创建事务代理。代理配置了事务 advice，以便在代理上调用适当的方法时，根据与该方法关联的事务配置，启动、暂停、标记为只读等事务。考虑以下测试驱动前面显示的配置的程序：\n\npublic final class Boot {\n\n    public static void main(final String[] args) throws Exception {\n        ApplicationContext ctx = new ClassPathXmlApplicationContext("context.xml");\n        FooService fooService = ctx.getBean(FooService.class);\n        fooService.insertFoo(new Foo());\n    }\n}\n\n\n\n# 回滚一个声明性事务\n\nSpring 框架中，触发事务回滚的推荐方式是在事务上下文的代码中抛出异常。Spring 事务框架会捕获任何未处理的异常，并确定是否将事务标记为回滚。\n\n在其默认配置中，Spring 事务框架只会将存在运行时且未经检查异常的事务标记为回滚。也就是说，当抛出的异常是 RuntimeException 的实例或子类时。 （默认情况下，错误实例也会导致回滚）。从事务方法抛出的检查异常不会导致默认配置中的回滚。\n\n您可以通过指定回滚规则，明确指定哪些异常类型将导致事务回滚。\n\n> 回滚规则约定在抛出指定异常时是否应回滚事务，并且规则基于模式。模式可以是完全限定的类名或异常类型的完全限定类名的子字符串（必须是 Throwable 的子类），目前不支持通配符。例如，javax.servlet.ServletException 或 ServletException 的值将匹配 javax.servlet.ServletException 及其子类。\n> \n> 回滚规则可以通过 rollback-for 和 no-rollback-for 属性在 XML 中配置，这允许将模式指定为字符串。使用 @Transactional 时，可以通过 rollbackFor / noRollbackFor 和rollbackForClassName / noRollbackForClassName 属性配置回滚规则，它们允许将模式分别指定为类引用或字符串。当异常类型被指定为类引用时，其完全限定名称将用作模式。因此，@Transactional(rollbackFor = example.CustomException.class) 等价于 @Transactional(rollbackForClassName = \'example.CustomException\')。\n\n以下 XML 片段演示了如何通过 rollback-for 属性提供异常模式来为已检查的、特定的 Exception 类型配置回滚：\n\n<tx:advice id="txAdvice" transaction-manager="txManager">\n    <tx:attributes>\n    <tx:method name="get*" read-only="true" rollback-for="NoProductInStockException"/>\n    <tx:method name="*"/>\n    </tx:attributes>\n</tx:advice>\n\n\n如果您不希望在抛出异常时回滚事务，您还可以指定“不回滚”规则。下面的例子告诉 Spring 事务框架，即使在面对未处理的 InstrumentNotFoundException 时也要提交伴随事务。\n\n<tx:advice id="txAdvice">\n    <tx:attributes>\n    <tx:method name="updateStock" no-rollback-for="InstrumentNotFoundException"/>\n    <tx:method name="*"/>\n    </tx:attributes>\n</tx:advice>\n\n\n当 Spring Framework 事务框架捕获到异常，并检查配置的回滚规则以确定是否将事务标记为回滚时，由最重要的匹配规则决定。因此，在以下配置的情况下，除 InstrumentNotFoundException 之外的任何异常都会导致伴随事务的回滚。\n\n<tx:advice id="txAdvice">\n    <tx:attributes>\n    <tx:method name="*" rollback-for="Throwable" no-rollback-for="InstrumentNotFoundException"/>\n    </tx:attributes>\n</tx:advice>\n\n\n您还可以以编程方式指示所需的回滚。虽然很简单，但这个过程非常具有侵入性，并且将您的代码与 Spring Framework 的事务基础设施紧密耦合。以下示例显示如何以编程方式指示所需的回滚。\n\npublic void resolvePosition() {\n    try {\n        // some business logic...\n    } catch (NoProductInStockException ex) {\n        // trigger rollback programmatically\n        TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();\n    }\n}\n\n\n如果可能的话，强烈建议您使用声明性方法进行回滚。如果您绝对需要，可以使用程序化回滚，但它的使用与实现干净的基于 POJO 的架构背道而驰。\n\n\n# 为不同的 Bean 配置不同的事务语义\n\n考虑您有许多服务层对象的场景，并且您希望对每个对象应用完全不同的事务配置。您可以通过定义具有不同 <aop:advisor/> 元素和不同 advice-ref 属性值的切点来实现这一点。\n\n作为一个比较点，首先假设您的所有服务层类都定义在根 x.y.service 包中。 要使作为该包（或子包）中定义的类的实例并且名称以 Service 结尾的所有 bean 都具有默认的事务配置，您可以编写以下内容：\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n    xmlns:aop="http://www.springframework.org/schema/aop"\n    xmlns:tx="http://www.springframework.org/schema/tx"\n    xsi:schemaLocation="\n        http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/tx\n        https://www.springframework.org/schema/tx/spring-tx.xsd\n        http://www.springframework.org/schema/aop\n        https://www.springframework.org/schema/aop/spring-aop.xsd">\n\n    <aop:config>\n\n        <aop:pointcut id="serviceOperation"\n                expression="execution(* x.y.service..*Service.*(..))"/>\n\n        <aop:advisor pointcut-ref="serviceOperation" advice-ref="txAdvice"/>\n\n    </aop:config>\n\n    \x3c!-- these two beans will be transactional... --\x3e\n    <bean id="fooService" class="x.y.service.DefaultFooService"/>\n    <bean id="barService" class="x.y.service.extras.SimpleBarService"/>\n\n    \x3c!-- ... and these two beans won\'t --\x3e\n    <bean id="anotherService" class="org.xyz.SomeService"/> \x3c!-- (not in the right package) --\x3e\n    <bean id="barManager" class="x.y.service.SimpleBarManager"/> \x3c!-- (doesn\'t end in \'Service\') --\x3e\n\n    <tx:advice id="txAdvice">\n        <tx:attributes>\n            <tx:method name="get*" read-only="true"/>\n            <tx:method name="*"/>\n        </tx:attributes>\n    </tx:advice>\n\n    \x3c!-- other transaction infrastructure beans such as a TransactionManager omitted... --\x3e\n\n</beans>\n\n\n以下示例显示了如何使用完全不同的事务设置配置两个不同的 bean\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n    xmlns:aop="http://www.springframework.org/schema/aop"\n    xmlns:tx="http://www.springframework.org/schema/tx"\n    xsi:schemaLocation="\n        http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/tx\n        https://www.springframework.org/schema/tx/spring-tx.xsd\n        http://www.springframework.org/schema/aop\n        https://www.springframework.org/schema/aop/spring-aop.xsd">\n\n    <aop:config>\n\n        <aop:pointcut id="defaultServiceOperation"\n                expression="execution(* x.y.service.*Service.*(..))"/>\n\n        <aop:pointcut id="noTxServiceOperation"\n                expression="execution(* x.y.service.ddl.DefaultDdlManager.*(..))"/>\n\n        <aop:advisor pointcut-ref="defaultServiceOperation" advice-ref="defaultTxAdvice"/>\n\n        <aop:advisor pointcut-ref="noTxServiceOperation" advice-ref="noTxAdvice"/>\n\n    </aop:config>\n\n    \x3c!-- this bean will be transactional (see the \'defaultServiceOperation\' pointcut) --\x3e\n    <bean id="fooService" class="x.y.service.DefaultFooService"/>\n\n    \x3c!-- this bean will also be transactional, but with totally different transactional settings --\x3e\n    <bean id="anotherFooService" class="x.y.service.ddl.DefaultDdlManager"/>\n\n    <tx:advice id="defaultTxAdvice">\n        <tx:attributes>\n            <tx:method name="get*" read-only="true"/>\n            <tx:method name="*"/>\n        </tx:attributes>\n    </tx:advice>\n\n    <tx:advice id="noTxAdvice">\n        <tx:attributes>\n            <tx:method name="*" propagation="NEVER"/>\n        </tx:attributes>\n    </tx:advice>\n\n    \x3c!-- other transaction infrastructure beans such as a TransactionManager omitted... --\x3e\n\n</beans>\n\n\n\n# <tx:advice/> 配置\n\n<tx:advice/> 的默认配置为：\n\n * 传播设置是 REQUIRED\n\n * 隔离级别为 DEFAULT\n\n * 事务是 read-write\n\n * 事务超时默认为底层事务系统的默认超时，如果不支持超时，则为无。\n\n * 任何 RuntimeException 都会触发回滚，而任何已检查的 Exception 都不会\n\n<tx:advice/> 配置属性\n\n属性                是否必要   默认值        描述\nname              Yes               与事务属性关联的方法名称。支持通配符，如：get*、handle*、on*Event\npropagation       No     REQUIRED   事务传播行为\nisolation         No     DEFAULT    事务隔离级别。仅适用于 REQUIRED 或 REQUIRES_NEW 的传播设置。\ntimeout           No     -1         事务超时时间（单位：秒）。仅适用于 REQUIRED 或 REQUIRES_NEW 的传播设置。\nread-only         No     false      read-write 或 read-only 事务。\nrollback-for      No                触发回滚的 Exception 实例列表（通过逗号分隔）。\nno-rollback-for   No                不触发回滚的 Exception 实例列表（通过逗号分隔）。\n\n\n# 使用 @Transactional 注解\n\n除了基于 XML 的声明式事务配置方法之外，您还可以使用基于注解的方法。\n\n下面是一个使用 @Transactional 注解的示例：\n\n@Transactional\npublic class DefaultFooService implements FooService {\n\n    @Override\n    public Foo getFoo(String fooName) {\n        // ...\n    }\n\n    @Override\n    public Foo getFoo(String fooName, String barName) {\n        // ...\n    }\n\n    @Override\n    public void insertFoo(Foo foo) {\n        // ...\n    }\n\n    @Override\n    public void updateFoo(Foo foo) {\n        // ...\n    }\n}\n\n\n如上所述在类级别使用，@Transactional 注解表明声明类（及其子类）的所有方法都使用默认事务配置。 或者，可以单独为每个方法指定注解。请注意，类级别的注解不适用于类层次结构中的祖先类； 在这种情况下，继承的方法需要在本地重新声明才能参与子类级别的注解。\n\n当上面的 POJO 类在 Spring 上下文中定义为 bean 时，您可以通过 @Configuration 类中的 @EnableTransactionManagement 注解使 bean 实例具有事务性。\n\n在 XML 配置中， <tx:annotation-driven/> 标签提供了类似的便利：\n\n\x3c!-- from the file \'context.xml\' --\x3e\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n    xmlns:aop="http://www.springframework.org/schema/aop"\n    xmlns:tx="http://www.springframework.org/schema/tx"\n    xsi:schemaLocation="\n        http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/tx\n        https://www.springframework.org/schema/tx/spring-tx.xsd\n        http://www.springframework.org/schema/aop\n        https://www.springframework.org/schema/aop/spring-aop.xsd">\n\n    \x3c!-- this is the service object that we want to make transactional --\x3e\n    <bean id="fooService" class="x.y.service.DefaultFooService"/>\n\n    \x3c!-- enable the configuration of transactional behavior based on annotations --\x3e\n    \x3c!-- a TransactionManager is still required --\x3e\n    <tx:annotation-driven transaction-manager="txManager"/>\n\n    <bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">\n        \x3c!-- (this dependency is defined somewhere else) --\x3e\n        <property name="dataSource" ref="dataSource"/>\n    </bean>\n\n    \x3c!-- other <bean/> definitions here --\x3e\n\n</beans>\n\n\n# @Transactional 配置\n\nPROPERTY                 TYPE                                                         DESCRIPTION\nvalue                    String                                                       Optional qualifier that specifies the transaction manager to\n                                                                                      be used.\ntransactionManager       String                                                       Alias for value.\nlabel                    Array of String labels to add an expressive description to   Labels may be evaluated by transaction managers to associate\n                         the transaction.                                             implementation-specific behavior with the actual\n                                                                                      transaction.\npropagation              enum: Propagation                                            Optional propagation setting.\nisolation                enum: Isolation                                              Optional isolation level. Applies only to propagation values\n                                                                                      of REQUIRED or REQUIRES_NEW.\ntimeout                  int (in seconds of granularity)                              Optional transaction timeout. Applies only to propagation\n                                                                                      values of REQUIRED or REQUIRES_NEW.\ntimeoutString            String (in seconds of granularity)                           Alternative for specifying the timeout in seconds as a\n                                                                                      String value — for example, as a placeholder.\nreadOnly                 boolean                                                      Read-write versus read-only transaction. Only applicable to\n                                                                                      values of REQUIRED or REQUIRES_NEW.\nrollbackFor              Array of Class objects, which must be derived from           Optional array of exception types that must cause rollback.\n                         Throwable.\nrollbackForClassName     Array of exception name patterns.                            Optional array of exception name patterns that must cause\n                                                                                      rollback.\nnoRollbackFor            Array of Class objects, which must be derived from           Optional array of exception types that must not cause\n                         Throwable.                                                   rollback.\nnoRollbackForClassName   Array of exception name patterns.                            Optional array of exception name patterns that must not\n                                                                                      cause rollback.\n\n# 多事务管理器场景下使用 @Transactional\n\n某些情况下，应用程序中可能需要接入多个数据源，相应的，也需要多个独立的事务管理器。使用者可以使用 @Transactional 注释的 value 或 transactionManager 属性来选择性地指定要使用的 TransactionManager 的标识。这可以是 bean 名称或事务管理器 bean 的限定符值。\n\npublic class TransactionalService {\n\n    @Transactional("order")\n    public void setSomething(String name) { ... }\n\n    @Transactional("account")\n    public void doSomething() { ... }\n\n    @Transactional("reactive-account")\n    public Mono<Void> doSomethingReactive() { ... }\n}\n\n\n下面展示如何定义 TransactionManager：\n\n<tx:annotation-driven/>\n\n    <bean id="transactionManager1" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">\n        ...\n        <qualifier value="order"/>\n    </bean>\n\n    <bean id="transactionManager2" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">\n        ...\n        <qualifier value="account"/>\n    </bean>\n\n    <bean id="transactionManager3" class="org.springframework.data.r2dbc.connectionfactory.R2dbcTransactionManager">\n        ...\n        <qualifier value="reactive-account"/>\n    </bean>\n\n\n在这种情况下，TransactionalService 上的各个方法在单独的事务管理器下运行，由 order、account 和 reactive-account 限定符区分。 如果没有找到明确指定的 TransactionManager bean，则仍使用默认的 <tx:annotation-driven> 目标 bean 名称。\n\n# 自定义组合注解\n\n如果您发现在许多不同的方法上重复使用 @Transactional 相同的属性，可以使用 Spring 的元注解自定义组合注解。\n\n@Target({ElementType.METHOD, ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Transactional(transactionManager = "order", label = "causal-consistency")\npublic @interface OrderTx {\n}\n\n@Target({ElementType.METHOD, ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Transactional(transactionManager = "account", label = "retryable")\npublic @interface AccountTx {\n}\n\n\n使用示例：\n\npublic class TransactionalService {\n\n    @OrderTx\n    public void setSomething(String name) {\n        // ...\n    }\n\n    @AccountTx\n    public void doSomething() {\n        // ...\n    }\n}\n\n\n在上面的示例中，我们使用语法来定义事务管理器限定符和事务标签，但我们也可以包括传播行为、回滚规则、超时和其他特性。\n\n# 事务传播\n\n在 Spring 管理的事务中，请注意物理事务和逻辑事务之间的差异，以及传播设置如何应用于这种差异。\n\n\n\nPROPAGATION_REQUIRED 强制执行物理事务，如果尚不存在事务，则在当前范围的本地执行或参与更大范围定义的现有“外部”事务。 这是同一线程内的常见调用堆栈安排中的一个很好的默认设置（例如，委托给多个存储库方法的服务外观，其中所有底层资源都必须参与服务级事务）。\n\n当传播设置为 PROPAGATION_REQUIRED 时，将为应用该设置的每个方法创建一个逻辑事务范围。每个这样的逻辑事务范围可以单独确定仅回滚状态，外部事务范围在逻辑上独立于内部事务范围。在标准 PROPAGATION_REQUIRED 行为的情况下，所有这些范围都映射到同一个物理事务。因此，在内部事务范围内设置的仅回滚标记确实会影响外部事务实际提交的机会。\n\n但是，在内部事务范围设置了仅回滚标记的情况下，外部事务尚未决定回滚本身，因此回滚（由内部事务范围静默触发）是意外的。此时会引发相应的 UnexpectedRollbackException。这是预期的行为，因此事务的调用者永远不会被误导以为执行了提交，而实际上并没有执行。因此，如果内部事务（外部调用者不知道）默默地将事务标记为仅回滚，外部调用者仍会调用提交。外部调用者需要接收 UnexpectedRollbackException 以清楚地指示执行了回滚。\n\n\n\nPROPAGATION_REQUIRES_NEW 与 PROPAGATION_REQUIRED 相比，始终为每个受影响的事务范围使用独立的物理事务，从不参与外部范围的现有事务。 在这种安排下，底层资源事务是不同的，因此可以独立提交或回滚，外部事务不受内部事务回滚状态的影响，内部事务的锁在完成后立即释放。 这样一个独立的内部事务也可以声明自己的隔离级别、超时和只读设置，而不是继承外部事务的特性。\n\n\n# JDBC 异常抽象\n\nSpring 会将数据操作的异常转换为 DataAccessException。\n\nSpring 是怎么认识那些错误码的\n\n通过 SQLErrorCodeSQLExceptionTranslator 解析错误码\n\nErrorCode 定义（sql-error-codes.xml 文件）\n\n\n# Spring 事务最佳实践\n\n\n\n\n# Spring 事务未生效\n\n使用 @Transactional 注解开启声明式事务时， 最容易忽略的问题是，很可能事务并没有生效。\n\n@Transactional 生效原则：\n\n# @Transactional 方法必须是 public\n\n原则一：除非特殊配置（比如使用 AspectJ 静态织入实现 AOP），否则只有定义在 public 方法上的 @Transactional 才能生效。原因是，Spring 默认通过动态代理的方式实现 AOP，对目标方法进行增强，private 方法无法代理到，Spring 自然也无法动态增强事务处理逻辑。\n\n【示例】错误使用 @Transactional 案例一\n\n\t@Transactional\n\tvoid createUserPrivate(UserEntity entity) {\n\t\tuserRepository.save(entity);\n\t\tif (entity.getName().contains("test")) { throw new RuntimeException("invalid username!"); }\n\t}\n\n\t//私有方法\n\tpublic int createUserWrong1(String name) {\n\t\ttry {\n\t\t\tthis.createUserPrivate(new UserEntity(name));\n\t\t} catch (Exception ex) {\n\t\t\tlog.error("create user failed because {}", ex.getMessage());\n\t\t}\n\t\treturn userRepository.findByName(name).size();\n\t}\n\n\n当传入名为 test 的用户实体，会抛出异常，但 @Transactional 未生效，不会触发回滚。\n\n# 必须通过 Spring 注入的 Bean 进行调用\n\n原则二：必须通过代理过的类从外部调用目标方法才能生效。\n\n【示例】错误使用 @Transactional 案例二\n\n\t//自调用\n\tpublic int createUserWrong2(String name) {\n\t\ttry {\n\t\t\tthis.createUserPublic(new UserEntity(name));\n\t\t} catch (Exception ex) {\n\t\t\tlog.error("create user failed because {}", ex.getMessage());\n\t\t}\n\t\treturn userRepository.findByName(name).size();\n\t}\n\n\t//可以传播出异常\n\t@Transactional\n\tpublic void createUserPublic(UserEntity entity) {\n\t\tuserRepository.save(entity);\n\t\tif (entity.getName().contains("test")) { throw new RuntimeException("invalid username!"); }\n\t}\n\n\n当传入名为 test 的用户实体，会抛出异常，但 @Transactional 未生效，不会触发回滚。\n\n说明：Spring 通过 AOP 技术对方法进行字节码增强，要调用增强过的方法必然是调用代理后的对象。\n\n\n# 事务虽然生效但未回滚\n\n通过 AOP 实现事务处理可以理解为，使用 try…catch… 来包裹标记了 @Transactional 注解的方法，当方法出现了异常并且满足一定条件的时候，在 catch 里面我们可以设置事务回滚，没有异常则直接提交事务。\n\n“一定条件”，主要包括两点：\n\n第一，只有异常传播出了标记了 @Transactional 注解的方法，事务才能回滚。在 Spring 的 TransactionAspectSupport 里有个 invokeWithinTransaction 方法，里面就是处理事务的逻辑。\n\n第二，默认情况下，出现 RuntimeException（非受检异常）或 Error 的时候，Spring 才会回滚事务。\n\n@Service\n@Slf4j\npublic class UserService {\n\n\t@Autowired\n\tprivate UserRepository userRepository;\n\n\t//异常无法传播出方法，导致事务无法回滚\n\t@Transactional\n\tpublic void createUserWrong1(String name) {\n\t\ttry {\n\t\t\tuserRepository.save(new UserEntity(name));\n\t\t\tthrow new RuntimeException("error");\n\t\t} catch (Exception ex) {\n\t\t\tlog.error("create user failed", ex);\n\t\t}\n\t}\n\n\t//即使出了受检异常也无法让事务回滚\n\t@Transactional\n\tpublic void createUserWrong2(String name) throws IOException {\n\t\tuserRepository.save(new UserEntity(name));\n\t\totherTask();\n\t}\n\n\t//因为文件不存在，一定会抛出一个IOException\n\tprivate void otherTask() throws IOException {\n\t\tFiles.readAllLines(Paths.get("file-that-not-exist"));\n\t}\n\n}\n\n\n在 createUserWrong1 方法中会抛出一个 RuntimeException，但由于方法内 catch 了所有异常，异常无法从方法传播出去，事务自然无法回滚。\n\n在 createUserWrong2 方法中，注册用户的同时会有一次 otherTask 文件读取操作，如果文件读取失败，我们希望用户注册的数据库操作回滚。虽然这里没有捕获异常，但因为 otherTask 方法抛出的是受检异常，createUserWrong2 传播出去的也是受检异常，事务同样不会回滚。\n\n【解决方案一】如果你希望自己捕获异常进行处理的话，也没关系，可以手动设置 TransactionAspectSupport.currentTransactionStatus().setRollbackOnly(); 让当前事务处于回滚状态：\n\n@Transactional\npublic void createUserRight1(String name) {\n   try {\n      userRepository.save(new UserEntity(name));\n      throw new RuntimeException("error");\n   } catch (Exception ex) {\n      log.error("create user failed", ex);\n      TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();\n   }\n}\n\n\n【解决方案二】在注解中声明 @Transactional(rollbackFor = Exception.class)，期望遇到所有的 Exception 都回滚事务（来突破默认不回滚受检异常的限制）：\n\n@Transactional(rollbackFor = Exception.class)\npublic void createUserRight2(String name) throws IOException {\n   userRepository.save(new UserEntity(name));\n   otherTask();\n}\n\n\n\n# 细化事务传播方式\n\n如果方法涉及多次数据库操作，并希望将它们作为独立的事务进行提交或回滚，那么 我们需要考虑进一步细化配置事务传播方式，也就是 @Transactional 注解的 Propagation 属性。\n\n/**\n * {@link Propagation#REQUIRES_NEW} 表示执行到这个方法时需要开启新的事务，并挂起当前事务\n */\n@Transactional(propagation = Propagation.REQUIRES_NEW)\npublic void createSubUserWithExceptionRight(UserEntity entity) {\n   log.info("createSubUserWithExceptionRight start");\n   userRepository.save(entity);\n   throw new RuntimeException("invalid status");\n}\n\n\n\n# 参考资料\n\n * Spring 官网\n * Spring 官方文档\n * Spring Boot 官方文档\n * 《Java 业务开发常见错误 100 例》',normalizedContent:'# spring 之事务\n\nspring 针对 java transaction api (jta)、jdbc、hibernate 和 java persistence api(jpa) 等事务 api，实现了一致的编程模型，而 spring 的声明式事务功能更是提供了极其方便的事务配置方式，配合 spring boot 的自动配置，大多数 spring boot 项目只需要在方法上标记 @transactional 注解，即可一键开启方法的事务性配置。\n\n\n# 理解事务\n\n在软件开发领域，全有或全无的操作被称为事务（transaction）。事务允许你将几个操作组合成一个要么全部发生要么全部不发生的工作单元。传统上 java ee 开发对事务管理有两种选择：全局事务或本地事务，两者都有很大的局限性。\n\n\n# 事务的特性\n\n事务应该具有 4 个属性：原子性、一致性、隔离性、持久性。这四个属性通常称为 acid。\n\n * 原子性（atomic）：一个事务是一个不可分割的工作单位，事务中包括的诸操作要么都做，要么都不做。\n * 一致性（consistent）：事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。\n * 隔离性（isolated）：一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。\n * 持久性（durable）：持久性也称永久性（permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。\n\n\n# 全局事务\n\n全局事务允许您使用多个事务资源，通常是关系数据库和消息队列。应用服务器通过 jta 管理全局事务，这是一个繁琐的 api（部分原因在于其异常模型）。此外，jta usertransaction 通常需要来自 jndi，这意味着您还需要使用 jndi 才能使用 jta。全局事务的使用限制了应用程序代码的任何潜在重用，因为 jta 通常仅在应用程序服务器环境中可用。\n\n以前，使用全局事务的首选方式是通过 ejb cmt（容器管理事务）。 cmt 是一种声明式事务管理（不同于程序化事务管理）。 ejb cmt 消除了对与事务相关的 jndi 查找的需要，尽管使用 ejb 本身就需要使用 jndi。它消除了大部分（但不是全部）编写 java 代码来控制事务的需要。其明显的缺点是 cmt 与 jta 和应用程序服务器环境相关联。此外，它仅在选择在 ejb 中实现业务逻辑（或至少在事务性 ejb 外观之后）时才可用。一般来说，ejb 的负面影响是如此之大，以至于这不是一个有吸引力的提议，尤其是在面对声明式事务管理的引人注目的替代方案时。\n\n\n# 本地事务\n\n本地事务是指定资源的，例如与 jdbc 连接关联的事务。本地事务可能更容易使用，但有一个明显的缺点：它们不能跨多个事务资源工作。例如，使用 jdbc 连接管理事务的代码不能在全局 jta 事务中运行。因为应用服务器不参与事务管理，它不能确保跨多个资源的正确性（值得注意的是，大多数应用程序使用单个事务资源。）。另一个缺点是本地事务对编程模型具有侵入性。\n\n\n# spring 对事务的支持\n\nspring 通过回调机制将实际的事务实现从事务性的代码中抽象出来。spring 解决了全局和本地事务的缺点。它允许开发人员在任何环境中使用一致的编程模型。您只需编写一次代码，它就可以从不同环境中的不同事务管理策略中受益。spring 提供了对编码式和声明式事务管理的支持，大多数情况下都推荐使用声明式事务管理。\n\n * 编码式事务允许用户在代码中精确定义事务的边界\n * 声明式事务（基于 aop）有助于用户将操作与事务规则进行解耦\n\n通过程序化事务管理，开发人员可以使用 spring 事务抽象，它可以在任何底层事务基础上运行。使用首选的声明性模型，开发人员通常编写很少或根本不编写与事务管理相关的代码，因此不依赖 spring 事务 api 或任何其他事务 api。\n\n\n# spring 事务的优点\n\nspring 框架为事务管理提供了一致的抽象，具有以下好处：\n\n * 跨不同事务 api 的一致编程模型，例如 java transaction api (jta)、jdbc、hibernate 和 java persistence api (jpa)。\n * 支持声明式事务管理。\n * 用于编程事务管理的 api 比复杂事务 api（如 jta）更简单。\n * 与 spring 的数据访问抽象完美集成。\n\n\n# 核心 api\n\n\n# transactionmanager\n\nspring 事务抽象的关键是事务策略的概念。事务策略由 transactionmanager 定义，特别是用于命令式事务管理的 org.springframework.transaction.platformtransactionmanager 接口和用于响应式事务管理的 org.springframework.transaction.reactivetransactionmanager 接口。\n\n\n\n# platformtransactionmanager\n\n以下清单显示了 platformtransactionmanager api 的定义：\n\npublic interface platformtransactionmanager extends transactionmanager {\n\n    transactionstatus gettransaction(transactiondefinition definition) throws transactionexception;\n\n    void commit(transactionstatus status) throws transactionexception;\n\n    void rollback(transactionstatus status) throws transactionexception;\n}\n\n\nplatformtransactionmanager 是一个 spi 接口，所以使用者可以以编程方式使用它。因为 platformtransactionmanager 是一个接口，所以可以根据需要轻松地 mock 或存根。它不依赖于查找策略，例如 jndi。 platformtransactionmanager 实现的定义与 spring ioc 容器中的任何其他对象（或 bean）一样。仅此一项优势就使 spring 事务成为有价值的抽象，即使您使用 jta 也是如此。与直接使用 jta 相比，您可以更轻松地测试事务代码。\n\n同样，为了与 spring 的理念保持一致，任何 platformtransactionmanager 接口的方法可以抛出的 transactionexception 都是未经检查的（也就是说，它扩展了 java.lang.runtimeexception 类）。事务架构故障几乎总是致命的。极少数情况下，应用程序可以从事务失败中恢复，开发人员可以选择捕获和处理 transactionexception。重点是开发人员并非被迫这样做。\n\ngettransaction(..) 方法根据 transactiondefinition 参数返回一个 transactionstatus 对象。如果当前调用堆栈中存在匹配的事务，则返回的 transactionstatus 可能表示新事务或可以表示现有事务。后一种情况的含义是，与 java ee 事务上下文一样，transactionstatus 与执行线程相关联。\n\n从以上可以看出，具体的事务管理机制对 spring 来说是透明的，它并不关心那些，那些是对应各个平台需要关心的，所以 spring 事务管理的一个优点就是为不同的事务 api 提供一致的编程模型，如 jta、jdbc、hibernate、jpa。下面分别介绍各个平台框架实现事务管理的机制。\n\n# jdbc 事务\n\n如果应用程序中直接使用 jdbc 来进行持久化，datasourcetransactionmanager 会为你处理事务边界。为了使用 datasourcetransactionmanager，你需要使用如下的 xml 将其装配到应用程序的上下文定义中：\n\n<bean id="transactionmanager" class="org.springframework.jdbc.datasource.datasourcetransactionmanager">\n  <property name="datasource" ref="datasource" />\n</bean>\n\n\n实际上，datasourcetransactionmanager 是通过调用 java.sql.connection 来管理事务，而后者是通过 datasource 获取到的。通过调用连接的 commit() 方法来提交事务，同样，事务失败则通过调用 rollback() 方法进行回滚。\n\n# hibernate 事务\n\n如果应用程序的持久化是通过 hibernate 实现的，那么你需要使用 hibernatetransactionmanager。对于 hibernate3，需要在 spring 上下文定义中添加如下的 bean 声明：\n\n<bean id="transactionmanager" class="org.springframework.orm.hibernate3.hibernatetransactionmanager">\n  <property name="sessionfactory" ref="sessionfactory" />\n</bean>\n\n\nsessionfactory 属性需要装配一个 hibernate 的 session 工厂，hibernatetransactionmanager 的实现细节是它将事务管理的职责委托给 org.hibernate.transaction 对象，而后者是从 hibernate session 中获取到的。当事务成功完成时，hibernatetransactionmanager 将会调用 transaction 对象的 commit() 方法，反之，将会调用 rollback() 方法。\n\n# java 持久化 api 事务（jpa）\n\nhibernate 多年来一直是事实上的 java 持久化标准，但是现在 java 持久化 api 作为真正的 java 持久化标准进入大家的视野。如果你计划使用 jpa 的话，那你需要使用 spring 的 jpatransactionmanager 来处理事务。你需要在 spring 中这样配置 jpatransactionmanager：\n\n<bean id="transactionmanager" class="org.springframework.orm.jpa.jpatransactionmanager">\n  <property name="sessionfactory" ref="sessionfactory" />\n</bean>\n\n\njpatransactionmanager 只需要装配一个 jpa 实体管理工厂（javax.persistence.entitymanagerfactory 接口的任意实现）。jpatransactionmanager 将与由工厂所产生的 jpa entitymanager 合作来构建事务。\n\n# java 原生 api 事务（jta）\n\n如果你没有使用以上所述的事务管理，或者是跨越了多个事务管理源（比如两个或者是多个不同的数据源），你就需要使用jtatransactionmanager：\n\n<bean id="transactionmanager" class="org.springframework.transaction.jta.jtatransactionmanager">\n  <property name="transactionmanagername" value="java:/transactionmanager" />\n</bean>\n\n\njtatransactionmanager 将事务管理的责任委托给 javax.transaction.usertransaction 和 javax.transaction.transactionmanager 对象，其中事务成功完成通过 usertransaction.commit() 方法提交，事务失败通过 usertransaction.rollback() 方法回滚。\n\n# reactivetransactionmanager\n\nspring 还为使用响应式类型或 kotlin 协程的响应式应用程序提供了事务管理抽象。以下清单显示了 org.springframework.transaction.reactivetransactionmanager 定义的事务策略：\n\npublic interface reactivetransactionmanager extends transactionmanager {\n\n    mono<reactivetransaction> getreactivetransaction(transactiondefinition definition) throws transactionexception;\n\n    mono<void> commit(reactivetransaction status) throws transactionexception;\n\n    mono<void> rollback(reactivetransaction status) throws transactionexception;\n}\n\n\n响应式事务管理器主要是一个 spi，所以使用者可以以编程方式使用它。因为 reactivetransactionmanager 是一个接口，所以可以根据需要轻松地 mock 或存根。\n\n\n# transactiondefinition\n\nplatformtransactionmanager 通过 gettransaction(transactiondefinition definition) 方法来得到事务，这个方法里面的参数是 transactiondefinition 类，这个类就定义了一些基本的事务属性。事务属性可以理解成事务的一些基本配置，描述了事务策略如何应用到方法上。\n\ntransactiondefinition 接口内容如下：\n\npublic interface transactiondefinition {\n    int getpropagationbehavior(); // 返回事务的传播行为\n    int getisolationlevel(); // 返回事务的隔离级别，事务管理器根据它来控制另外一个事务可以看到本事务内的哪些数据\n    int gettimeout();  // 返回事务必须在多少秒内完成\n    boolean isreadonly(); // 事务是否只读，事务管理器能够根据这个返回值进行优化，确保事务是只读的\n}\n\n\n我们可以发现 transactiondefinition 正好用来定义事务属性，下面详细介绍一下各个事务属性。\n\n# 传播行为\n\n事务的传播行为（propagation behavior）是指：当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。spring 定义了七种传播行为：\n\n传播行为                        含义\npropagation_required        表示当前方法必须运行在事务中。如果当前事务存在，方法将会在该事务中运行。否则，会启动一个新的事务\npropagation_supports        表示当前方法不需要事务上下文，但是如果存在当前事务的话，那么该方法会在这个事务中运行\npropagation_mandatory       表示该方法必须在事务中运行，如果当前事务不存在，则会抛出一个异常\npropagation_required_new    表示当前方法必须运行在它自己的事务中。一个新的事务将被启动。如果存在当前事务，在该方法执行期间，当前事务会被挂起。如果使用\n                            jtatransactionmanager 的话，则需要访问 transactionmanager\npropagation_not_supported   表示该方法不应该运行在事务中。如果存在当前事务，在该方法运行期间，当前事务将被挂起。如果使用\n                            jtatransactionmanager 的话，则需要访问 transactionmanager\npropagation_never           表示当前方法不应该运行在事务上下文中。如果当前正有一个事务在运行，则会抛出异常\npropagation_nested          表示如果当前已经存在一个事务，那么该方法将会在嵌套事务中运行。嵌套的事务可以独立于当前事务进行单独地提交或回滚。如果当前事务不存在，那么其行为与\n                            propagation_required\n                            一样。注意各厂商对这种传播行为的支持是有所差异的。可以参考资源管理器的文档来确认它们是否支持嵌套事务\n\n注：以下具体讲解传播行为的内容参考自 spring 事务机制详解\n\n 1. propagation_required 如果存在一个事务，则支持当前事务。如果没有事务则开启一个新的事务。\n\n// 事务属性 propagation_required\nmethoda {\n    ……\n    methodb();\n    ……\n}\n\n\n// 事务属性 propagation_required\nmethodb {\n   ……\n}\n\n\n使用 spring 声明式事务，spring 使用 aop 来支持声明式事务，会根据事务属性，自动在方法调用之前决定是否开启一个事务，并在方法执行之后决定事务提交或回滚事务。\n\n单独调用 methodb 方法：\n\nmain {\n    metodb();\n}\n\n\n相当于\n\nmain {\n    connection con=null;\n    try{\n        con = getconnection();\n        con.setautocommit(false);\n\n        //方法调用\n        methodb();\n\n        //提交事务\n        con.commit();\n    } catch(runtimeexception ex) {\n        //回滚事务\n        con.rollback();\n    } finally {\n        //释放资源\n        closecon();\n    }\n}\n\n\nspring 保证在 methodb 方法中所有的调用都获得到一个相同的连接。在调用 methodb 时，没有一个存在的事务，所以获得一个新的连接，开启了一个新的事务。 单独调用 methoda 时，在 methoda 内又会调用 methodb.\n\n执行效果相当于：\n\nmain{\n    connection con = null;\n    try{\n        con = getconnection();\n        methoda();\n        con.commit();\n    } catch(runtimeexception ex) {\n        con.rollback();\n    } finally {\n        closecon();\n    }\n}\n\n\n调用 methoda 时，环境中没有事务，所以开启一个新的事务.当在 methoda 中调用 methodb 时，环境中已经有了一个事务，所以 methodb 就加入当前事务。\n\n 2. propagation_supports 如果存在一个事务，支持当前事务。如果没有事务，则非事务的执行。但是对于事务同步的事务管理器，propagation_supports 与不使用事务有少许不同。\n\n//事务属性 propagation_required\nmethoda(){\n  methodb();\n}\n\n//事务属性 propagation_supports\nmethodb(){\n  ……\n}\n\n\n单纯的调用 methodb 时，methodb 方法是非事务的执行的。当调用 methda 时,methodb 则加入了 methoda 的事务中,事务地执行。\n\n 3. propagation_mandatory 如果已经存在一个事务，支持当前事务。如果没有一个活动的事务，则抛出异常。\n\n//事务属性 propagation_required\nmethoda(){\n    methodb();\n}\n\n//事务属性 propagation_mandatory\n    methodb(){\n    ……\n}\n\n\n当单独调用 methodb 时，因为当前没有一个活动的事务，则会抛出异常 throw new illegaltransactionstateexception(“transaction propagation ‘mandatory’ but no existing transaction found”);当调用 methoda 时，methodb 则加入到 methoda 的事务中，事务地执行。\n\n 4. propagation_requires_new 总是开启一个新的事务。如果一个事务已经存在，则将这个存在的事务挂起。\n\n//事务属性 propagation_required\nmethoda(){\n    dosomethinga();\n    methodb();\n    dosomethingb();\n}\n\n//事务属性 propagation_requires_new\nmethodb(){\n    ……\n}\n\n\n调用 a 方法：\n\nmain(){\n    methoda();\n}\n\n\n相当于\n\nmain(){\n    transactionmanager tm = null;\n    try{\n        //获得一个jta事务管理器\n        tm = gettransactionmanager();\n        tm.begin();//开启一个新的事务\n        transaction ts1 = tm.gettransaction();\n        dosomething();\n        tm.suspend();//挂起当前事务\n        try{\n            tm.begin();//重新开启第二个事务\n            transaction ts2 = tm.gettransaction();\n            methodb();\n            ts2.commit();//提交第二个事务\n        } catch(runtimeexception ex) {\n            ts2.rollback();//回滚第二个事务\n        } finally {\n            //释放资源\n        }\n        //methodb执行完后，恢复第一个事务\n        tm.resume(ts1);\n        dosomethingb();\n        ts1.commit();//提交第一个事务\n    } catch(runtimeexception ex) {\n        ts1.rollback();//回滚第一个事务\n    } finally {\n        //释放资源\n    }\n}\n\n\n在这里，我把 ts1 称为外层事务，ts2 称为内层事务。从上面的代码可以看出，ts2 与 ts1 是两个独立的事务，互不相干。ts2 是否成功并不依赖于 ts1。如果 methoda 方法在调用 methodb 方法后的 dosomethingb 方法失败了，而 methodb 方法所做的结果依然被提交。而除了 methodb 之外的其它代码导致的结果却被回滚了。使用 propagation_requires_new,需要使用 jtatransactionmanager 作为事务管理器。\n\n 5. propagation_not_supported 总是非事务地执行，并挂起任何存在的事务。使用 propagation_not_supported,也需要使用 jtatransactionmanager 作为事务管理器。（代码示例同上，可同理推出）\n 6. propagation_never 总是非事务地执行，如果存在一个活动事务，则抛出异常。\n 7. propagation_nested 如果一个活动的事务存在，则运行在一个嵌套的事务中. 如果没有活动事务, 则按 transactiondefinition.propagation_required 属性执行。这是一个嵌套事务,使用 jdbc 3.0 驱动时,仅仅支持 datasourcetransactionmanager 作为事务管理器。需要 jdbc 驱动的 java.sql.savepoint 类。有一些 jta 的事务管理器实现可能也提供了同样的功能。使用 propagation_nested，还需要把 platformtransactionmanager 的 nestedtransactionallowed 属性设为 true;而 nestedtransactionallowed 属性值默认为 false。\n\n//事务属性 propagation_required\nmethoda(){\n    dosomethinga();\n    methodb();\n    dosomethingb();\n}\n\n//事务属性 propagation_nested\nmethodb(){\n    ……\n}\n\n\n如果单独调用 methodb 方法，则按 required 属性执行。如果调用 methoda 方法，相当于下面的效果：\n\nmain(){\n    connection con = null;\n    savepoint savepoint = null;\n    try{\n        con = getconnection();\n        con.setautocommit(false);\n        dosomethinga();\n        savepoint = con2.setsavepoint();\n        try{\n            methodb();\n        } catch(runtimeexception ex) {\n            con.rollback(savepoint);\n        } finally {\n            //释放资源\n        }\n        dosomethingb();\n        con.commit();\n    } catch(runtimeexception ex) {\n        con.rollback();\n    } finally {\n        //释放资源\n    }\n}\n\n\n当 methodb 方法调用之前，调用 setsavepoint 方法，保存当前的状态到 savepoint。如果 methodb 方法调用失败，则恢复到之前保存的状态。但是需要注意的是，这时的事务并没有进行提交，如果后续的代码(dosomethingb()方法)调用失败，则回滚包括 methodb 方法的所有操作。\n\n嵌套事务一个非常重要的概念就是内层事务依赖于外层事务。外层事务失败时，会回滚内层事务所做的动作。而内层事务操作失败并不会引起外层事务的回滚。\n\npropagation_nested 与 propagation_requires_new 的区别:它们非常类似,都像一个嵌套事务，如果不存在一个活动的事务，都会开启一个新的事务。使用 propagation_requires_new 时，内层事务与外层事务就像两个独立的事务一样，一旦内层事务进行了提交后，外层事务不能对其进行回滚。两个事务互不影响。两个事务不是一个真正的嵌套事务。同时它需要 jta 事务管理器的支持。\n\n使用 propagation_nested 时，外层事务的回滚可以引起内层事务的回滚。而内层事务的异常并不会导致外层事务的回滚，它是一个真正的嵌套事务。datasourcetransactionmanager 使用 savepoint 支持 propagation_nested 时，需要 jdbc 3.0 以上驱动及 1.4 以上的 jdk 版本支持。其它的 jta trasactionmanager 实现可能有不同的支持方式。\n\npropagation_requires_new 启动一个新的, 不依赖于环境的 “内部” 事务. 这个事务将被完全 commited 或 rolled back 而不依赖于外部事务, 它拥有自己的隔离范围, 自己的锁, 等等. 当内部事务开始执行时, 外部事务将被挂起, 内务事务结束时, 外部事务将继续执行。\n\n另一方面, propagation_nested 开始一个 “嵌套的” 事务, 它是已经存在事务的一个真正的子事务. 潜套事务开始执行时, 它将取得一个 savepoint. 如果这个嵌套事务失败, 我们将回滚到此 savepoint. 潜套事务是外部事务的一部分, 只有外部事务结束后它才会被提交。\n\n由此可见, propagation_requires_new 和 propagation_nested 的最大区别在于, propagation_requires_new 完全是一个新的事务, 而 propagation_nested 则是外部事务的子事务, 如果外部事务 commit, 嵌套事务也会被 commit, 这个规则同样适用于 roll back.\n\npropagation_required 应该是我们首先的事务传播行为。它能够满足我们大多数的事务需求。\n\n# 隔离级别\n\n事务的第二个维度就是隔离级别（isolation level）。隔离级别定义了一个事务可能受其他并发事务影响的程度。\n\n 1. 并发事务引起的问题\n\n在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务。并发虽然是必须的，但可能会导致一下的问题。\n\n * 脏读（dirty reads）——脏读发生在一个事务读取了另一个事务改写但尚未提交的数据时。如果改写在稍后被回滚了，那么第一个事务获取的数据就是无效的。\n * 不可重复读（nonrepeatable read）——不可重复读发生在一个事务执行相同的查询两次或两次以上，但是每次都得到不同的数据时。这通常是因为另一个并发事务在两次查询期间进行了更新。\n * 幻读（phantom read）——幻读与不可重复读类似。它发生在一个事务（t1）读取了几行数据，接着另一个并发事务（t2）插入了一些数据时。在随后的查询中，第一个事务（t1）就会发现多了一些原本不存在的记录。\n\n不可重复读与幻读的区别\n\n不可重复读的重点是修改: 同样的条件, 你读取过的数据, 再次读取出来发现值不一样了 例如：在事务 1 中，mary 读取了自己的工资为 1000,操作并没有完成\n\n    con1 = getconnection();\n    select salary from employee empid ="mary";\n\n\n在事务 2 中，这时财务人员修改了 mary 的工资为 2000,并提交了事务.\n\n    con2 = getconnection();\n    update employee set salary = 2000;\n    con2.commit();\n\n\n在事务 1 中，mary 再次读取自己的工资时，工资变为了 2000\n\n    //con1\n    select salary from employee empid ="mary";\n\n\n在一个事务中前后两次读取的结果并不一致，导致了不可重复读。\n\n幻读的重点在于新增或者删除： 同样的条件, 第 1 次和第 2 次读出来的记录数不一样 例如：目前工资为 1000 的员工有 10 人。事务 1,读取所有工资为 1000 的员工。\n\n    con1 = getconnection();\n    select * from employee where salary =1000;\n\n\n共读取 10 条记录\n\n这时另一个事务向 employee 表插入了一条员工记录，工资也为 1000\n\n    con2 = getconnection();\n    insert into employee(empid,salary) values("lili",1000);\n    con2.commit();\n\n\n事务 1 再次读取所有工资为 1000 的员工\n\n    //con1\n    select * from employee where salary =1000;\n\n\n共读取到了 11 条记录，这就产生了幻像读。\n\n从总的结果来看, 似乎不可重复读和幻读都表现为两次读取的结果不一致。但如果你从控制的角度来看, 两者的区别就比较大。 对于前者, 只需要锁住满足条件的记录。 对于后者, 要锁住满足条件及其相近的记录。\n\n 2. 隔离级别\n\n隔离级别                         含义\nisolation_default            使用后端数据库默认的隔离级别\nisolation_read_uncommitted   最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读\nisolation_read_committed     允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生\nisolation_repeatable_read    对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生\nisolation_serializable       最高的隔离级别，完全服从 acid\n                             的隔离级别，确保阻止脏读、不可重复读以及幻读，也是最慢的事务隔离级别，因为它通常是通过完全锁定事务相关的数据库表来实现的\n\n# 只读\n\n事务的第三个特性是它是否为只读事务。如果事务只对后端的数据库进行该操作，数据库可以利用事务的只读特性来进行一些特定的优化。通过将事务设置为只读，你就可以给数据库一个机会，让它应用它认为合适的优化措施。\n\n# 事务超时\n\n为了使应用程序很好地运行，事务不能运行太长的时间。因为事务可能涉及对后端数据库的锁定，所以长时间的事务会不必要的占用数据库资源。事务超时就是事务的一个定时器，在特定时间内事务如果没有执行完毕，那么就会自动回滚，而不是一直等待其结束。\n\n# 回滚规则\n\n事务五边形的最后一个方面是一组规则，这些规则定义了哪些异常会导致事务回滚而哪些不会。默认情况下，事务只有遇到运行期异常时才会回滚，而在遇到检查型异常时不会回滚（这一行为与 ejb 的回滚行为是一致的） 但是你可以声明事务在遇到特定的检查型异常时像遇到运行期异常那样回滚。同样，你还可以声明事务遇到特定的异常不回滚，即使这些异常是运行期异常。\n\n\n# transactionstatus\n\ntransactionstatus 接口为事务代码提供了一种简单的方式来控制事务执行和查询事务状态。这些概念应该很熟悉，因为它们对所有事务 api 都是通用的。以下清单显示了 transactionstatus 接口：\n\npublic interface transactionstatus extends transactionexecution, savepointmanager, flushable {\n\n    @override\n    boolean isnewtransaction();\n\n    boolean hassavepoint();\n\n    @override\n    void setrollbackonly();\n\n    @override\n    boolean isrollbackonly();\n\n    void flush();\n\n    @override\n    boolean iscompleted();\n}\n\n\n可以发现这个接口描述的是一些处理事务提供简单的控制事务执行和查询事务状态的方法，在回滚或提交的时候需要应用对应的事务状态。\n\n\n# transactiontemplate\n\nspring 提供了对编程式事务和声明式事务的支持。编程式事务允许用户在代码中精确定义事务的边界，而声明式事务（基于 aop）有助于用户将操作与事务规则进行解耦。transactiontemplate 就是用于支持编程式事务的核心 api。\n\n采用 transactiontemplate 和采用其他 spring 模板，如 jdbctempalte 和 hibernatetemplate 是一样的方法。它使用回调方法，把应用程序从处理取得和释放资源中解脱出来。如同其他模板，transactiontemplate 是线程安全的。代码片段：\n\n    transactiontemplate tt = new transactiontemplate(); // 新建一个transactiontemplate\n    object result = tt.execute(\n        new transactioncallback(){\n            public object dotransaction(transactionstatus status){\n                updateoperation();\n                return resultofupdateoperation();\n            }\n    }); // 执行execute方法进行事务管理\n\n\n使用 transactioncallback()可以返回一个值。如果使用 transactioncallbackwithoutresult 则没有返回值。\n\n\n# 声明式事务管理\n\n> 大多数 spring 用户选择声明式事务管理。此选项对应用程序代码的影响最小，因此最符合非侵入式轻量级容器的理想。\n\nspring 框架的声明式事务管理是通过 spring aop 实现的。然而，由于事务方面代码随 spring 发行版一起提供并且可以以样板方式使用，因此通常不必理解 aop 概念即可有效地使用此代码。\n\nspring 框架的声明式事务管理类似于 ejb cmt，因为您可以指定事务行为（或缺少它）到单个方法级别。如有必要，您可以在事务上下文中进行 setrollbackonly() 调用。两种类型的事务管理之间的区别是：\n\n * 与绑定到 jta 的 ejb cmt 不同，spring 框架的声明式事务管理适用于任何环境。通过调整配置文件，它可以使用 jdbc、jpa 或 hibernate 处理 jta 事务或本地事务。\n * 您可以将 spring 声明式事务管理应用于任何类，而不仅仅是诸如 ejb 之类的特殊类。\n * spring 提供声明性回滚规则，这是一个没有 ejb 等效功能的特性。提供了对回滚规则的编程和声明性支持。\n * spring 允许您使用 aop 自定义事务行为。例如，您可以在事务回滚的情况下插入自定义行为。您还可以添加任意 advice 以及事务性 advice。使用 ejb cmt，您无法影响容器的事务管理，除非使用 setrollbackonly()。\n * spring 不像高端应用服务器那样支持跨远程调用传播事务上下文。如果您需要此功能，我们建议您使用 ejb。但是，在使用这种特性之前要仔细考虑，因为通常情况下，不希望事务跨越远程调用。\n\n回滚规则的概念很重要。它们让您指定哪些异常（和 throwable）应该导致自动回滚。您可以在配置中以声明方式指定它，而不是在 java 代码中。因此，尽管您仍然可以在 transactionstatus 对象上调用 setrollbackonly() 来回滚当前事务，但通常您可以指定 myapplicationexception 必须始终导致回滚的规则。此选项的显着优势是业务对象不依赖于事务基础架构。例如，它们通常不需要导入 spring 事务 api 或其他 spring api。\n\n尽管 ejb 容器默认行为会在系统异常（通常是运行时异常）上自动回滚事务，但 ejb cmt 不会在应用程序异常（即除 java.rmi.remoteexception 之外的检查异常）上自动回滚事务。虽然声明式事务管理的 spring 默认行为遵循 ejb 约定（回滚仅在未经检查的异常上自动），但自定义此行为通常很有用。\n\n\n# spring 声明式事务管理的实现\n\n关于 spring 框架的声明式事务支持，最重要的概念是这种支持是通过 aop 代理启用的，并且事务 advice 是由元数据驱动的（目前是基于 xml 或基于注释的）。 aop 与事务元数据的结合产生了一个 aop 代理，它使用 transactioninterceptor 和适当的 transactionmanager 实现来驱动围绕方法调用的事务。\n\nspring 的 transactioninterceptor 为命令式和响应式编程模型提供事务管理。拦截器通过检查方法返回类型来检测所需的事务管理风格。返回响应式类型的方法，例如 publisher 或 kotlin flow（或它们的子类型）有资格进行响应式事务管理。包括 void 在内的所有其他返回类型都使用代码路径进行命令式事务管理。\n\n事务管理风格会影响需要哪个事务管理器。命令式事务需要 platformtransactionmanager，而响应式事务使用 reactivetransactionmanager 实现。\n\n> @transactional 通常与 platformtransactionmanager 管理的线程绑定事务一起使用，将事务公开给当前执行线程中的所有数据访问操作。注意：这不会传播到方法中新启动的线程。\n> \n> 由 reactivetransactionmanager 管理的反应式事务使用 reactor 上下文而不是线程本地属性。因此，所有参与的数据访问操作都需要在同一个反应式管道中的同一个 reactor 上下文中执行。\n\n下图显示了在事务代理上调用方法的概念视图：\n\n\n\n\n# 声明式事务示例\n\n考虑以下接口及其伴随的实现。此示例使用 foo 和 bar 类作为占位符，以便您可以专注于事务使用，而无需关注特定的域模型。就本示例而言，defaultfooservice 类在每个已实现方法的主体中抛出 unsupportedoperationexception 实例这一事实很好。该行为使您可以看到正在创建的事务，然后回滚以响应 unsupportedoperationexception 实例。\n\n以下清单显示了 fooservice 接口：\n\n// the service interface that we want to make transactional\n\npackage x.y.service;\n\npublic interface fooservice {\n\n    foo getfoo(string fooname);\n\n    foo getfoo(string fooname, string barname);\n\n    void insertfoo(foo foo);\n\n    void updatefoo(foo foo);\n\n}\n\n\n以下示例显示了上述接口的实现：\n\npackage x.y.service;\n\npublic class defaultfooservice implements fooservice {\n\n    @override\n    public foo getfoo(string fooname) {\n        // ...\n    }\n\n    @override\n    public foo getfoo(string fooname, string barname) {\n        // ...\n    }\n\n    @override\n    public void insertfoo(foo foo) {\n        // ...\n    }\n\n    @override\n    public void updatefoo(foo foo) {\n        // ...\n    }\n}\n\n\n假设 fooservice 接口的前两个方法 getfoo(string) 和 getfoo(string, string) 必须在具有只读语义的事务上下文中运行，并且其他方法 insertfoo(foo) 和 updatefoo(foo )，必须在具有读写语义的事务上下文中运行。以下配置将在接下来的几段中详细说明：\n\n\x3c!-- from the file \'context.xml\' --\x3e\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n    xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n    xmlns:aop="http://www.springframework.org/schema/aop"\n    xmlns:tx="http://www.springframework.org/schema/tx"\n    xsi:schemalocation="\n        http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/tx\n        https://www.springframework.org/schema/tx/spring-tx.xsd\n        http://www.springframework.org/schema/aop\n        https://www.springframework.org/schema/aop/spring-aop.xsd">\n\n    \x3c!-- this is the service object that we want to make transactional --\x3e\n    <bean id="fooservice" class="x.y.service.defaultfooservice"/>\n\n    \x3c!-- the transactional advice (what \'happens\'; see the <aop:advisor/> bean below) --\x3e\n    <tx:advice id="txadvice" transaction-manager="txmanager">\n        \x3c!-- the transactional semantics... --\x3e\n        <tx:attributes>\n            \x3c!-- all methods starting with \'get\' are read-only --\x3e\n            <tx:method name="get*" read-only="true"/>\n            \x3c!-- other methods use the default transaction settings (see below) --\x3e\n            <tx:method name="*"/>\n        </tx:attributes>\n    </tx:advice>\n\n    \x3c!-- ensure that the above transactional advice runs for any execution\n        of an operation defined by the fooservice interface --\x3e\n    <aop:config>\n        <aop:pointcut id="fooserviceoperation" expression="execution(* x.y.service.fooservice.*(..))"/>\n        <aop:advisor advice-ref="txadvice" pointcut-ref="fooserviceoperation"/>\n    </aop:config>\n\n    \x3c!-- don\'t forget the datasource --\x3e\n    <bean id="datasource" class="org.apache.commons.dbcp.basicdatasource" destroy-method="close">\n        <property name="driverclassname" value="oracle.jdbc.driver.oracledriver"/>\n        <property name="url" value="jdbc:oracle:thin:@rj-t42:1521:elvis"/>\n        <property name="username" value="scott"/>\n        <property name="password" value="tiger"/>\n    </bean>\n\n    \x3c!-- similarly, don\'t forget the transactionmanager --\x3e\n    <bean id="txmanager" class="org.springframework.jdbc.datasource.datasourcetransactionmanager">\n        <property name="datasource" ref="datasource"/>\n    </bean>\n\n    \x3c!-- other <bean/> definitions here --\x3e\n\n</beans>\n\n\n检查前面的配置。它假定您要使服务对象 fooservice bean 具有事务性。要应用的事务语义封装在 <tx:advice/> 定义中。<tx:advice/> 定义读作“所有以 get 开头的方法都将在只读事务的上下文中运行，所有其他方法都将以默认事务语义运行”。<tx:advice/> 标签的 transaction-manager 属性设置为将驱动事务的 transactionmanager bean 的名称（在本例中为 txmanager bean）。\n\n> 如果要连接的 transactionmanager 的 bean 名称具有名称 transactionmanager，则可以省略事务 advice (tx:advice/) 中的 transaction-manager 属性。如果要连接的 transactionmanager bean 有任何其他名称，则必须显式使用 transaction-manager 属性，如前面的示例所示。\n\n<aop:config/> 定义确保由 txadvice bean 定义的事务性建议在程序中的适当位置运行。首先，您定义一个切入点，该切入点与 fooservice 接口 (fooserviceoperation) 中定义的任何操作的执行相匹配。然后，您使用一个 adviser 将切入点与 txadvice 相关联。结果表明，在执行 fooserviceoperation 时，会运行 txadvice 定义的建议。\n\n一个常见的要求是使整个服务层具有事务性。最好的方法是更改切入点表达式以匹配服务层中的任何操作。以下示例显示了如何执行此操作：\n\n<aop:config>\n    <aop:pointcut id="fooservicemethods" expression="execution(* x.y.service.*.*(..))"/>\n    <aop:advisor advice-ref="txadvice" pointcut-ref="fooservicemethods"/>\n</aop:config>\n\n\n前面显示的配置用于围绕从 fooservice bean 定义创建的对象创建事务代理。代理配置了事务 advice，以便在代理上调用适当的方法时，根据与该方法关联的事务配置，启动、暂停、标记为只读等事务。考虑以下测试驱动前面显示的配置的程序：\n\npublic final class boot {\n\n    public static void main(final string[] args) throws exception {\n        applicationcontext ctx = new classpathxmlapplicationcontext("context.xml");\n        fooservice fooservice = ctx.getbean(fooservice.class);\n        fooservice.insertfoo(new foo());\n    }\n}\n\n\n\n# 回滚一个声明性事务\n\nspring 框架中，触发事务回滚的推荐方式是在事务上下文的代码中抛出异常。spring 事务框架会捕获任何未处理的异常，并确定是否将事务标记为回滚。\n\n在其默认配置中，spring 事务框架只会将存在运行时且未经检查异常的事务标记为回滚。也就是说，当抛出的异常是 runtimeexception 的实例或子类时。 （默认情况下，错误实例也会导致回滚）。从事务方法抛出的检查异常不会导致默认配置中的回滚。\n\n您可以通过指定回滚规则，明确指定哪些异常类型将导致事务回滚。\n\n> 回滚规则约定在抛出指定异常时是否应回滚事务，并且规则基于模式。模式可以是完全限定的类名或异常类型的完全限定类名的子字符串（必须是 throwable 的子类），目前不支持通配符。例如，javax.servlet.servletexception 或 servletexception 的值将匹配 javax.servlet.servletexception 及其子类。\n> \n> 回滚规则可以通过 rollback-for 和 no-rollback-for 属性在 xml 中配置，这允许将模式指定为字符串。使用 @transactional 时，可以通过 rollbackfor / norollbackfor 和rollbackforclassname / norollbackforclassname 属性配置回滚规则，它们允许将模式分别指定为类引用或字符串。当异常类型被指定为类引用时，其完全限定名称将用作模式。因此，@transactional(rollbackfor = example.customexception.class) 等价于 @transactional(rollbackforclassname = \'example.customexception\')。\n\n以下 xml 片段演示了如何通过 rollback-for 属性提供异常模式来为已检查的、特定的 exception 类型配置回滚：\n\n<tx:advice id="txadvice" transaction-manager="txmanager">\n    <tx:attributes>\n    <tx:method name="get*" read-only="true" rollback-for="noproductinstockexception"/>\n    <tx:method name="*"/>\n    </tx:attributes>\n</tx:advice>\n\n\n如果您不希望在抛出异常时回滚事务，您还可以指定“不回滚”规则。下面的例子告诉 spring 事务框架，即使在面对未处理的 instrumentnotfoundexception 时也要提交伴随事务。\n\n<tx:advice id="txadvice">\n    <tx:attributes>\n    <tx:method name="updatestock" no-rollback-for="instrumentnotfoundexception"/>\n    <tx:method name="*"/>\n    </tx:attributes>\n</tx:advice>\n\n\n当 spring framework 事务框架捕获到异常，并检查配置的回滚规则以确定是否将事务标记为回滚时，由最重要的匹配规则决定。因此，在以下配置的情况下，除 instrumentnotfoundexception 之外的任何异常都会导致伴随事务的回滚。\n\n<tx:advice id="txadvice">\n    <tx:attributes>\n    <tx:method name="*" rollback-for="throwable" no-rollback-for="instrumentnotfoundexception"/>\n    </tx:attributes>\n</tx:advice>\n\n\n您还可以以编程方式指示所需的回滚。虽然很简单，但这个过程非常具有侵入性，并且将您的代码与 spring framework 的事务基础设施紧密耦合。以下示例显示如何以编程方式指示所需的回滚。\n\npublic void resolveposition() {\n    try {\n        // some business logic...\n    } catch (noproductinstockexception ex) {\n        // trigger rollback programmatically\n        transactionaspectsupport.currenttransactionstatus().setrollbackonly();\n    }\n}\n\n\n如果可能的话，强烈建议您使用声明性方法进行回滚。如果您绝对需要，可以使用程序化回滚，但它的使用与实现干净的基于 pojo 的架构背道而驰。\n\n\n# 为不同的 bean 配置不同的事务语义\n\n考虑您有许多服务层对象的场景，并且您希望对每个对象应用完全不同的事务配置。您可以通过定义具有不同 <aop:advisor/> 元素和不同 advice-ref 属性值的切点来实现这一点。\n\n作为一个比较点，首先假设您的所有服务层类都定义在根 x.y.service 包中。 要使作为该包（或子包）中定义的类的实例并且名称以 service 结尾的所有 bean 都具有默认的事务配置，您可以编写以下内容：\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n    xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n    xmlns:aop="http://www.springframework.org/schema/aop"\n    xmlns:tx="http://www.springframework.org/schema/tx"\n    xsi:schemalocation="\n        http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/tx\n        https://www.springframework.org/schema/tx/spring-tx.xsd\n        http://www.springframework.org/schema/aop\n        https://www.springframework.org/schema/aop/spring-aop.xsd">\n\n    <aop:config>\n\n        <aop:pointcut id="serviceoperation"\n                expression="execution(* x.y.service..*service.*(..))"/>\n\n        <aop:advisor pointcut-ref="serviceoperation" advice-ref="txadvice"/>\n\n    </aop:config>\n\n    \x3c!-- these two beans will be transactional... --\x3e\n    <bean id="fooservice" class="x.y.service.defaultfooservice"/>\n    <bean id="barservice" class="x.y.service.extras.simplebarservice"/>\n\n    \x3c!-- ... and these two beans won\'t --\x3e\n    <bean id="anotherservice" class="org.xyz.someservice"/> \x3c!-- (not in the right package) --\x3e\n    <bean id="barmanager" class="x.y.service.simplebarmanager"/> \x3c!-- (doesn\'t end in \'service\') --\x3e\n\n    <tx:advice id="txadvice">\n        <tx:attributes>\n            <tx:method name="get*" read-only="true"/>\n            <tx:method name="*"/>\n        </tx:attributes>\n    </tx:advice>\n\n    \x3c!-- other transaction infrastructure beans such as a transactionmanager omitted... --\x3e\n\n</beans>\n\n\n以下示例显示了如何使用完全不同的事务设置配置两个不同的 bean\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n    xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n    xmlns:aop="http://www.springframework.org/schema/aop"\n    xmlns:tx="http://www.springframework.org/schema/tx"\n    xsi:schemalocation="\n        http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/tx\n        https://www.springframework.org/schema/tx/spring-tx.xsd\n        http://www.springframework.org/schema/aop\n        https://www.springframework.org/schema/aop/spring-aop.xsd">\n\n    <aop:config>\n\n        <aop:pointcut id="defaultserviceoperation"\n                expression="execution(* x.y.service.*service.*(..))"/>\n\n        <aop:pointcut id="notxserviceoperation"\n                expression="execution(* x.y.service.ddl.defaultddlmanager.*(..))"/>\n\n        <aop:advisor pointcut-ref="defaultserviceoperation" advice-ref="defaulttxadvice"/>\n\n        <aop:advisor pointcut-ref="notxserviceoperation" advice-ref="notxadvice"/>\n\n    </aop:config>\n\n    \x3c!-- this bean will be transactional (see the \'defaultserviceoperation\' pointcut) --\x3e\n    <bean id="fooservice" class="x.y.service.defaultfooservice"/>\n\n    \x3c!-- this bean will also be transactional, but with totally different transactional settings --\x3e\n    <bean id="anotherfooservice" class="x.y.service.ddl.defaultddlmanager"/>\n\n    <tx:advice id="defaulttxadvice">\n        <tx:attributes>\n            <tx:method name="get*" read-only="true"/>\n            <tx:method name="*"/>\n        </tx:attributes>\n    </tx:advice>\n\n    <tx:advice id="notxadvice">\n        <tx:attributes>\n            <tx:method name="*" propagation="never"/>\n        </tx:attributes>\n    </tx:advice>\n\n    \x3c!-- other transaction infrastructure beans such as a transactionmanager omitted... --\x3e\n\n</beans>\n\n\n\n# <tx:advice/> 配置\n\n<tx:advice/> 的默认配置为：\n\n * 传播设置是 required\n\n * 隔离级别为 default\n\n * 事务是 read-write\n\n * 事务超时默认为底层事务系统的默认超时，如果不支持超时，则为无。\n\n * 任何 runtimeexception 都会触发回滚，而任何已检查的 exception 都不会\n\n<tx:advice/> 配置属性\n\n属性                是否必要   默认值        描述\nname              yes               与事务属性关联的方法名称。支持通配符，如：get*、handle*、on*event\npropagation       no     required   事务传播行为\nisolation         no     default    事务隔离级别。仅适用于 required 或 requires_new 的传播设置。\ntimeout           no     -1         事务超时时间（单位：秒）。仅适用于 required 或 requires_new 的传播设置。\nread-only         no     false      read-write 或 read-only 事务。\nrollback-for      no                触发回滚的 exception 实例列表（通过逗号分隔）。\nno-rollback-for   no                不触发回滚的 exception 实例列表（通过逗号分隔）。\n\n\n# 使用 @transactional 注解\n\n除了基于 xml 的声明式事务配置方法之外，您还可以使用基于注解的方法。\n\n下面是一个使用 @transactional 注解的示例：\n\n@transactional\npublic class defaultfooservice implements fooservice {\n\n    @override\n    public foo getfoo(string fooname) {\n        // ...\n    }\n\n    @override\n    public foo getfoo(string fooname, string barname) {\n        // ...\n    }\n\n    @override\n    public void insertfoo(foo foo) {\n        // ...\n    }\n\n    @override\n    public void updatefoo(foo foo) {\n        // ...\n    }\n}\n\n\n如上所述在类级别使用，@transactional 注解表明声明类（及其子类）的所有方法都使用默认事务配置。 或者，可以单独为每个方法指定注解。请注意，类级别的注解不适用于类层次结构中的祖先类； 在这种情况下，继承的方法需要在本地重新声明才能参与子类级别的注解。\n\n当上面的 pojo 类在 spring 上下文中定义为 bean 时，您可以通过 @configuration 类中的 @enabletransactionmanagement 注解使 bean 实例具有事务性。\n\n在 xml 配置中， <tx:annotation-driven/> 标签提供了类似的便利：\n\n\x3c!-- from the file \'context.xml\' --\x3e\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n    xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n    xmlns:aop="http://www.springframework.org/schema/aop"\n    xmlns:tx="http://www.springframework.org/schema/tx"\n    xsi:schemalocation="\n        http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/tx\n        https://www.springframework.org/schema/tx/spring-tx.xsd\n        http://www.springframework.org/schema/aop\n        https://www.springframework.org/schema/aop/spring-aop.xsd">\n\n    \x3c!-- this is the service object that we want to make transactional --\x3e\n    <bean id="fooservice" class="x.y.service.defaultfooservice"/>\n\n    \x3c!-- enable the configuration of transactional behavior based on annotations --\x3e\n    \x3c!-- a transactionmanager is still required --\x3e\n    <tx:annotation-driven transaction-manager="txmanager"/>\n\n    <bean id="txmanager" class="org.springframework.jdbc.datasource.datasourcetransactionmanager">\n        \x3c!-- (this dependency is defined somewhere else) --\x3e\n        <property name="datasource" ref="datasource"/>\n    </bean>\n\n    \x3c!-- other <bean/> definitions here --\x3e\n\n</beans>\n\n\n# @transactional 配置\n\nproperty                 type                                                         description\nvalue                    string                                                       optional qualifier that specifies the transaction manager to\n                                                                                      be used.\ntransactionmanager       string                                                       alias for value.\nlabel                    array of string labels to add an expressive description to   labels may be evaluated by transaction managers to associate\n                         the transaction.                                             implementation-specific behavior with the actual\n                                                                                      transaction.\npropagation              enum: propagation                                            optional propagation setting.\nisolation                enum: isolation                                              optional isolation level. applies only to propagation values\n                                                                                      of required or requires_new.\ntimeout                  int (in seconds of granularity)                              optional transaction timeout. applies only to propagation\n                                                                                      values of required or requires_new.\ntimeoutstring            string (in seconds of granularity)                           alternative for specifying the timeout in seconds as a\n                                                                                      string value — for example, as a placeholder.\nreadonly                 boolean                                                      read-write versus read-only transaction. only applicable to\n                                                                                      values of required or requires_new.\nrollbackfor              array of class objects, which must be derived from           optional array of exception types that must cause rollback.\n                         throwable.\nrollbackforclassname     array of exception name patterns.                            optional array of exception name patterns that must cause\n                                                                                      rollback.\nnorollbackfor            array of class objects, which must be derived from           optional array of exception types that must not cause\n                         throwable.                                                   rollback.\nnorollbackforclassname   array of exception name patterns.                            optional array of exception name patterns that must not\n                                                                                      cause rollback.\n\n# 多事务管理器场景下使用 @transactional\n\n某些情况下，应用程序中可能需要接入多个数据源，相应的，也需要多个独立的事务管理器。使用者可以使用 @transactional 注释的 value 或 transactionmanager 属性来选择性地指定要使用的 transactionmanager 的标识。这可以是 bean 名称或事务管理器 bean 的限定符值。\n\npublic class transactionalservice {\n\n    @transactional("order")\n    public void setsomething(string name) { ... }\n\n    @transactional("account")\n    public void dosomething() { ... }\n\n    @transactional("reactive-account")\n    public mono<void> dosomethingreactive() { ... }\n}\n\n\n下面展示如何定义 transactionmanager：\n\n<tx:annotation-driven/>\n\n    <bean id="transactionmanager1" class="org.springframework.jdbc.datasource.datasourcetransactionmanager">\n        ...\n        <qualifier value="order"/>\n    </bean>\n\n    <bean id="transactionmanager2" class="org.springframework.jdbc.datasource.datasourcetransactionmanager">\n        ...\n        <qualifier value="account"/>\n    </bean>\n\n    <bean id="transactionmanager3" class="org.springframework.data.r2dbc.connectionfactory.r2dbctransactionmanager">\n        ...\n        <qualifier value="reactive-account"/>\n    </bean>\n\n\n在这种情况下，transactionalservice 上的各个方法在单独的事务管理器下运行，由 order、account 和 reactive-account 限定符区分。 如果没有找到明确指定的 transactionmanager bean，则仍使用默认的 <tx:annotation-driven> 目标 bean 名称。\n\n# 自定义组合注解\n\n如果您发现在许多不同的方法上重复使用 @transactional 相同的属性，可以使用 spring 的元注解自定义组合注解。\n\n@target({elementtype.method, elementtype.type})\n@retention(retentionpolicy.runtime)\n@transactional(transactionmanager = "order", label = "causal-consistency")\npublic @interface ordertx {\n}\n\n@target({elementtype.method, elementtype.type})\n@retention(retentionpolicy.runtime)\n@transactional(transactionmanager = "account", label = "retryable")\npublic @interface accounttx {\n}\n\n\n使用示例：\n\npublic class transactionalservice {\n\n    @ordertx\n    public void setsomething(string name) {\n        // ...\n    }\n\n    @accounttx\n    public void dosomething() {\n        // ...\n    }\n}\n\n\n在上面的示例中，我们使用语法来定义事务管理器限定符和事务标签，但我们也可以包括传播行为、回滚规则、超时和其他特性。\n\n# 事务传播\n\n在 spring 管理的事务中，请注意物理事务和逻辑事务之间的差异，以及传播设置如何应用于这种差异。\n\n\n\npropagation_required 强制执行物理事务，如果尚不存在事务，则在当前范围的本地执行或参与更大范围定义的现有“外部”事务。 这是同一线程内的常见调用堆栈安排中的一个很好的默认设置（例如，委托给多个存储库方法的服务外观，其中所有底层资源都必须参与服务级事务）。\n\n当传播设置为 propagation_required 时，将为应用该设置的每个方法创建一个逻辑事务范围。每个这样的逻辑事务范围可以单独确定仅回滚状态，外部事务范围在逻辑上独立于内部事务范围。在标准 propagation_required 行为的情况下，所有这些范围都映射到同一个物理事务。因此，在内部事务范围内设置的仅回滚标记确实会影响外部事务实际提交的机会。\n\n但是，在内部事务范围设置了仅回滚标记的情况下，外部事务尚未决定回滚本身，因此回滚（由内部事务范围静默触发）是意外的。此时会引发相应的 unexpectedrollbackexception。这是预期的行为，因此事务的调用者永远不会被误导以为执行了提交，而实际上并没有执行。因此，如果内部事务（外部调用者不知道）默默地将事务标记为仅回滚，外部调用者仍会调用提交。外部调用者需要接收 unexpectedrollbackexception 以清楚地指示执行了回滚。\n\n\n\npropagation_requires_new 与 propagation_required 相比，始终为每个受影响的事务范围使用独立的物理事务，从不参与外部范围的现有事务。 在这种安排下，底层资源事务是不同的，因此可以独立提交或回滚，外部事务不受内部事务回滚状态的影响，内部事务的锁在完成后立即释放。 这样一个独立的内部事务也可以声明自己的隔离级别、超时和只读设置，而不是继承外部事务的特性。\n\n\n# jdbc 异常抽象\n\nspring 会将数据操作的异常转换为 dataaccessexception。\n\nspring 是怎么认识那些错误码的\n\n通过 sqlerrorcodesqlexceptiontranslator 解析错误码\n\nerrorcode 定义（sql-error-codes.xml 文件）\n\n\n# spring 事务最佳实践\n\n\n\n\n# spring 事务未生效\n\n使用 @transactional 注解开启声明式事务时， 最容易忽略的问题是，很可能事务并没有生效。\n\n@transactional 生效原则：\n\n# @transactional 方法必须是 public\n\n原则一：除非特殊配置（比如使用 aspectj 静态织入实现 aop），否则只有定义在 public 方法上的 @transactional 才能生效。原因是，spring 默认通过动态代理的方式实现 aop，对目标方法进行增强，private 方法无法代理到，spring 自然也无法动态增强事务处理逻辑。\n\n【示例】错误使用 @transactional 案例一\n\n\t@transactional\n\tvoid createuserprivate(userentity entity) {\n\t\tuserrepository.save(entity);\n\t\tif (entity.getname().contains("test")) { throw new runtimeexception("invalid username!"); }\n\t}\n\n\t//私有方法\n\tpublic int createuserwrong1(string name) {\n\t\ttry {\n\t\t\tthis.createuserprivate(new userentity(name));\n\t\t} catch (exception ex) {\n\t\t\tlog.error("create user failed because {}", ex.getmessage());\n\t\t}\n\t\treturn userrepository.findbyname(name).size();\n\t}\n\n\n当传入名为 test 的用户实体，会抛出异常，但 @transactional 未生效，不会触发回滚。\n\n# 必须通过 spring 注入的 bean 进行调用\n\n原则二：必须通过代理过的类从外部调用目标方法才能生效。\n\n【示例】错误使用 @transactional 案例二\n\n\t//自调用\n\tpublic int createuserwrong2(string name) {\n\t\ttry {\n\t\t\tthis.createuserpublic(new userentity(name));\n\t\t} catch (exception ex) {\n\t\t\tlog.error("create user failed because {}", ex.getmessage());\n\t\t}\n\t\treturn userrepository.findbyname(name).size();\n\t}\n\n\t//可以传播出异常\n\t@transactional\n\tpublic void createuserpublic(userentity entity) {\n\t\tuserrepository.save(entity);\n\t\tif (entity.getname().contains("test")) { throw new runtimeexception("invalid username!"); }\n\t}\n\n\n当传入名为 test 的用户实体，会抛出异常，但 @transactional 未生效，不会触发回滚。\n\n说明：spring 通过 aop 技术对方法进行字节码增强，要调用增强过的方法必然是调用代理后的对象。\n\n\n# 事务虽然生效但未回滚\n\n通过 aop 实现事务处理可以理解为，使用 try…catch… 来包裹标记了 @transactional 注解的方法，当方法出现了异常并且满足一定条件的时候，在 catch 里面我们可以设置事务回滚，没有异常则直接提交事务。\n\n“一定条件”，主要包括两点：\n\n第一，只有异常传播出了标记了 @transactional 注解的方法，事务才能回滚。在 spring 的 transactionaspectsupport 里有个 invokewithintransaction 方法，里面就是处理事务的逻辑。\n\n第二，默认情况下，出现 runtimeexception（非受检异常）或 error 的时候，spring 才会回滚事务。\n\n@service\n@slf4j\npublic class userservice {\n\n\t@autowired\n\tprivate userrepository userrepository;\n\n\t//异常无法传播出方法，导致事务无法回滚\n\t@transactional\n\tpublic void createuserwrong1(string name) {\n\t\ttry {\n\t\t\tuserrepository.save(new userentity(name));\n\t\t\tthrow new runtimeexception("error");\n\t\t} catch (exception ex) {\n\t\t\tlog.error("create user failed", ex);\n\t\t}\n\t}\n\n\t//即使出了受检异常也无法让事务回滚\n\t@transactional\n\tpublic void createuserwrong2(string name) throws ioexception {\n\t\tuserrepository.save(new userentity(name));\n\t\tothertask();\n\t}\n\n\t//因为文件不存在，一定会抛出一个ioexception\n\tprivate void othertask() throws ioexception {\n\t\tfiles.readalllines(paths.get("file-that-not-exist"));\n\t}\n\n}\n\n\n在 createuserwrong1 方法中会抛出一个 runtimeexception，但由于方法内 catch 了所有异常，异常无法从方法传播出去，事务自然无法回滚。\n\n在 createuserwrong2 方法中，注册用户的同时会有一次 othertask 文件读取操作，如果文件读取失败，我们希望用户注册的数据库操作回滚。虽然这里没有捕获异常，但因为 othertask 方法抛出的是受检异常，createuserwrong2 传播出去的也是受检异常，事务同样不会回滚。\n\n【解决方案一】如果你希望自己捕获异常进行处理的话，也没关系，可以手动设置 transactionaspectsupport.currenttransactionstatus().setrollbackonly(); 让当前事务处于回滚状态：\n\n@transactional\npublic void createuserright1(string name) {\n   try {\n      userrepository.save(new userentity(name));\n      throw new runtimeexception("error");\n   } catch (exception ex) {\n      log.error("create user failed", ex);\n      transactionaspectsupport.currenttransactionstatus().setrollbackonly();\n   }\n}\n\n\n【解决方案二】在注解中声明 @transactional(rollbackfor = exception.class)，期望遇到所有的 exception 都回滚事务（来突破默认不回滚受检异常的限制）：\n\n@transactional(rollbackfor = exception.class)\npublic void createuserright2(string name) throws ioexception {\n   userrepository.save(new userentity(name));\n   othertask();\n}\n\n\n\n# 细化事务传播方式\n\n如果方法涉及多次数据库操作，并希望将它们作为独立的事务进行提交或回滚，那么 我们需要考虑进一步细化配置事务传播方式，也就是 @transactional 注解的 propagation 属性。\n\n/**\n * {@link propagation#requires_new} 表示执行到这个方法时需要开启新的事务，并挂起当前事务\n */\n@transactional(propagation = propagation.requires_new)\npublic void createsubuserwithexceptionright(userentity entity) {\n   log.info("createsubuserwithexceptionright start");\n   userrepository.save(entity);\n   throw new runtimeexception("invalid status");\n}\n\n\n\n# 参考资料\n\n * spring 官网\n * spring 官方文档\n * spring boot 官方文档\n * 《java 业务开发常见错误 100 例》',charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Spring 之 JPA",frontmatter:{title:"Spring 之 JPA",date:"2019-02-18T14:33:55.000Z",order:4,categories:["Java","框架","Spring","Spring数据"],tags:["Java","框架","Spring","SpringBoot","JPA"],permalink:"/pages/a03d7b/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/02.Spring%E6%95%B0%E6%8D%AE/04.Spring%E4%B9%8BJPA.html",relativePath:"01.Java/13.框架/01.Spring/02.Spring数据/04.Spring之JPA.md",key:"v-3b4bf83b",path:"/pages/a03d7b/",headers:[{level:2,title:"快速入门",slug:"快速入门",normalizedTitle:"快速入门",charIndex:97},{level:2,title:"常用 JPA 注解",slug:"常用-jpa-注解",normalizedTitle:"常用 jpa 注解",charIndex:6402},{level:3,title:"实体",slug:"实体",normalizedTitle:"实体",charIndex:1098},{level:4,title:"@Entity",slug:"entity",normalizedTitle:"@entity",charIndex:306},{level:4,title:"@MappedSuperclass",slug:"mappedsuperclass",normalizedTitle:"@mappedsuperclass",charIndex:6433},{level:4,title:"@Table",slug:"table",normalizedTitle:"@table",charIndex:6525},{level:3,title:"主键",slug:"主键",normalizedTitle:"主键",charIndex:6593},{level:4,title:"@Id",slug:"id",normalizedTitle:"@id",charIndex:1357},{level:4,title:"@GeneratedValue",slug:"generatedvalue",normalizedTitle:"@generatedvalue",charIndex:1365},{level:3,title:"映射",slug:"映射",normalizedTitle:"映射",charIndex:25},{level:4,title:"@Column",slug:"column",normalizedTitle:"@column",charIndex:1439},{level:3,title:"关系",slug:"关系",normalizedTitle:"关系",charIndex:23},{level:4,title:"@OneToOne",slug:"onetoone",normalizedTitle:"@onetoone",charIndex:8020},{level:4,title:"@OneToMany",slug:"onetomany",normalizedTitle:"@onetomany",charIndex:8039},{level:2,title:"查询",slug:"查询",normalizedTitle:"查询",charIndex:8291},{level:3,title:"方法名字方式查询方式",slug:"方法名字方式查询方式",normalizedTitle:"方法名字方式查询方式",charIndex:8669},{level:3,title:"@Query 注解方式查询",slug:"query-注解方式查询",normalizedTitle:"@query 注解方式查询",charIndex:8319},{level:3,title:"动态 SQL 方式查询",slug:"动态-sql-方式查询",normalizedTitle:"动态 sql 方式查询",charIndex:8337},{level:3,title:"Example 方式查询",slug:"example-方式查询",normalizedTitle:"example 方式查询",charIndex:8353},{level:3,title:"排序 Sort",slug:"排序-sort",normalizedTitle:"排序 sort",charIndex:14731},{level:3,title:"分页 Page 和 Pageable",slug:"分页-page-和-pageable",normalizedTitle:"分页 page 和 pageable",charIndex:15353},{level:2,title:"核心 API",slug:"核心-api",normalizedTitle:"核心 api",charIndex:15938},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:15951}],headersStr:"快速入门 常用 JPA 注解 实体 @Entity @MappedSuperclass @Table 主键 @Id @GeneratedValue 映射 @Column 关系 @OneToOne @OneToMany 查询 方法名字方式查询方式 @Query 注解方式查询 动态 SQL 方式查询 Example 方式查询 排序 Sort 分页 Page 和 Pageable 核心 API 参考资料",content:'# Spring 之 JPA\n\nJPA 为对象关系映射提供了一种基于 POJO 的持久化模型。\n\n * 简化数据持久化代码的开发\n * 为 Java 社区屏蔽不同持久化 API 的差异\n\n\n# 快速入门\n\n（1）在 pom.xml 中引入依赖\n\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-jpa</artifactId>\n</dependency>\n\n\n（2）设置启动注解\n\n// 【可选】指定扫描的 Entity 目录，如果不指定，会扫描全部目录\n@EntityScan("io.github.dunwu.springboot.data.jpa")\n// 【可选】指定扫描的 Repository 目录，如果不指定，会扫描全部目录\n@EnableJpaRepositories(basePackages = {"io.github.dunwu.springboot.data.jpa"})\n// 【可选】开启 JPA auditing 能力，可以自动赋值一些字段，比如创建时间、最后一次修改时间等等\n@EnableJpaAuditing\n@SpringBootApplication\npublic class Application {\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n}\n\n\n（3）配置\n\n# 数据库连接\nspring.datasource.url = jdbc:mysql://localhost:3306/spring_tutorial?serverTimezone=UTC&useUnicode=true&characterEncoding=utf8\nspring.datasource.driver-class-name = com.mysql.cj.jdbc.Driver\nspring.datasource.username = root\nspring.datasource.password = root\n# 是否打印 JPA SQL 日志\nspring.jpa.show-sql = true\n# Hibernate的DDL策略\nspring.jpa.hibernate.ddl-auto = create-drop\n\n\n（4）定义实体\n\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\nimport lombok.ToString;\n\nimport java.util.Objects;\nimport javax.persistence.*;\n\n@Entity\n@Data\n@ToString\n@NoArgsConstructor\n@AllArgsConstructor\npublic class User {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.AUTO)\n    private Long id;\n\n    @Column(unique = true)\n    private String name;\n\n    private Integer age;\n\n    private String address;\n\n    private String email;\n\n    public User(String name, Integer age, String address, String email) {\n        this.name = name;\n        this.age = age;\n        this.address = address;\n        this.email = email;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(id, name);\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) {\n            return true;\n        }\n\n        if (!(o instanceof User)) {\n            return false;\n        }\n\n        User user = (User) o;\n\n        if (id != null && id.equals(user.id)) {\n            return true;\n        }\n\n        return name.equals(user.name);\n    }\n\n}\n\n\n（5）定义 Repository\n\n\nimport org.springframework.data.jpa.repository.JpaRepository;\nimport org.springframework.data.jpa.repository.Query;\nimport org.springframework.data.repository.query.Param;\nimport org.springframework.data.rest.core.annotation.RepositoryRestResource;\nimport org.springframework.transaction.annotation.Transactional;\nimport org.springframework.web.bind.annotation.PathVariable;\n\nimport java.util.List;\n\n@RepositoryRestResource(collectionResourceRel = "user", path = "user")\npublic interface UserRepository extends JpaRepository<User, Long> {\n\n    User findUserById(@PathVariable("id") Long id);\n\n    /**\n     * 根据用户名查找用户\n     * <p>\n     * 示例：http://localhost:8080/user/search/findByName?name=lisi\n     *\n     * @param name 用户名\n     * @return {@link User}\n     */\n    User findUserByName(@Param("name") String name);\n\n    /**\n     * 根据邮箱查找用户\n     * <p>\n     * 示例：http://localhost:8080/user/search/findByEmail?email=xxx@163.com\n     *\n     * @param email 邮箱\n     * @return {@link User}\n     */\n    @Query("from User u where u.email=:email")\n    List<User> findByEmail(@Param("email") String email);\n\n    /**\n     * 根据用户名删除用户\n     *\n     * @param name 用户名\n     */\n    @Transactional(rollbackFor = Exception.class)\n    void deleteByName(@Param("name") String name);\n\n}\n\n\n（6）测试\n\n@Slf4j\n@SpringBootTest(classes = { DataJpaApplication.class })\npublic class DataJpaTests {\n\n    @Autowired\n    private UserRepository repository;\n\n    @BeforeEach\n    public void before() {\n        repository.deleteAll();\n    }\n\n    @Test\n    public void insert() {\n        User user = new User("张三", 18, "北京", "user1@163.com");\n        repository.save(user);\n        Optional<User> optional = repository.findById(user.getId());\n        assertThat(optional).isNotNull();\n        assertThat(optional.isPresent()).isTrue();\n    }\n\n    @Test\n    public void batchInsert() {\n        List<User> users = new ArrayList<>();\n        users.add(new User("张三", 18, "北京", "user1@163.com"));\n        users.add(new User("李四", 19, "上海", "user1@163.com"));\n        users.add(new User("王五", 18, "南京", "user1@163.com"));\n        users.add(new User("赵六", 20, "武汉", "user1@163.com"));\n        repository.saveAll(users);\n\n        long count = repository.count();\n        assertThat(count).isEqualTo(4);\n\n        List<User> list = repository.findAll();\n        assertThat(list).isNotEmpty().hasSize(4);\n        list.forEach(this::accept);\n    }\n\n    private void accept(User user) { log.info(user.toString()); }\n\n    @Test\n    public void delete() {\n        List<User> users = new ArrayList<>();\n        users.add(new User("张三", 18, "北京", "user1@163.com"));\n        users.add(new User("李四", 19, "上海", "user1@163.com"));\n        users.add(new User("王五", 18, "南京", "user1@163.com"));\n        users.add(new User("赵六", 20, "武汉", "user1@163.com"));\n        repository.saveAll(users);\n\n        repository.deleteByName("张三");\n        assertThat(repository.findUserByName("张三")).isNull();\n\n        repository.deleteAll();\n        List<User> list = repository.findAll();\n        assertThat(list).isEmpty();\n    }\n\n    @Test\n    public void findAllInPage() {\n        List<User> users = new ArrayList<>();\n        users.add(new User("张三", 18, "北京", "user1@163.com"));\n        users.add(new User("李四", 19, "上海", "user1@163.com"));\n        users.add(new User("王五", 18, "南京", "user1@163.com"));\n        users.add(new User("赵六", 20, "武汉", "user1@163.com"));\n        repository.saveAll(users);\n\n        PageRequest pageRequest = PageRequest.of(1, 2);\n        Page<User> page = repository.findAll(pageRequest);\n        assertThat(page).isNotNull();\n        assertThat(page.isEmpty()).isFalse();\n        assertThat(page.getTotalElements()).isEqualTo(4);\n        assertThat(page.getTotalPages()).isEqualTo(2);\n\n        List<User> list = page.get().collect(Collectors.toList());\n        System.out.println("user list: ");\n        list.forEach(System.out::println);\n    }\n\n    @Test\n    public void update() {\n        User oldUser = new User("张三", 18, "北京", "user1@163.com");\n        oldUser.setName("张三丰");\n        repository.save(oldUser);\n\n        User newUser = repository.findUserByName("张三丰");\n        assertThat(newUser).isNotNull();\n    }\n\n}\n\n\n\n# 常用 JPA 注解\n\n\n# 实体\n\n# @Entity\n\n# @MappedSuperclass\n\n当多个实体有共同的属性字段，比如说 id，则可以把它提炼出一个父类，并且加上 @MappedSuperclass，则实体基类就可以继承了。\n\n# @Table\n\n当实体名和表名不一致时，可以通过 @Table(name="CUSTOMERS") 的形式来明确指定一个表名。\n\n\n# 主键\n\n# @Id\n\n@Id 注解用于声明一个实体类的属性映射为数据库的主键。\n\n# @GeneratedValue\n\n@GeneratedValue 用于标注主键的生成策略，通过 strategy 属性指定。\n\n默认情况下，JPA 自动选择一个最适合底层数据库的主键生成策略：SqlServer 对应 identity，MySQL 对应 auto increment。\n\n在 javax.persistence.GenerationType 中定义了以下几种可供选择的策略：\n\npublic enum GenerationType {\n    TABLE,\n    SEQUENCE,\n    IDENTITY,\n    AUTO\n}\n\n\n * IDENTITY：采用数据库 ID 自增长的方式来自增主键字段，Oracle 不支持这种方式；\n * AUTO： JPA 自动选择合适的策略，是默认选项；\n * SEQUENCE：通过序列产生主键，通过 @SequenceGenerator 注解指定序列名，MySql 不支持这种方式\n * TABLE：通过表产生主键，框架借由表模拟序列产生主键，使用该策略可以使应用更易于数据库移植。\n\n也就是如果你没有指定 strategy 属性，默认策略是 AUTO，JPA 会根据你使用的数据库来自动选择策略，比如说我使用的是 mysql 则，自动的主键策略就是 IDENTITY （auto increment）。\n\n\n# 映射\n\n# @Column\n\n当你的 entity 属性名和数据库中的字段名不一致，可以使用 @Column 明确指定，它也可以设置一些属性\n\n@Column(length = 10, nullable = false, unique = true)\n\n\n@Column(columnDefinition = "INT(3)")\nprivate int age;\n\n\n@Column 支持的参数：\n\n * unique 属性表示该字段是否为唯一标识，默认为 false。如果表中有一个字段需要唯一标识，则既可以使用该标记，也可以使用 @Table 标记中的 @UniqueConstraint。\n * nullable 属性表示该字段是否可以为 null 值，默认为 true。\n * insertable 属性表示在使用 INSERT 插入数据时，是否需要插入该字段的值。\n * updatable 属性表示在使用 UPDATE 更新数据时，是否需要更新该字段的值。insertable 和 updatable 属性一般多用于只读的属性，例如主键和外键等。这些字段的值通常是自动生成的。\n * columnDefinition 属性表示创建表时，该字段创建的 SQL 语句，一般用于通过 Entity 生成表定义时使用。\n * table 属性表示当映射多个表时，指定表的表中的字段。默认值为主表的表名。\n * length 属性表示字段的长度，当字段的类型为 varchar 时，该属性才有效，默认为 255 个字符。\n * precision 属性和 scale 属性表示精度，当字段类型为 double 时，precision 表示数值的总长度，scale 表示小数点所占的位数。\n\n@JoinTable\n\n@JoinColumn\n\n\n# 关系\n\n表关系映射（双向映射）\n\n * @OneToOne：一对一关系\n * @OneToMany：一对多\n * @ManyToMany（不推荐使用，而是采用用中间对象，把多对多拆成两个对多一关系）\n\n字段映射（单向映射）：\n\n * @Embedded、@Embeddable 嵌入式关系（单向映射）\n * @ElementCollection 集合一对多关系（单向映射）\n\n# @OneToOne\n\n@OneToOne 表示一对一关系\n\n# @OneToMany\n\n@OneToMany 表示一对多关系\n\n@ManyToOne\n\n@ManyToMany\n\nOrderBy\n\n\n# 查询\n\n查询方式有：\n\n * 方法名字方式查询\n\n * @Query 注解方式查询\n\n * 动态 SQL 方式查询\n\n * Example 方式查询\n\nJpaRepository 提供了如下表所述的内置查询\n\n * List<T> findAll(); - 返回所有实体\n * List<T> findAllById(Iterable<ID> var1); - 返回指定 id 的所有实体\n * T getOne(ID var1); - 根据 id 返回对应的实体，如果未找到，则返回空。\n * List<T> findAll(Sort var1); - 返回所有实体，按照指定顺序返回。\n * Page<T> findAll(Pageable var1); - 返回实体列表，实体的 offset 和 limit 通过 pageable 来指定\n\n\n# 方法名字方式查询方式\n\nSpring Data 通过查询的方法名和参数名来自动构造一个 JPA QQL 查询。\n\npublic interface UserRepository extends JpaRepository<User, Integer> {\n    public User findByName(String name);\n}\n\n\n方法名和参数名要遵守一定的规则，Spring Data JPA 才能自动转换为 JPQL：\n\n * 方法名通常包含多个实体属性用于查询，属性之间可以使用 AND 和 OR 连接，也支持 Between、LessThan、GreaterThan、Like；\n\n * 方法名可以以 findBy、getBy、queryBy 开头；\n\n * 查询结果可以排序，方法名包含 OrderBy+属性+ASC（DESC）；\n\n * 可以通过 Top、First 来限定查询的结果集；\n\n * 一些特殊的参数可以出现在参数列表里，比如 Pageeable、Sort\n\n示例：\n\n// 根据名字查询，且按照名字升序\nList<Person> findByLastnameOrderByFirstnameAsc(String name);\n\n// 根据名字查询，且使用翻页查询\nPage<User> findByLastname(String lastname, Pageable pageable);\n\n// 查询满足条件的前10个用户\nList<User> findFirst10ByLastname(String lastname, Sort sort);\n\n// 使用And联合查询\nList<Person> findByFirstnameAndLastname(String firstname, String lastname);\n\n// 使用Or查询\nList<Person> findDistinctPeopleByLastnameOrFirstname(String lastname, String firstname);\n\n// 使用like查询，name 必须包含like中的%或者?\npublic User findByNameLike(String name);\n\n\nKEYWORD             SAMPLE                                                    JPQL SNIPPET\nAnd                 findByLastnameAndFirstname                                … where x.lastname = ?1 and x.firstname = ?2\nOr                  findByLastnameOrFirstname                                 … where x.lastname = ?1 or x.firstname = ?2\nIs,Equals           findByFirstname,findByFirstnameIs,findByFirstnameEquals   … where x.firstname = 1?\nBetween             findByStartDateBetween                                    … where x.startDate between 1? and ?2\nLessThan            findByAgeLessThan                                         … where x.age < ?1\nLessThanEqual       findByAgeLessThanEqual                                    … where x.age <= ?1\nGreaterThan         findByAgeGreaterThan                                      … where x.age > ?1\nGreaterThanEqual    findByAgeGreaterThanEqual                                 … where x.age >= ?1\nAfter               findByStartDateAfter                                      … where x.startDate > ?1\nBefore              findByStartDateBefore                                     … where x.startDate < ?1\nIsNull              findByAgeIsNull                                           … where x.age is null\nIsNotNull,NotNull   findByAge(Is)NotNull                                      … where x.age not null\nLike                findByFirstnameLike                                       … where x.firstname like ?1\nNotLike             findByFirstnameNotLike                                    … where x.firstname not like ?1\nStartingWith        findByFirstnameStartingWith                               … where x.firstname like ?1 (parameter bound with appended\n                                                                              %)\nEndingWith          findByFirstnameEndingWith                                 … where x.firstname like ?1 (parameter bound with prepended\n                                                                              %)\nContaining          findByFirstnameContaining                                 … where x.firstname like ?1 (parameter bound wrapped in %)\nOrderBy             findByAgeOrderByLastnameDesc                              … where x.age = ?1 order by x.lastname desc\nNot                 findByLastnameNot                                         … where x.lastname <> ?1\nIn                  findByAgeIn(Collection<Age> ages)                         … where x.age in ?1\nNotIn               findByAgeNotIn(Collection<Age> age)                       … where x.age not in ?1\nTrue                findByActiveTrue()                                        … where x.active = true\nFalse               findByActiveFalse()                                       … where x.active = false\nIgnoreCase          findByFirstnameIgnoreCase                                 … where UPPER(x.firstame) = UPPER(?1)\n\n\n# @Query 注解方式查询\n\n注解 @Query 允许在方法上使用 JPQL。\n\n其中操作针对的是对象名和对象属性名，而非数据库中的表名和字段名。\n\n@Query("select u form User u where u.name=?1 and u.depantment.id=?2");\npublic User findUser(String name, Integer departmentId);\n\n\n@Query("form User u where u.name=?1 and u.depantment.id=?2");\npublic User findUser(String name, Integer departmentId);\n\n\n如果使用 SQL 而不是 JPSQL，可以使用 nativeQuery 属性，设置为 true。\n\n@Query(value="select * from user where name=?1 and department_id=?2", nativeQuery=true)\npublic User nativeQuery(String name, Integer departmentId);\n\n\n无论 JPQL，还是 SQL，都支持"命名参数"：\n\n@Query(value="select * from user where name=:name and department_id=:departmentId", nativeQuery=true)\npublic User nativeQuery2(String name, Integer departmentId);\n\n\n如果 SQL 活着 JPQL 查询结果集并非 Entity，可以用 Object[] 数组代替，比如分组统计每个部分的用户数\n\n@Query(value="select department_id,count(*) from user group by department_id", nativeQuery=true)\npublic List<Object[]> queryUserCount()\n\n\n这条查询将返回数组，对象类型依赖于查询结果，被示例中，返回的是 String 和 BigInteger 类型\n\n查询时可以使用 Pageable 和 Sort 来完成翻页和排序。\n\n@Query("select u from User u where department.id=?1")\npublic Page<User> QueryUsers(Integer departmentId, Pageable page);\n\n\n@Query 还允许 SQL 更新、删除语句，此时必须搭配 @Modifying 使用，比如：\n\n@Modifying\n@Query("update User u set u.name= ?1 where u.id= ?2")\nint updateName(String name, Integer id);\n\n\n\n# 动态 SQL 方式查询\n\n可参考：SpringDataJpa 中的复杂查询和动态查询，多表查询\n\n\n# Example 方式查询\n\n允许根据实体创建一个 Example 对象，Spring Data 通过 Example 对象来构造 JPQL。但是使用不灵活条件是 AND,不能使用 or，时间的大于小于，between 等。\n\n继承 JpaRepository\n\n<S extends T> List<S> findAll(Example<S> var1);\n<S extends T> List<S> findAll(Example<S> var1, Sort var2);\n\n\npublic List<User> getByExample(String name) {\n    Department dept = new Department();\n    dept.setId(1);\n\n    User user = new User();\n    user.setName(name);\n    user.setDepartment(dept);\n    Example<User> example = Example.of(user);\n    List<User> list = userDao.findAll(example);\n    return list\n}\n\n\n以上代码首先创建了 User 对象，设置 查询条件，名称为参数 name，部门 id 为 1，通过 Example.of 构造了此查询。\n\n大部分查询并非完全匹配查询，ExampleMatcher 提供了更多的条件指定.比如以 xxx 开头的所有用户，则可以使用以下代码构造\n\nExampleMatcher matcher = ExampleMatcher.matching().withMatcher("xxx",\n    GenericPropertyMatchers.startsWith().ignoreCase());\nExample<User> example = Example.of(user, matcher);\n\n\n\n# 排序 Sort\n\nSort 对象用来指定排序，最简单的 Sort 对象构造可以传入一个属性名列表（不是数据库列名，是属性名）。默认采用升序排序。\n\nSort sort = new Sort("id");\n//Sort sort = new Sort(Direction.DESC, "id");\nreturn userDao.findAll(sort);\n\n\nHibernate 根据 Sort 构造了排序条件，Sort("id") 表示按照 id 采用默认 升序进行排序\n\n其他 Sort 的构造方法还包括以下主要的一些：\n\n * public Sort(String... properties)，按照指定的属性列表升序排序。\n * public Sort(Sort.Direction direction, String... properties)，按照指定属性列表排序，排序由 direction 指定，direction 是一个枚举类型，有 Direction.ASC 和 Direction.DESC。\n * public Sort(Sort.Order... orders)，可以通过 Order 静态方法来创建\n   * public static Sort.Order asc(String property)\n   * public static Sort.Order desc(String property)\n\n\n# 分页 Page 和 Pageable\n\nPageable 接口用于构造翻页查询，PageRequest 是其实现类，可以通过提供的工厂方法创建 PageRequest：\n\n注意我这边使用的是 sring boot 2.0.2 ，jpa 版本是 2.0.8，新版本与之前版本的操作方法有所不同。\n\n * public static PageRequest of(int page, int size)\n\n * public static PageRequest of(int page, int size, Sort sort) - 也可以在 PageRequest 中加入排序\n\n * public static PageRequest of(int page, int size, Direction direction, String... properties)，或者自定义排序规则\n\npage 是从 0 开始，表示查询页，size 指每页的期望行数。\n\nSpring Data 翻页查询总是返回 Page 对象，Page 对象提供了以下常用的方法\n\n * int getTotalPages();，总的页数\n * long getTotalElements(); - 返回总数\n * List<T> getContent(); - 返回此次查询的结果集\n\n\n# 核心 API\n\n\n\n\n# 参考资料\n\n * Spring 官网\n * Spring Framework 官方文档\n * Spring Boot 官方文档',normalizedContent:'# spring 之 jpa\n\njpa 为对象关系映射提供了一种基于 pojo 的持久化模型。\n\n * 简化数据持久化代码的开发\n * 为 java 社区屏蔽不同持久化 api 的差异\n\n\n# 快速入门\n\n（1）在 pom.xml 中引入依赖\n\n<dependency>\n    <groupid>org.springframework.boot</groupid>\n    <artifactid>spring-boot-starter-data-jpa</artifactid>\n</dependency>\n\n\n（2）设置启动注解\n\n// 【可选】指定扫描的 entity 目录，如果不指定，会扫描全部目录\n@entityscan("io.github.dunwu.springboot.data.jpa")\n// 【可选】指定扫描的 repository 目录，如果不指定，会扫描全部目录\n@enablejparepositories(basepackages = {"io.github.dunwu.springboot.data.jpa"})\n// 【可选】开启 jpa auditing 能力，可以自动赋值一些字段，比如创建时间、最后一次修改时间等等\n@enablejpaauditing\n@springbootapplication\npublic class application {\n    public static void main(string[] args) {\n        springapplication.run(application.class, args);\n    }\n}\n\n\n（3）配置\n\n# 数据库连接\nspring.datasource.url = jdbc:mysql://localhost:3306/spring_tutorial?servertimezone=utc&useunicode=true&characterencoding=utf8\nspring.datasource.driver-class-name = com.mysql.cj.jdbc.driver\nspring.datasource.username = root\nspring.datasource.password = root\n# 是否打印 jpa sql 日志\nspring.jpa.show-sql = true\n# hibernate的ddl策略\nspring.jpa.hibernate.ddl-auto = create-drop\n\n\n（4）定义实体\n\nimport lombok.allargsconstructor;\nimport lombok.data;\nimport lombok.noargsconstructor;\nimport lombok.tostring;\n\nimport java.util.objects;\nimport javax.persistence.*;\n\n@entity\n@data\n@tostring\n@noargsconstructor\n@allargsconstructor\npublic class user {\n\n    @id\n    @generatedvalue(strategy = generationtype.auto)\n    private long id;\n\n    @column(unique = true)\n    private string name;\n\n    private integer age;\n\n    private string address;\n\n    private string email;\n\n    public user(string name, integer age, string address, string email) {\n        this.name = name;\n        this.age = age;\n        this.address = address;\n        this.email = email;\n    }\n\n    @override\n    public int hashcode() {\n        return objects.hash(id, name);\n    }\n\n    @override\n    public boolean equals(object o) {\n        if (this == o) {\n            return true;\n        }\n\n        if (!(o instanceof user)) {\n            return false;\n        }\n\n        user user = (user) o;\n\n        if (id != null && id.equals(user.id)) {\n            return true;\n        }\n\n        return name.equals(user.name);\n    }\n\n}\n\n\n（5）定义 repository\n\n\nimport org.springframework.data.jpa.repository.jparepository;\nimport org.springframework.data.jpa.repository.query;\nimport org.springframework.data.repository.query.param;\nimport org.springframework.data.rest.core.annotation.repositoryrestresource;\nimport org.springframework.transaction.annotation.transactional;\nimport org.springframework.web.bind.annotation.pathvariable;\n\nimport java.util.list;\n\n@repositoryrestresource(collectionresourcerel = "user", path = "user")\npublic interface userrepository extends jparepository<user, long> {\n\n    user finduserbyid(@pathvariable("id") long id);\n\n    /**\n     * 根据用户名查找用户\n     * <p>\n     * 示例：http://localhost:8080/user/search/findbyname?name=lisi\n     *\n     * @param name 用户名\n     * @return {@link user}\n     */\n    user finduserbyname(@param("name") string name);\n\n    /**\n     * 根据邮箱查找用户\n     * <p>\n     * 示例：http://localhost:8080/user/search/findbyemail?email=xxx@163.com\n     *\n     * @param email 邮箱\n     * @return {@link user}\n     */\n    @query("from user u where u.email=:email")\n    list<user> findbyemail(@param("email") string email);\n\n    /**\n     * 根据用户名删除用户\n     *\n     * @param name 用户名\n     */\n    @transactional(rollbackfor = exception.class)\n    void deletebyname(@param("name") string name);\n\n}\n\n\n（6）测试\n\n@slf4j\n@springboottest(classes = { datajpaapplication.class })\npublic class datajpatests {\n\n    @autowired\n    private userrepository repository;\n\n    @beforeeach\n    public void before() {\n        repository.deleteall();\n    }\n\n    @test\n    public void insert() {\n        user user = new user("张三", 18, "北京", "user1@163.com");\n        repository.save(user);\n        optional<user> optional = repository.findbyid(user.getid());\n        assertthat(optional).isnotnull();\n        assertthat(optional.ispresent()).istrue();\n    }\n\n    @test\n    public void batchinsert() {\n        list<user> users = new arraylist<>();\n        users.add(new user("张三", 18, "北京", "user1@163.com"));\n        users.add(new user("李四", 19, "上海", "user1@163.com"));\n        users.add(new user("王五", 18, "南京", "user1@163.com"));\n        users.add(new user("赵六", 20, "武汉", "user1@163.com"));\n        repository.saveall(users);\n\n        long count = repository.count();\n        assertthat(count).isequalto(4);\n\n        list<user> list = repository.findall();\n        assertthat(list).isnotempty().hassize(4);\n        list.foreach(this::accept);\n    }\n\n    private void accept(user user) { log.info(user.tostring()); }\n\n    @test\n    public void delete() {\n        list<user> users = new arraylist<>();\n        users.add(new user("张三", 18, "北京", "user1@163.com"));\n        users.add(new user("李四", 19, "上海", "user1@163.com"));\n        users.add(new user("王五", 18, "南京", "user1@163.com"));\n        users.add(new user("赵六", 20, "武汉", "user1@163.com"));\n        repository.saveall(users);\n\n        repository.deletebyname("张三");\n        assertthat(repository.finduserbyname("张三")).isnull();\n\n        repository.deleteall();\n        list<user> list = repository.findall();\n        assertthat(list).isempty();\n    }\n\n    @test\n    public void findallinpage() {\n        list<user> users = new arraylist<>();\n        users.add(new user("张三", 18, "北京", "user1@163.com"));\n        users.add(new user("李四", 19, "上海", "user1@163.com"));\n        users.add(new user("王五", 18, "南京", "user1@163.com"));\n        users.add(new user("赵六", 20, "武汉", "user1@163.com"));\n        repository.saveall(users);\n\n        pagerequest pagerequest = pagerequest.of(1, 2);\n        page<user> page = repository.findall(pagerequest);\n        assertthat(page).isnotnull();\n        assertthat(page.isempty()).isfalse();\n        assertthat(page.gettotalelements()).isequalto(4);\n        assertthat(page.gettotalpages()).isequalto(2);\n\n        list<user> list = page.get().collect(collectors.tolist());\n        system.out.println("user list: ");\n        list.foreach(system.out::println);\n    }\n\n    @test\n    public void update() {\n        user olduser = new user("张三", 18, "北京", "user1@163.com");\n        olduser.setname("张三丰");\n        repository.save(olduser);\n\n        user newuser = repository.finduserbyname("张三丰");\n        assertthat(newuser).isnotnull();\n    }\n\n}\n\n\n\n# 常用 jpa 注解\n\n\n# 实体\n\n# @entity\n\n# @mappedsuperclass\n\n当多个实体有共同的属性字段，比如说 id，则可以把它提炼出一个父类，并且加上 @mappedsuperclass，则实体基类就可以继承了。\n\n# @table\n\n当实体名和表名不一致时，可以通过 @table(name="customers") 的形式来明确指定一个表名。\n\n\n# 主键\n\n# @id\n\n@id 注解用于声明一个实体类的属性映射为数据库的主键。\n\n# @generatedvalue\n\n@generatedvalue 用于标注主键的生成策略，通过 strategy 属性指定。\n\n默认情况下，jpa 自动选择一个最适合底层数据库的主键生成策略：sqlserver 对应 identity，mysql 对应 auto increment。\n\n在 javax.persistence.generationtype 中定义了以下几种可供选择的策略：\n\npublic enum generationtype {\n    table,\n    sequence,\n    identity,\n    auto\n}\n\n\n * identity：采用数据库 id 自增长的方式来自增主键字段，oracle 不支持这种方式；\n * auto： jpa 自动选择合适的策略，是默认选项；\n * sequence：通过序列产生主键，通过 @sequencegenerator 注解指定序列名，mysql 不支持这种方式\n * table：通过表产生主键，框架借由表模拟序列产生主键，使用该策略可以使应用更易于数据库移植。\n\n也就是如果你没有指定 strategy 属性，默认策略是 auto，jpa 会根据你使用的数据库来自动选择策略，比如说我使用的是 mysql 则，自动的主键策略就是 identity （auto increment）。\n\n\n# 映射\n\n# @column\n\n当你的 entity 属性名和数据库中的字段名不一致，可以使用 @column 明确指定，它也可以设置一些属性\n\n@column(length = 10, nullable = false, unique = true)\n\n\n@column(columndefinition = "int(3)")\nprivate int age;\n\n\n@column 支持的参数：\n\n * unique 属性表示该字段是否为唯一标识，默认为 false。如果表中有一个字段需要唯一标识，则既可以使用该标记，也可以使用 @table 标记中的 @uniqueconstraint。\n * nullable 属性表示该字段是否可以为 null 值，默认为 true。\n * insertable 属性表示在使用 insert 插入数据时，是否需要插入该字段的值。\n * updatable 属性表示在使用 update 更新数据时，是否需要更新该字段的值。insertable 和 updatable 属性一般多用于只读的属性，例如主键和外键等。这些字段的值通常是自动生成的。\n * columndefinition 属性表示创建表时，该字段创建的 sql 语句，一般用于通过 entity 生成表定义时使用。\n * table 属性表示当映射多个表时，指定表的表中的字段。默认值为主表的表名。\n * length 属性表示字段的长度，当字段的类型为 varchar 时，该属性才有效，默认为 255 个字符。\n * precision 属性和 scale 属性表示精度，当字段类型为 double 时，precision 表示数值的总长度，scale 表示小数点所占的位数。\n\n@jointable\n\n@joincolumn\n\n\n# 关系\n\n表关系映射（双向映射）\n\n * @onetoone：一对一关系\n * @onetomany：一对多\n * @manytomany（不推荐使用，而是采用用中间对象，把多对多拆成两个对多一关系）\n\n字段映射（单向映射）：\n\n * @embedded、@embeddable 嵌入式关系（单向映射）\n * @elementcollection 集合一对多关系（单向映射）\n\n# @onetoone\n\n@onetoone 表示一对一关系\n\n# @onetomany\n\n@onetomany 表示一对多关系\n\n@manytoone\n\n@manytomany\n\norderby\n\n\n# 查询\n\n查询方式有：\n\n * 方法名字方式查询\n\n * @query 注解方式查询\n\n * 动态 sql 方式查询\n\n * example 方式查询\n\njparepository 提供了如下表所述的内置查询\n\n * list<t> findall(); - 返回所有实体\n * list<t> findallbyid(iterable<id> var1); - 返回指定 id 的所有实体\n * t getone(id var1); - 根据 id 返回对应的实体，如果未找到，则返回空。\n * list<t> findall(sort var1); - 返回所有实体，按照指定顺序返回。\n * page<t> findall(pageable var1); - 返回实体列表，实体的 offset 和 limit 通过 pageable 来指定\n\n\n# 方法名字方式查询方式\n\nspring data 通过查询的方法名和参数名来自动构造一个 jpa qql 查询。\n\npublic interface userrepository extends jparepository<user, integer> {\n    public user findbyname(string name);\n}\n\n\n方法名和参数名要遵守一定的规则，spring data jpa 才能自动转换为 jpql：\n\n * 方法名通常包含多个实体属性用于查询，属性之间可以使用 and 和 or 连接，也支持 between、lessthan、greaterthan、like；\n\n * 方法名可以以 findby、getby、queryby 开头；\n\n * 查询结果可以排序，方法名包含 orderby+属性+asc（desc）；\n\n * 可以通过 top、first 来限定查询的结果集；\n\n * 一些特殊的参数可以出现在参数列表里，比如 pageeable、sort\n\n示例：\n\n// 根据名字查询，且按照名字升序\nlist<person> findbylastnameorderbyfirstnameasc(string name);\n\n// 根据名字查询，且使用翻页查询\npage<user> findbylastname(string lastname, pageable pageable);\n\n// 查询满足条件的前10个用户\nlist<user> findfirst10bylastname(string lastname, sort sort);\n\n// 使用and联合查询\nlist<person> findbyfirstnameandlastname(string firstname, string lastname);\n\n// 使用or查询\nlist<person> finddistinctpeoplebylastnameorfirstname(string lastname, string firstname);\n\n// 使用like查询，name 必须包含like中的%或者?\npublic user findbynamelike(string name);\n\n\nkeyword             sample                                                    jpql snippet\nand                 findbylastnameandfirstname                                … where x.lastname = ?1 and x.firstname = ?2\nor                  findbylastnameorfirstname                                 … where x.lastname = ?1 or x.firstname = ?2\nis,equals           findbyfirstname,findbyfirstnameis,findbyfirstnameequals   … where x.firstname = 1?\nbetween             findbystartdatebetween                                    … where x.startdate between 1? and ?2\nlessthan            findbyagelessthan                                         … where x.age < ?1\nlessthanequal       findbyagelessthanequal                                    … where x.age <= ?1\ngreaterthan         findbyagegreaterthan                                      … where x.age > ?1\ngreaterthanequal    findbyagegreaterthanequal                                 … where x.age >= ?1\nafter               findbystartdateafter                                      … where x.startdate > ?1\nbefore              findbystartdatebefore                                     … where x.startdate < ?1\nisnull              findbyageisnull                                           … where x.age is null\nisnotnull,notnull   findbyage(is)notnull                                      … where x.age not null\nlike                findbyfirstnamelike                                       … where x.firstname like ?1\nnotlike             findbyfirstnamenotlike                                    … where x.firstname not like ?1\nstartingwith        findbyfirstnamestartingwith                               … where x.firstname like ?1 (parameter bound with appended\n                                                                              %)\nendingwith          findbyfirstnameendingwith                                 … where x.firstname like ?1 (parameter bound with prepended\n                                                                              %)\ncontaining          findbyfirstnamecontaining                                 … where x.firstname like ?1 (parameter bound wrapped in %)\norderby             findbyageorderbylastnamedesc                              … where x.age = ?1 order by x.lastname desc\nnot                 findbylastnamenot                                         … where x.lastname <> ?1\nin                  findbyagein(collection<age> ages)                         … where x.age in ?1\nnotin               findbyagenotin(collection<age> age)                       … where x.age not in ?1\ntrue                findbyactivetrue()                                        … where x.active = true\nfalse               findbyactivefalse()                                       … where x.active = false\nignorecase          findbyfirstnameignorecase                                 … where upper(x.firstame) = upper(?1)\n\n\n# @query 注解方式查询\n\n注解 @query 允许在方法上使用 jpql。\n\n其中操作针对的是对象名和对象属性名，而非数据库中的表名和字段名。\n\n@query("select u form user u where u.name=?1 and u.depantment.id=?2");\npublic user finduser(string name, integer departmentid);\n\n\n@query("form user u where u.name=?1 and u.depantment.id=?2");\npublic user finduser(string name, integer departmentid);\n\n\n如果使用 sql 而不是 jpsql，可以使用 nativequery 属性，设置为 true。\n\n@query(value="select * from user where name=?1 and department_id=?2", nativequery=true)\npublic user nativequery(string name, integer departmentid);\n\n\n无论 jpql，还是 sql，都支持"命名参数"：\n\n@query(value="select * from user where name=:name and department_id=:departmentid", nativequery=true)\npublic user nativequery2(string name, integer departmentid);\n\n\n如果 sql 活着 jpql 查询结果集并非 entity，可以用 object[] 数组代替，比如分组统计每个部分的用户数\n\n@query(value="select department_id,count(*) from user group by department_id", nativequery=true)\npublic list<object[]> queryusercount()\n\n\n这条查询将返回数组，对象类型依赖于查询结果，被示例中，返回的是 string 和 biginteger 类型\n\n查询时可以使用 pageable 和 sort 来完成翻页和排序。\n\n@query("select u from user u where department.id=?1")\npublic page<user> queryusers(integer departmentid, pageable page);\n\n\n@query 还允许 sql 更新、删除语句，此时必须搭配 @modifying 使用，比如：\n\n@modifying\n@query("update user u set u.name= ?1 where u.id= ?2")\nint updatename(string name, integer id);\n\n\n\n# 动态 sql 方式查询\n\n可参考：springdatajpa 中的复杂查询和动态查询，多表查询\n\n\n# example 方式查询\n\n允许根据实体创建一个 example 对象，spring data 通过 example 对象来构造 jpql。但是使用不灵活条件是 and,不能使用 or，时间的大于小于，between 等。\n\n继承 jparepository\n\n<s extends t> list<s> findall(example<s> var1);\n<s extends t> list<s> findall(example<s> var1, sort var2);\n\n\npublic list<user> getbyexample(string name) {\n    department dept = new department();\n    dept.setid(1);\n\n    user user = new user();\n    user.setname(name);\n    user.setdepartment(dept);\n    example<user> example = example.of(user);\n    list<user> list = userdao.findall(example);\n    return list\n}\n\n\n以上代码首先创建了 user 对象，设置 查询条件，名称为参数 name，部门 id 为 1，通过 example.of 构造了此查询。\n\n大部分查询并非完全匹配查询，examplematcher 提供了更多的条件指定.比如以 xxx 开头的所有用户，则可以使用以下代码构造\n\nexamplematcher matcher = examplematcher.matching().withmatcher("xxx",\n    genericpropertymatchers.startswith().ignorecase());\nexample<user> example = example.of(user, matcher);\n\n\n\n# 排序 sort\n\nsort 对象用来指定排序，最简单的 sort 对象构造可以传入一个属性名列表（不是数据库列名，是属性名）。默认采用升序排序。\n\nsort sort = new sort("id");\n//sort sort = new sort(direction.desc, "id");\nreturn userdao.findall(sort);\n\n\nhibernate 根据 sort 构造了排序条件，sort("id") 表示按照 id 采用默认 升序进行排序\n\n其他 sort 的构造方法还包括以下主要的一些：\n\n * public sort(string... properties)，按照指定的属性列表升序排序。\n * public sort(sort.direction direction, string... properties)，按照指定属性列表排序，排序由 direction 指定，direction 是一个枚举类型，有 direction.asc 和 direction.desc。\n * public sort(sort.order... orders)，可以通过 order 静态方法来创建\n   * public static sort.order asc(string property)\n   * public static sort.order desc(string property)\n\n\n# 分页 page 和 pageable\n\npageable 接口用于构造翻页查询，pagerequest 是其实现类，可以通过提供的工厂方法创建 pagerequest：\n\n注意我这边使用的是 sring boot 2.0.2 ，jpa 版本是 2.0.8，新版本与之前版本的操作方法有所不同。\n\n * public static pagerequest of(int page, int size)\n\n * public static pagerequest of(int page, int size, sort sort) - 也可以在 pagerequest 中加入排序\n\n * public static pagerequest of(int page, int size, direction direction, string... properties)，或者自定义排序规则\n\npage 是从 0 开始，表示查询页，size 指每页的期望行数。\n\nspring data 翻页查询总是返回 page 对象，page 对象提供了以下常用的方法\n\n * int gettotalpages();，总的页数\n * long gettotalelements(); - 返回总数\n * list<t> getcontent(); - 返回此次查询的结果集\n\n\n# 核心 api\n\n\n\n\n# 参考资料\n\n * spring 官网\n * spring framework 官方文档\n * spring boot 官方文档',charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Spring 集成 Mybatis",frontmatter:{title:"Spring 集成 Mybatis",date:"2019-05-09T17:09:25.000Z",order:10,categories:["Java","框架","Spring","Spring数据"],tags:["Java","框架","Spring","SpringBoot","MyBatis","PageHelper","Mapper"],permalink:"/pages/88219e/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/02.Spring%E6%95%B0%E6%8D%AE/10.Spring%E9%9B%86%E6%88%90Mybatis.html",relativePath:"01.Java/13.框架/01.Spring/02.Spring数据/10.Spring集成Mybatis.md",key:"v-299bf82c",path:"/pages/88219e/",headers:[{level:2,title:"快速入门",slug:"快速入门",normalizedTitle:"快速入门",charIndex:202},{level:3,title:"从 XML 中构建 SqlSessionFactory",slug:"从-xml-中构建-sqlsessionfactory",normalizedTitle:"从 xml 中构建 sqlsessionfactory",charIndex:438},{level:3,title:"不使用 XML 构建 SqlSessionFactory",slug:"不使用-xml-构建-sqlsessionfactory",normalizedTitle:"不使用 xml 构建 sqlsessionfactory",charIndex:2056},{level:3,title:"从 SqlSessionFactory 中获取 SqlSession",slug:"从-sqlsessionfactory-中获取-sqlsession",normalizedTitle:"从 sqlsessionfactory 中获取 sqlsession",charIndex:2877},{level:3,title:"探究已映射的 SQL 语句",slug:"探究已映射的-sql-语句",normalizedTitle:"探究已映射的 sql 语句",charIndex:3532},{level:3,title:"作用域（Scope）和生命周期",slug:"作用域-scope-和生命周期",normalizedTitle:"作用域（scope）和生命周期",charIndex:5848},{level:4,title:"SqlSessionFactoryBuilder",slug:"sqlsessionfactorybuilder",normalizedTitle:"sqlsessionfactorybuilder",charIndex:541},{level:4,title:"SqlSessionFactory",slug:"sqlsessionfactory",normalizedTitle:"sqlsessionfactory",charIndex:448},{level:4,title:"SqlSession",slug:"sqlsession",normalizedTitle:"sqlsession",charIndex:448},{level:4,title:"映射器实例",slug:"映射器实例",normalizedTitle:"映射器实例",charIndex:7059},{level:2,title:"Mybatis 扩展工具",slug:"mybatis-扩展工具",normalizedTitle:"mybatis 扩展工具",charIndex:7471},{level:3,title:"Mybatis Plus",slug:"mybatis-plus",normalizedTitle:"mybatis plus",charIndex:7488},{level:3,title:"Mapper",slug:"mapper",normalizedTitle:"mapper",charIndex:1842},{level:3,title:"PageHelper",slug:"pagehelper",normalizedTitle:"pagehelper",charIndex:7793},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:7879}],headersStr:"快速入门 从 XML 中构建 SqlSessionFactory 不使用 XML 构建 SqlSessionFactory 从 SqlSessionFactory 中获取 SqlSession 探究已映射的 SQL 语句 作用域（Scope）和生命周期 SqlSessionFactoryBuilder SqlSessionFactory SqlSession 映射器实例 Mybatis 扩展工具 Mybatis Plus Mapper PageHelper 参考资料",content:'# Spring 集成 Mybatis\n\nMybatis 官网 是一款持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。\n\n\n# 快速入门\n\n要使用 MyBatis， 只需将 mybatis-x.x.x.jar 文件置于类路径（classpath）中即可。\n\n如果使用 Maven 来构建项目，则需将下面的依赖代码置于 pom.xml 文件中：\n\n<dependency>\n  <groupId>org.mybatis</groupId>\n  <artifactId>mybatis</artifactId>\n  <version>x.x.x</version>\n</dependency>\n\n\n\n# 从 XML 中构建 SqlSessionFactory\n\n每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为核心的。SqlSessionFactory 的实例可以通过 SqlSessionFactoryBuilder 获得。而 SqlSessionFactoryBuilder 则可以从 XML 配置文件或一个预先配置的 Configuration 实例来构建出 SqlSessionFactory 实例。\n\n从 XML 文件中构建 SqlSessionFactory 的实例非常简单，建议使用类路径下的资源文件进行配置。 但也可以使用任意的输入流（InputStream）实例，比如用文件路径字符串或 file:// URL 构造的输入流。MyBatis 包含一个名叫 Resources 的工具类，它包含一些实用方法，使得从类路径或其它位置加载资源文件更加容易。\n\nString resource = "org/mybatis/example/mybatis-config.xml";\nInputStream inputStream = Resources.getResourceAsStream(resource);\nSqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\n\n\nXML 配置文件中包含了对 MyBatis 系统的核心设置，包括获取数据库连接实例的数据源（DataSource）以及决定事务作用域和控制方式的事务管理器（TransactionManager）。后面会再探讨 XML 配置文件的详细内容，这里先给出一个简单的示例：\n\n<?xml version="1.0" encoding="UTF-8" ?>\n<!DOCTYPE configuration\n  PUBLIC "-//mybatis.org//DTD Config 3.0//EN"\n  "https://mybatis.org/dtd/mybatis-3-config.dtd">\n<configuration>\n  <environments default="development">\n    <environment id="development">\n      <transactionManager type="JDBC"/>\n      <dataSource type="POOLED">\n        <property name="driver" value="${driver}"/>\n        <property name="url" value="${url}"/>\n        <property name="username" value="${username}"/>\n        <property name="password" value="${password}"/>\n      </dataSource>\n    </environment>\n  </environments>\n  <mappers>\n    <mapper resource="org/mybatis/example/BlogMapper.xml"/>\n  </mappers>\n</configuration>\n\n\n当然，还有很多可以在 XML 文件中配置的选项，上面的示例仅罗列了最关键的部分。 注意 XML 头部的声明，它用来验证 XML 文档的正确性。environment 元素体中包含了事务管理和连接池的配置。mappers 元素则包含了一组映射器（mapper），这些映射器的 XML 映射文件包含了 SQL 代码和映射定义信息。\n\n\n# 不使用 XML 构建 SqlSessionFactory\n\n如果你更愿意直接从 Java 代码而不是 XML 文件中创建配置，或者想要创建你自己的配置构建器，MyBatis 也提供了完整的配置类，提供了所有与 XML 文件等价的配置项。\n\nDataSource dataSource = BlogDataSourceFactory.getBlogDataSource();\nTransactionFactory transactionFactory = new JdbcTransactionFactory();\nEnvironment environment = new Environment("development", transactionFactory, dataSource);\nConfiguration configuration = new Configuration(environment);\nconfiguration.addMapper(BlogMapper.class);\nSqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(configuration);\n\n\n注意该例中，configuration 添加了一个映射器类（mapper class）。映射器类是 Java 类，它们包含 SQL 映射注解从而避免依赖 XML 映射文件。不过，由于 Java 注解的一些限制以及某些 MyBatis 映射的复杂性，要使用大多数高级映射（比如：嵌套联合映射），仍然需要使用 XML 映射文件进行映射。有鉴于此，如果存在一个同名 XML 映射文件，MyBatis 会自动查找并加载它（在这个例子中，基于类路径和 BlogMapper.class 的类名，会加载 BlogMapper.xml）。具体细节稍后讨论。\n\n\n# 从 SqlSessionFactory 中获取 SqlSession\n\n既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例。SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。你可以通过 SqlSession 实例来直接执行已映射的 SQL 语句。例如：\n\ntry (SqlSession session = sqlSessionFactory.openSession()) {\n  Blog blog = (Blog) session.selectOne("org.mybatis.example.BlogMapper.selectBlog", 101);\n}\n\n\n诚然，这种方式能够正常工作，对使用旧版本 MyBatis 的用户来说也比较熟悉。但现在有了一种更简洁的方式——使用和指定语句的参数和返回值相匹配的接口（比如 BlogMapper.class），现在你的代码不仅更清晰，更加类型安全，还不用担心可能出错的字符串字面值以及强制类型转换。\n\n例如：\n\ntry (SqlSession session = sqlSessionFactory.openSession()) {\n  BlogMapper mapper = session.getMapper(BlogMapper.class);\n  Blog blog = mapper.selectBlog(101);\n}\n\n\n现在我们来探究一下这段代码究竟做了些什么。\n\n\n# 探究已映射的 SQL 语句\n\n现在你可能很想知道 SqlSession 和 Mapper 到底具体执行了些什么操作，但 SQL 语句映射是个相当广泛的话题，可能会占去文档的大部分篇幅。 但为了让你能够了解个大概，这里先给出几个例子。\n\n在上面提到的例子中，一个语句既可以通过 XML 定义，也可以通过注解定义。我们先看看 XML 定义语句的方式，事实上 MyBatis 提供的所有特性都可以利用基于 XML 的映射语言来实现，这使得 MyBatis 在过去的数年间得以流行。如果你用过旧版本的 MyBatis，你应该对这个概念比较熟悉。 但相比于之前的版本，新版本改进了许多 XML 的配置，后面我们会提到这些改进。这里给出一个基于 XML 映射语句的示例，它应该可以满足上个示例中 SqlSession 的调用。\n\n<?xml version="1.0" encoding="UTF-8" ?>\n<!DOCTYPE mapper\n  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"\n  "https://mybatis.org/dtd/mybatis-3-mapper.dtd">\n<mapper namespace="org.mybatis.example.BlogMapper">\n  <select id="selectBlog" resultType="Blog">\n    select * from Blog where id = #{id}\n  </select>\n</mapper>\n\n\n为了这个简单的例子，我们似乎写了不少配置，但其实并不多。在一个 XML 映射文件中，可以定义无数个映射语句，这样一来，XML 头部和文档类型声明部分就显得微不足道了。文档的其它部分很直白，容易理解。 它在命名空间 “org.mybatis.example.BlogMapper” 中定义了一个名为 “selectBlog” 的映射语句，这样你就可以用全限定名 “org.mybatis.example.BlogMapper.selectBlog” 来调用映射语句了，就像上面例子中那样：\n\nBlog blog = (Blog) session.selectOne("org.mybatis.example.BlogMapper.selectBlog", 101);\n\n\n你可能会注意到，这种方式和用全限定名调用 Java 对象的方法类似。这样，该命名就可以直接映射到在命名空间中同名的映射器类，并将已映射的 select 语句匹配到对应名称、参数和返回类型的方法。因此你就可以像上面那样，不费吹灰之力地在对应的映射器接口调用方法，就像下面这样：\n\nBlogMapper mapper = session.getMapper(BlogMapper.class);\nBlog blog = mapper.selectBlog(101);\n\n\n第二种方法有很多优势，首先它不依赖于字符串字面值，会更安全一点；其次，如果你的 IDE 有代码补全功能，那么代码补全可以帮你快速选择到映射好的 SQL 语句。\n\n提示 对命名空间的一点补充\n\n在之前版本的 MyBatis 中，**命名空间（Namespaces）**的作用并不大，是可选的。 但现在，随着命名空间越发重要，你必须指定命名空间。\n\n命名空间的作用有两个，一个是利用更长的全限定名来将不同的语句隔离开来，同时也实现了你上面见到的接口绑定。就算你觉得暂时用不到接口绑定，你也应该遵循这里的规定，以防哪天你改变了主意。 长远来看，只要将命名空间置于合适的 Java 包命名空间之中，你的代码会变得更加整洁，也有利于你更方便地使用 MyBatis。\n\n**命名解析：**为了减少输入量，MyBatis 对所有具有名称的配置元素（包括语句，结果映射，缓存等）使用了如下的命名解析规则。\n\n * 全限定名（比如 “com.mypackage.MyMapper.selectAllThings）将被直接用于查找及使用。\n * 短名称（比如 “selectAllThings”）如果全局唯一也可以作为一个单独的引用。 如果不唯一，有两个或两个以上的相同名称（比如 “com.foo.selectAllThings” 和 “com.bar.selectAllThings”），那么使用时就会产生“短名称不唯一”的错误，这种情况下就必须使用全限定名。\n\n对于像 BlogMapper 这样的映射器类来说，还有另一种方法来完成语句映射。 它们映射的语句可以不用 XML 来配置，而可以使用 Java 注解来配置。比如，上面的 XML 示例可以被替换成如下的配置：\n\npackage org.mybatis.example;\npublic interface BlogMapper {\n  @Select("SELECT * FROM blog WHERE id = #{id}")\n  Blog selectBlog(int id);\n}\n\n\n使用注解来映射简单语句会使代码显得更加简洁，但对于稍微复杂一点的语句，Java 注解不仅力不从心，还会让本就复杂的 SQL 语句更加混乱不堪。 因此，如果你需要做一些很复杂的操作，最好用 XML 来映射语句。\n\n选择何种方式来配置映射，以及是否应该要统一映射语句定义的形式，完全取决于你和你的团队。 换句话说，永远不要拘泥于一种方式，你可以很轻松地在基于注解和 XML 的语句映射方式间自由移植和切换。\n\n\n# 作用域（Scope）和生命周期\n\n理解我们之前讨论过的不同作用域和生命周期类别是至关重要的，因为错误的使用会导致非常严重的并发问题。\n\n提示 对象生命周期和依赖注入框架\n\n依赖注入框架可以创建线程安全的、基于事务的 SqlSession 和映射器，并将它们直接注入到你的 bean 中，因此可以直接忽略它们的生命周期。 如果对如何通过依赖注入框架使用 MyBatis 感兴趣，可以研究一下 MyBatis-Spring 或 MyBatis-Guice 两个子项目。\n\n# SqlSessionFactoryBuilder\n\n这个类可以被实例化、使用和丢弃，一旦创建了 SqlSessionFactory，就不再需要它了。 因此 SqlSessionFactoryBuilder 实例的最佳作用域是方法作用域（也就是局部方法变量）。 你可以重用 SqlSessionFactoryBuilder 来创建多个 SqlSessionFactory 实例，但最好还是不要一直保留着它，以保证所有的 XML 解析资源可以被释放给更重要的事情。\n\n# SqlSessionFactory\n\nSqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例。 使用 SqlSessionFactory 的最佳实践是在应用运行期间不要重复创建多次，多次重建 SqlSessionFactory 被视为一种代码“坏习惯”。因此 SqlSessionFactory 的最佳作用域是应用作用域。 有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式。\n\n# SqlSession\n\n每个线程都应该有它自己的 SqlSession 实例。SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。 绝对不能将 SqlSession 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。 也绝不能将 SqlSession 实例的引用放在任何类型的托管作用域中，比如 Servlet 框架中的 HttpSession。 如果你现在正在使用一种 Web 框架，考虑将 SqlSession 放在一个和 HTTP 请求相似的作用域中。 换句话说，每次收到 HTTP 请求，就可以打开一个 SqlSession，返回一个响应后，就关闭它。 这个关闭操作很重要，为了确保每次都能执行关闭操作，你应该把这个关闭操作放到 finally 块中。 下面的示例就是一个确保 SqlSession 关闭的标准模式：\n\ntry (SqlSession session = sqlSessionFactory.openSession()) {\n  // 你的应用逻辑代码\n}\n\n\n在所有代码中都遵循这种使用模式，可以保证所有数据库资源都能被正确地关闭。\n\n# 映射器实例\n\n映射器是一些绑定映射语句的接口。映射器接口的实例是从 SqlSession 中获得的。虽然从技术层面上来讲，任何映射器实例的最大作用域与请求它们的 SqlSession 相同。但方法作用域才是映射器实例的最合适的作用域。 也就是说，映射器实例应该在调用它们的方法中被获取，使用完毕之后即可丢弃。 映射器实例并不需要被显式地关闭。尽管在整个请求作用域保留映射器实例不会有什么问题，但是你很快会发现，在这个作用域上管理太多像 SqlSession 的资源会让你忙不过来。 因此，最好将映射器放在方法作用域内。就像下面的例子一样：\n\ntry (SqlSession session = sqlSessionFactory.openSession()) {\n  BlogMapper mapper = session.getMapper(BlogMapper.class);\n  // 你的应用逻辑代码\n}\n\n\n\n# Mybatis 扩展工具\n\n\n# Mybatis Plus\n\nMyBatis-Plus（简称 MP）是一个 MyBatis 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。\n\n【集成示例】spring-boot-data-mybatis-plus\n\n\n# Mapper\n\nMapper 是一个 Mybatis CRUD 扩展插件。\n\nMapper 的基本原理是将实体类映射为数据库中的表和字段信息，因此实体类需要通过注解配置基本的元数据，配置好实体后， 只需要创建一个继承基础接口的 Mapper 接口就可以开始使用了。\n\n【集成示例】spring-boot-data-mybatis-mapper\n\n\n# PageHelper\n\nPageHelper 是一个 Mybatis 通用分页插件。\n\n【集成示例】spring-boot-data-mybatis-mapper\n\n\n# 参考资料\n\n * 官方\n   * Mybatis Github\n   * Mybatis 官网\n   * MyBatis 官方代码生成（mybatis-generator）\n   * MyBatis 官方集成 Spring（mybatis-spring）\n   * Mybatis 官方集成 Spring Boot（mybatis-spring-boot）\n * 扩展插件\n   * MyBatis-Plus - CRUD 扩展插件、代码生成器、分页器等多功能\n   * Mapper - Mybatis CRUD 扩展插件\n   * PageHelper - Mybatis 通用分页插件\n * 文章\n   * 深入理解 mybatis 原理\n   * mybatis 源码中文注释\n   * MyBatis Generator 详解\n   * Mybatis 常见面试题\n   * Mybatis 中强大的 resultMap',normalizedContent:'# spring 集成 mybatis\n\nmybatis 官网 是一款持久层框架，它支持定制化 sql、存储过程以及高级映射。mybatis 避免了几乎所有的 jdbc 代码和手动设置参数以及获取结果集。mybatis 可以使用简单的 xml 或注解来配置和映射原生类型、接口和 java 的 pojo（plain old java objects，普通老式 java 对象）为数据库中的记录。\n\n\n# 快速入门\n\n要使用 mybatis， 只需将 mybatis-x.x.x.jar 文件置于类路径（classpath）中即可。\n\n如果使用 maven 来构建项目，则需将下面的依赖代码置于 pom.xml 文件中：\n\n<dependency>\n  <groupid>org.mybatis</groupid>\n  <artifactid>mybatis</artifactid>\n  <version>x.x.x</version>\n</dependency>\n\n\n\n# 从 xml 中构建 sqlsessionfactory\n\n每个基于 mybatis 的应用都是以一个 sqlsessionfactory 的实例为核心的。sqlsessionfactory 的实例可以通过 sqlsessionfactorybuilder 获得。而 sqlsessionfactorybuilder 则可以从 xml 配置文件或一个预先配置的 configuration 实例来构建出 sqlsessionfactory 实例。\n\n从 xml 文件中构建 sqlsessionfactory 的实例非常简单，建议使用类路径下的资源文件进行配置。 但也可以使用任意的输入流（inputstream）实例，比如用文件路径字符串或 file:// url 构造的输入流。mybatis 包含一个名叫 resources 的工具类，它包含一些实用方法，使得从类路径或其它位置加载资源文件更加容易。\n\nstring resource = "org/mybatis/example/mybatis-config.xml";\ninputstream inputstream = resources.getresourceasstream(resource);\nsqlsessionfactory sqlsessionfactory = new sqlsessionfactorybuilder().build(inputstream);\n\n\nxml 配置文件中包含了对 mybatis 系统的核心设置，包括获取数据库连接实例的数据源（datasource）以及决定事务作用域和控制方式的事务管理器（transactionmanager）。后面会再探讨 xml 配置文件的详细内容，这里先给出一个简单的示例：\n\n<?xml version="1.0" encoding="utf-8" ?>\n<!doctype configuration\n  public "-//mybatis.org//dtd config 3.0//en"\n  "https://mybatis.org/dtd/mybatis-3-config.dtd">\n<configuration>\n  <environments default="development">\n    <environment id="development">\n      <transactionmanager type="jdbc"/>\n      <datasource type="pooled">\n        <property name="driver" value="${driver}"/>\n        <property name="url" value="${url}"/>\n        <property name="username" value="${username}"/>\n        <property name="password" value="${password}"/>\n      </datasource>\n    </environment>\n  </environments>\n  <mappers>\n    <mapper resource="org/mybatis/example/blogmapper.xml"/>\n  </mappers>\n</configuration>\n\n\n当然，还有很多可以在 xml 文件中配置的选项，上面的示例仅罗列了最关键的部分。 注意 xml 头部的声明，它用来验证 xml 文档的正确性。environment 元素体中包含了事务管理和连接池的配置。mappers 元素则包含了一组映射器（mapper），这些映射器的 xml 映射文件包含了 sql 代码和映射定义信息。\n\n\n# 不使用 xml 构建 sqlsessionfactory\n\n如果你更愿意直接从 java 代码而不是 xml 文件中创建配置，或者想要创建你自己的配置构建器，mybatis 也提供了完整的配置类，提供了所有与 xml 文件等价的配置项。\n\ndatasource datasource = blogdatasourcefactory.getblogdatasource();\ntransactionfactory transactionfactory = new jdbctransactionfactory();\nenvironment environment = new environment("development", transactionfactory, datasource);\nconfiguration configuration = new configuration(environment);\nconfiguration.addmapper(blogmapper.class);\nsqlsessionfactory sqlsessionfactory = new sqlsessionfactorybuilder().build(configuration);\n\n\n注意该例中，configuration 添加了一个映射器类（mapper class）。映射器类是 java 类，它们包含 sql 映射注解从而避免依赖 xml 映射文件。不过，由于 java 注解的一些限制以及某些 mybatis 映射的复杂性，要使用大多数高级映射（比如：嵌套联合映射），仍然需要使用 xml 映射文件进行映射。有鉴于此，如果存在一个同名 xml 映射文件，mybatis 会自动查找并加载它（在这个例子中，基于类路径和 blogmapper.class 的类名，会加载 blogmapper.xml）。具体细节稍后讨论。\n\n\n# 从 sqlsessionfactory 中获取 sqlsession\n\n既然有了 sqlsessionfactory，顾名思义，我们可以从中获得 sqlsession 的实例。sqlsession 提供了在数据库执行 sql 命令所需的所有方法。你可以通过 sqlsession 实例来直接执行已映射的 sql 语句。例如：\n\ntry (sqlsession session = sqlsessionfactory.opensession()) {\n  blog blog = (blog) session.selectone("org.mybatis.example.blogmapper.selectblog", 101);\n}\n\n\n诚然，这种方式能够正常工作，对使用旧版本 mybatis 的用户来说也比较熟悉。但现在有了一种更简洁的方式——使用和指定语句的参数和返回值相匹配的接口（比如 blogmapper.class），现在你的代码不仅更清晰，更加类型安全，还不用担心可能出错的字符串字面值以及强制类型转换。\n\n例如：\n\ntry (sqlsession session = sqlsessionfactory.opensession()) {\n  blogmapper mapper = session.getmapper(blogmapper.class);\n  blog blog = mapper.selectblog(101);\n}\n\n\n现在我们来探究一下这段代码究竟做了些什么。\n\n\n# 探究已映射的 sql 语句\n\n现在你可能很想知道 sqlsession 和 mapper 到底具体执行了些什么操作，但 sql 语句映射是个相当广泛的话题，可能会占去文档的大部分篇幅。 但为了让你能够了解个大概，这里先给出几个例子。\n\n在上面提到的例子中，一个语句既可以通过 xml 定义，也可以通过注解定义。我们先看看 xml 定义语句的方式，事实上 mybatis 提供的所有特性都可以利用基于 xml 的映射语言来实现，这使得 mybatis 在过去的数年间得以流行。如果你用过旧版本的 mybatis，你应该对这个概念比较熟悉。 但相比于之前的版本，新版本改进了许多 xml 的配置，后面我们会提到这些改进。这里给出一个基于 xml 映射语句的示例，它应该可以满足上个示例中 sqlsession 的调用。\n\n<?xml version="1.0" encoding="utf-8" ?>\n<!doctype mapper\n  public "-//mybatis.org//dtd mapper 3.0//en"\n  "https://mybatis.org/dtd/mybatis-3-mapper.dtd">\n<mapper namespace="org.mybatis.example.blogmapper">\n  <select id="selectblog" resulttype="blog">\n    select * from blog where id = #{id}\n  </select>\n</mapper>\n\n\n为了这个简单的例子，我们似乎写了不少配置，但其实并不多。在一个 xml 映射文件中，可以定义无数个映射语句，这样一来，xml 头部和文档类型声明部分就显得微不足道了。文档的其它部分很直白，容易理解。 它在命名空间 “org.mybatis.example.blogmapper” 中定义了一个名为 “selectblog” 的映射语句，这样你就可以用全限定名 “org.mybatis.example.blogmapper.selectblog” 来调用映射语句了，就像上面例子中那样：\n\nblog blog = (blog) session.selectone("org.mybatis.example.blogmapper.selectblog", 101);\n\n\n你可能会注意到，这种方式和用全限定名调用 java 对象的方法类似。这样，该命名就可以直接映射到在命名空间中同名的映射器类，并将已映射的 select 语句匹配到对应名称、参数和返回类型的方法。因此你就可以像上面那样，不费吹灰之力地在对应的映射器接口调用方法，就像下面这样：\n\nblogmapper mapper = session.getmapper(blogmapper.class);\nblog blog = mapper.selectblog(101);\n\n\n第二种方法有很多优势，首先它不依赖于字符串字面值，会更安全一点；其次，如果你的 ide 有代码补全功能，那么代码补全可以帮你快速选择到映射好的 sql 语句。\n\n提示 对命名空间的一点补充\n\n在之前版本的 mybatis 中，**命名空间（namespaces）**的作用并不大，是可选的。 但现在，随着命名空间越发重要，你必须指定命名空间。\n\n命名空间的作用有两个，一个是利用更长的全限定名来将不同的语句隔离开来，同时也实现了你上面见到的接口绑定。就算你觉得暂时用不到接口绑定，你也应该遵循这里的规定，以防哪天你改变了主意。 长远来看，只要将命名空间置于合适的 java 包命名空间之中，你的代码会变得更加整洁，也有利于你更方便地使用 mybatis。\n\n**命名解析：**为了减少输入量，mybatis 对所有具有名称的配置元素（包括语句，结果映射，缓存等）使用了如下的命名解析规则。\n\n * 全限定名（比如 “com.mypackage.mymapper.selectallthings）将被直接用于查找及使用。\n * 短名称（比如 “selectallthings”）如果全局唯一也可以作为一个单独的引用。 如果不唯一，有两个或两个以上的相同名称（比如 “com.foo.selectallthings” 和 “com.bar.selectallthings”），那么使用时就会产生“短名称不唯一”的错误，这种情况下就必须使用全限定名。\n\n对于像 blogmapper 这样的映射器类来说，还有另一种方法来完成语句映射。 它们映射的语句可以不用 xml 来配置，而可以使用 java 注解来配置。比如，上面的 xml 示例可以被替换成如下的配置：\n\npackage org.mybatis.example;\npublic interface blogmapper {\n  @select("select * from blog where id = #{id}")\n  blog selectblog(int id);\n}\n\n\n使用注解来映射简单语句会使代码显得更加简洁，但对于稍微复杂一点的语句，java 注解不仅力不从心，还会让本就复杂的 sql 语句更加混乱不堪。 因此，如果你需要做一些很复杂的操作，最好用 xml 来映射语句。\n\n选择何种方式来配置映射，以及是否应该要统一映射语句定义的形式，完全取决于你和你的团队。 换句话说，永远不要拘泥于一种方式，你可以很轻松地在基于注解和 xml 的语句映射方式间自由移植和切换。\n\n\n# 作用域（scope）和生命周期\n\n理解我们之前讨论过的不同作用域和生命周期类别是至关重要的，因为错误的使用会导致非常严重的并发问题。\n\n提示 对象生命周期和依赖注入框架\n\n依赖注入框架可以创建线程安全的、基于事务的 sqlsession 和映射器，并将它们直接注入到你的 bean 中，因此可以直接忽略它们的生命周期。 如果对如何通过依赖注入框架使用 mybatis 感兴趣，可以研究一下 mybatis-spring 或 mybatis-guice 两个子项目。\n\n# sqlsessionfactorybuilder\n\n这个类可以被实例化、使用和丢弃，一旦创建了 sqlsessionfactory，就不再需要它了。 因此 sqlsessionfactorybuilder 实例的最佳作用域是方法作用域（也就是局部方法变量）。 你可以重用 sqlsessionfactorybuilder 来创建多个 sqlsessionfactory 实例，但最好还是不要一直保留着它，以保证所有的 xml 解析资源可以被释放给更重要的事情。\n\n# sqlsessionfactory\n\nsqlsessionfactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例。 使用 sqlsessionfactory 的最佳实践是在应用运行期间不要重复创建多次，多次重建 sqlsessionfactory 被视为一种代码“坏习惯”。因此 sqlsessionfactory 的最佳作用域是应用作用域。 有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式。\n\n# sqlsession\n\n每个线程都应该有它自己的 sqlsession 实例。sqlsession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。 绝对不能将 sqlsession 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。 也绝不能将 sqlsession 实例的引用放在任何类型的托管作用域中，比如 servlet 框架中的 httpsession。 如果你现在正在使用一种 web 框架，考虑将 sqlsession 放在一个和 http 请求相似的作用域中。 换句话说，每次收到 http 请求，就可以打开一个 sqlsession，返回一个响应后，就关闭它。 这个关闭操作很重要，为了确保每次都能执行关闭操作，你应该把这个关闭操作放到 finally 块中。 下面的示例就是一个确保 sqlsession 关闭的标准模式：\n\ntry (sqlsession session = sqlsessionfactory.opensession()) {\n  // 你的应用逻辑代码\n}\n\n\n在所有代码中都遵循这种使用模式，可以保证所有数据库资源都能被正确地关闭。\n\n# 映射器实例\n\n映射器是一些绑定映射语句的接口。映射器接口的实例是从 sqlsession 中获得的。虽然从技术层面上来讲，任何映射器实例的最大作用域与请求它们的 sqlsession 相同。但方法作用域才是映射器实例的最合适的作用域。 也就是说，映射器实例应该在调用它们的方法中被获取，使用完毕之后即可丢弃。 映射器实例并不需要被显式地关闭。尽管在整个请求作用域保留映射器实例不会有什么问题，但是你很快会发现，在这个作用域上管理太多像 sqlsession 的资源会让你忙不过来。 因此，最好将映射器放在方法作用域内。就像下面的例子一样：\n\ntry (sqlsession session = sqlsessionfactory.opensession()) {\n  blogmapper mapper = session.getmapper(blogmapper.class);\n  // 你的应用逻辑代码\n}\n\n\n\n# mybatis 扩展工具\n\n\n# mybatis plus\n\nmybatis-plus（简称 mp）是一个 mybatis 的增强工具，在 mybatis 的基础上只做增强不做改变，为简化开发、提高效率而生。\n\n【集成示例】spring-boot-data-mybatis-plus\n\n\n# mapper\n\nmapper 是一个 mybatis crud 扩展插件。\n\nmapper 的基本原理是将实体类映射为数据库中的表和字段信息，因此实体类需要通过注解配置基本的元数据，配置好实体后， 只需要创建一个继承基础接口的 mapper 接口就可以开始使用了。\n\n【集成示例】spring-boot-data-mybatis-mapper\n\n\n# pagehelper\n\npagehelper 是一个 mybatis 通用分页插件。\n\n【集成示例】spring-boot-data-mybatis-mapper\n\n\n# 参考资料\n\n * 官方\n   * mybatis github\n   * mybatis 官网\n   * mybatis 官方代码生成（mybatis-generator）\n   * mybatis 官方集成 spring（mybatis-spring）\n   * mybatis 官方集成 spring boot（mybatis-spring-boot）\n * 扩展插件\n   * mybatis-plus - crud 扩展插件、代码生成器、分页器等多功能\n   * mapper - mybatis crud 扩展插件\n   * pagehelper - mybatis 通用分页插件\n * 文章\n   * 深入理解 mybatis 原理\n   * mybatis 源码中文注释\n   * mybatis generator 详解\n   * mybatis 常见面试题\n   * mybatis 中强大的 resultmap',charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Spring Data 综合",frontmatter:{title:"Spring Data 综合",date:"2023-02-08T09:10:35.000Z",order:20,categories:["Java","框架","Spring","Spring数据"],tags:["Java","框架","Spring","SpringBoot"],permalink:"/pages/191cdb/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/02.Spring%E6%95%B0%E6%8D%AE/20.SpringData%E7%BB%BC%E5%90%88.html",relativePath:"01.Java/13.框架/01.Spring/02.Spring数据/20.SpringData综合.md",key:"v-c837cd76",path:"/pages/191cdb/",headers:[{level:2,title:"核心概念",slug:"核心概念",normalizedTitle:"核心概念",charIndex:72},{level:2,title:"查询方法",slug:"查询方法",normalizedTitle:"查询方法",charIndex:1089},{level:2,title:"定义 Repository",slug:"定义-repository",normalizedTitle:"定义 repository",charIndex:2162},{level:3,title:"微调 Repository 定义",slug:"微调-repository-定义",normalizedTitle:"微调 repository 定义",charIndex:2286},{level:3,title:"使用多个 Spring 数据模块",slug:"使用多个-spring-数据模块",normalizedTitle:"使用多个 spring 数据模块",charIndex:3341},{level:2,title:"定义查询方法",slug:"定义查询方法",normalizedTitle:"定义查询方法",charIndex:5447},{level:3,title:"查询策略",slug:"查询策略",normalizedTitle:"查询策略",charIndex:5567},{level:3,title:"查询创建",slug:"查询创建",normalizedTitle:"查询创建",charIndex:5826},{level:2,title:"创建 Repository 实例",slug:"创建-repository-实例",normalizedTitle:"创建 repository 实例",charIndex:6943},{level:2,title:"自定义 Repository 实现",slug:"自定义-repository-实现",normalizedTitle:"自定义 repository 实现",charIndex:6964},{level:2,title:"Spring Data 扩展",slug:"spring-data-扩展",normalizedTitle:"spring data 扩展",charIndex:6986},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:7005}],headersStr:"核心概念 查询方法 定义 Repository 微调 Repository 定义 使用多个 Spring 数据模块 定义查询方法 查询策略 查询创建 创建 Repository 实例 自定义 Repository 实现 Spring Data 扩展 参考资料",content:'# Spring Data 综合\n\nSpring Data Repository 抽象的目标是显著减少各种访问持久化存储的样板式代码。\n\n\n# 核心概念\n\nRepository 是 Spring Data 的核心接口。此接口主要用作标记接口，以捕获要使用的类型并帮助您发现扩展此接口的接口。CrudRepository 和 ListCrudRepository 接口为被管理的实体类提供复杂的 CRUD 功能。ListCrudRepository 提供等效方法，但它们返回 List，而 CrudRepository 方法返回 Iterable。\n\nCrudRepository 接口定义：\n\npublic interface CrudRepository<T, ID> extends Repository<T, ID> {\n\n  <S extends T> S save(S entity);\n\n  Optional<T> findById(ID primaryKey);\n\n  Iterable<T> findAll();\n\n  long count();\n\n  void delete(T entity);\n\n  boolean existsById(ID primaryKey);\n\n  // … more functionality omitted.\n}\n\n\n> Spring Data 项目也提供了一些特定持久化技术的抽象接口，如：JpaRepository 或 MongoRepository。这些接口扩展了 CrudRepository 并暴露了一些持久化技术的底层功能。\n\n除了 CrudRepository 之外，还有一个 PagingAndSortingRepository 接口，它添加了额外的方法来简化对实体的分页访问：\n\npublic interface PagingAndSortingRepository<T, ID>  {\n\n  Iterable<T> findAll(Sort sort);\n\n  Page<T> findAll(Pageable pageable);\n}\n\n\n【示例】要按页面大小 20 访问 User 的第二页，可以执行如下操作\n\nPagingAndSortingRepository<User, Long> repository = // … get access to a bean\nPage<User> users = repository.findAll(PageRequest.of(1, 20));\n\n\n除了查询方法之外，计数和删除时的查询也是可用的。\n\n【示例】根据姓氏计数\n\ninterface UserRepository extends CrudRepository<User, Long> {\n  long countByLastname(String lastname);\n}\n\n\n【示例】根据姓氏删除\n\ninterface UserRepository extends CrudRepository<User, Long> {\n\n  long deleteByLastname(String lastname);\n\n  List<User> removeByLastname(String lastname);\n}\n\n\n\n# 查询方法\n\n使用 Spring Data 对数据库进行查询有以下四步：\n\n 1. 声明一个扩展 Repository 或其子接口的接口，并指定泛型类型（实体类和 ID 类型），如以下示例所示：\n    \n    interface PersonRepository extends Repository<Person, Long> { … }\n    \n\n 2. 在接口中声明查询方法\n    \n    interface PersonRepository extends Repository<Person, Long> {\n      List<Person> findByLastname(String lastname);\n    }\n    \n\n 3. 使用 JavaConfig 或 XML 配置为这些接口创建代理实例\n    \n    @EnableJpaRepositories\n    class Config { … }\n    \n\n 4. 注入 Repository 实例并使用\n    \n    class SomeClient {\n    \n      private final PersonRepository repository;\n    \n      SomeClient(PersonRepository repository) {\n        this.repository = repository;\n      }\n    \n      void doSomething() {\n        List<Person> persons = repository.findByLastname("Matthews");\n      }\n    }\n    \n\n\n# 定义 Repository\n\n首先需要定义一个 Repository 接口，该接口必须扩展 Repository 并且指定泛型类型（实体类和 ID 类型）。如果想为该实体暴露 CRUD 方法，可以扩展 CrudRepository 接口。\n\n\n# 微调 Repository 定义\n\nSpring Data 提供了很多种 Repository 以应对不同的需求场景。\n\nCrudRepository 提供了 CRUD 功能。\n\nListCrudRepository 和 CrudRepository 类似，但对于那些返回多个实体的方法，它返回一个 List 而不是 Iterable，这样使用可能更方便。\n\n如果使用响应式框架，可以使用 ReactiveCrudRepository 或 RxJava3CrudRepository。\n\nCoroutineCrudRepository 支持 Kotlin 的协程特性。\n\nPagingAndSortingRepository 提供了分页、排序功能。\n\n如果不想扩展 Spring Data 接口，还可以使用 @RepositoryDefinition 注释您的 Repository 接口。 扩展一个 CRUD Repository 接口，需要暴露一组完整的方法来操作实体。如果希望对暴露的方法有选择性，可以将要暴露的方法从 CRUD Repository 复制到自定义的 Repository 中。 这样做时，可以更改方法的返回类型。 如果可能，Spring Data 将遵循返回类型。 例如，对于返回多个实体的方法，可以选择 Iterable<T>、List<T>、Collection<T> 或 VAVR 列表。\n\n自定义基础 Repository 接口，必须用 @NoRepositoryBean 标记。 这可以防止 Spring Data 尝试直接创建它的实例并失败，因为它无法确定该 Repository 的实体，因为它仍然包含一个通用类型变量。\n\n以下示例显示了如何有选择地暴露 CRUD 方法（在本例中为 findById 和 save）：\n\n@NoRepositoryBean\ninterface MyBaseRepository<T, ID> extends Repository<T, ID> {\n\n  Optional<T> findById(ID id);\n\n  <S extends T> S save(S entity);\n}\n\ninterface UserRepository extends MyBaseRepository<User, Long> {\n  User findByEmailAddress(EmailAddress emailAddress);\n}\n\n\n\n# 使用多个 Spring 数据模块\n\n有时，程序中需要使用多个 Spring Data 模块。在这种情况下，必须区分持久化技术。当检测到类路径上有多个 Repository 工厂时，Spring Data 进入严格的配置模式。\n\n如果定义的 Repository 扩展了特定模块中的 Repository，则它是特定 Spring Data 模块的有效候选者。\n\n如果实体类使用了特定模块的类型注解，则它是特定 Spring Data 模块的有效候选者。 Spring Data 模块接受第三方注解（例如 JPA 的 @Entity）或提供自己的注解（例如用于 Spring Data MongoDB 和 Spring Data Elasticsearch 的 @Document）。\n\n以下示例显示了一个使用模块特定接口（在本例中为 JPA）的 Repository：\n\ninterface MyRepository extends JpaRepository<User, Long> { }\n\n@NoRepositoryBean\ninterface MyBaseRepository<T, ID> extends JpaRepository<T, ID> { … }\n\ninterface UserRepository extends MyBaseRepository<User, Long> { … }\n\n\nMyRepository 和 UserRepository 扩展了 JpaRepository。它们是 Spring Data JPA 模块的有效候选者。\n\n以下示例显示了一个使用通用接口的 Repository\n\ninterface AmbiguousRepository extends Repository<User, Long> { … }\n\n@NoRepositoryBean\ninterface MyBaseRepository<T, ID> extends CrudRepository<T, ID> { … }\n\ninterface AmbiguousUserRepository extends MyBaseRepository<User, Long> { … }\n\n\nAmbiguousRepository 和 AmbiguousUserRepository 仅扩展了 Repository 和 CrudRepository。 虽然这在使用唯一的 Spring Data 模块时很好，但是存在多个模块时，无法区分这些 Repository 应该绑定到哪个特定的 Spring Data。\n\n以下示例显示了一个使用带注解的实体类的 Repository\n\ninterface PersonRepository extends Repository<Person, Long> { … }\n\n@Entity\nclass Person { … }\n\ninterface UserRepository extends Repository<User, Long> { … }\n\n@Document\nclass User { … }\n\n\nPersonRepository 引用 Person，它使用 JPA @Entity 注解进行标记，因此这个 Repository 显然属于 Spring Data JPA。 UserRepository 引用 User，它使用 Spring Data MongoDB 的 @Document 注解进行标记。\n\n以下错误示例显示了一个使用带有混合注解的实体类的 Repository\n\ninterface JpaPersonRepository extends Repository<Person, Long> { … }\n\ninterface MongoDBPersonRepository extends Repository<Person, Long> { … }\n\n@Entity\n@Document\nclass Person { … }\n\n\n此示例中的实体类同时使用了 JPA 和 Spring Data MongoDB 的注解。示例中定义了两个 Repository：JpaPersonRepository 和 MongoDBPersonRepository。 一个用于 JPA，另一个用于 MongoDB。 Spring Data 不再能够区分 Repository，这会导致未定义的行为。\n\n区分 Repository 的最后一种方法是确定 Repository 扫描 package 的范围。\n\n@EnableJpaRepositories(basePackages = "com.acme.repositories.jpa")\n@EnableMongoRepositories(basePackages = "com.acme.repositories.mongo")\nclass Configuration { … }\n\n\n\n# 定义查询方法\n\nRepository 代理有两种方法可以从方法名称派生特定于存储的查询：\n\n * 通过直接从方法名称派生查询。\n * 通过使用手动定义的查询。\n\n可用选项取决于实际存储。但是，必须有一个策略来决定创建什么实际查询。\n\n\n# 查询策略\n\n以下策略可用于Repository 基础结构来解析查询。 对于 Java 配置，您可以使用 EnableJpaRepositories 注释的 queryLookupStrategy 属性。 特定数据存储可能不支持某些策略。\n\n * CREATE 尝试从查询方法名称构造特定存储的查询。\n * USE_DECLARED_QUERY 尝试查找已声明的查询，如果找不到则抛出异常。\n * CREATE_IF_NOT_FOUND （默认）结合了 CREATE 和 USE_DECLARED_QUERY。\n\n\n# 查询创建\n\nSpring Data 中有一套内置的查询构建器机制，可以自动映射符合命名和参数规则的方法。\n\ninterface PersonRepository extends Repository<Person, Long> {\n\n  List<Person> findByEmailAddressAndLastname(EmailAddress emailAddress, String lastname);\n\n  // Enables the distinct flag for the query\n  List<Person> findDistinctPeopleByLastnameOrFirstname(String lastname, String firstname);\n  List<Person> findPeopleDistinctByLastnameOrFirstname(String lastname, String firstname);\n\n  // Enabling ignoring case for an individual property\n  List<Person> findByLastnameIgnoreCase(String lastname);\n  // Enabling ignoring case for all suitable properties\n  List<Person> findByLastnameAndFirstnameAllIgnoreCase(String lastname, String firstname);\n\n  // Enabling static ORDER BY for a query\n  List<Person> findByLastnameOrderByFirstnameAsc(String lastname);\n  List<Person> findByLastnameOrderByFirstnameDesc(String lastname);\n}\n\n\n解析查询方法名称分为主语和谓语。第一部分 (find…By, exists…By) 定义查询的主语，第二部分构成谓词。 主语可以包含更多的表达。 find（或其他引入关键字）和 By 之间的任何文本都被认为是描述性的，除非使用其中一个结果限制关键字，例如 Distinct 在要创建的查询上设置不同的标志或 Top/First 限制查询结果。\n\n> 参考：\n> \n> Spring Data 支持的查询主语关键词\n> \n> Spring Data 支持的查询谓语关键词\n\n\n# 创建 Repository 实例\n\n\n# 自定义 Repository 实现\n\n\n# Spring Data 扩展\n\n\n# 参考资料\n\n * Redis 官网\n * Redis Github\n * spring-data-redis Github\n * Spring Data Redis 官方文档\n * Spring Data 官方示例',normalizedContent:'# spring data 综合\n\nspring data repository 抽象的目标是显著减少各种访问持久化存储的样板式代码。\n\n\n# 核心概念\n\nrepository 是 spring data 的核心接口。此接口主要用作标记接口，以捕获要使用的类型并帮助您发现扩展此接口的接口。crudrepository 和 listcrudrepository 接口为被管理的实体类提供复杂的 crud 功能。listcrudrepository 提供等效方法，但它们返回 list，而 crudrepository 方法返回 iterable。\n\ncrudrepository 接口定义：\n\npublic interface crudrepository<t, id> extends repository<t, id> {\n\n  <s extends t> s save(s entity);\n\n  optional<t> findbyid(id primarykey);\n\n  iterable<t> findall();\n\n  long count();\n\n  void delete(t entity);\n\n  boolean existsbyid(id primarykey);\n\n  // … more functionality omitted.\n}\n\n\n> spring data 项目也提供了一些特定持久化技术的抽象接口，如：jparepository 或 mongorepository。这些接口扩展了 crudrepository 并暴露了一些持久化技术的底层功能。\n\n除了 crudrepository 之外，还有一个 pagingandsortingrepository 接口，它添加了额外的方法来简化对实体的分页访问：\n\npublic interface pagingandsortingrepository<t, id>  {\n\n  iterable<t> findall(sort sort);\n\n  page<t> findall(pageable pageable);\n}\n\n\n【示例】要按页面大小 20 访问 user 的第二页，可以执行如下操作\n\npagingandsortingrepository<user, long> repository = // … get access to a bean\npage<user> users = repository.findall(pagerequest.of(1, 20));\n\n\n除了查询方法之外，计数和删除时的查询也是可用的。\n\n【示例】根据姓氏计数\n\ninterface userrepository extends crudrepository<user, long> {\n  long countbylastname(string lastname);\n}\n\n\n【示例】根据姓氏删除\n\ninterface userrepository extends crudrepository<user, long> {\n\n  long deletebylastname(string lastname);\n\n  list<user> removebylastname(string lastname);\n}\n\n\n\n# 查询方法\n\n使用 spring data 对数据库进行查询有以下四步：\n\n 1. 声明一个扩展 repository 或其子接口的接口，并指定泛型类型（实体类和 id 类型），如以下示例所示：\n    \n    interface personrepository extends repository<person, long> { … }\n    \n\n 2. 在接口中声明查询方法\n    \n    interface personrepository extends repository<person, long> {\n      list<person> findbylastname(string lastname);\n    }\n    \n\n 3. 使用 javaconfig 或 xml 配置为这些接口创建代理实例\n    \n    @enablejparepositories\n    class config { … }\n    \n\n 4. 注入 repository 实例并使用\n    \n    class someclient {\n    \n      private final personrepository repository;\n    \n      someclient(personrepository repository) {\n        this.repository = repository;\n      }\n    \n      void dosomething() {\n        list<person> persons = repository.findbylastname("matthews");\n      }\n    }\n    \n\n\n# 定义 repository\n\n首先需要定义一个 repository 接口，该接口必须扩展 repository 并且指定泛型类型（实体类和 id 类型）。如果想为该实体暴露 crud 方法，可以扩展 crudrepository 接口。\n\n\n# 微调 repository 定义\n\nspring data 提供了很多种 repository 以应对不同的需求场景。\n\ncrudrepository 提供了 crud 功能。\n\nlistcrudrepository 和 crudrepository 类似，但对于那些返回多个实体的方法，它返回一个 list 而不是 iterable，这样使用可能更方便。\n\n如果使用响应式框架，可以使用 reactivecrudrepository 或 rxjava3crudrepository。\n\ncoroutinecrudrepository 支持 kotlin 的协程特性。\n\npagingandsortingrepository 提供了分页、排序功能。\n\n如果不想扩展 spring data 接口，还可以使用 @repositorydefinition 注释您的 repository 接口。 扩展一个 crud repository 接口，需要暴露一组完整的方法来操作实体。如果希望对暴露的方法有选择性，可以将要暴露的方法从 crud repository 复制到自定义的 repository 中。 这样做时，可以更改方法的返回类型。 如果可能，spring data 将遵循返回类型。 例如，对于返回多个实体的方法，可以选择 iterable<t>、list<t>、collection<t> 或 vavr 列表。\n\n自定义基础 repository 接口，必须用 @norepositorybean 标记。 这可以防止 spring data 尝试直接创建它的实例并失败，因为它无法确定该 repository 的实体，因为它仍然包含一个通用类型变量。\n\n以下示例显示了如何有选择地暴露 crud 方法（在本例中为 findbyid 和 save）：\n\n@norepositorybean\ninterface mybaserepository<t, id> extends repository<t, id> {\n\n  optional<t> findbyid(id id);\n\n  <s extends t> s save(s entity);\n}\n\ninterface userrepository extends mybaserepository<user, long> {\n  user findbyemailaddress(emailaddress emailaddress);\n}\n\n\n\n# 使用多个 spring 数据模块\n\n有时，程序中需要使用多个 spring data 模块。在这种情况下，必须区分持久化技术。当检测到类路径上有多个 repository 工厂时，spring data 进入严格的配置模式。\n\n如果定义的 repository 扩展了特定模块中的 repository，则它是特定 spring data 模块的有效候选者。\n\n如果实体类使用了特定模块的类型注解，则它是特定 spring data 模块的有效候选者。 spring data 模块接受第三方注解（例如 jpa 的 @entity）或提供自己的注解（例如用于 spring data mongodb 和 spring data elasticsearch 的 @document）。\n\n以下示例显示了一个使用模块特定接口（在本例中为 jpa）的 repository：\n\ninterface myrepository extends jparepository<user, long> { }\n\n@norepositorybean\ninterface mybaserepository<t, id> extends jparepository<t, id> { … }\n\ninterface userrepository extends mybaserepository<user, long> { … }\n\n\nmyrepository 和 userrepository 扩展了 jparepository。它们是 spring data jpa 模块的有效候选者。\n\n以下示例显示了一个使用通用接口的 repository\n\ninterface ambiguousrepository extends repository<user, long> { … }\n\n@norepositorybean\ninterface mybaserepository<t, id> extends crudrepository<t, id> { … }\n\ninterface ambiguoususerrepository extends mybaserepository<user, long> { … }\n\n\nambiguousrepository 和 ambiguoususerrepository 仅扩展了 repository 和 crudrepository。 虽然这在使用唯一的 spring data 模块时很好，但是存在多个模块时，无法区分这些 repository 应该绑定到哪个特定的 spring data。\n\n以下示例显示了一个使用带注解的实体类的 repository\n\ninterface personrepository extends repository<person, long> { … }\n\n@entity\nclass person { … }\n\ninterface userrepository extends repository<user, long> { … }\n\n@document\nclass user { … }\n\n\npersonrepository 引用 person，它使用 jpa @entity 注解进行标记，因此这个 repository 显然属于 spring data jpa。 userrepository 引用 user，它使用 spring data mongodb 的 @document 注解进行标记。\n\n以下错误示例显示了一个使用带有混合注解的实体类的 repository\n\ninterface jpapersonrepository extends repository<person, long> { … }\n\ninterface mongodbpersonrepository extends repository<person, long> { … }\n\n@entity\n@document\nclass person { … }\n\n\n此示例中的实体类同时使用了 jpa 和 spring data mongodb 的注解。示例中定义了两个 repository：jpapersonrepository 和 mongodbpersonrepository。 一个用于 jpa，另一个用于 mongodb。 spring data 不再能够区分 repository，这会导致未定义的行为。\n\n区分 repository 的最后一种方法是确定 repository 扫描 package 的范围。\n\n@enablejparepositories(basepackages = "com.acme.repositories.jpa")\n@enablemongorepositories(basepackages = "com.acme.repositories.mongo")\nclass configuration { … }\n\n\n\n# 定义查询方法\n\nrepository 代理有两种方法可以从方法名称派生特定于存储的查询：\n\n * 通过直接从方法名称派生查询。\n * 通过使用手动定义的查询。\n\n可用选项取决于实际存储。但是，必须有一个策略来决定创建什么实际查询。\n\n\n# 查询策略\n\n以下策略可用于repository 基础结构来解析查询。 对于 java 配置，您可以使用 enablejparepositories 注释的 querylookupstrategy 属性。 特定数据存储可能不支持某些策略。\n\n * create 尝试从查询方法名称构造特定存储的查询。\n * use_declared_query 尝试查找已声明的查询，如果找不到则抛出异常。\n * create_if_not_found （默认）结合了 create 和 use_declared_query。\n\n\n# 查询创建\n\nspring data 中有一套内置的查询构建器机制，可以自动映射符合命名和参数规则的方法。\n\ninterface personrepository extends repository<person, long> {\n\n  list<person> findbyemailaddressandlastname(emailaddress emailaddress, string lastname);\n\n  // enables the distinct flag for the query\n  list<person> finddistinctpeoplebylastnameorfirstname(string lastname, string firstname);\n  list<person> findpeopledistinctbylastnameorfirstname(string lastname, string firstname);\n\n  // enabling ignoring case for an individual property\n  list<person> findbylastnameignorecase(string lastname);\n  // enabling ignoring case for all suitable properties\n  list<person> findbylastnameandfirstnameallignorecase(string lastname, string firstname);\n\n  // enabling static order by for a query\n  list<person> findbylastnameorderbyfirstnameasc(string lastname);\n  list<person> findbylastnameorderbyfirstnamedesc(string lastname);\n}\n\n\n解析查询方法名称分为主语和谓语。第一部分 (find…by, exists…by) 定义查询的主语，第二部分构成谓词。 主语可以包含更多的表达。 find（或其他引入关键字）和 by 之间的任何文本都被认为是描述性的，除非使用其中一个结果限制关键字，例如 distinct 在要创建的查询上设置不同的标志或 top/first 限制查询结果。\n\n> 参考：\n> \n> spring data 支持的查询主语关键词\n> \n> spring data 支持的查询谓语关键词\n\n\n# 创建 repository 实例\n\n\n# 自定义 repository 实现\n\n\n# spring data 扩展\n\n\n# 参考资料\n\n * redis 官网\n * redis github\n * spring-data-redis github\n * spring data redis 官方文档\n * spring data 官方示例',charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Spring 访问 MongoDB",frontmatter:{title:"Spring 访问 MongoDB",date:"2018-12-15T17:29:36.000Z",order:22,categories:["Java","框架","Spring","Spring数据"],tags:["Java","框架","Spring","SpringBoot","MongoDB"],permalink:"/pages/db2a41/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/02.Spring%E6%95%B0%E6%8D%AE/22.Spring%E8%AE%BF%E9%97%AEMongoDB.html",relativePath:"01.Java/13.框架/01.Spring/02.Spring数据/22.Spring访问MongoDB.md",key:"v-029db6b7",path:"/pages/db2a41/",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:24},{level:2,title:"Spring Boot 快速入门",slug:"spring-boot-快速入门",normalizedTitle:"spring boot 快速入门",charIndex:440},{level:3,title:"引入依赖",slug:"引入依赖",normalizedTitle:"引入依赖",charIndex:461},{level:3,title:"数据源配置",slug:"数据源配置",normalizedTitle:"数据源配置",charIndex:623},{level:3,title:"定义实体",slug:"定义实体",normalizedTitle:"定义实体",charIndex:813},{level:3,title:"创建 Repository",slug:"创建-repository",normalizedTitle:"创建 repository",charIndex:1442},{level:3,title:"创建 Application",slug:"创建-application",normalizedTitle:"创建 application",charIndex:1952},{level:2,title:"示例源码",slug:"示例源码",normalizedTitle:"示例源码",charIndex:4240},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:4290}],headersStr:"简介 Spring Boot 快速入门 引入依赖 数据源配置 定义实体 创建 Repository 创建 Application 示例源码 参考资料",content:'# Spring 访问 MongoDB\n\n\n# 简介\n\nMongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。MongoDB 将数据存储为一个文档，数据结构由键值对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。\n\n在 Spring 中，spring-data-mongodb 项目对访问 MongoDB 进行了 API 封装，提供了便捷的访问方式。 Spring Data MongoDB 的核心是一个以 POJO 为中心的模型，用于与 MongoDB DBCollection 交互并轻松编写 Repository 样式的数据访问层。\n\nspring-boot 项目中的子模块 spring-boot-starter-data-mongodb 基于 spring-data-mongodb 项目，做了二次封装，大大简化了 MongoDB 的相关配置。\n\n\n# Spring Boot 快速入门\n\n\n# 引入依赖\n\n在 pom.xml 中引入依赖：\n\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-data-mongodb</artifactId>\n</dependency>\n\n\n\n# 数据源配置\n\nspring.data.mongodb.host = localhost\nspring.data.mongodb.port = 27017\nspring.data.mongodb.database = test\nspring.data.mongodb.username = root\nspring.data.mongodb.password = root\n\n\n\n# 定义实体\n\n定义一个具有三个属性的 Customer 类：id、firstName 和 lastName\n\nimport org.springframework.data.annotation.Id;\n\npublic class Customer {\n\n    @Id\n    public String id;\n\n    public String firstName;\n\n    public String lastName;\n\n    public Customer(String firstName, String lastName) {\n        this.firstName = firstName;\n        this.lastName = lastName;\n    }\n\n    @Override\n    public String toString() {\n        return String.format(\n            "Customer[id=%s, firstName=\'%s\', lastName=\'%s\']",\n            id, firstName, lastName);\n    }\n\n}\n\n\nspring-data-mongodb 会将 Customer 类映射到一个名为 customer 的集合中。如果要更改集合的名称，可以在类上使用 @Document 注解。\n\n\n# 创建 Repository\n\nspring-data-mongodb 继承了 Spring Data Commons 项目的能力，所以可以使用其通用 API——Repository。\n\n先定义一个 CustomerRepository 类，继承 MongoRepository 接口，并指定其泛型参数：Customer 和 String。MongoRepository 接口支持多种操作，包括 CRUD 和分页查询。在下面的例子中，定义了两个查询方法：\n\nimport java.util.List;\n\nimport org.springframework.data.mongodb.repository.MongoRepository;\n\npublic interface CustomerRepository extends MongoRepository<Customer, String> {\n\n    Customer findByFirstName(String firstName);\n    List<Customer> findByLastName(String lastName);\n\n}\n\n\n\n# 创建 Application\n\n创建一个 Spring Boot 的启动类 Application，并在启动的 main 方法中使用 CustomerRepository 实例访问 MongoDB。\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.CommandLineRunner;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class DataMongodbApplication implements CommandLineRunner {\n\n    @Autowired\n    private CustomerRepository repository;\n\n    public static void main(String[] args) {\n        SpringApplication.run(DataMongodbApplication.class, args);\n    }\n\n    @Override\n    public void run(String... args) {\n\n        repository.deleteAll();\n\n        // save a couple of customers\n        repository.save(new Customer("Alice", "Smith"));\n        repository.save(new Customer("Bob", "Smith"));\n\n        // fetch all customers\n        System.out.println("Customers found with findAll():");\n        System.out.println("-------------------------------");\n        for (Customer customer : repository.findAll()) {\n            System.out.println(customer);\n        }\n        System.out.println();\n\n        // fetch an individual customer\n        System.out.println("Customer found with findByFirstName(\'Alice\'):");\n        System.out.println("--------------------------------");\n        System.out.println(repository.findByFirstName("Alice"));\n\n        System.out.println("Customers found with findByLastName(\'Smith\'):");\n        System.out.println("--------------------------------");\n        for (Customer customer : repository.findByLastName("Smith")) {\n            System.out.println(customer);\n        }\n    }\n\n}\n\n\n运行 DataMongodbApplication 的 main 方法后，输出类似如下类容：\n\nCustomers found with findAll():\n-------------------------------\nCustomer(id=63d6157b265e7c5e48077f63, firstName=Alice, lastName=Smith)\nCustomer(id=63d6157b265e7c5e48077f64, firstName=Bob, lastName=Smith)\n\nCustomer found with findByFirstName(\'Alice\'):\n--------------------------------\nCustomer(id=63d6157b265e7c5e48077f63, firstName=Alice, lastName=Smith)\nCustomers found with findByLastName(\'Smith\'):\n--------------------------------\nCustomer(id=63d6157b265e7c5e48077f63, firstName=Alice, lastName=Smith)\nCustomer(id=63d6157b265e7c5e48077f64, firstName=Bob, lastName=Smith)\n\n\n\n# 示例源码\n\n更多 Spring 访问 MongoDB 示例请参考：MongoDB 示例源码\n\n\n# 参考资料\n\n * MongoDB 官网\n * MongoDB Github\n * MongoDB 官方免费教程\n * spring-data-mongodb Github\n * Spring Data MongoDB 官方文档\n * Spring Data 官方示例\n * Accessing Data with MongoDB\n * Accessing MongoDB Data with REST',normalizedContent:'# spring 访问 mongodb\n\n\n# 简介\n\nmongodb 是一个基于分布式文件存储的数据库。由 c++ 语言编写。旨在为 web 应用提供可扩展的高性能数据存储解决方案。mongodb 将数据存储为一个文档，数据结构由键值对组成。mongodb 文档类似于 json 对象。字段值可以包含其他文档，数组及文档数组。\n\n在 spring 中，spring-data-mongodb 项目对访问 mongodb 进行了 api 封装，提供了便捷的访问方式。 spring data mongodb 的核心是一个以 pojo 为中心的模型，用于与 mongodb dbcollection 交互并轻松编写 repository 样式的数据访问层。\n\nspring-boot 项目中的子模块 spring-boot-starter-data-mongodb 基于 spring-data-mongodb 项目，做了二次封装，大大简化了 mongodb 的相关配置。\n\n\n# spring boot 快速入门\n\n\n# 引入依赖\n\n在 pom.xml 中引入依赖：\n\n<dependency>\n  <groupid>org.springframework.boot</groupid>\n  <artifactid>spring-boot-starter-data-mongodb</artifactid>\n</dependency>\n\n\n\n# 数据源配置\n\nspring.data.mongodb.host = localhost\nspring.data.mongodb.port = 27017\nspring.data.mongodb.database = test\nspring.data.mongodb.username = root\nspring.data.mongodb.password = root\n\n\n\n# 定义实体\n\n定义一个具有三个属性的 customer 类：id、firstname 和 lastname\n\nimport org.springframework.data.annotation.id;\n\npublic class customer {\n\n    @id\n    public string id;\n\n    public string firstname;\n\n    public string lastname;\n\n    public customer(string firstname, string lastname) {\n        this.firstname = firstname;\n        this.lastname = lastname;\n    }\n\n    @override\n    public string tostring() {\n        return string.format(\n            "customer[id=%s, firstname=\'%s\', lastname=\'%s\']",\n            id, firstname, lastname);\n    }\n\n}\n\n\nspring-data-mongodb 会将 customer 类映射到一个名为 customer 的集合中。如果要更改集合的名称，可以在类上使用 @document 注解。\n\n\n# 创建 repository\n\nspring-data-mongodb 继承了 spring data commons 项目的能力，所以可以使用其通用 api——repository。\n\n先定义一个 customerrepository 类，继承 mongorepository 接口，并指定其泛型参数：customer 和 string。mongorepository 接口支持多种操作，包括 crud 和分页查询。在下面的例子中，定义了两个查询方法：\n\nimport java.util.list;\n\nimport org.springframework.data.mongodb.repository.mongorepository;\n\npublic interface customerrepository extends mongorepository<customer, string> {\n\n    customer findbyfirstname(string firstname);\n    list<customer> findbylastname(string lastname);\n\n}\n\n\n\n# 创建 application\n\n创建一个 spring boot 的启动类 application，并在启动的 main 方法中使用 customerrepository 实例访问 mongodb。\n\nimport org.springframework.beans.factory.annotation.autowired;\nimport org.springframework.boot.commandlinerunner;\nimport org.springframework.boot.springapplication;\nimport org.springframework.boot.autoconfigure.springbootapplication;\n\n@springbootapplication\npublic class datamongodbapplication implements commandlinerunner {\n\n    @autowired\n    private customerrepository repository;\n\n    public static void main(string[] args) {\n        springapplication.run(datamongodbapplication.class, args);\n    }\n\n    @override\n    public void run(string... args) {\n\n        repository.deleteall();\n\n        // save a couple of customers\n        repository.save(new customer("alice", "smith"));\n        repository.save(new customer("bob", "smith"));\n\n        // fetch all customers\n        system.out.println("customers found with findall():");\n        system.out.println("-------------------------------");\n        for (customer customer : repository.findall()) {\n            system.out.println(customer);\n        }\n        system.out.println();\n\n        // fetch an individual customer\n        system.out.println("customer found with findbyfirstname(\'alice\'):");\n        system.out.println("--------------------------------");\n        system.out.println(repository.findbyfirstname("alice"));\n\n        system.out.println("customers found with findbylastname(\'smith\'):");\n        system.out.println("--------------------------------");\n        for (customer customer : repository.findbylastname("smith")) {\n            system.out.println(customer);\n        }\n    }\n\n}\n\n\n运行 datamongodbapplication 的 main 方法后，输出类似如下类容：\n\ncustomers found with findall():\n-------------------------------\ncustomer(id=63d6157b265e7c5e48077f63, firstname=alice, lastname=smith)\ncustomer(id=63d6157b265e7c5e48077f64, firstname=bob, lastname=smith)\n\ncustomer found with findbyfirstname(\'alice\'):\n--------------------------------\ncustomer(id=63d6157b265e7c5e48077f63, firstname=alice, lastname=smith)\ncustomers found with findbylastname(\'smith\'):\n--------------------------------\ncustomer(id=63d6157b265e7c5e48077f63, firstname=alice, lastname=smith)\ncustomer(id=63d6157b265e7c5e48077f64, firstname=bob, lastname=smith)\n\n\n\n# 示例源码\n\n更多 spring 访问 mongodb 示例请参考：mongodb 示例源码\n\n\n# 参考资料\n\n * mongodb 官网\n * mongodb github\n * mongodb 官方免费教程\n * spring-data-mongodb github\n * spring data mongodb 官方文档\n * spring data 官方示例\n * accessing data with mongodb\n * accessing mongodb data with rest',charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Spring 访问 Redis",frontmatter:{title:"Spring 访问 Redis",date:"2023-01-31T20:54:42.000Z",order:21,categories:["Java","框架","Spring","Spring数据"],tags:["Java","框架","Spring","SpringBoot","Redis"],permalink:"/pages/65e4a2/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/02.Spring%E6%95%B0%E6%8D%AE/21.Spring%E8%AE%BF%E9%97%AERedis.html",relativePath:"01.Java/13.框架/01.Spring/02.Spring数据/21.Spring访问Redis.md",key:"v-1b892327",path:"/pages/65e4a2/",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:22},{level:2,title:"Spring Boot 快速入门",slug:"spring-boot-快速入门",normalizedTitle:"spring boot 快速入门",charIndex:259},{level:3,title:"引入依赖",slug:"引入依赖",normalizedTitle:"引入依赖",charIndex:280},{level:3,title:"数据源配置",slug:"数据源配置",normalizedTitle:"数据源配置",charIndex:440},{level:3,title:"定义实体",slug:"定义实体",normalizedTitle:"定义实体",charIndex:557},{level:3,title:"定义 CRUD 接口",slug:"定义-crud-接口",normalizedTitle:"定义 crud 接口",charIndex:1010},{level:3,title:"创建 CRUD 接口实现",slug:"创建-crud-接口实现",normalizedTitle:"创建 crud 接口实现",charIndex:1211},{level:3,title:"创建 Application",slug:"创建-application",normalizedTitle:"创建 application",charIndex:2299},{level:3,title:"测试",slug:"测试",normalizedTitle:"测试",charIndex:4653},{level:2,title:"示例源码",slug:"示例源码",normalizedTitle:"示例源码",charIndex:5614},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:5660}],headersStr:"简介 Spring Boot 快速入门 引入依赖 数据源配置 定义实体 定义 CRUD 接口 创建 CRUD 接口实现 创建 Application 测试 示例源码 参考资料",content:'# Spring 访问 Redis\n\n\n# 简介\n\nRedis 是一个被数百万开发人员用作数据库、缓存、流引擎和消息代理的开源内存数据库。\n\n在 Spring 中，spring-data-redis 项目对访问 Redis 进行了 API 封装，提供了便捷的访问方式。 spring-data-redis\n\nspring-boot 项目中的子模块 spring-boot-starter-data-redis 基于 spring-data-redis 项目，做了二次封装，大大简化了 Redis 的相关配置。\n\n\n# Spring Boot 快速入门\n\n\n# 引入依赖\n\n在 pom.xml 中引入依赖：\n\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-data-redis</artifactId>\n</dependency>\n\n\n\n# 数据源配置\n\nspring.redis.database = 0\nspring.redis.host = localhost\nspring.redis.port = 6379\nspring.redis.password =\n\n\n\n# 定义实体\n\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\nimport lombok.ToString;\n\nimport java.io.Serializable;\n\n@Data\n@ToString\n@NoArgsConstructor\n@AllArgsConstructor\npublic class User implements Serializable {\n\n    private static final long serialVersionUID = 4142994984277644695L;\n\n    private Long id;\n    private String name;\n    private Integer age;\n    private String address;\n    private String email;\n\n}\n\n\n\n# 定义 CRUD 接口\n\nimport java.util.Map;\n\npublic interface UserService {\n\n    void batchSetUsers(Map<String, User> users);\n\n    long count();\n\n    User getUser(Long id);\n\n    void setUser(User user);\n\n}\n\n\n\n# 创建 CRUD 接口实现\n\n\nimport cn.hutool.core.bean.BeanUtil;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.stereotype.Service;\n\nimport java.util.Map;\n\n@Service\npublic class UserServiceImpl implements UserService {\n\n    public static final String DEFAULT_KEY = "spring:tutorial:user";\n\n    private final RedisTemplate<String, Object> redisTemplate;\n\n    public UserServiceImpl(RedisTemplate<String, Object> redisTemplate) {\n        this.redisTemplate = redisTemplate;\n    }\n\n    @Override\n    public void batchSetUsers(Map<String, User> users) {\n        redisTemplate.opsForHash().putAll(DEFAULT_KEY, users);\n    }\n\n    @Override\n    public long count() {\n        return redisTemplate.opsForHash().size(DEFAULT_KEY);\n    }\n\n    @Override\n    public User getUser(Long id) {\n        Object obj = redisTemplate.opsForHash().get(DEFAULT_KEY, id.toString());\n        return BeanUtil.toBean(obj, User.class);\n    }\n\n    @Override\n    public void setUser(User user) {\n        redisTemplate.opsForHash().put(DEFAULT_KEY, user.getId().toString(), user);\n    }\n\n}\n\n\n\n# 创建 Application\n\n创建 Application，实例化一个 RedisTemplate 对象。\n\nimport com.fasterxml.jackson.annotation.JsonAutoDetect;\nimport com.fasterxml.jackson.annotation.PropertyAccessor;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Primary;\nimport org.springframework.data.redis.connection.RedisConnectionFactory;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;\nimport org.springframework.data.redis.serializer.StringRedisSerializer;\n\n@Slf4j\n@SpringBootApplication\npublic class RedisQuickstartApplication {\n\n    @Autowired\n    private ObjectMapper objectMapper;\n\n    @Bean\n    @Primary\n    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory factory) {\n\n        // 指定要序列化的域，field,get和set,以及修饰符范围，ANY是都有包括private和public\n        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);\n        // // 指定序列化输入的类型，类必须是非final修饰的，final修饰的类，比如String,Integer等会跑出异常\n        // objectMapper.activateDefaultTyping(new DefaultBaseTypeLimitingValidator(),\n        //     ObjectMapper.DefaultTyping.NON_FINAL);\n\n        // 使用Jackson2JsonRedisSerializer来序列化和反序列化redis的value值（默认使用JDK的序列化方式）\n        Jackson2JsonRedisSerializer<Object> serializer = new Jackson2JsonRedisSerializer<>(Object.class);\n        serializer.setObjectMapper(objectMapper);\n\n        RedisTemplate<String, Object> template = new RedisTemplate<>();\n        // 配置连接工厂\n        template.setConnectionFactory(factory);\n        // 值采用json序列化\n        template.setValueSerializer(serializer);\n        // 使用StringRedisSerializer来序列化和反序列化redis的key值\n        template.setKeySerializer(new StringRedisSerializer());\n        // 设置hash key 和value序列化模式\n        template.setHashKeySerializer(new StringRedisSerializer());\n        template.setHashValueSerializer(serializer);\n        template.afterPropertiesSet();\n\n        return template;\n    }\n\n    public static void main(String[] args) {\n        SpringApplication.run(RedisQuickstartApplication.class, args);\n    }\n\n}\n\n\n\n# 测试\n\n@Slf4j\n@SpringBootTest(classes = { RedisQuickstartApplication.class })\npublic class RedisQuickstartTests {\n\n    @Autowired\n    private UserService userService;\n\n    @Test\n    public void test() {\n        final long SIZE = 1000L;\n        Map<String, User> map = new HashMap<>();\n        for (long i = 0; i < SIZE; i++) {\n            User user = new User(i, RandomUtil.randomChineseName(),\n                RandomUtil.randomInt(1, 100),\n                RandomUtil.randomEnum(Location.class).name(),\n                RandomUtil.randomEmail());\n            map.put(String.valueOf(i), user);\n        }\n        userService.batchSetUsers(map);\n        long count = userService.count();\n        Assertions.assertThat(count).isEqualTo(SIZE);\n\n        for (int i = 0; i < 100; i++) {\n            long id = RandomUtil.randomLong(0, 1000);\n            User user = userService.getUser(id);\n            log.info("user-{}: {}", id, user.toString());\n        }\n    }\n\n}\n\n\n\n# 示例源码\n\n更多 Spring 访问 Redis 示例请参考：Redis 示例源码\n\n\n# 参考资料\n\n * Redis 官网\n * Redis Github\n * spring-data-redis Github\n * Spring Data Redis 官方文档\n * Spring Data 官方示例',normalizedContent:'# spring 访问 redis\n\n\n# 简介\n\nredis 是一个被数百万开发人员用作数据库、缓存、流引擎和消息代理的开源内存数据库。\n\n在 spring 中，spring-data-redis 项目对访问 redis 进行了 api 封装，提供了便捷的访问方式。 spring-data-redis\n\nspring-boot 项目中的子模块 spring-boot-starter-data-redis 基于 spring-data-redis 项目，做了二次封装，大大简化了 redis 的相关配置。\n\n\n# spring boot 快速入门\n\n\n# 引入依赖\n\n在 pom.xml 中引入依赖：\n\n<dependency>\n  <groupid>org.springframework.boot</groupid>\n  <artifactid>spring-boot-starter-data-redis</artifactid>\n</dependency>\n\n\n\n# 数据源配置\n\nspring.redis.database = 0\nspring.redis.host = localhost\nspring.redis.port = 6379\nspring.redis.password =\n\n\n\n# 定义实体\n\nimport lombok.allargsconstructor;\nimport lombok.data;\nimport lombok.noargsconstructor;\nimport lombok.tostring;\n\nimport java.io.serializable;\n\n@data\n@tostring\n@noargsconstructor\n@allargsconstructor\npublic class user implements serializable {\n\n    private static final long serialversionuid = 4142994984277644695l;\n\n    private long id;\n    private string name;\n    private integer age;\n    private string address;\n    private string email;\n\n}\n\n\n\n# 定义 crud 接口\n\nimport java.util.map;\n\npublic interface userservice {\n\n    void batchsetusers(map<string, user> users);\n\n    long count();\n\n    user getuser(long id);\n\n    void setuser(user user);\n\n}\n\n\n\n# 创建 crud 接口实现\n\n\nimport cn.hutool.core.bean.beanutil;\nimport org.springframework.data.redis.core.redistemplate;\nimport org.springframework.stereotype.service;\n\nimport java.util.map;\n\n@service\npublic class userserviceimpl implements userservice {\n\n    public static final string default_key = "spring:tutorial:user";\n\n    private final redistemplate<string, object> redistemplate;\n\n    public userserviceimpl(redistemplate<string, object> redistemplate) {\n        this.redistemplate = redistemplate;\n    }\n\n    @override\n    public void batchsetusers(map<string, user> users) {\n        redistemplate.opsforhash().putall(default_key, users);\n    }\n\n    @override\n    public long count() {\n        return redistemplate.opsforhash().size(default_key);\n    }\n\n    @override\n    public user getuser(long id) {\n        object obj = redistemplate.opsforhash().get(default_key, id.tostring());\n        return beanutil.tobean(obj, user.class);\n    }\n\n    @override\n    public void setuser(user user) {\n        redistemplate.opsforhash().put(default_key, user.getid().tostring(), user);\n    }\n\n}\n\n\n\n# 创建 application\n\n创建 application，实例化一个 redistemplate 对象。\n\nimport com.fasterxml.jackson.annotation.jsonautodetect;\nimport com.fasterxml.jackson.annotation.propertyaccessor;\nimport com.fasterxml.jackson.databind.objectmapper;\nimport lombok.extern.slf4j.slf4j;\nimport org.springframework.beans.factory.annotation.autowired;\nimport org.springframework.boot.springapplication;\nimport org.springframework.boot.autoconfigure.springbootapplication;\nimport org.springframework.context.annotation.bean;\nimport org.springframework.context.annotation.primary;\nimport org.springframework.data.redis.connection.redisconnectionfactory;\nimport org.springframework.data.redis.core.redistemplate;\nimport org.springframework.data.redis.serializer.jackson2jsonredisserializer;\nimport org.springframework.data.redis.serializer.stringredisserializer;\n\n@slf4j\n@springbootapplication\npublic class redisquickstartapplication {\n\n    @autowired\n    private objectmapper objectmapper;\n\n    @bean\n    @primary\n    public redistemplate<string, object> redistemplate(redisconnectionfactory factory) {\n\n        // 指定要序列化的域，field,get和set,以及修饰符范围，any是都有包括private和public\n        objectmapper.setvisibility(propertyaccessor.all, jsonautodetect.visibility.any);\n        // // 指定序列化输入的类型，类必须是非final修饰的，final修饰的类，比如string,integer等会跑出异常\n        // objectmapper.activatedefaulttyping(new defaultbasetypelimitingvalidator(),\n        //     objectmapper.defaulttyping.non_final);\n\n        // 使用jackson2jsonredisserializer来序列化和反序列化redis的value值（默认使用jdk的序列化方式）\n        jackson2jsonredisserializer<object> serializer = new jackson2jsonredisserializer<>(object.class);\n        serializer.setobjectmapper(objectmapper);\n\n        redistemplate<string, object> template = new redistemplate<>();\n        // 配置连接工厂\n        template.setconnectionfactory(factory);\n        // 值采用json序列化\n        template.setvalueserializer(serializer);\n        // 使用stringredisserializer来序列化和反序列化redis的key值\n        template.setkeyserializer(new stringredisserializer());\n        // 设置hash key 和value序列化模式\n        template.sethashkeyserializer(new stringredisserializer());\n        template.sethashvalueserializer(serializer);\n        template.afterpropertiesset();\n\n        return template;\n    }\n\n    public static void main(string[] args) {\n        springapplication.run(redisquickstartapplication.class, args);\n    }\n\n}\n\n\n\n# 测试\n\n@slf4j\n@springboottest(classes = { redisquickstartapplication.class })\npublic class redisquickstarttests {\n\n    @autowired\n    private userservice userservice;\n\n    @test\n    public void test() {\n        final long size = 1000l;\n        map<string, user> map = new hashmap<>();\n        for (long i = 0; i < size; i++) {\n            user user = new user(i, randomutil.randomchinesename(),\n                randomutil.randomint(1, 100),\n                randomutil.randomenum(location.class).name(),\n                randomutil.randomemail());\n            map.put(string.valueof(i), user);\n        }\n        userservice.batchsetusers(map);\n        long count = userservice.count();\n        assertions.assertthat(count).isequalto(size);\n\n        for (int i = 0; i < 100; i++) {\n            long id = randomutil.randomlong(0, 1000);\n            user user = userservice.getuser(id);\n            log.info("user-{}: {}", id, user.tostring());\n        }\n    }\n\n}\n\n\n\n# 示例源码\n\n更多 spring 访问 redis 示例请参考：redis 示例源码\n\n\n# 参考资料\n\n * redis 官网\n * redis github\n * spring-data-redis github\n * spring data redis 官方文档\n * spring data 官方示例',charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Spring 访问 Elasticsearch",frontmatter:{title:"Spring 访问 Elasticsearch",date:"2018-12-25T14:06:36.000Z",order:23,categories:["Java","框架","Spring","Spring数据"],tags:["Java","框架","Spring","SpringBoot","Elasticsearch"],permalink:"/pages/fac14c/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/02.Spring%E6%95%B0%E6%8D%AE/23.Spring%E8%AE%BF%E9%97%AEElasticsearch.html",relativePath:"01.Java/13.框架/01.Spring/02.Spring数据/23.Spring访问Elasticsearch.md",key:"v-577422c2",path:"/pages/fac14c/",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:30},{level:3,title:"通过 REST 客户端连接 Elasticsearch",slug:"通过-rest-客户端连接-elasticsearch",normalizedTitle:"通过 rest 客户端连接 elasticsearch",charIndex:72},{level:3,title:"通过 Jest 连接 Elasticsearch",slug:"通过-jest-连接-elasticsearch",normalizedTitle:"通过 jest 连接 elasticsearch",charIndex:660},{level:3,title:"通过 Spring Data 访问 Elasticsearch",slug:"通过-spring-data-访问-elasticsearch",normalizedTitle:"通过 spring data 访问 elasticsearch",charIndex:1321},{level:3,title:"Elasticsearch Repositories",slug:"elasticsearch-repositories",normalizedTitle:"elasticsearch repositories",charIndex:1852},{level:2,title:"源码",slug:"源码",normalizedTitle:"源码",charIndex:2013},{level:2,title:"版本",slug:"版本",normalizedTitle:"版本",charIndex:2111},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:2914}],headersStr:"简介 通过 REST 客户端连接 Elasticsearch 通过 Jest 连接 Elasticsearch 通过 Spring Data 访问 Elasticsearch Elasticsearch Repositories 源码 版本 参考资料",content:"# Spring 访问 Elasticsearch\n\n\n# 简介\n\nElasticsearch 是一个开源的、分布式的搜索和分析引擎。\n\n\n# 通过 REST 客户端连接 Elasticsearch\n\n如果在 classpath 路径下存在 org.elasticsearch.client:elasticsearch-rest-client jar 包，Spring Boot 会自动配置并注册一个 RestClient Bean，它的默认访问路径为：localhost:9200。\n\n你可以使用如下方式进行定制：\n\nspring.elasticsearch.rest.uris=http://search.example.com:9200\nspring.elasticsearch.rest.username=user\nspring.elasticsearch.rest.password=secret\n\n\n您还可以注册实现任意数量的 RestClientBuilderCustomizer bean，以进行更高级的定制。要完全控制注册，请定义 RestClient bean。\n\n如果 classpath 路径有 org.elasticsearch.client：elasticsearch-rest-high-level-client jar 包，Spring Boot 将自动配置一个 RestHighLevelClient，它包装任何现有的 RestClient bean，重用其 HTTP 配置。\n\n\n# 通过 Jest 连接 Elasticsearch\n\n如果 classpath 上有 Jest，你可以注入一个自动配置的 JestClient，默认情况下是 localhost:9200。您可以进一步调整客户端的配置方式，如以下示例所示：\n\nspring.elasticsearch.jest.uris=http://search.example.com:9200\nspring.elasticsearch.jest.read-timeout=10000\nspring.elasticsearch.jest.username=user\nspring.elasticsearch.jest.password=secret\n\n\n您还可以注册实现任意数量的 HttpClientConfigBuilderCustomizer bean，以进行更高级的定制。以下示例调整为其他 HTTP 设置：\n\nstatic class HttpSettingsCustomizer implements HttpClientConfigBuilderCustomizer {\n\n\t@Override\n\tpublic void customize(HttpClientConfig.Builder builder) {\n\t\tbuilder.maxTotalConnection(100).defaultMaxTotalConnectionPerRoute(5);\n\t}\n\n}\n\n\n要完全控制注册，请定义 JestClient bean。\n\n\n# 通过 Spring Data 访问 Elasticsearch\n\n要连接到 Elasticsearch，您必须提供一个或多个集群节点的地址。可以通过将 spring.data.elasticsearch.cluster-nodes 属性设置为以逗号分隔的 host:port 列表来指定地址。使用此配置，可以像任何其他 Spring bean 一样注入 ElasticsearchTemplate 或 TransportClient，如以下示例所示：\n\nspring.data.elasticsearch.cluster-nodes=localhost:9300\n@Component\npublic class MyBean {\n\n\tprivate final ElasticsearchTemplate template;\n\n\tpublic MyBean(ElasticsearchTemplate template) {\n\t\tthis.template = template;\n\t}\n\n\t// ...\n\n}\n\n\n如果你添加了自定义的 ElasticsearchTemplate 或 TransportClient @Bean ，就会替换默认的配置。\n\n\n# Elasticsearch Repositories\n\nSpring Data 包含对 Elasticsearch 的 repository 支持。基本原则是根据方法名称自动为您构建查询。\n\n事实上，Spring Data JPA 和 Spring Data Elasticsearch 共享相同的通用基础架构。\n\n\n# 源码\n\n完整示例：源码\n\n使用方法：\n\nmvn clean package\ncd target\njava -jar spring-boot-data-elasticsearch.jar\n\n\n\n# 版本\n\nSpring 和 Elasticsearch 匹配版本：\n\nSPRING DATA ELASTICSEARCH   ELASTICSEARCH   SPRING FRAMEWORK   SPRING BOOT\n5.0.x                       8.5.3           6.0.x              3.0.x\n4.4.x                       7.17.3          5.3.x              2.7.x\n4.3.x                       7.15.2          5.3.x              2.6.x\n4.2.x[1]                    7.12.0          5.3.x              2.5.x\n4.1.x[1]                    7.9.3           5.3.2              2.4.x\n4.0.x[1]                    7.6.2           5.2.12             2.3.x\n3.2.x[1]                    6.8.12          5.2.12             2.2.x\n3.1.x[1]                    6.2.2           5.1.19             2.1.x\n3.0.x[1]                    5.5.0           5.0.13             2.0.x\n2.1.x[1]                    2.4.0           4.3.25             1.5.x\n\n\n# 参考资料\n\n * 官方\n   * Elasticsearch 官网\n   * Elasticsearch Github\n   * Elasticsearch 官方文档\n   * Elasticsearch: The Definitive Guide - ElasticSearch 官方学习资料\n * Spring Boot 官方文档之 boot-features-elasticsearch\n * Spring Data Elasticsearch Github\n * Spring Data Elasticsearch 官方文档",normalizedContent:"# spring 访问 elasticsearch\n\n\n# 简介\n\nelasticsearch 是一个开源的、分布式的搜索和分析引擎。\n\n\n# 通过 rest 客户端连接 elasticsearch\n\n如果在 classpath 路径下存在 org.elasticsearch.client:elasticsearch-rest-client jar 包，spring boot 会自动配置并注册一个 restclient bean，它的默认访问路径为：localhost:9200。\n\n你可以使用如下方式进行定制：\n\nspring.elasticsearch.rest.uris=http://search.example.com:9200\nspring.elasticsearch.rest.username=user\nspring.elasticsearch.rest.password=secret\n\n\n您还可以注册实现任意数量的 restclientbuildercustomizer bean，以进行更高级的定制。要完全控制注册，请定义 restclient bean。\n\n如果 classpath 路径有 org.elasticsearch.client：elasticsearch-rest-high-level-client jar 包，spring boot 将自动配置一个 resthighlevelclient，它包装任何现有的 restclient bean，重用其 http 配置。\n\n\n# 通过 jest 连接 elasticsearch\n\n如果 classpath 上有 jest，你可以注入一个自动配置的 jestclient，默认情况下是 localhost:9200。您可以进一步调整客户端的配置方式，如以下示例所示：\n\nspring.elasticsearch.jest.uris=http://search.example.com:9200\nspring.elasticsearch.jest.read-timeout=10000\nspring.elasticsearch.jest.username=user\nspring.elasticsearch.jest.password=secret\n\n\n您还可以注册实现任意数量的 httpclientconfigbuildercustomizer bean，以进行更高级的定制。以下示例调整为其他 http 设置：\n\nstatic class httpsettingscustomizer implements httpclientconfigbuildercustomizer {\n\n\t@override\n\tpublic void customize(httpclientconfig.builder builder) {\n\t\tbuilder.maxtotalconnection(100).defaultmaxtotalconnectionperroute(5);\n\t}\n\n}\n\n\n要完全控制注册，请定义 jestclient bean。\n\n\n# 通过 spring data 访问 elasticsearch\n\n要连接到 elasticsearch，您必须提供一个或多个集群节点的地址。可以通过将 spring.data.elasticsearch.cluster-nodes 属性设置为以逗号分隔的 host:port 列表来指定地址。使用此配置，可以像任何其他 spring bean 一样注入 elasticsearchtemplate 或 transportclient，如以下示例所示：\n\nspring.data.elasticsearch.cluster-nodes=localhost:9300\n@component\npublic class mybean {\n\n\tprivate final elasticsearchtemplate template;\n\n\tpublic mybean(elasticsearchtemplate template) {\n\t\tthis.template = template;\n\t}\n\n\t// ...\n\n}\n\n\n如果你添加了自定义的 elasticsearchtemplate 或 transportclient @bean ，就会替换默认的配置。\n\n\n# elasticsearch repositories\n\nspring data 包含对 elasticsearch 的 repository 支持。基本原则是根据方法名称自动为您构建查询。\n\n事实上，spring data jpa 和 spring data elasticsearch 共享相同的通用基础架构。\n\n\n# 源码\n\n完整示例：源码\n\n使用方法：\n\nmvn clean package\ncd target\njava -jar spring-boot-data-elasticsearch.jar\n\n\n\n# 版本\n\nspring 和 elasticsearch 匹配版本：\n\nspring data elasticsearch   elasticsearch   spring framework   spring boot\n5.0.x                       8.5.3           6.0.x              3.0.x\n4.4.x                       7.17.3          5.3.x              2.7.x\n4.3.x                       7.15.2          5.3.x              2.6.x\n4.2.x[1]                    7.12.0          5.3.x              2.5.x\n4.1.x[1]                    7.9.3           5.3.2              2.4.x\n4.0.x[1]                    7.6.2           5.2.12             2.3.x\n3.2.x[1]                    6.8.12          5.2.12             2.2.x\n3.1.x[1]                    6.2.2           5.1.19             2.1.x\n3.0.x[1]                    5.5.0           5.0.13             2.0.x\n2.1.x[1]                    2.4.0           4.3.25             1.5.x\n\n\n# 参考资料\n\n * 官方\n   * elasticsearch 官网\n   * elasticsearch github\n   * elasticsearch 官方文档\n   * elasticsearch: the definitive guide - elasticsearch 官方学习资料\n * spring boot 官方文档之 boot-features-elasticsearch\n * spring data elasticsearch github\n * spring data elasticsearch 官方文档",charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"spring-mvc",frontmatter:{title:"spring-mvc",date:"2017-11-08T16:53:27.000Z",order:1,categories:["Java","框架","Spring","SpringWeb"],tags:["Java","框架","Spring","Web"],permalink:"/pages/65351b/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/03.SpringWeb/01.SpringWebMvc.html",relativePath:"01.Java/13.框架/01.Spring/03.SpringWeb/01.SpringWebMvc.md",key:"v-033238fd",path:"/pages/65351b/",headers:[{level:2,title:"SpringMVC 工作流程描述",slug:"springmvc-工作流程描述",normalizedTitle:"springmvc 工作流程描述",charIndex:19}],headersStr:"SpringMVC 工作流程描述",content:"# SpringMVC 简介\n\n\n# SpringMVC 工作流程描述\n\nSpring MVC 的工作流程可以用一幅图来说明：\n\n\n\n 1. 向服务器发送 HTTP 请求，请求被前端控制器 DispatcherServlet 捕获。\n 2. DispatcherServlet 根据 <servlet-name>-servlet.xml 中的配置对请求的 URL 进行解析，得到请求资源标识符（URI）。然后根据该 URI，调用 HandlerMapping 获得该 Handler 配置的所有相关的对象（包括 Handler 对象以及 Handler 对象对应的拦截器），最后以HandlerExecutionChain 对象的形式返回。\n 3. DispatcherServlet 根据获得的Handler，选择一个合适的 HandlerAdapter。（附注：如果成功获得HandlerAdapter后，此时将开始执行拦截器的 preHandler(...)方法）。\n 4. 提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)。 在填充Handler的入参过程中，根据你的配置，Spring 将帮你做一些额外的工作：\n    * HttpMessageConveter： 将请求消息（如 Json、xml 等数据）转换成一个对象，将对象转换为指定的响应信息。\n    * 数据转换：对请求消息进行数据转换。如String转换成Integer、Double等。\n    * 数据根式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等。\n    * 数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中。\n 5. Handler(Controller)执行完成后，向 DispatcherServlet 返回一个 ModelAndView 对象；\n 6. 根据返回的ModelAndView，选择一个适合的 ViewResolver（必须是已经注册到 Spring 容器中的ViewResolver)返回给DispatcherServlet。\n 7. ViewResolver 结合Model和View，来渲染视图。\n 8. 视图负责将渲染结果返回给客户端。",normalizedContent:"# springmvc 简介\n\n\n# springmvc 工作流程描述\n\nspring mvc 的工作流程可以用一幅图来说明：\n\n\n\n 1. 向服务器发送 http 请求，请求被前端控制器 dispatcherservlet 捕获。\n 2. dispatcherservlet 根据 <servlet-name>-servlet.xml 中的配置对请求的 url 进行解析，得到请求资源标识符（uri）。然后根据该 uri，调用 handlermapping 获得该 handler 配置的所有相关的对象（包括 handler 对象以及 handler 对象对应的拦截器），最后以handlerexecutionchain 对象的形式返回。\n 3. dispatcherservlet 根据获得的handler，选择一个合适的 handleradapter。（附注：如果成功获得handleradapter后，此时将开始执行拦截器的 prehandler(...)方法）。\n 4. 提取request中的模型数据，填充handler入参，开始执行handler（controller)。 在填充handler的入参过程中，根据你的配置，spring 将帮你做一些额外的工作：\n    * httpmessageconveter： 将请求消息（如 json、xml 等数据）转换成一个对象，将对象转换为指定的响应信息。\n    * 数据转换：对请求消息进行数据转换。如string转换成integer、double等。\n    * 数据根式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等。\n    * 数据验证： 验证数据的有效性（长度、格式等），验证结果存储到bindingresult或error中。\n 5. handler(controller)执行完成后，向 dispatcherservlet 返回一个 modelandview 对象；\n 6. 根据返回的modelandview，选择一个适合的 viewresolver（必须是已经注册到 spring 容器中的viewresolver)返回给dispatcherservlet。\n 7. viewresolver 结合model和view，来渲染视图。\n 8. 视图负责将渲染结果返回给客户端。",charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Spring 数据篇",frontmatter:{title:"Spring 数据篇",date:"2022-09-18T11:05:36.000Z",categories:["Java","框架","Spring","Spring数据"],tags:["Java","框架","Spring","SpringBoot","数据库"],permalink:"/pages/b912d1/",hidden:!0,index:!1},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/02.Spring%E6%95%B0%E6%8D%AE/",relativePath:"01.Java/13.框架/01.Spring/02.Spring数据/README.md",key:"v-b0144bd0",path:"/pages/b912d1/",headers:[{level:2,title:"📖 内容",slug:"📖-内容",normalizedTitle:"📖 内容",charIndex:17},{level:2,title:"💻 示例",slug:"💻-示例",normalizedTitle:"💻 示例",charIndex:178},{level:2,title:"📚 资料",slug:"📚-资料",normalizedTitle:"📚 资料",charIndex:1554},{level:2,title:"🚪 传送",slug:"🚪-传送",normalizedTitle:"🚪 传送",charIndex:1733}],headersStr:"📖 内容 💻 示例 📚 资料 🚪 传送",content:"# Spring 数据篇\n\n\n# 📖 内容\n\n * Spring 之数据源\n * Spring 之 JDBC\n * Spring 之事务\n * Spring 之 JPA\n * Spring 集成 Mybatis\n * Spring 访问 Redis\n * Spring 访问 MongoDB\n * Spring 访问 Elasticsearch\n\n\n# 💻 示例\n\n * JDBC\n   * spring-data-jdbc-basics - Spring Boot 以 JDBC 方式访问关系型数据库，通过 JdbcTemplate 执行基本的 CRUD 操作。\n   * spring-data-jdbc-druid - SpringBoot 使用 Druid 作为数据库连接池。\n   * spring-data-jdbc-multi-datasource - SpringBoot 连接多数据源示例。\n   * spring-data-jdbc-xml - Spring 以 JDBC 方式访问关系型数据库，通过 JdbcTemplate 执行基本的 CRUD 操作。\n * ORM\n   * spring-data-orm-jpa - SpringBoot 使用 JPA 作为 ORM 框架访问数据库示例。\n   * spring-data-orm-mybatis - Spring 使用 MyBatis 作为 ORM 框架访问数据库示例。\n   * spring-data-orm-mybatis-mapper - SpringBoot 使用 MyBatis + Mapper + PageHelper 作为 ORM 框架访问数据库示例。\n   * spring-data-orm-mybatis-multi-datasource - SpringBoot 连接多数据源，并使用 MyBatis Plus 作为 ORM 框架访问数据库示例。\n   * spring-data-orm-mybatis-plus - SpringBoot 使用 MyBatis Plus 作为 ORM 框架访问数据库示例。\n * Nosql\n   * spring-data-nosql-basics - Spring 访问各种 NoSQL 的示例。\n   * spring-data-nosql-mongodb - SpringBoot 访问 MongoDB 的示例。\n   * spring-data-nosql-redis - SpringBoot 访问 Redis 单节点、集群的示例。\n   * spring-data-nosql-elasticsearch - SpringBoot 访问 Elasticsearch 的示例。\n   * spring-data-nosql-hdfs - SpringBoot 访问 HDFS 的示例。\n * Cache\n   * spring-data-cache-basics - SpringBoot 默认缓存框架的示例。\n   * spring-data-cache-j2cache - SpringBoot 使用 j2cache 作为缓存框架的示例。\n   * spring-data-cache-jetcache - SpringBoot 使用 jetcache 作为缓存框架的示例。\n * 中间件\n   * spring-data-middleware-flyway - Spring 使用版本管理中间件 Flyway 示例。\n   * spring-data-middleware-sharding - Spring 使用分库分表中间件示例。\n\n\n# 📚 资料\n\n * 官方\n   * Spring 官网\n   * Spring Framework 官方文档\n   * Spring Github\n * 书籍\n   * 《Spring In Action》\n * 教程\n   * 《小马哥讲 Spring 核心编程思想》\n   * geekbang-lessons\n   * 跟我学 Spring3\n\n\n# 🚪 传送\n\n◾ 💧 钝悟的 IT 知识图谱 ◾ 🎯 我的博客 ◾",normalizedContent:"# spring 数据篇\n\n\n# 📖 内容\n\n * spring 之数据源\n * spring 之 jdbc\n * spring 之事务\n * spring 之 jpa\n * spring 集成 mybatis\n * spring 访问 redis\n * spring 访问 mongodb\n * spring 访问 elasticsearch\n\n\n# 💻 示例\n\n * jdbc\n   * spring-data-jdbc-basics - spring boot 以 jdbc 方式访问关系型数据库，通过 jdbctemplate 执行基本的 crud 操作。\n   * spring-data-jdbc-druid - springboot 使用 druid 作为数据库连接池。\n   * spring-data-jdbc-multi-datasource - springboot 连接多数据源示例。\n   * spring-data-jdbc-xml - spring 以 jdbc 方式访问关系型数据库，通过 jdbctemplate 执行基本的 crud 操作。\n * orm\n   * spring-data-orm-jpa - springboot 使用 jpa 作为 orm 框架访问数据库示例。\n   * spring-data-orm-mybatis - spring 使用 mybatis 作为 orm 框架访问数据库示例。\n   * spring-data-orm-mybatis-mapper - springboot 使用 mybatis + mapper + pagehelper 作为 orm 框架访问数据库示例。\n   * spring-data-orm-mybatis-multi-datasource - springboot 连接多数据源，并使用 mybatis plus 作为 orm 框架访问数据库示例。\n   * spring-data-orm-mybatis-plus - springboot 使用 mybatis plus 作为 orm 框架访问数据库示例。\n * nosql\n   * spring-data-nosql-basics - spring 访问各种 nosql 的示例。\n   * spring-data-nosql-mongodb - springboot 访问 mongodb 的示例。\n   * spring-data-nosql-redis - springboot 访问 redis 单节点、集群的示例。\n   * spring-data-nosql-elasticsearch - springboot 访问 elasticsearch 的示例。\n   * spring-data-nosql-hdfs - springboot 访问 hdfs 的示例。\n * cache\n   * spring-data-cache-basics - springboot 默认缓存框架的示例。\n   * spring-data-cache-j2cache - springboot 使用 j2cache 作为缓存框架的示例。\n   * spring-data-cache-jetcache - springboot 使用 jetcache 作为缓存框架的示例。\n * 中间件\n   * spring-data-middleware-flyway - spring 使用版本管理中间件 flyway 示例。\n   * spring-data-middleware-sharding - spring 使用分库分表中间件示例。\n\n\n# 📚 资料\n\n * 官方\n   * spring 官网\n   * spring framework 官方文档\n   * spring github\n * 书籍\n   * 《spring in action》\n * 教程\n   * 《小马哥讲 spring 核心编程思想》\n   * geekbang-lessons\n   * 跟我学 spring3\n\n\n# 🚪 传送\n\n◾ 💧 钝悟的 it 知识图谱 ◾ 🎯 我的博客 ◾",charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"SpringBoot 之应用 EasyUI",frontmatter:{title:"SpringBoot 之应用 EasyUI",date:"2019-01-08T17:19:34.000Z",order:21,categories:["Java","框架","Spring","SpringWeb"],tags:["Java","框架","Spring","SpringBoot","Web"],permalink:"/pages/ad0516/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/03.SpringWeb/21.SpringBoot%E4%B9%8B%E5%BA%94%E7%94%A8EasyUI.html",relativePath:"01.Java/13.框架/01.Spring/03.SpringWeb/21.SpringBoot之应用EasyUI.md",key:"v-27fc8106",path:"/pages/ad0516/",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:288},{level:3,title:"什么是 EasyUI？",slug:"什么是-easyui",normalizedTitle:"什么是 easyui？",charIndex:295},{level:2,title:"Spring Boot 整合 EasyUI",slug:"spring-boot-整合-easyui",normalizedTitle:"spring boot 整合 easyui",charIndex:549},{level:3,title:"配置",slug:"配置",normalizedTitle:"配置",charIndex:575},{level:3,title:"引入 easyui",slug:"引入-easyui",normalizedTitle:"引入 easyui",charIndex:676},{level:2,title:"实战",slug:"实战",normalizedTitle:"实战",charIndex:1583},{level:3,title:"引入 maven 依赖",slug:"引入-maven-依赖",normalizedTitle:"引入 maven 依赖",charIndex:1590},{level:3,title:"使用 JPA",slug:"使用-jpa",normalizedTitle:"使用 jpa",charIndex:2677},{level:3,title:"使用 Web",slug:"使用-web",normalizedTitle:"使用 web",charIndex:3374},{level:3,title:"使用 EasyUI",slug:"使用-easyui",normalizedTitle:"使用 easyui",charIndex:4980},{level:2,title:"完整示例",slug:"完整示例",normalizedTitle:"完整示例",charIndex:11229},{level:2,title:"引用和引申",slug:"引用和引申",normalizedTitle:"引用和引申",charIndex:11340}],headersStr:"简介 什么是 EasyUI？ Spring Boot 整合 EasyUI 配置 引入 easyui 实战 引入 maven 依赖 使用 JPA 使用 Web 使用 EasyUI 完整示例 引用和引申",content:'# SpringBoot 之应用 EasyUI\n\n> EasyUI 是一个简单的用户界面组件的集合。由于 EasyUI 已经封装好大部分 UI 基本功能，能帮用户减少大量的 js 和 css 代码。所以，EasyUI 非常适合用于开发简单的系统或原型系统。\n> \n> 本文示例使用技术点：\n> \n>  * Spring Boot：主要使用了 spring-boot-starter-web、spring-boot-starter-data-jpa\n>  * EasyUI：按需加载，并没有引入所有的 EasyUI 特性\n>  * 数据库：为了测试方便，使用 H2\n\n\n\n\n# 简介\n\n\n# 什么是 EasyUI？\n\n * easyui 是基于 jQuery、Angular.、Vue 和 React 的用户界面组件的集合。\n * easyui 提供了构建现代交互式 javascript 应用程序的基本功能。\n * 使用 easyui，您不需要编写许多 javascript 代码，通常通过编写一些 HTML 标记来定义用户界面。\n * 完整的 HTML5 网页框架。\n * 使用 easyui 开发你的产品时可以大量节省你的时间和规模。\n * easyui 使用非常简单但功能非常强大。\n\n\n# Spring Boot 整合 EasyUI\n\n\n# 配置\n\napplication.properties 修改：\n\nspring.mvc.view.prefix = /views/\nspring.mvc.view.suffix = .html\n\n\n\n# 引入 easyui\n\nEasyUI 下载地址：http://www.jeasyui.cn/download.html\n\n在 src/main/resources/static 目录下引入 easyui。\n\n然后在 html 中引用：\n\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset="UTF-8" />\n    <link\n      rel="stylesheet"\n      type="text/css"\n      href="../lib/easyui/themes/bootstrap/easyui.css"\n    />\n    <link\n      rel="stylesheet"\n      type="text/css"\n      href="../lib/easyui/themes/icon.css"\n    />\n    <link\n      rel="stylesheet"\n      type="text/css"\n      href="../lib/easyui/themes/color.css"\n    />\n    <script type="text/javascript" src="../lib/easyui/jquery.min.js"><\/script>\n    <script\n      type="text/javascript"\n      src="../lib/easyui/jquery.easyui.min.js"\n    ><\/script>\n    <script\n      type="text/javascript"\n      src="../lib/easyui/locale/easyui-lang-zh_CN.js"\n    ><\/script>\n  </head>\n  <body>\n    \x3c!-- 省略 --\x3e\n  </body>\n</html>\n\n\n引入 easyui 后，需要使用哪种组件，可以查看相关文档或 API，十分简单，此处不一一赘述。\n\n\n# 实战\n\n\n# 引入 maven 依赖\n\n  <dependencies>\n    <dependency>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n    <dependency>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter-data-jpa</artifactId>\n    </dependency>\n    <dependency>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter-tomcat</artifactId>\n      <scope>provided</scope>\n    </dependency>\n    <dependency>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter-test</artifactId>\n      <scope>test</scope>\n    </dependency>\n\n    <dependency>\n      <groupId>com.h2database</groupId>\n      <artifactId>h2</artifactId>\n    </dependency>\n    <dependency>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-devtools</artifactId>\n    </dependency>\n    <dependency>\n      <groupId>commons-collections</groupId>\n      <artifactId>commons-collections</artifactId>\n      <version>3.2.2</version>\n    </dependency>\n  </dependencies>\n\n\n\n# 使用 JPA\n\n为了使用 JPA 技术访问数据，我们需要定义 Entity 和 Repository\n\n定义一个 Entity：\n\n@Entity\npublic class User {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.AUTO)\n    private Long id;\n    private String firstName;\n    private String lastName;\n    private String phone;\n    private String email;\n\n    protected User() {}\n\n    public User(String firstName, String lastName, String phone, String email) {\n        this.firstName = firstName;\n        this.lastName = lastName;\n        this.phone = phone;\n        this.email = email;\n    }\n\n    // 略 getter/setter\n}\n\n\n定义一个 Repository：\n\npublic interface UserRepository extends CrudRepository<User, Long> {\n\n    List<User> findByLastName(String lastName);\n}\n\n\n\n# 使用 Web\n\n首页 Controller，将 web 请求定向到指定页面（下面的例子定向到 index.html）\n\n@Controller\npublic class IndexController {\n\n    @RequestMapping(value = {"", "/", "index"})\n    public String index() {\n        return "index";\n    }\n\n}\n\n\n此外，需要定义一个 Controller，提供后台的 API 接口\n\n@Controller\npublic class UserController {\n\n    @Autowired\n    private UserRepository customerRepository;\n\n    @RequestMapping(value = "/user", method = RequestMethod.GET)\n    public String user() {\n        return "user";\n    }\n\n    @ResponseBody\n    @RequestMapping(value = "/user/list")\n    public ResponseDTO<User> list() {\n        Iterable<User> all = customerRepository.findAll();\n        List<User> list = IteratorUtils.toList(all.iterator());\n        return new ResponseDTO<>(true, list.size(), list);\n    }\n\n    @ResponseBody\n    @RequestMapping(value = "/user/add")\n    public ResponseDTO<User> add(User user) {\n        User result = customerRepository.save(user);\n        List<User> list = new ArrayList<>();\n        list.add(result);\n        return new ResponseDTO<>(true, 1, list);\n    }\n\n    @ResponseBody\n    @RequestMapping(value = "/user/save")\n    public ResponseDTO<User> save(@RequestParam("id") Long id, User user) {\n        user.setId(id);\n        customerRepository.save(user);\n        List<User> list = new ArrayList<>();\n        list.add(user);\n        return new ResponseDTO<>(true, 1, list);\n    }\n\n    @ResponseBody\n    @RequestMapping(value = "/user/delete")\n    public ResponseDTO delete(@RequestParam("id") Long id) {\n        customerRepository.deleteById(id);\n        return new ResponseDTO<>(true, null, null);\n    }\n\n}\n\n\n\n# 使用 EasyUI\n\n接下来，我们要使用前面定义的后台接口，仅需要在 EasyUI API 中指定 url 即可。\n\n请留意下面示例中的 url 字段，和实际接口是一一对应的。\n\n<!DOCTYPE html>\n<html>\n  <head>\n    <title>Complex Layout - jQuery EasyUI Demo</title>\n    <meta charset="UTF-8" />\n    <link\n      rel="stylesheet"\n      type="text/css"\n      href="../lib/easyui/themes/bootstrap/easyui.css"\n    />\n    <link\n      rel="stylesheet"\n      type="text/css"\n      href="../lib/easyui/themes/icon.css"\n    />\n    <link\n      rel="stylesheet"\n      type="text/css"\n      href="../lib/easyui/themes/color.css"\n    />\n    <script type="text/javascript" src="../lib/easyui/jquery.min.js"><\/script>\n    <script\n      type="text/javascript"\n      src="../lib/easyui/jquery.easyui.min.js"\n    ><\/script>\n    <script\n      type="text/javascript"\n      src="../lib/easyui/locale/easyui-lang-zh_CN.js"\n    ><\/script>\n    <style type="text/css">\n      body {\n        font-family: microsoft yahei;\n      }\n    </style>\n  </head>\n  <body>\n    <div style="width:100%">\n      <h2>基本的 CRUD 应用</h2>\n      <p>数据来源于后台系统</p>\n\n      <table\n        id="dg"\n        title="Custom List"\n        class="easyui-datagrid"\n        url="/user/list"\n        toolbar="#toolbar"\n        pagination="true"\n        rownumbers="true"\n        fitColumns="true"\n        singleSelect="true"\n      >\n        <thead>\n          <tr>\n            <th field="id" width="50">ID</th>\n            <th field="firstName" width="50">First Name</th>\n            <th field="lastName" width="50">Last Name</th>\n            <th field="phone" width="50">Phone</th>\n            <th field="email" width="50">Email</th>\n          </tr>\n        </thead>\n      </table>\n      <div id="toolbar">\n        <a\n          href="javascript:void(0)"\n          class="easyui-linkbutton"\n          iconCls="icon-add"\n          plain="true"\n          onclick="newUser()"\n          >添加</a\n        >\n        <a\n          href="javascript:void(0)"\n          class="easyui-linkbutton"\n          iconCls="icon-edit"\n          plain="true"\n          onclick="editUser()"\n          >修改</a\n        >\n        <a\n          href="javascript:void(0)"\n          class="easyui-linkbutton"\n          iconCls="icon-remove"\n          plain="true"\n          onclick="destroyUser()"\n          >删除</a\n        >\n      </div>\n\n      <div\n        id="dlg"\n        class="easyui-dialog"\n        style="width:400px"\n        data-options="closed:true,modal:true,border:\'thin\',buttons:\'#dlg-buttons\'"\n      >\n        <form\n          id="fm"\n          method="post"\n          novalidate\n          style="margin:0;padding:20px 50px"\n        >\n          <h3>User Information</h3>\n          <div style="margin-bottom:10px">\n            <input\n              name="firstName"\n              class="easyui-textbox"\n              required="true"\n              label="First Name:"\n              style="width:100%"\n            />\n          </div>\n          <div style="margin-bottom:10px">\n            <input\n              name="lastName"\n              class="easyui-textbox"\n              required="true"\n              label="Last Name:"\n              style="width:100%"\n            />\n          </div>\n          <div style="margin-bottom:10px">\n            <input\n              name="phone"\n              class="easyui-textbox"\n              required="true"\n              label="Phone:"\n              style="width:100%"\n            />\n          </div>\n          <div style="margin-bottom:10px">\n            <input\n              name="email"\n              class="easyui-textbox"\n              required="true"\n              validType="email"\n              label="Email:"\n              style="width:100%"\n            />\n          </div>\n        </form>\n      </div>\n      <div id="dlg-buttons">\n        <a\n          href="javascript:void(0)"\n          class="easyui-linkbutton c6"\n          iconCls="icon-ok"\n          onclick="saveUser()"\n          style="width:90px"\n          >Save</a\n        >\n        <a\n          href="javascript:void(0)"\n          class="easyui-linkbutton"\n          iconCls="icon-cancel"\n          onclick="javascript:$(\'#dlg\').dialog(\'close\')"\n          style="width:90px"\n          >Cancel</a\n        >\n      </div>\n    </div>\n\n    <script type="text/javascript">\n      var url\n\n      function newUser() {\n        $(\'#dlg\')\n          .dialog(\'open\')\n          .dialog(\'center\')\n          .dialog(\'setTitle\', \'New User\')\n        $(\'#fm\').form(\'clear\')\n        url = \'/user/add\'\n      }\n\n      function editUser() {\n        var row = $(\'#dg\').datagrid(\'getSelected\')\n        if (row) {\n          $(\'#dlg\')\n            .dialog(\'open\')\n            .dialog(\'center\')\n            .dialog(\'setTitle\', \'Edit User\')\n          $(\'#fm\').form(\'load\', row)\n          url = \'/user/save\'\n        }\n      }\n\n      function saveUser() {\n        $(\'#fm\').form(\'submit\', {\n          url: url,\n          onSubmit: function() {\n            return $(this).form(\'validate\')\n          },\n          success: function(result) {\n            var result = eval(\'(\' + result + \')\')\n            if (result.errorMsg) {\n              $.messager.show({\n                title: \'Error\',\n                msg: result.errorMsg\n              })\n            } else {\n              $(\'#dlg\').dialog(\'close\') // close the dialog\n              $(\'#dg\').datagrid(\'reload\') // reload the user data\n            }\n          }\n        })\n      }\n\n      function destroyUser() {\n        var row = $(\'#dg\').datagrid(\'getSelected\')\n        if (row) {\n          $.messager.confirm(\n            \'Confirm\',\n            \'Are you sure you want to destroy this user?\',\n            function(r) {\n              if (r) {\n                $.post(\n                  \'/user/delete\',\n                  { id: row.id },\n                  function(result) {\n                    if (result.success) {\n                      $(\'#dg\').datagrid(\'reload\') // reload the user data\n                    } else {\n                      $.messager.show({\n                        // show error message\n                        title: \'Error\',\n                        msg: result.errorMsg\n                      })\n                    }\n                  },\n                  \'json\'\n                )\n              }\n            }\n          )\n        }\n      }\n    <\/script>\n  </body>\n</html>\n\n\n\n# 完整示例\n\n请参考 源码\n\n运行方式：\n\nmvn clean package -DskipTests=true\njava -jar target/\n\n\n在浏览器中访问：http://localhost:8080/\n\n\n# 引用和引申\n\n * EasyUI 官网\n * EasyUI 中文网',normalizedContent:'# springboot 之应用 easyui\n\n> easyui 是一个简单的用户界面组件的集合。由于 easyui 已经封装好大部分 ui 基本功能，能帮用户减少大量的 js 和 css 代码。所以，easyui 非常适合用于开发简单的系统或原型系统。\n> \n> 本文示例使用技术点：\n> \n>  * spring boot：主要使用了 spring-boot-starter-web、spring-boot-starter-data-jpa\n>  * easyui：按需加载，并没有引入所有的 easyui 特性\n>  * 数据库：为了测试方便，使用 h2\n\n\n\n\n# 简介\n\n\n# 什么是 easyui？\n\n * easyui 是基于 jquery、angular.、vue 和 react 的用户界面组件的集合。\n * easyui 提供了构建现代交互式 javascript 应用程序的基本功能。\n * 使用 easyui，您不需要编写许多 javascript 代码，通常通过编写一些 html 标记来定义用户界面。\n * 完整的 html5 网页框架。\n * 使用 easyui 开发你的产品时可以大量节省你的时间和规模。\n * easyui 使用非常简单但功能非常强大。\n\n\n# spring boot 整合 easyui\n\n\n# 配置\n\napplication.properties 修改：\n\nspring.mvc.view.prefix = /views/\nspring.mvc.view.suffix = .html\n\n\n\n# 引入 easyui\n\neasyui 下载地址：http://www.jeasyui.cn/download.html\n\n在 src/main/resources/static 目录下引入 easyui。\n\n然后在 html 中引用：\n\n<!doctype html>\n<html>\n  <head>\n    <meta charset="utf-8" />\n    <link\n      rel="stylesheet"\n      type="text/css"\n      href="../lib/easyui/themes/bootstrap/easyui.css"\n    />\n    <link\n      rel="stylesheet"\n      type="text/css"\n      href="../lib/easyui/themes/icon.css"\n    />\n    <link\n      rel="stylesheet"\n      type="text/css"\n      href="../lib/easyui/themes/color.css"\n    />\n    <script type="text/javascript" src="../lib/easyui/jquery.min.js"><\/script>\n    <script\n      type="text/javascript"\n      src="../lib/easyui/jquery.easyui.min.js"\n    ><\/script>\n    <script\n      type="text/javascript"\n      src="../lib/easyui/locale/easyui-lang-zh_cn.js"\n    ><\/script>\n  </head>\n  <body>\n    \x3c!-- 省略 --\x3e\n  </body>\n</html>\n\n\n引入 easyui 后，需要使用哪种组件，可以查看相关文档或 api，十分简单，此处不一一赘述。\n\n\n# 实战\n\n\n# 引入 maven 依赖\n\n  <dependencies>\n    <dependency>\n      <groupid>org.springframework.boot</groupid>\n      <artifactid>spring-boot-starter-web</artifactid>\n    </dependency>\n    <dependency>\n      <groupid>org.springframework.boot</groupid>\n      <artifactid>spring-boot-starter-data-jpa</artifactid>\n    </dependency>\n    <dependency>\n      <groupid>org.springframework.boot</groupid>\n      <artifactid>spring-boot-starter-tomcat</artifactid>\n      <scope>provided</scope>\n    </dependency>\n    <dependency>\n      <groupid>org.springframework.boot</groupid>\n      <artifactid>spring-boot-starter-test</artifactid>\n      <scope>test</scope>\n    </dependency>\n\n    <dependency>\n      <groupid>com.h2database</groupid>\n      <artifactid>h2</artifactid>\n    </dependency>\n    <dependency>\n      <groupid>org.springframework.boot</groupid>\n      <artifactid>spring-boot-devtools</artifactid>\n    </dependency>\n    <dependency>\n      <groupid>commons-collections</groupid>\n      <artifactid>commons-collections</artifactid>\n      <version>3.2.2</version>\n    </dependency>\n  </dependencies>\n\n\n\n# 使用 jpa\n\n为了使用 jpa 技术访问数据，我们需要定义 entity 和 repository\n\n定义一个 entity：\n\n@entity\npublic class user {\n\n    @id\n    @generatedvalue(strategy = generationtype.auto)\n    private long id;\n    private string firstname;\n    private string lastname;\n    private string phone;\n    private string email;\n\n    protected user() {}\n\n    public user(string firstname, string lastname, string phone, string email) {\n        this.firstname = firstname;\n        this.lastname = lastname;\n        this.phone = phone;\n        this.email = email;\n    }\n\n    // 略 getter/setter\n}\n\n\n定义一个 repository：\n\npublic interface userrepository extends crudrepository<user, long> {\n\n    list<user> findbylastname(string lastname);\n}\n\n\n\n# 使用 web\n\n首页 controller，将 web 请求定向到指定页面（下面的例子定向到 index.html）\n\n@controller\npublic class indexcontroller {\n\n    @requestmapping(value = {"", "/", "index"})\n    public string index() {\n        return "index";\n    }\n\n}\n\n\n此外，需要定义一个 controller，提供后台的 api 接口\n\n@controller\npublic class usercontroller {\n\n    @autowired\n    private userrepository customerrepository;\n\n    @requestmapping(value = "/user", method = requestmethod.get)\n    public string user() {\n        return "user";\n    }\n\n    @responsebody\n    @requestmapping(value = "/user/list")\n    public responsedto<user> list() {\n        iterable<user> all = customerrepository.findall();\n        list<user> list = iteratorutils.tolist(all.iterator());\n        return new responsedto<>(true, list.size(), list);\n    }\n\n    @responsebody\n    @requestmapping(value = "/user/add")\n    public responsedto<user> add(user user) {\n        user result = customerrepository.save(user);\n        list<user> list = new arraylist<>();\n        list.add(result);\n        return new responsedto<>(true, 1, list);\n    }\n\n    @responsebody\n    @requestmapping(value = "/user/save")\n    public responsedto<user> save(@requestparam("id") long id, user user) {\n        user.setid(id);\n        customerrepository.save(user);\n        list<user> list = new arraylist<>();\n        list.add(user);\n        return new responsedto<>(true, 1, list);\n    }\n\n    @responsebody\n    @requestmapping(value = "/user/delete")\n    public responsedto delete(@requestparam("id") long id) {\n        customerrepository.deletebyid(id);\n        return new responsedto<>(true, null, null);\n    }\n\n}\n\n\n\n# 使用 easyui\n\n接下来，我们要使用前面定义的后台接口，仅需要在 easyui api 中指定 url 即可。\n\n请留意下面示例中的 url 字段，和实际接口是一一对应的。\n\n<!doctype html>\n<html>\n  <head>\n    <title>complex layout - jquery easyui demo</title>\n    <meta charset="utf-8" />\n    <link\n      rel="stylesheet"\n      type="text/css"\n      href="../lib/easyui/themes/bootstrap/easyui.css"\n    />\n    <link\n      rel="stylesheet"\n      type="text/css"\n      href="../lib/easyui/themes/icon.css"\n    />\n    <link\n      rel="stylesheet"\n      type="text/css"\n      href="../lib/easyui/themes/color.css"\n    />\n    <script type="text/javascript" src="../lib/easyui/jquery.min.js"><\/script>\n    <script\n      type="text/javascript"\n      src="../lib/easyui/jquery.easyui.min.js"\n    ><\/script>\n    <script\n      type="text/javascript"\n      src="../lib/easyui/locale/easyui-lang-zh_cn.js"\n    ><\/script>\n    <style type="text/css">\n      body {\n        font-family: microsoft yahei;\n      }\n    </style>\n  </head>\n  <body>\n    <div style="width:100%">\n      <h2>基本的 crud 应用</h2>\n      <p>数据来源于后台系统</p>\n\n      <table\n        id="dg"\n        title="custom list"\n        class="easyui-datagrid"\n        url="/user/list"\n        toolbar="#toolbar"\n        pagination="true"\n        rownumbers="true"\n        fitcolumns="true"\n        singleselect="true"\n      >\n        <thead>\n          <tr>\n            <th field="id" width="50">id</th>\n            <th field="firstname" width="50">first name</th>\n            <th field="lastname" width="50">last name</th>\n            <th field="phone" width="50">phone</th>\n            <th field="email" width="50">email</th>\n          </tr>\n        </thead>\n      </table>\n      <div id="toolbar">\n        <a\n          href="javascript:void(0)"\n          class="easyui-linkbutton"\n          iconcls="icon-add"\n          plain="true"\n          onclick="newuser()"\n          >添加</a\n        >\n        <a\n          href="javascript:void(0)"\n          class="easyui-linkbutton"\n          iconcls="icon-edit"\n          plain="true"\n          onclick="edituser()"\n          >修改</a\n        >\n        <a\n          href="javascript:void(0)"\n          class="easyui-linkbutton"\n          iconcls="icon-remove"\n          plain="true"\n          onclick="destroyuser()"\n          >删除</a\n        >\n      </div>\n\n      <div\n        id="dlg"\n        class="easyui-dialog"\n        style="width:400px"\n        data-options="closed:true,modal:true,border:\'thin\',buttons:\'#dlg-buttons\'"\n      >\n        <form\n          id="fm"\n          method="post"\n          novalidate\n          style="margin:0;padding:20px 50px"\n        >\n          <h3>user information</h3>\n          <div style="margin-bottom:10px">\n            <input\n              name="firstname"\n              class="easyui-textbox"\n              required="true"\n              label="first name:"\n              style="width:100%"\n            />\n          </div>\n          <div style="margin-bottom:10px">\n            <input\n              name="lastname"\n              class="easyui-textbox"\n              required="true"\n              label="last name:"\n              style="width:100%"\n            />\n          </div>\n          <div style="margin-bottom:10px">\n            <input\n              name="phone"\n              class="easyui-textbox"\n              required="true"\n              label="phone:"\n              style="width:100%"\n            />\n          </div>\n          <div style="margin-bottom:10px">\n            <input\n              name="email"\n              class="easyui-textbox"\n              required="true"\n              validtype="email"\n              label="email:"\n              style="width:100%"\n            />\n          </div>\n        </form>\n      </div>\n      <div id="dlg-buttons">\n        <a\n          href="javascript:void(0)"\n          class="easyui-linkbutton c6"\n          iconcls="icon-ok"\n          onclick="saveuser()"\n          style="width:90px"\n          >save</a\n        >\n        <a\n          href="javascript:void(0)"\n          class="easyui-linkbutton"\n          iconcls="icon-cancel"\n          onclick="javascript:$(\'#dlg\').dialog(\'close\')"\n          style="width:90px"\n          >cancel</a\n        >\n      </div>\n    </div>\n\n    <script type="text/javascript">\n      var url\n\n      function newuser() {\n        $(\'#dlg\')\n          .dialog(\'open\')\n          .dialog(\'center\')\n          .dialog(\'settitle\', \'new user\')\n        $(\'#fm\').form(\'clear\')\n        url = \'/user/add\'\n      }\n\n      function edituser() {\n        var row = $(\'#dg\').datagrid(\'getselected\')\n        if (row) {\n          $(\'#dlg\')\n            .dialog(\'open\')\n            .dialog(\'center\')\n            .dialog(\'settitle\', \'edit user\')\n          $(\'#fm\').form(\'load\', row)\n          url = \'/user/save\'\n        }\n      }\n\n      function saveuser() {\n        $(\'#fm\').form(\'submit\', {\n          url: url,\n          onsubmit: function() {\n            return $(this).form(\'validate\')\n          },\n          success: function(result) {\n            var result = eval(\'(\' + result + \')\')\n            if (result.errormsg) {\n              $.messager.show({\n                title: \'error\',\n                msg: result.errormsg\n              })\n            } else {\n              $(\'#dlg\').dialog(\'close\') // close the dialog\n              $(\'#dg\').datagrid(\'reload\') // reload the user data\n            }\n          }\n        })\n      }\n\n      function destroyuser() {\n        var row = $(\'#dg\').datagrid(\'getselected\')\n        if (row) {\n          $.messager.confirm(\n            \'confirm\',\n            \'are you sure you want to destroy this user?\',\n            function(r) {\n              if (r) {\n                $.post(\n                  \'/user/delete\',\n                  { id: row.id },\n                  function(result) {\n                    if (result.success) {\n                      $(\'#dg\').datagrid(\'reload\') // reload the user data\n                    } else {\n                      $.messager.show({\n                        // show error message\n                        title: \'error\',\n                        msg: result.errormsg\n                      })\n                    }\n                  },\n                  \'json\'\n                )\n              }\n            }\n          )\n        }\n      }\n    <\/script>\n  </body>\n</html>\n\n\n\n# 完整示例\n\n请参考 源码\n\n运行方式：\n\nmvn clean package -dskiptests=true\njava -jar target/\n\n\n在浏览器中访问：http://localhost:8080/\n\n\n# 引用和引申\n\n * easyui 官网\n * easyui 中文网',charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Spring Web",frontmatter:{title:"Spring Web",date:"2020-02-26T23:48:06.000Z",categories:["Java","框架","Spring","SpringWeb"],tags:["Java","框架","Spring","SpringBoot","Web"],permalink:"/pages/e2586a/",hidden:!0,index:!1},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/03.SpringWeb/",relativePath:"01.Java/13.框架/01.Spring/03.SpringWeb/README.md",key:"v-e92f7bb8",path:"/pages/e2586a/",headers:[{level:2,title:"📖 内容",slug:"📖-内容",normalizedTitle:"📖 内容",charIndex:72},{level:2,title:"📚 资料",slug:"📚-资料",normalizedTitle:"📚 资料",charIndex:125},{level:2,title:"🚪 传送",slug:"🚪-传送",normalizedTitle:"🚪 传送",charIndex:304}],headersStr:"📖 内容 📚 资料 🚪 传送",content:"# Spring Web\n\n> 章节主要针对：Spring 在 web 领域的应用。如：Spring MVC、WebSocket 等。\n\n\n# 📖 内容\n\n * Spring WebMvc\n * SpringBoot 之应用 EasyUI\n\n\n# 📚 资料\n\n * 官方\n   * Spring 官网\n   * Spring Framework 官方文档\n   * Spring Github\n * 书籍\n   * 《Spring In Action》\n * 教程\n   * 《小马哥讲 Spring 核心编程思想》\n   * geekbang-lessons\n   * 跟我学 Spring3\n\n\n# 🚪 传送\n\n◾ 💧 钝悟的 IT 知识图谱 ◾ 🎯 我的博客 ◾",normalizedContent:"# spring web\n\n> 章节主要针对：spring 在 web 领域的应用。如：spring mvc、websocket 等。\n\n\n# 📖 内容\n\n * spring webmvc\n * springboot 之应用 easyui\n\n\n# 📚 资料\n\n * 官方\n   * spring 官网\n   * spring framework 官方文档\n   * spring github\n * 书籍\n   * 《spring in action》\n * 教程\n   * 《小马哥讲 spring 核心编程思想》\n   * geekbang-lessons\n   * 跟我学 spring3\n\n\n# 🚪 传送\n\n◾ 💧 钝悟的 it 知识图谱 ◾ 🎯 我的博客 ◾",charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"spring-boot-async",frontmatter:{title:"spring-boot-async",date:"2019-11-18T14:55:01.000Z",order:1,categories:["Java","框架","Spring","SpringIO"],tags:["Java","框架","Spring","SpringBoot","异步"],permalink:"/pages/92add2/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/04.SpringIO/01.SpringBoot%E4%B9%8B%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82.html",relativePath:"01.Java/13.框架/01.Spring/04.SpringIO/01.SpringBoot之异步请求.md",key:"v-aa040a8e",path:"/pages/92add2/",headers:[{level:2,title:"@EnableAsync 注解",slug:"enableasync-注解",normalizedTitle:"@enableasync 注解",charIndex:27},{level:2,title:"@Async 注解",slug:"async-注解",normalizedTitle:"@async 注解",charIndex:192},{level:3,title:"支持的用法",slug:"支持的用法",normalizedTitle:"支持的用法",charIndex:206},{level:3,title:"不支持的用法",slug:"不支持的用法",normalizedTitle:"不支持的用法",charIndex:866},{level:2,title:"明确指定执行器",slug:"明确指定执行器",normalizedTitle:"明确指定执行器",charIndex:1355},{level:2,title:"管理 @Async 的异常",slug:"管理-async-的异常",normalizedTitle:"管理 @async 的异常",charIndex:1800},{level:2,title:"示例源码",slug:"示例源码",normalizedTitle:"示例源码",charIndex:2318},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:2353}],headersStr:"@EnableAsync 注解 @Async 注解 支持的用法 不支持的用法 明确指定执行器 管理 @Async 的异常 示例源码 参考资料",content:'# SpringBoot 教程之处理异步请求\n\n\n# @EnableAsync 注解\n\n要使用 @Async，首先需要使用 @EnableAsync 注解开启 Spring Boot 中的异步特性。\n\n@Configuration\n@EnableAsync\npublic class AppConfig {\n}\n\n\n更详细的配置说明，可以参考：AsyncConfigurer\n\n\n# @Async 注解\n\n\n# 支持的用法\n\n（1）无入参无返回值方法\n\n您可以用 @Async 注解修饰方法，这表明这个方法是异步方式调用。换句话说，程序在调用此方法时会立即返回，而方法的实际执行发生在已提交给 Spring TaskExecutor 的任务中。在最简单的情况下，您可以将注解应用于返回 void 的方法，如以下示例所示：\n\n@Async\nvoid doSomething() {\n    // this will be executed asynchronously\n}\n\n\n（2）有入参无返回值方法\n\n与使用 @Scheduled 注释注释的方法不同，这些方法可以指定参数，因为它们在运行时由调用者以“正常”方式调用，而不是由容器管理的调度任务调用。例如，以下代码是 @Async 注解的合法应用：\n\n@Async\nvoid doSomething(String s) {\n    // this will be executed asynchronously\n}\n\n\n（3）有入参有返回值方法\n\n甚至可以异步调用返回值的方法。但是，这些方法需要具有 Future 类型的返回值。这仍然提供了异步执行的好处，以便调用者可以在调用 Future 上的 get() 之前执行其他任务。以下示例显示如何在返回值的方法上使用@Async：\n\n@Async\nFuture<String> returnSomething(int i) {\n    // this will be executed asynchronously\n}\n\n\n\n# 不支持的用法\n\n@Async 不能与生命周期回调一起使用，例如 @PostConstruct。\n\n要异步初始化 Spring bean，必须使用单独的初始化 Spring bean，然后在目标上调用 @Async 带注释的方法，如以下示例所示：\n\npublic class SampleBeanImpl implements SampleBean {\n\n    @Async\n    void doSomething() {\n        // ...\n    }\n\n}\n\npublic class SampleBeanInitializer {\n\n    private final SampleBean bean;\n\n    public SampleBeanInitializer(SampleBean bean) {\n        this.bean = bean;\n    }\n\n    @PostConstruct\n    public void initialize() {\n        bean.doSomething();\n    }\n\n}\n\n\n\n# 明确指定执行器\n\n默认情况下，在方法上指定 @Async 时，使用的执行器是在启用异步支持时配置的执行器，即如果使用 XML 或 AsyncConfigurer 实现（如果有），则为 annotation-driven 元素。但是，如果需要指示在执行给定方法时应使用默认值以外的执行器，则可以使用 @Async 注解的 value 属性。以下示例显示了如何执行此操作：\n\n@Async("otherExecutor")\nvoid doSomething(String s) {\n    // this will be executed asynchronously by "otherExecutor"\n}\n\n\n在这种情况下，“otherExecutor”可以是 Spring 容器中任何 Executor bean 的名称，也可以是与任何 Executor 关联的限定符的名称（例如，使用 <qualifier> 元素或 Spring 的 @Qualifier 注释指定） ）。\n\n\n# 管理 @Async 的异常\n\n当 @Async 方法的返回值类型为 Future 型时，很容易管理在方法执行期间抛出的异常，因为在调用 get 结果时会抛出此异常。但是，对于返回值类型为 void 型的方法，异常不会被捕获且无法传输。您可以提供 AsyncUncaughtExceptionHandler 来处理此类异常。以下示例显示了如何执行此操作：\n\npublic class MyAsyncUncaughtExceptionHandler implements AsyncUncaughtExceptionHandler {\n\n    @Override\n    public void handleUncaughtException(Throwable ex, Method method, Object... params) {\n        // handle exception\n    }\n}\n\n\n默认情况下，仅记录异常。您可以使用 AsyncConfigurer 或 <task：annotation-driven /> XML 元素定义自定义 AsyncUncaughtExceptionHandler。\n\n\n# 示例源码\n\n> 示例源码：spring-boot-async\n\n\n# 参考资料\n\n * Spring Boot 官方文档之 boot-features-external-config\n * Spring Boot 官方文档之 scheduling-annotation-support',normalizedContent:'# springboot 教程之处理异步请求\n\n\n# @enableasync 注解\n\n要使用 @async，首先需要使用 @enableasync 注解开启 spring boot 中的异步特性。\n\n@configuration\n@enableasync\npublic class appconfig {\n}\n\n\n更详细的配置说明，可以参考：asyncconfigurer\n\n\n# @async 注解\n\n\n# 支持的用法\n\n（1）无入参无返回值方法\n\n您可以用 @async 注解修饰方法，这表明这个方法是异步方式调用。换句话说，程序在调用此方法时会立即返回，而方法的实际执行发生在已提交给 spring taskexecutor 的任务中。在最简单的情况下，您可以将注解应用于返回 void 的方法，如以下示例所示：\n\n@async\nvoid dosomething() {\n    // this will be executed asynchronously\n}\n\n\n（2）有入参无返回值方法\n\n与使用 @scheduled 注释注释的方法不同，这些方法可以指定参数，因为它们在运行时由调用者以“正常”方式调用，而不是由容器管理的调度任务调用。例如，以下代码是 @async 注解的合法应用：\n\n@async\nvoid dosomething(string s) {\n    // this will be executed asynchronously\n}\n\n\n（3）有入参有返回值方法\n\n甚至可以异步调用返回值的方法。但是，这些方法需要具有 future 类型的返回值。这仍然提供了异步执行的好处，以便调用者可以在调用 future 上的 get() 之前执行其他任务。以下示例显示如何在返回值的方法上使用@async：\n\n@async\nfuture<string> returnsomething(int i) {\n    // this will be executed asynchronously\n}\n\n\n\n# 不支持的用法\n\n@async 不能与生命周期回调一起使用，例如 @postconstruct。\n\n要异步初始化 spring bean，必须使用单独的初始化 spring bean，然后在目标上调用 @async 带注释的方法，如以下示例所示：\n\npublic class samplebeanimpl implements samplebean {\n\n    @async\n    void dosomething() {\n        // ...\n    }\n\n}\n\npublic class samplebeaninitializer {\n\n    private final samplebean bean;\n\n    public samplebeaninitializer(samplebean bean) {\n        this.bean = bean;\n    }\n\n    @postconstruct\n    public void initialize() {\n        bean.dosomething();\n    }\n\n}\n\n\n\n# 明确指定执行器\n\n默认情况下，在方法上指定 @async 时，使用的执行器是在启用异步支持时配置的执行器，即如果使用 xml 或 asyncconfigurer 实现（如果有），则为 annotation-driven 元素。但是，如果需要指示在执行给定方法时应使用默认值以外的执行器，则可以使用 @async 注解的 value 属性。以下示例显示了如何执行此操作：\n\n@async("otherexecutor")\nvoid dosomething(string s) {\n    // this will be executed asynchronously by "otherexecutor"\n}\n\n\n在这种情况下，“otherexecutor”可以是 spring 容器中任何 executor bean 的名称，也可以是与任何 executor 关联的限定符的名称（例如，使用 <qualifier> 元素或 spring 的 @qualifier 注释指定） ）。\n\n\n# 管理 @async 的异常\n\n当 @async 方法的返回值类型为 future 型时，很容易管理在方法执行期间抛出的异常，因为在调用 get 结果时会抛出此异常。但是，对于返回值类型为 void 型的方法，异常不会被捕获且无法传输。您可以提供 asyncuncaughtexceptionhandler 来处理此类异常。以下示例显示了如何执行此操作：\n\npublic class myasyncuncaughtexceptionhandler implements asyncuncaughtexceptionhandler {\n\n    @override\n    public void handleuncaughtexception(throwable ex, method method, object... params) {\n        // handle exception\n    }\n}\n\n\n默认情况下，仅记录异常。您可以使用 asyncconfigurer 或 <task：annotation-driven /> xml 元素定义自定义 asyncuncaughtexceptionhandler。\n\n\n# 示例源码\n\n> 示例源码：spring-boot-async\n\n\n# 参考资料\n\n * spring boot 官方文档之 boot-features-external-config\n * spring boot 官方文档之 scheduling-annotation-support',charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"SpringBoot 之集成 Json",frontmatter:{title:"SpringBoot 之集成 Json",date:"2018-12-30T22:24:16.000Z",order:2,categories:["Java","框架","Spring","SpringIO"],tags:["Java","框架","Spring","SpringBoot","JSON"],permalink:"/pages/676725/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/04.SpringIO/02.SpringBoot%E4%B9%8BJson.html",relativePath:"01.Java/13.框架/01.Spring/04.SpringIO/02.SpringBoot之Json.md",key:"v-52097332",path:"/pages/676725/",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:26},{level:3,title:"Spring Boot 支持的 Json 库",slug:"spring-boot-支持的-json-库",normalizedTitle:"spring boot 支持的 json 库",charIndex:33},{level:3,title:"Spring Web 中的序列化、反序列化",slug:"spring-web-中的序列化、反序列化",normalizedTitle:"spring web 中的序列化、反序列化",charIndex:523},{level:4,title:"@ResponseBody",slug:"responsebody",normalizedTitle:"@responsebody",charIndex:575},{level:4,title:"@RequestBody",slug:"requestbody",normalizedTitle:"@requestbody",charIndex:939},{level:4,title:"@RestController",slug:"restcontroller",normalizedTitle:"@restcontroller",charIndex:1306},{level:2,title:"指定类的 Json 序列化、反序列化",slug:"指定类的-json-序列化、反序列化",normalizedTitle:"指定类的 json 序列化、反序列化",charIndex:1675},{level:2,title:"@JsonTest",slug:"jsontest",normalizedTitle:"@jsontest",charIndex:2609},{level:2,title:"Spring Boot 中的 json 配置",slug:"spring-boot-中的-json-配置",normalizedTitle:"spring boot 中的 json 配置",charIndex:4531},{level:3,title:"Jackson 配置",slug:"jackson-配置",normalizedTitle:"jackson 配置",charIndex:4558},{level:3,title:"GSON 配置",slug:"gson-配置",normalizedTitle:"gson 配置",charIndex:6030},{level:2,title:"Spring Boot 中使用 Fastjson",slug:"spring-boot-中使用-fastjson",normalizedTitle:"spring boot 中使用 fastjson",charIndex:7330},{level:2,title:"示例源码",slug:"示例源码",normalizedTitle:"示例源码",charIndex:9154},{level:2,title:"引申和引用",slug:"引申和引用",normalizedTitle:"引申和引用",charIndex:9172}],headersStr:"简介 Spring Boot 支持的 Json 库 Spring Web 中的序列化、反序列化 @ResponseBody @RequestBody @RestController 指定类的 Json 序列化、反序列化 @JsonTest Spring Boot 中的 json 配置 Jackson 配置 GSON 配置 Spring Boot 中使用 Fastjson 示例源码 引申和引用",content:'# SpringBoot 之集成 Json\n\n\n# 简介\n\n\n# Spring Boot 支持的 Json 库\n\nSpring Boot 支持三种 Json 库：\n\n * Gson\n * Jackson\n * JSON-B\n\nJackson 是 Spring Boot 官方推荐的默认库。\n\nSpring Boot 提供了 Jackson 的自动配置，Jackson 是 spring-boot-starter-json 的一部分。当 Jackson 在类路径上时，会自动配置 ObjectMapper bean。\n\nSpring Boot 提供了 Gson 的自动配置。当 Gson 在 classpath 上时，会自动配置 Gson bean。提供了几个 spring.gson.* 配置属性来自定义配置。为了获得更多控制，可以使用一个或多个 GsonBuilderCustomizer bean。\n\nSpring Boot 提供了 JSON-B 的自动配置。当 JSON-B API 在 classpath 上时，将自动配置 Jsonb bean。首选的 JSON-B 实现是 Apache Johnzon，它提供了依赖关系管理。\n\n\n# Spring Web 中的序列化、反序列化\n\n以下注解都是 spring-web 中提供的支持。\n\n# @ResponseBody\n\n@Responsebody 注解用于将 Controller 的方法返回的对象，通过适当的 HttpMessageConverter 转换为指定格式后，写入到 HTTP Response 对象的 body 数据区。一般在异步获取数据时使用。通常是在使用 @RequestMapping 后，返回值通常解析为跳转路径，加上 @Responsebody 后返回结果不会被解析为跳转路径，而是直接写入 HTTP 响应正文中。\n\n示例：\n\n@ResponseBody\n@RequestMapping(name = "/getInfo", method = RequestMethod.GET)\npublic InfoDTO getInfo() {\n\treturn new InfoDTO();\n}\n\n\n# @RequestBody\n\n@RequestBody 注解用于读取 HTTP Request 请求的 body 部分数据，使用系统默认配置的 HttpMessageConverter 进行解析，然后把相应的数据绑定到要返回的对象上；再把 HttpMessageConverter 返回的对象数据绑定到 controller 中方法的参数上。\n\nrequest 的 body 部分的数据编码格式由 header 部分的 Content-Type 指定。\n\n示例：\n\n@RequestMapping(name = "/postInfo", method = RequestMethod.POST)\npublic void postInfo(@RequestBody InfoDTO infoDTO) {\n    // ...\n}\n\n\n# @RestController\n\nSpring 4 以前：\n\n如果需要返回到指定页面，则需要用 @Controller 配合视图解析器 InternalResourceViewResolver 。\n\n如果需要返回 JSON，XML 或自定义 mediaType 内容到页面，则需要在对应的方法上加上 @ResponseBody 注解。\n\nSpring 4 以后，新增了 @RestController 注解：\n\n它相当于 @Controller + @RequestBody 。\n\n如果使用 @RestController 注解 Controller，则 Controller 中的方法无法返回 jsp 页面，或者 html，配置的视图解析器 InternalResourceViewResolver 将不起作用，直接返回内容。\n\n\n# 指定类的 Json 序列化、反序列化\n\n如果使用 Jackson 序列化和反序列化 JSON 数据，您可能需要编写自己的 JsonSerializer 和 JsonDeserializer 类。自定义序列化程序通常通过模块向 Jackson 注册，但 Spring Boot 提供了另一种 @JsonComponent 注释，可以更容易地直接注册 Spring Beans。\n\n您可以直接在 JsonSerializer 或 JsonDeserializer 实现上使用 @JsonComponent 注释。您还可以在包含序列化程序/反序列化程序作为内部类的类上使用它，如以下示例所示：\n\nimport java.io.*;\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.databind.*;\nimport org.springframework.boot.jackson.*;\n\n@JsonComponent\npublic class Example {\n\n\tpublic static class Serializer extends JsonSerializer<SomeObject> {\n\t\t// ...\n\t}\n\n\tpublic static class Deserializer extends JsonDeserializer<SomeObject> {\n\t\t// ...\n\t}\n\n}\n\n\nApplicationContext 中的所有 @JsonComponent bean 都会自动注册到 Jackson。因为 @JsonComponent 是使用 @Component 进行元注释的，所以通常的组件扫描规则适用。\n\nSpring Boot 还提供了 JsonObjectSerializer 和 JsonObjectDeserializer 基类，它们在序列化对象时提供了标准 Jackson 版本的有用替代方法。有关详细信息，请参阅 Javadoc 中的 JsonObjectSerializer 和 JsonObjectDeserializer。\n\n\n# @JsonTest\n\n使用 @JsonTest 可以很方便的在 Spring Boot 中测试序列化、反序列化。\n\n使用 @JsonTest 相当于使用以下自动配置：\n\norg.springframework.boot.autoconfigure.cache.CacheAutoConfiguration org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration org.springframework.boot.autoconfigure.jsonb.JsonbAutoConfiguration org.springframework.boot.test.autoconfigure.json.JsonTestersAutoConfiguration\n\n\n@JsonTest 使用示例：\n\n想试试完整示例，可以参考：源码\n\n@JsonTest\n@RunWith(SpringRunner.class)\npublic class SimpleJsonTest {\n\n    private final Logger log = LoggerFactory.getLogger(this.getClass());\n\n    @Autowired\n    private JacksonTester<InfoDTO> json;\n\n    @Test\n    public void testSerialize() throws Exception {\n        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");\n        InfoDTO infoDTO = new InfoDTO("JSON测试应用", "1.0.0", sdf.parse("2019-01-01 12:00:00"));\n        JsonContent<InfoDTO> jsonContent = json.write(infoDTO);\n        log.info("json content: {}", jsonContent.getJson());\n        // 或者使用基于JSON path的校验\n        assertThat(jsonContent).hasJsonPathStringValue("@.appName");\n        assertThat(jsonContent).extractingJsonPathStringValue("@.appName").isEqualTo("JSON测试应用");\n        assertThat(jsonContent).hasJsonPathStringValue("@.version");\n        assertThat(jsonContent).extractingJsonPathStringValue("@.version").isEqualTo("1.0.0");\n        assertThat(jsonContent).hasJsonPathStringValue("@.date");\n        assertThat(jsonContent).extractingJsonPathStringValue("@.date").isEqualTo("2019-01-01 12:00:00");\n    }\n\n    @Test\n    public void testDeserialize() throws Exception {\n        String content = "{\\"appName\\":\\"JSON测试应用\\",\\"version\\":\\"1.0.0\\",\\"date\\":\\"2019-01-01\\"}";\n        InfoDTO actual = json.parseObject(content);\n        assertThat(actual.getAppName()).isEqualTo("JSON测试应用");\n        assertThat(actual.getVersion()).isEqualTo("1.0.0");\n    }\n}\n\n\n\n# Spring Boot 中的 json 配置\n\n\n# Jackson 配置\n\n当 Spring Boot 的 json 库为 jackson 时，可以使用以下配置属性（对应 JacksonProperties 类）：\n\nspring.jackson.date-format= # Date format string or a fully-qualified date format class name. For instance, `yyyy-MM-dd HH:mm:ss`.\nspring.jackson.default-property-inclusion= # Controls the inclusion of properties during serialization. Configured with one of the values in Jackson\'s JsonInclude.Include enumeration.\nspring.jackson.deserialization.*= # Jackson on/off features that affect the way Java objects are deserialized.\nspring.jackson.generator.*= # Jackson on/off features for generators.\nspring.jackson.joda-date-time-format= # Joda date time format string. If not configured, "date-format" is used as a fallback if it is configured with a format string.\nspring.jackson.locale= # Locale used for formatting.\nspring.jackson.mapper.*= # Jackson general purpose on/off features.\nspring.jackson.parser.*= # Jackson on/off features for parsers.\nspring.jackson.property-naming-strategy= # One of the constants on Jackson\'s PropertyNamingStrategy. Can also be a fully-qualified class name of a PropertyNamingStrategy subclass.\nspring.jackson.serialization.*= # Jackson on/off features that affect the way Java objects are serialized.\nspring.jackson.time-zone= #  Time zone used when formatting dates. For instance, "America/Los_Angeles" or "GMT+10".\nspring.jackson.visibility.*= # Jackson visibility thresholds that can be used to limit which methods (and fields) are auto-detected.\n\n\n\n# GSON 配置\n\n当 Spring Boot 的 json 库为 gson 时，可以使用以下配置属性（对应 GsonProperties 类）：\n\nspring.gson.date-format= # Format to use when serializing Date objects.\nspring.gson.disable-html-escaping= # Whether to disable the escaping of HTML characters such as \'<\', \'>\', etc.\nspring.gson.disable-inner-class-serialization= # Whether to exclude inner classes during serialization.\nspring.gson.enable-complex-map-key-serialization= # Whether to enable serialization of complex map keys (i.e. non-primitives).\nspring.gson.exclude-fields-without-expose-annotation= # Whether to exclude all fields from consideration for serialization or deserialization that do not have the "Expose" annotation.\nspring.gson.field-naming-policy= # Naming policy that should be applied to an object\'s field during serialization and deserialization.\nspring.gson.generate-non-executable-json= # Whether to generate non executable JSON by prefixing the output with some special text.\nspring.gson.lenient= # Whether to be lenient about parsing JSON that doesn\'t conform to RFC 4627.\nspring.gson.long-serialization-policy= # Serialization policy for Long and long types.\nspring.gson.pretty-printing= # Whether to output serialized JSON that fits in a page for pretty printing.\nspring.gson.serialize-nulls= # Whether to serialize null fields.\n\n\n\n# Spring Boot 中使用 Fastjson\n\n国内很多的 Java 程序员更喜欢使用阿里的 fastjson 作为 json lib。那么，如何在 Spring Boot 中将其替换默认的 jackson 库呢？\n\n你需要做如下处理：\n\n（1）引入 fastjson jar 包：\n\n<dependency>\n\t<groupId>com.alibaba</groupId>\n\t<artifactId>fastjson</artifactId>\n\t<version>1.2.54</version>\n</dependency>\n\n\n（2）实现 WebMvcConfigurer 接口，自定义 configureMessageConverters 接口。如下所示：\n\n@Configuration\npublic class WebMvcConfig implements WebMvcConfigurer {\n\n    private final Logger log = LoggerFactory.getLogger(this.getClass());\n\n    /**\n     * 自定义消息转换器\n     * @param converters\n     */\n    @Override\n    public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {\n        // 清除默认 Json 转换器\n        converters.removeIf(converter -> converter instanceof MappingJackson2HttpMessageConverter);\n\n        // 配置 FastJson\n        FastJsonConfig config = new FastJsonConfig();\n        config.setSerializerFeatures(SerializerFeature.QuoteFieldNames, SerializerFeature.WriteEnumUsingToString,\n            SerializerFeature.WriteMapNullValue, SerializerFeature.WriteDateUseDateFormat,\n            SerializerFeature.DisableCircularReferenceDetect);\n\n        // 添加 FastJsonHttpMessageConverter\n        FastJsonHttpMessageConverter fastJsonHttpMessageConverter = new FastJsonHttpMessageConverter();\n        fastJsonHttpMessageConverter.setFastJsonConfig(config);\n        List<MediaType> fastMediaTypes = new ArrayList<>();\n        fastMediaTypes.add(MediaType.APPLICATION_JSON_UTF8);\n        fastJsonHttpMessageConverter.setSupportedMediaTypes(fastMediaTypes);\n        converters.add(fastJsonHttpMessageConverter);\n\n        // 添加 StringHttpMessageConverter，解决中文乱码问题\n        StringHttpMessageConverter stringHttpMessageConverter = new StringHttpMessageConverter(Charset.forName("UTF-8"));\n        converters.add(stringHttpMessageConverter);\n    }\n\n    // ...\n}\n\n\n\n# 示例源码\n\n完整示例：源码\n\n\n# 引申和引用\n\n引申\n\n * Spring Boot 教程\n\n引用\n\n * Spring Boot 官方文档之 boot-features-json',normalizedContent:'# springboot 之集成 json\n\n\n# 简介\n\n\n# spring boot 支持的 json 库\n\nspring boot 支持三种 json 库：\n\n * gson\n * jackson\n * json-b\n\njackson 是 spring boot 官方推荐的默认库。\n\nspring boot 提供了 jackson 的自动配置，jackson 是 spring-boot-starter-json 的一部分。当 jackson 在类路径上时，会自动配置 objectmapper bean。\n\nspring boot 提供了 gson 的自动配置。当 gson 在 classpath 上时，会自动配置 gson bean。提供了几个 spring.gson.* 配置属性来自定义配置。为了获得更多控制，可以使用一个或多个 gsonbuildercustomizer bean。\n\nspring boot 提供了 json-b 的自动配置。当 json-b api 在 classpath 上时，将自动配置 jsonb bean。首选的 json-b 实现是 apache johnzon，它提供了依赖关系管理。\n\n\n# spring web 中的序列化、反序列化\n\n以下注解都是 spring-web 中提供的支持。\n\n# @responsebody\n\n@responsebody 注解用于将 controller 的方法返回的对象，通过适当的 httpmessageconverter 转换为指定格式后，写入到 http response 对象的 body 数据区。一般在异步获取数据时使用。通常是在使用 @requestmapping 后，返回值通常解析为跳转路径，加上 @responsebody 后返回结果不会被解析为跳转路径，而是直接写入 http 响应正文中。\n\n示例：\n\n@responsebody\n@requestmapping(name = "/getinfo", method = requestmethod.get)\npublic infodto getinfo() {\n\treturn new infodto();\n}\n\n\n# @requestbody\n\n@requestbody 注解用于读取 http request 请求的 body 部分数据，使用系统默认配置的 httpmessageconverter 进行解析，然后把相应的数据绑定到要返回的对象上；再把 httpmessageconverter 返回的对象数据绑定到 controller 中方法的参数上。\n\nrequest 的 body 部分的数据编码格式由 header 部分的 content-type 指定。\n\n示例：\n\n@requestmapping(name = "/postinfo", method = requestmethod.post)\npublic void postinfo(@requestbody infodto infodto) {\n    // ...\n}\n\n\n# @restcontroller\n\nspring 4 以前：\n\n如果需要返回到指定页面，则需要用 @controller 配合视图解析器 internalresourceviewresolver 。\n\n如果需要返回 json，xml 或自定义 mediatype 内容到页面，则需要在对应的方法上加上 @responsebody 注解。\n\nspring 4 以后，新增了 @restcontroller 注解：\n\n它相当于 @controller + @requestbody 。\n\n如果使用 @restcontroller 注解 controller，则 controller 中的方法无法返回 jsp 页面，或者 html，配置的视图解析器 internalresourceviewresolver 将不起作用，直接返回内容。\n\n\n# 指定类的 json 序列化、反序列化\n\n如果使用 jackson 序列化和反序列化 json 数据，您可能需要编写自己的 jsonserializer 和 jsondeserializer 类。自定义序列化程序通常通过模块向 jackson 注册，但 spring boot 提供了另一种 @jsoncomponent 注释，可以更容易地直接注册 spring beans。\n\n您可以直接在 jsonserializer 或 jsondeserializer 实现上使用 @jsoncomponent 注释。您还可以在包含序列化程序/反序列化程序作为内部类的类上使用它，如以下示例所示：\n\nimport java.io.*;\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.databind.*;\nimport org.springframework.boot.jackson.*;\n\n@jsoncomponent\npublic class example {\n\n\tpublic static class serializer extends jsonserializer<someobject> {\n\t\t// ...\n\t}\n\n\tpublic static class deserializer extends jsondeserializer<someobject> {\n\t\t// ...\n\t}\n\n}\n\n\napplicationcontext 中的所有 @jsoncomponent bean 都会自动注册到 jackson。因为 @jsoncomponent 是使用 @component 进行元注释的，所以通常的组件扫描规则适用。\n\nspring boot 还提供了 jsonobjectserializer 和 jsonobjectdeserializer 基类，它们在序列化对象时提供了标准 jackson 版本的有用替代方法。有关详细信息，请参阅 javadoc 中的 jsonobjectserializer 和 jsonobjectdeserializer。\n\n\n# @jsontest\n\n使用 @jsontest 可以很方便的在 spring boot 中测试序列化、反序列化。\n\n使用 @jsontest 相当于使用以下自动配置：\n\norg.springframework.boot.autoconfigure.cache.cacheautoconfiguration org.springframework.boot.autoconfigure.gson.gsonautoconfiguration org.springframework.boot.autoconfigure.jackson.jacksonautoconfiguration org.springframework.boot.autoconfigure.jsonb.jsonbautoconfiguration org.springframework.boot.test.autoconfigure.json.jsontestersautoconfiguration\n\n\n@jsontest 使用示例：\n\n想试试完整示例，可以参考：源码\n\n@jsontest\n@runwith(springrunner.class)\npublic class simplejsontest {\n\n    private final logger log = loggerfactory.getlogger(this.getclass());\n\n    @autowired\n    private jacksontester<infodto> json;\n\n    @test\n    public void testserialize() throws exception {\n        simpledateformat sdf = new simpledateformat("yyyy-mm-dd hh:mm:ss");\n        infodto infodto = new infodto("json测试应用", "1.0.0", sdf.parse("2019-01-01 12:00:00"));\n        jsoncontent<infodto> jsoncontent = json.write(infodto);\n        log.info("json content: {}", jsoncontent.getjson());\n        // 或者使用基于json path的校验\n        assertthat(jsoncontent).hasjsonpathstringvalue("@.appname");\n        assertthat(jsoncontent).extractingjsonpathstringvalue("@.appname").isequalto("json测试应用");\n        assertthat(jsoncontent).hasjsonpathstringvalue("@.version");\n        assertthat(jsoncontent).extractingjsonpathstringvalue("@.version").isequalto("1.0.0");\n        assertthat(jsoncontent).hasjsonpathstringvalue("@.date");\n        assertthat(jsoncontent).extractingjsonpathstringvalue("@.date").isequalto("2019-01-01 12:00:00");\n    }\n\n    @test\n    public void testdeserialize() throws exception {\n        string content = "{\\"appname\\":\\"json测试应用\\",\\"version\\":\\"1.0.0\\",\\"date\\":\\"2019-01-01\\"}";\n        infodto actual = json.parseobject(content);\n        assertthat(actual.getappname()).isequalto("json测试应用");\n        assertthat(actual.getversion()).isequalto("1.0.0");\n    }\n}\n\n\n\n# spring boot 中的 json 配置\n\n\n# jackson 配置\n\n当 spring boot 的 json 库为 jackson 时，可以使用以下配置属性（对应 jacksonproperties 类）：\n\nspring.jackson.date-format= # date format string or a fully-qualified date format class name. for instance, `yyyy-mm-dd hh:mm:ss`.\nspring.jackson.default-property-inclusion= # controls the inclusion of properties during serialization. configured with one of the values in jackson\'s jsoninclude.include enumeration.\nspring.jackson.deserialization.*= # jackson on/off features that affect the way java objects are deserialized.\nspring.jackson.generator.*= # jackson on/off features for generators.\nspring.jackson.joda-date-time-format= # joda date time format string. if not configured, "date-format" is used as a fallback if it is configured with a format string.\nspring.jackson.locale= # locale used for formatting.\nspring.jackson.mapper.*= # jackson general purpose on/off features.\nspring.jackson.parser.*= # jackson on/off features for parsers.\nspring.jackson.property-naming-strategy= # one of the constants on jackson\'s propertynamingstrategy. can also be a fully-qualified class name of a propertynamingstrategy subclass.\nspring.jackson.serialization.*= # jackson on/off features that affect the way java objects are serialized.\nspring.jackson.time-zone= #  time zone used when formatting dates. for instance, "america/los_angeles" or "gmt+10".\nspring.jackson.visibility.*= # jackson visibility thresholds that can be used to limit which methods (and fields) are auto-detected.\n\n\n\n# gson 配置\n\n当 spring boot 的 json 库为 gson 时，可以使用以下配置属性（对应 gsonproperties 类）：\n\nspring.gson.date-format= # format to use when serializing date objects.\nspring.gson.disable-html-escaping= # whether to disable the escaping of html characters such as \'<\', \'>\', etc.\nspring.gson.disable-inner-class-serialization= # whether to exclude inner classes during serialization.\nspring.gson.enable-complex-map-key-serialization= # whether to enable serialization of complex map keys (i.e. non-primitives).\nspring.gson.exclude-fields-without-expose-annotation= # whether to exclude all fields from consideration for serialization or deserialization that do not have the "expose" annotation.\nspring.gson.field-naming-policy= # naming policy that should be applied to an object\'s field during serialization and deserialization.\nspring.gson.generate-non-executable-json= # whether to generate non executable json by prefixing the output with some special text.\nspring.gson.lenient= # whether to be lenient about parsing json that doesn\'t conform to rfc 4627.\nspring.gson.long-serialization-policy= # serialization policy for long and long types.\nspring.gson.pretty-printing= # whether to output serialized json that fits in a page for pretty printing.\nspring.gson.serialize-nulls= # whether to serialize null fields.\n\n\n\n# spring boot 中使用 fastjson\n\n国内很多的 java 程序员更喜欢使用阿里的 fastjson 作为 json lib。那么，如何在 spring boot 中将其替换默认的 jackson 库呢？\n\n你需要做如下处理：\n\n（1）引入 fastjson jar 包：\n\n<dependency>\n\t<groupid>com.alibaba</groupid>\n\t<artifactid>fastjson</artifactid>\n\t<version>1.2.54</version>\n</dependency>\n\n\n（2）实现 webmvcconfigurer 接口，自定义 configuremessageconverters 接口。如下所示：\n\n@configuration\npublic class webmvcconfig implements webmvcconfigurer {\n\n    private final logger log = loggerfactory.getlogger(this.getclass());\n\n    /**\n     * 自定义消息转换器\n     * @param converters\n     */\n    @override\n    public void configuremessageconverters(list<httpmessageconverter<?>> converters) {\n        // 清除默认 json 转换器\n        converters.removeif(converter -> converter instanceof mappingjackson2httpmessageconverter);\n\n        // 配置 fastjson\n        fastjsonconfig config = new fastjsonconfig();\n        config.setserializerfeatures(serializerfeature.quotefieldnames, serializerfeature.writeenumusingtostring,\n            serializerfeature.writemapnullvalue, serializerfeature.writedateusedateformat,\n            serializerfeature.disablecircularreferencedetect);\n\n        // 添加 fastjsonhttpmessageconverter\n        fastjsonhttpmessageconverter fastjsonhttpmessageconverter = new fastjsonhttpmessageconverter();\n        fastjsonhttpmessageconverter.setfastjsonconfig(config);\n        list<mediatype> fastmediatypes = new arraylist<>();\n        fastmediatypes.add(mediatype.application_json_utf8);\n        fastjsonhttpmessageconverter.setsupportedmediatypes(fastmediatypes);\n        converters.add(fastjsonhttpmessageconverter);\n\n        // 添加 stringhttpmessageconverter，解决中文乱码问题\n        stringhttpmessageconverter stringhttpmessageconverter = new stringhttpmessageconverter(charset.forname("utf-8"));\n        converters.add(stringhttpmessageconverter);\n    }\n\n    // ...\n}\n\n\n\n# 示例源码\n\n完整示例：源码\n\n\n# 引申和引用\n\n引申\n\n * spring boot 教程\n\n引用\n\n * spring boot 官方文档之 boot-features-json',charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"SpringBoot 之发送邮件",frontmatter:{title:"SpringBoot 之发送邮件",date:"2019-11-20T15:20:44.000Z",order:3,categories:["Java","框架","Spring","SpringIO"],tags:["Java","框架","Spring","SpringBoot","邮件"],permalink:"/pages/2586f1/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/04.SpringIO/03.SpringBoot%E4%B9%8B%E9%82%AE%E4%BB%B6.html",relativePath:"01.Java/13.框架/01.Spring/04.SpringIO/03.SpringBoot之邮件.md",key:"v-5c0a26b0",path:"/pages/2586f1/",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:23},{level:2,title:"API",slug:"api",normalizedTitle:"api",charIndex:304},{level:2,title:"配置",slug:"配置",normalizedTitle:"配置",charIndex:414},{level:2,title:"实战",slug:"实战",normalizedTitle:"实战",charIndex:1591},{level:3,title:"引入依赖",slug:"引入依赖",normalizedTitle:"引入依赖",charIndex:1598},{level:3,title:"配置邮件属性",slug:"配置邮件属性",normalizedTitle:"配置邮件属性",charIndex:2200},{level:3,title:"Java 代码",slug:"java-代码",normalizedTitle:"java 代码",charIndex:2882},{level:2,title:"示例源码",slug:"示例源码",normalizedTitle:"示例源码",charIndex:6562},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:6596}],headersStr:"简介 API 配置 实战 引入依赖 配置邮件属性 Java 代码 示例源码 参考资料",content:'# SpringBoot 之发送邮件\n\n\n# 简介\n\nSpring Boot 收发邮件最简便方式是通过 spring-boot-starter-mail。\n\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-mail</artifactId>\n</dependency>\n\n\nspring-boot-starter-mail 本质上是使用 JavaMail(javax.mail)。如果想对 JavaMail 有进一步了解，可以参考： JavaMail 使用指南\n\n\n# API\n\nSpring Framework 提供了一个使用 JavaMailSender 接口发送电子邮件的简单抽象，这是发送邮件的核心 API。\n\nJavaMailSender 接口提供的 API 如下：\n\n\n\n\n# 配置\n\nSpring Boot 为 JavaMailSender 提供了自动配置以及启动器模块。\n\n如果 spring.mail.host 和相关库（由 spring-boot-starter-mail 定义）可用，则 Spring Boot 会创建默认 JavaMailSender（如果不存在）。可以通过 spring.mail 命名空间中的配置项进一步自定义发件人。 特别是，某些默认超时值是无限的，您可能希望更改它以避免线程被无响应的邮件服务器阻塞，如以下示例所示：\n\nspring.mail.properties.mail.smtp.connectiontimeout=5000\nspring.mail.properties.mail.smtp.timeout=3000\nspring.mail.properties.mail.smtp.writetimeout=5000\n\n\n也可以使用 JNDI 中的现有会话配置 JavaMailSender：\n\nspring.mail.jndi-name=mail/Session\n\n\n以下为 Spring Boot 关于 Mail 的配置：\n\n有关更多详细信息，请参阅 MailProperties。\n\n# Email (MailProperties)\nspring.mail.default-encoding=UTF-8 # Default MimeMessage encoding.\nspring.mail.host= # SMTP server host. For instance, `smtp.example.com`.\nspring.mail.jndi-name= # Session JNDI name. When set, takes precedence over other Session settings.\nspring.mail.password= # Login password of the SMTP server.\nspring.mail.port= # SMTP server port.\nspring.mail.properties.*= # Additional JavaMail Session properties.\nspring.mail.protocol=smtp # Protocol used by the SMTP server.\nspring.mail.test-connection=false # Whether to test that the mail server is available on startup.\nspring.mail.username= # Login user of the SMTP server.\n\n\n\n# 实战\n\n\n# 引入依赖\n\n<dependencies>\n  <dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-mail</artifactId>\n  </dependency>\n  <dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-test</artifactId>\n    <scope>test</scope>\n  </dependency>\n\n  <dependency>\n    <groupId>org.projectlombok</groupId>\n    <artifactId>lombok</artifactId>\n  </dependency>\n  <dependency>\n    <groupId>com.github.dozermapper</groupId>\n    <artifactId>dozer-spring-boot-starter</artifactId>\n    <version>6.4.0</version>\n  </dependency>\n</dependencies>\n\n\n\n# 配置邮件属性\n\n在 src/main/resources 目录下添加 application-163.properties 配置文件，内容如下：\n\nspring.mail.host = smtp.163.com\nspring.mail.username = xxxxxx\nspring.mail.password = xxxxxx\nspring.mail.properties.mail.smtp.auth = true\nspring.mail.properties.mail.smtp.starttls.enable = true\nspring.mail.properties.mail.smtp.starttls.required = true\nspring.mail.default-encoding = UTF-8\n\nmail.domain = 163.com\nmail.from = ${spring.mail.username}@${mail.domain}\n\n\n注：需替换有效的 spring.mail.username、spring.mail.password。\n\napplication-163.properties 配置文件表示使用 163 邮箱时的配置，为了使之生效，需要通过 spring.profiles.active = 163 来激活它。\n\n在 src/main/resources 目录下添加 application.properties 配置文件，内容如下：\n\nspring.profiles.active = 163\n\n\n\n# Java 代码\n\n首先，需要读取部分配置属性，方法如下：\n\nimport org.springframework.boot.context.properties.ConfigurationProperties;\nimport org.springframework.stereotype.Component;\nimport org.springframework.validation.annotation.Validated;\n\n@Validated\n@Component\n@ConfigurationProperties(prefix = "mail")\npublic class MailProperties {\n    private String domain;\n    private String from;\n\n    public String getDomain() {\n        return domain;\n    }\n\n    public void setDomain(String domain) {\n        this.domain = domain;\n    }\n\n    public String getFrom() {\n        return from;\n    }\n\n    public void setFrom(String from) {\n        this.from = from;\n    }\n}\n\n\n接着，定义一个邮件参数实体类（使用 lombok 简化了 getter、setter）：\n\nimport lombok.Data;\nimport java.util.Date;\n\n@Data\npublic class MailDTO {\n    private String from;\n    private String replyTo;\n    private String[] to;\n    private String[] cc;\n    private String[] bcc;\n    private Date sentDate;\n    private String subject;\n    private String text;\n    private String[] filenames;\n}\n\n\n接着，实现发送邮件的功能接口：\n\nimport com.github.dozermapper.core.Mapper;\nimport org.apache.commons.lang3.StringUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.mail.SimpleMailMessage;\nimport org.springframework.mail.javamail.JavaMailSender;\nimport org.springframework.mail.javamail.MimeMessageHelper;\nimport org.springframework.stereotype.Service;\n\nimport javax.mail.MessagingException;\nimport javax.mail.internet.MimeBodyPart;\nimport javax.mail.internet.MimeMessage;\nimport javax.mail.internet.MimeMultipart;\nimport java.io.IOException;\n\n@Service\npublic class MailService {\n\n    private final Logger log = LoggerFactory.getLogger(this.getClass());\n\n    @Autowired\n    private MailProperties mailProperties;\n\n    @Autowired\n    private JavaMailSender javaMailSender;\n\n    @Autowired\n    private Mapper mapper;\n\n    public void sendSimpleMailMessage(MailDTO mailDTO) {\n        SimpleMailMessage simpleMailMessage = mapper.map(mailDTO, SimpleMailMessage.class);\n        if (StringUtils.isEmpty(mailDTO.getFrom())) {\n            mailDTO.setFrom(mailProperties.getFrom());\n        }\n        javaMailSender.send(simpleMailMessage);\n    }\n\n    public void sendMimeMessage(MailDTO mailDTO) {\n\n        MimeMessage mimeMessage = javaMailSender.createMimeMessage();\n        MimeMessageHelper messageHelper;\n        try {\n            messageHelper = new MimeMessageHelper(mimeMessage, true);\n\n            if (StringUtils.isEmpty(mailDTO.getFrom())) {\n                messageHelper.setFrom(mailProperties.getFrom());\n            }\n            messageHelper.setTo(mailDTO.getTo());\n            messageHelper.setSubject(mailDTO.getSubject());\n\n            mimeMessage = messageHelper.getMimeMessage();\n            MimeBodyPart mimeBodyPart = new MimeBodyPart();\n            mimeBodyPart.setContent(mailDTO.getText(), "text/html;charset=UTF-8");\n\n            // 描述数据关系\n            MimeMultipart mm = new MimeMultipart();\n            mm.setSubType("related");\n            mm.addBodyPart(mimeBodyPart);\n\n            // 添加邮件附件\n            for (String filename : mailDTO.getFilenames()) {\n                MimeBodyPart attachPart = new MimeBodyPart();\n                try {\n                    attachPart.attachFile(filename);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                mm.addBodyPart(attachPart);\n            }\n            mimeMessage.setContent(mm);\n            mimeMessage.saveChanges();\n\n        } catch (MessagingException e) {\n            e.printStackTrace();\n        }\n\n        javaMailSender.send(mimeMessage);\n    }\n}\n\n\n\n# 示例源码\n\n> 示例源码：spring-boot-mail\n\n\n# 参考资料\n\n * Spring Boot 官方文档之 Sending Email',normalizedContent:'# springboot 之发送邮件\n\n\n# 简介\n\nspring boot 收发邮件最简便方式是通过 spring-boot-starter-mail。\n\n<dependency>\n  <groupid>org.springframework.boot</groupid>\n  <artifactid>spring-boot-starter-mail</artifactid>\n</dependency>\n\n\nspring-boot-starter-mail 本质上是使用 javamail(javax.mail)。如果想对 javamail 有进一步了解，可以参考： javamail 使用指南\n\n\n# api\n\nspring framework 提供了一个使用 javamailsender 接口发送电子邮件的简单抽象，这是发送邮件的核心 api。\n\njavamailsender 接口提供的 api 如下：\n\n\n\n\n# 配置\n\nspring boot 为 javamailsender 提供了自动配置以及启动器模块。\n\n如果 spring.mail.host 和相关库（由 spring-boot-starter-mail 定义）可用，则 spring boot 会创建默认 javamailsender（如果不存在）。可以通过 spring.mail 命名空间中的配置项进一步自定义发件人。 特别是，某些默认超时值是无限的，您可能希望更改它以避免线程被无响应的邮件服务器阻塞，如以下示例所示：\n\nspring.mail.properties.mail.smtp.connectiontimeout=5000\nspring.mail.properties.mail.smtp.timeout=3000\nspring.mail.properties.mail.smtp.writetimeout=5000\n\n\n也可以使用 jndi 中的现有会话配置 javamailsender：\n\nspring.mail.jndi-name=mail/session\n\n\n以下为 spring boot 关于 mail 的配置：\n\n有关更多详细信息，请参阅 mailproperties。\n\n# email (mailproperties)\nspring.mail.default-encoding=utf-8 # default mimemessage encoding.\nspring.mail.host= # smtp server host. for instance, `smtp.example.com`.\nspring.mail.jndi-name= # session jndi name. when set, takes precedence over other session settings.\nspring.mail.password= # login password of the smtp server.\nspring.mail.port= # smtp server port.\nspring.mail.properties.*= # additional javamail session properties.\nspring.mail.protocol=smtp # protocol used by the smtp server.\nspring.mail.test-connection=false # whether to test that the mail server is available on startup.\nspring.mail.username= # login user of the smtp server.\n\n\n\n# 实战\n\n\n# 引入依赖\n\n<dependencies>\n  <dependency>\n    <groupid>org.springframework.boot</groupid>\n    <artifactid>spring-boot-starter-mail</artifactid>\n  </dependency>\n  <dependency>\n    <groupid>org.springframework.boot</groupid>\n    <artifactid>spring-boot-starter-test</artifactid>\n    <scope>test</scope>\n  </dependency>\n\n  <dependency>\n    <groupid>org.projectlombok</groupid>\n    <artifactid>lombok</artifactid>\n  </dependency>\n  <dependency>\n    <groupid>com.github.dozermapper</groupid>\n    <artifactid>dozer-spring-boot-starter</artifactid>\n    <version>6.4.0</version>\n  </dependency>\n</dependencies>\n\n\n\n# 配置邮件属性\n\n在 src/main/resources 目录下添加 application-163.properties 配置文件，内容如下：\n\nspring.mail.host = smtp.163.com\nspring.mail.username = xxxxxx\nspring.mail.password = xxxxxx\nspring.mail.properties.mail.smtp.auth = true\nspring.mail.properties.mail.smtp.starttls.enable = true\nspring.mail.properties.mail.smtp.starttls.required = true\nspring.mail.default-encoding = utf-8\n\nmail.domain = 163.com\nmail.from = ${spring.mail.username}@${mail.domain}\n\n\n注：需替换有效的 spring.mail.username、spring.mail.password。\n\napplication-163.properties 配置文件表示使用 163 邮箱时的配置，为了使之生效，需要通过 spring.profiles.active = 163 来激活它。\n\n在 src/main/resources 目录下添加 application.properties 配置文件，内容如下：\n\nspring.profiles.active = 163\n\n\n\n# java 代码\n\n首先，需要读取部分配置属性，方法如下：\n\nimport org.springframework.boot.context.properties.configurationproperties;\nimport org.springframework.stereotype.component;\nimport org.springframework.validation.annotation.validated;\n\n@validated\n@component\n@configurationproperties(prefix = "mail")\npublic class mailproperties {\n    private string domain;\n    private string from;\n\n    public string getdomain() {\n        return domain;\n    }\n\n    public void setdomain(string domain) {\n        this.domain = domain;\n    }\n\n    public string getfrom() {\n        return from;\n    }\n\n    public void setfrom(string from) {\n        this.from = from;\n    }\n}\n\n\n接着，定义一个邮件参数实体类（使用 lombok 简化了 getter、setter）：\n\nimport lombok.data;\nimport java.util.date;\n\n@data\npublic class maildto {\n    private string from;\n    private string replyto;\n    private string[] to;\n    private string[] cc;\n    private string[] bcc;\n    private date sentdate;\n    private string subject;\n    private string text;\n    private string[] filenames;\n}\n\n\n接着，实现发送邮件的功能接口：\n\nimport com.github.dozermapper.core.mapper;\nimport org.apache.commons.lang3.stringutils;\nimport org.slf4j.logger;\nimport org.slf4j.loggerfactory;\nimport org.springframework.beans.factory.annotation.autowired;\nimport org.springframework.mail.simplemailmessage;\nimport org.springframework.mail.javamail.javamailsender;\nimport org.springframework.mail.javamail.mimemessagehelper;\nimport org.springframework.stereotype.service;\n\nimport javax.mail.messagingexception;\nimport javax.mail.internet.mimebodypart;\nimport javax.mail.internet.mimemessage;\nimport javax.mail.internet.mimemultipart;\nimport java.io.ioexception;\n\n@service\npublic class mailservice {\n\n    private final logger log = loggerfactory.getlogger(this.getclass());\n\n    @autowired\n    private mailproperties mailproperties;\n\n    @autowired\n    private javamailsender javamailsender;\n\n    @autowired\n    private mapper mapper;\n\n    public void sendsimplemailmessage(maildto maildto) {\n        simplemailmessage simplemailmessage = mapper.map(maildto, simplemailmessage.class);\n        if (stringutils.isempty(maildto.getfrom())) {\n            maildto.setfrom(mailproperties.getfrom());\n        }\n        javamailsender.send(simplemailmessage);\n    }\n\n    public void sendmimemessage(maildto maildto) {\n\n        mimemessage mimemessage = javamailsender.createmimemessage();\n        mimemessagehelper messagehelper;\n        try {\n            messagehelper = new mimemessagehelper(mimemessage, true);\n\n            if (stringutils.isempty(maildto.getfrom())) {\n                messagehelper.setfrom(mailproperties.getfrom());\n            }\n            messagehelper.setto(maildto.getto());\n            messagehelper.setsubject(maildto.getsubject());\n\n            mimemessage = messagehelper.getmimemessage();\n            mimebodypart mimebodypart = new mimebodypart();\n            mimebodypart.setcontent(maildto.gettext(), "text/html;charset=utf-8");\n\n            // 描述数据关系\n            mimemultipart mm = new mimemultipart();\n            mm.setsubtype("related");\n            mm.addbodypart(mimebodypart);\n\n            // 添加邮件附件\n            for (string filename : maildto.getfilenames()) {\n                mimebodypart attachpart = new mimebodypart();\n                try {\n                    attachpart.attachfile(filename);\n                } catch (ioexception e) {\n                    e.printstacktrace();\n                }\n                mm.addbodypart(attachpart);\n            }\n            mimemessage.setcontent(mm);\n            mimemessage.savechanges();\n\n        } catch (messagingexception e) {\n            e.printstacktrace();\n        }\n\n        javamailsender.send(mimemessage);\n    }\n}\n\n\n\n# 示例源码\n\n> 示例源码：spring-boot-mail\n\n\n# 参考资料\n\n * spring boot 官方文档之 sending email',charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Spring IO",frontmatter:{title:"Spring IO",date:"2022-09-18T11:34:00.000Z",categories:["Java","框架","Spring","SpringIO"],tags:["Java","框架","Spring","SpringBoot","IO"],permalink:"/pages/56581b/",hidden:!0,index:!1},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/04.SpringIO/",relativePath:"01.Java/13.框架/01.Spring/04.SpringIO/README.md",key:"v-69fdd354",path:"/pages/56581b/",headers:[{level:2,title:"📖 内容",slug:"📖-内容",normalizedTitle:"📖 内容",charIndex:16},{level:2,title:"📚 资料",slug:"📚-资料",normalizedTitle:"📚 资料",charIndex:86},{level:2,title:"🚪 传送",slug:"🚪-传送",normalizedTitle:"🚪 传送",charIndex:265}],headersStr:"📖 内容 📚 资料 🚪 传送",content:"# Spring IO\n\n\n# 📖 内容\n\n * SpringBoot 之异步请求\n * SpringBoot 之 Json\n * SpringBoot 之邮件\n\n\n# 📚 资料\n\n * 官方\n   * Spring 官网\n   * Spring Framework 官方文档\n   * Spring Github\n * 书籍\n   * 《Spring In Action》\n * 教程\n   * 《小马哥讲 Spring 核心编程思想》\n   * geekbang-lessons\n   * 跟我学 Spring3\n\n\n# 🚪 传送\n\n◾ 💧 钝悟的 IT 知识图谱 ◾ 🎯 我的博客 ◾",normalizedContent:"# spring io\n\n\n# 📖 内容\n\n * springboot 之异步请求\n * springboot 之 json\n * springboot 之邮件\n\n\n# 📚 资料\n\n * 官方\n   * spring 官网\n   * spring framework 官方文档\n   * spring github\n * 书籍\n   * 《spring in action》\n * 教程\n   * 《小马哥讲 spring 核心编程思想》\n   * geekbang-lessons\n   * 跟我学 spring3\n\n\n# 🚪 传送\n\n◾ 💧 钝悟的 it 知识图谱 ◾ 🎯 我的博客 ◾",charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Spring集成缓存",frontmatter:{title:"Spring集成缓存",date:"2017-11-08T16:53:27.000Z",order:1,categories:["Java","框架","Spring","Spring集成"],tags:["Java","框架","Spring","集成","缓存"],permalink:"/pages/a311cb/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/05.Spring%E9%9B%86%E6%88%90/01.Spring%E9%9B%86%E6%88%90%E7%BC%93%E5%AD%98.html",relativePath:"01.Java/13.框架/01.Spring/05.Spring集成/01.Spring集成缓存.md",key:"v-5a2a2041",path:"/pages/a311cb/",headers:[{level:2,title:"缓存接口",slug:"缓存接口",normalizedTitle:"缓存接口",charIndex:64},{level:3,title:"开启注解",slug:"开启注解",normalizedTitle:"开启注解",charIndex:108},{level:3,title:"缓存注解使用",slug:"缓存注解使用",normalizedTitle:"缓存注解使用",charIndex:398},{level:4,title:"@Cacheable",slug:"cacheable",normalizedTitle:"@cacheable",charIndex:515},{level:4,title:"@CachePut",slug:"cacheput",normalizedTitle:"@cacheput",charIndex:682},{level:4,title:"@CacheEvict",slug:"cacheevict",normalizedTitle:"@cacheevict",charIndex:767},{level:4,title:"@Caching",slug:"caching",normalizedTitle:"@caching",charIndex:1641},{level:4,title:"@CacheConfig",slug:"cacheconfig",normalizedTitle:"@cacheconfig",charIndex:1871},{level:2,title:"缓存存储",slug:"缓存存储",normalizedTitle:"缓存存储",charIndex:2094},{level:3,title:"使用 ConcurrentHashMap 作为缓存",slug:"使用-concurrenthashmap-作为缓存",normalizedTitle:"使用 concurrenthashmap 作为缓存",charIndex:2197},{level:3,title:"使用 Ehcache 作为缓存",slug:"使用-ehcache-作为缓存",normalizedTitle:"使用 ehcache 作为缓存",charIndex:3676},{level:3,title:"使用 Caffeine 作为缓存",slug:"使用-caffeine-作为缓存",normalizedTitle:"使用 caffeine 作为缓存",charIndex:5072},{level:2,title:"示例代码",slug:"示例代码",normalizedTitle:"示例代码",charIndex:6197},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:6250}],headersStr:"缓存接口 开启注解 缓存注解使用 @Cacheable @CachePut @CacheEvict @Caching @CacheConfig 缓存存储 使用 ConcurrentHashMap 作为缓存 使用 Ehcache 作为缓存 使用 Caffeine 作为缓存 示例代码 参考资料",content:'# Spring 集成缓存中间件\n\n> Spring 中提供了缓存功能的抽象，允许你在底层灵活的替换缓存实现，而对上层暴露相同的缓存接口。\n\n\n# 缓存接口\n\nSpring 的缓存 API 以注解方式提供。\n\n\n# 开启注解\n\nSpring 为缓存功能提供了注解功能，但是你必须启动注解。 你有两个选择： (1) 在 xml 中声明 像上一节 spring-ehcache.xml 中的做法一样，使用<cache:annotation-driven/>\n\n<cache:annotation-driven cache-manager="cacheManager"/>\n\n\n(2) 使用标记注解 你也可以通过对一个类进行注解修饰的方式在这个类中使用缓存注解。 范例如下：\n\n@Configuration\n@EnableCaching\npublic class AppConfig {\n}\n\n\n\n# 缓存注解使用\n\nSpring 对缓存的支持类似于对事务的支持。 首先使用注解标记方法，相当于定义了切点，然后使用 Aop 技术在这个方法的调用前、调用后获取方法的入参和返回值，进而实现了缓存的逻辑。 下面三个注解都是方法级别：\n\n# @Cacheable\n\n表明所修饰的方法是可以缓存的：当第一次调用这个方法时，它的结果会被缓存下来，在缓存的有效时间内，以后访问这个方法都直接返回缓存结果，不再执行方法中的代码段。 这个注解可以用condition属性来设置条件，如果不满足条件，就不使用缓存能力，直接执行方法。 可以使用key属性来指定 key 的生成规则。\n\n# @CachePut\n\n与@Cacheable不同，@CachePut不仅会缓存方法的结果，还会执行方法的代码段。 它支持的属性和用法都与@Cacheable一致。\n\n# @CacheEvict\n\n与@Cacheable功能相反，@CacheEvict表明所修饰的方法是用来删除失效或无用的缓存数据。 下面是@Cacheable、@CacheEvict和@CachePut基本使用方法的一个集中展示：\n\n@Service\npublic class UserService {\n    // @Cacheable可以设置多个缓存，形式如：@Cacheable({"books", "isbns"})\n    @Cacheable(value={"users"}, key="#user.id")\n    public User findUser(User user) {\n        return findUserInDB(user.getId());\n    }\n\n    @Cacheable(value = "users", condition = "#user.getId() <= 2")\n    public User findUserInLimit(User user) {\n        return findUserInDB(user.getId());\n    }\n\n    @CachePut(value = "users", key = "#user.getId()")\n    public void updateUser(User user) {\n        updateUserInDB(user);\n    }\n\n    @CacheEvict(value = "users")\n    public void removeUser(User user) {\n        removeUserInDB(user.getId());\n    }\n\n    @CacheEvict(value = "users", allEntries = true)\n    public void clear() {\n        removeAllInDB();\n    }\n}\n\n\n# @Caching\n\n如果需要使用同一个缓存注解（@Cacheable、@CacheEvict或@CachePut）多次修饰一个方法，就需要用到@Caching。\n\n@Caching(evict = { @CacheEvict("primary"), @CacheEvict(cacheNames="secondary", key="#p0") })\npublic Book importBooks(String deposit, Date date)\n\n\n# @CacheConfig\n\n与前面的缓存注解不同，这是一个类级别的注解。 如果类的所有操作都是缓存操作，你可以使用@CacheConfig来指定类，省去一些配置。\n\n@CacheConfig("books")\npublic class BookRepositoryImpl implements BookRepository {\n\t@Cacheable\n\tpublic Book findBook(ISBN isbn) {...}\n}\n\n\n\n# 缓存存储\n\nSpring 允许通过配置方式接入多种不同的缓存存储。用户可以根据实际需要选择。\n\n不同的缓存存储，具有不同的性能和特性，如果想了解具体原理，可以参考：全面理解缓存原理。这里不再赘述。\n\n\n# 使用 ConcurrentHashMap 作为缓存\n\n参考配置：\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xmlns:cache="http://www.springframework.org/schema/cache" xmlns:p="http://www.springframework.org/schema/p"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n         http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\n         http://www.springframework.org/schema/cache http://www.springframework.org/schema/cache/spring-cache.xsd">\n\n  <description>使用 ConcurrentHashMap 作为 Spring 缓存</description>\n\n  \x3c!--配置参考：https://docs.spring.io/spring/docs/current/spring-framework-reference/integration.html#cache-store-configuration--\x3e\n\n  <context:component-scan base-package="io.github.dunwu.spring.cache"/>\n\n  <bean id="simpleCacheManager" class="org.springframework.cache.support.SimpleCacheManager">\n    <property name="caches">\n      <set>\n        <bean class="org.springframework.cache.concurrent.ConcurrentMapCacheFactoryBean" p:name="default"/>\n        <bean class="org.springframework.cache.concurrent.ConcurrentMapCacheFactoryBean" p:name="users"/>\n      </set>\n    </property>\n  </bean>\n\n  <cache:annotation-driven cache-manager="simpleCacheManager"/>\n</beans>\n\n\n\n# 使用 Ehcache 作为缓存\n\n参考配置：\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xmlns:cache="http://www.springframework.org/schema/cache"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n         http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\n         http://www.springframework.org/schema/cache http://www.springframework.org/schema/cache/spring-cache.xsd">\n\n  <description>使用 EhCache 作为 Spring 缓存</description>\n\n  \x3c!--配置参考：https://docs.spring.io/spring/docs/current/spring-framework-reference/integration.html#cache-store-configuration--\x3e\n\n  <context:component-scan base-package="io.github.dunwu.spring.cache"/>\n\n  <bean id="ehcache" class="org.springframework.cache.ehcache.EhCacheManagerFactoryBean">\n    <property name="configLocation" value="classpath:ehcache/ehcache.xml"/>\n  </bean>\n\n  <bean id="ehcacheCacheManager" class="org.springframework.cache.ehcache.EhCacheCacheManager">\n    <property name="cacheManager" ref="ehcache"/>\n  </bean>\n\n  <cache:annotation-driven cache-manager="ehcacheCacheManager"/>\n</beans>\n\n\nehcache.xml 中的配置内容完全符合 Ehcache 的官方配置标准。\n\n\n# 使用 Caffeine 作为缓存\n\n参考配置：\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xmlns:cache="http://www.springframework.org/schema/cache"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n         http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\n         http://www.springframework.org/schema/cache http://www.springframework.org/schema/cache/spring-cache.xsd">\n\n  <description>使用 Caffeine 作为 Spring 缓存</description>\n\n  \x3c!--配置参考：https://docs.spring.io/spring/docs/current/spring-framework-reference/integration.html#cache-store-configuration--\x3e\n\n  <context:component-scan base-package="io.github.dunwu.spring.cache"/>\n\n  <bean id="caffeineCacheManager" class="org.springframework.cache.caffeine.CaffeineCacheManager"/>\n\n  <cache:annotation-driven cache-manager="caffeineCacheManager"/>\n</beans>\n\n\n\n# 示例代码\n\n我的示例代码地址：spring-tutorial-integration-cache\n\n\n# 参考资料\n\n * Spring 官方文档之缓存抽象\n * 注释驱动的 Spring cache 缓存介绍',normalizedContent:'# spring 集成缓存中间件\n\n> spring 中提供了缓存功能的抽象，允许你在底层灵活的替换缓存实现，而对上层暴露相同的缓存接口。\n\n\n# 缓存接口\n\nspring 的缓存 api 以注解方式提供。\n\n\n# 开启注解\n\nspring 为缓存功能提供了注解功能，但是你必须启动注解。 你有两个选择： (1) 在 xml 中声明 像上一节 spring-ehcache.xml 中的做法一样，使用<cache:annotation-driven/>\n\n<cache:annotation-driven cache-manager="cachemanager"/>\n\n\n(2) 使用标记注解 你也可以通过对一个类进行注解修饰的方式在这个类中使用缓存注解。 范例如下：\n\n@configuration\n@enablecaching\npublic class appconfig {\n}\n\n\n\n# 缓存注解使用\n\nspring 对缓存的支持类似于对事务的支持。 首先使用注解标记方法，相当于定义了切点，然后使用 aop 技术在这个方法的调用前、调用后获取方法的入参和返回值，进而实现了缓存的逻辑。 下面三个注解都是方法级别：\n\n# @cacheable\n\n表明所修饰的方法是可以缓存的：当第一次调用这个方法时，它的结果会被缓存下来，在缓存的有效时间内，以后访问这个方法都直接返回缓存结果，不再执行方法中的代码段。 这个注解可以用condition属性来设置条件，如果不满足条件，就不使用缓存能力，直接执行方法。 可以使用key属性来指定 key 的生成规则。\n\n# @cacheput\n\n与@cacheable不同，@cacheput不仅会缓存方法的结果，还会执行方法的代码段。 它支持的属性和用法都与@cacheable一致。\n\n# @cacheevict\n\n与@cacheable功能相反，@cacheevict表明所修饰的方法是用来删除失效或无用的缓存数据。 下面是@cacheable、@cacheevict和@cacheput基本使用方法的一个集中展示：\n\n@service\npublic class userservice {\n    // @cacheable可以设置多个缓存，形式如：@cacheable({"books", "isbns"})\n    @cacheable(value={"users"}, key="#user.id")\n    public user finduser(user user) {\n        return finduserindb(user.getid());\n    }\n\n    @cacheable(value = "users", condition = "#user.getid() <= 2")\n    public user finduserinlimit(user user) {\n        return finduserindb(user.getid());\n    }\n\n    @cacheput(value = "users", key = "#user.getid()")\n    public void updateuser(user user) {\n        updateuserindb(user);\n    }\n\n    @cacheevict(value = "users")\n    public void removeuser(user user) {\n        removeuserindb(user.getid());\n    }\n\n    @cacheevict(value = "users", allentries = true)\n    public void clear() {\n        removeallindb();\n    }\n}\n\n\n# @caching\n\n如果需要使用同一个缓存注解（@cacheable、@cacheevict或@cacheput）多次修饰一个方法，就需要用到@caching。\n\n@caching(evict = { @cacheevict("primary"), @cacheevict(cachenames="secondary", key="#p0") })\npublic book importbooks(string deposit, date date)\n\n\n# @cacheconfig\n\n与前面的缓存注解不同，这是一个类级别的注解。 如果类的所有操作都是缓存操作，你可以使用@cacheconfig来指定类，省去一些配置。\n\n@cacheconfig("books")\npublic class bookrepositoryimpl implements bookrepository {\n\t@cacheable\n\tpublic book findbook(isbn isbn) {...}\n}\n\n\n\n# 缓存存储\n\nspring 允许通过配置方式接入多种不同的缓存存储。用户可以根据实际需要选择。\n\n不同的缓存存储，具有不同的性能和特性，如果想了解具体原理，可以参考：全面理解缓存原理。这里不再赘述。\n\n\n# 使用 concurrenthashmap 作为缓存\n\n参考配置：\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xmlns:cache="http://www.springframework.org/schema/cache" xmlns:p="http://www.springframework.org/schema/p"\n       xsi:schemalocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n         http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\n         http://www.springframework.org/schema/cache http://www.springframework.org/schema/cache/spring-cache.xsd">\n\n  <description>使用 concurrenthashmap 作为 spring 缓存</description>\n\n  \x3c!--配置参考：https://docs.spring.io/spring/docs/current/spring-framework-reference/integration.html#cache-store-configuration--\x3e\n\n  <context:component-scan base-package="io.github.dunwu.spring.cache"/>\n\n  <bean id="simplecachemanager" class="org.springframework.cache.support.simplecachemanager">\n    <property name="caches">\n      <set>\n        <bean class="org.springframework.cache.concurrent.concurrentmapcachefactorybean" p:name="default"/>\n        <bean class="org.springframework.cache.concurrent.concurrentmapcachefactorybean" p:name="users"/>\n      </set>\n    </property>\n  </bean>\n\n  <cache:annotation-driven cache-manager="simplecachemanager"/>\n</beans>\n\n\n\n# 使用 ehcache 作为缓存\n\n参考配置：\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xmlns:cache="http://www.springframework.org/schema/cache"\n       xsi:schemalocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n         http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\n         http://www.springframework.org/schema/cache http://www.springframework.org/schema/cache/spring-cache.xsd">\n\n  <description>使用 ehcache 作为 spring 缓存</description>\n\n  \x3c!--配置参考：https://docs.spring.io/spring/docs/current/spring-framework-reference/integration.html#cache-store-configuration--\x3e\n\n  <context:component-scan base-package="io.github.dunwu.spring.cache"/>\n\n  <bean id="ehcache" class="org.springframework.cache.ehcache.ehcachemanagerfactorybean">\n    <property name="configlocation" value="classpath:ehcache/ehcache.xml"/>\n  </bean>\n\n  <bean id="ehcachecachemanager" class="org.springframework.cache.ehcache.ehcachecachemanager">\n    <property name="cachemanager" ref="ehcache"/>\n  </bean>\n\n  <cache:annotation-driven cache-manager="ehcachecachemanager"/>\n</beans>\n\n\nehcache.xml 中的配置内容完全符合 ehcache 的官方配置标准。\n\n\n# 使用 caffeine 作为缓存\n\n参考配置：\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xmlns:cache="http://www.springframework.org/schema/cache"\n       xsi:schemalocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n         http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\n         http://www.springframework.org/schema/cache http://www.springframework.org/schema/cache/spring-cache.xsd">\n\n  <description>使用 caffeine 作为 spring 缓存</description>\n\n  \x3c!--配置参考：https://docs.spring.io/spring/docs/current/spring-framework-reference/integration.html#cache-store-configuration--\x3e\n\n  <context:component-scan base-package="io.github.dunwu.spring.cache"/>\n\n  <bean id="caffeinecachemanager" class="org.springframework.cache.caffeine.caffeinecachemanager"/>\n\n  <cache:annotation-driven cache-manager="caffeinecachemanager"/>\n</beans>\n\n\n\n# 示例代码\n\n我的示例代码地址：spring-tutorial-integration-cache\n\n\n# 参考资料\n\n * spring 官方文档之缓存抽象\n * 注释驱动的 spring cache 缓存介绍',charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Spring 集成调度器",frontmatter:{title:"Spring 集成调度器",date:"2017-11-08T16:53:27.000Z",order:2,categories:["Java","框架","Spring","Spring集成"],tags:["Java","框架","Spring","集成","调度器"],permalink:"/pages/a187f0/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/05.Spring%E9%9B%86%E6%88%90/02.Spring%E9%9B%86%E6%88%90%E8%B0%83%E5%BA%A6%E5%99%A8.html",relativePath:"01.Java/13.框架/01.Spring/05.Spring集成/02.Spring集成调度器.md",key:"v-23820ebe",path:"/pages/a187f0/",headers:[{level:2,title:"概述",slug:"概述",normalizedTitle:"概述",charIndex:19},{level:2,title:"实时触发调度任务",slug:"实时触发调度任务",normalizedTitle:"实时触发调度任务",charIndex:140},{level:3,title:"TaskScheduler 接口",slug:"taskscheduler-接口",normalizedTitle:"taskscheduler 接口",charIndex:153},{level:4,title:"Trigger 接口",slug:"trigger-接口",normalizedTitle:"trigger 接口",charIndex:1106},{level:4,title:"完整范例",slug:"完整范例",normalizedTitle:"完整范例",charIndex:1368},{level:3,title:"@Scheduler 的使用方法",slug:"scheduler-的使用方法",normalizedTitle:"@scheduler 的使用方法",charIndex:3844},{level:4,title:"启动注解",slug:"启动注解",normalizedTitle:"启动注解",charIndex:3912},{level:4,title:"@Scheduler 定义触发条件",slug:"scheduler-定义触发条件",normalizedTitle:"@scheduler 定义触发条件",charIndex:4853},{level:4,title:"完整范例",slug:"完整范例-2",normalizedTitle:"完整范例",charIndex:1368},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:10462}],headersStr:"概述 实时触发调度任务 TaskScheduler 接口 Trigger 接口 完整范例 @Scheduler 的使用方法 启动注解 @Scheduler 定义触发条件 完整范例 参考",content:'# Spring 集成调度器\n\n\n# 概述\n\n如果想在 Spring 中使用任务调度功能，除了集成调度框架 Quartz 这种方式，也可以使用 Spring 自己的调度任务框架。 使用 Spring 的调度框架，优点是：支持注解@Scheduler，可以省去大量的配置。\n\n\n# 实时触发调度任务\n\n\n# TaskScheduler 接口\n\nSpring3 引入了TaskScheduler接口，这个接口定义了调度任务的抽象方法。 TaskScheduler 接口的声明：\n\npublic interface TaskScheduler {\n\n    ScheduledFuture schedule(Runnable task, Trigger trigger);\n\n    ScheduledFuture schedule(Runnable task, Date startTime);\n\n    ScheduledFuture scheduleAtFixedRate(Runnable task, Date startTime, long period);\n\n    ScheduledFuture scheduleAtFixedRate(Runnable task, long period);\n\n    ScheduledFuture scheduleWithFixedDelay(Runnable task, Date startTime, long delay);\n\n    ScheduledFuture scheduleWithFixedDelay(Runnable task, long delay);\n\n}\n\n\n从以上方法可以看出 TaskScheduler 有两类重要参数：\n\n * 一个是要调度的方法，即一个实现了 Runnable 接口的线程类的 run()方法；\n * 另一个就是触发条件。\n\nTaskScheduler 接口的实现类 它有三个实现类：DefaultManagedTaskScheduler、ThreadPoolTaskScheduler、TimerManagerTaskScheduler。 DefaultManagedTaskScheduler：基于 JNDI 的调度器。 TimerManagerTaskScheduler：托管commonj.timers.TimerManager实例的调度器。 ThreadPoolTaskScheduler：提供线程池管理的调度器，它也实现了TaskExecutor接口，从而使的单一的实例可以尽可能快地异步执行。\n\n# Trigger 接口\n\nTrigger 接口抽象了触发条件的方法。 Trigger 接口的声明：\n\npublic interface Trigger {\n    Date nextExecutionTime(TriggerContext triggerContext);\n}\n\n\nTrigger 接口的实现类 CronTrigger：实现了 cron 规则的触发器类（和 Quartz 的 cron 规则相同）。 PeriodicTrigger：实现了一个周期性规则的触发器类（例如：定义触发起始时间、间隔时间等）。\n\n# 完整范例\n\n实现一个调度任务的功能有以下几个关键点： (1) 定义调度器 在 spring-bean.xml 中进行配置 使用task:scheduler标签定义一个大小为 10 的线程池调度器，spring 会实例化一个ThreadPoolTaskScheduler。\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xmlns:mvc="http://www.springframework.org/schema/mvc"\n       xmlns:task="http://www.springframework.org/schema/task"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans-3.1.xsd\n       http://www.springframework.org/schema/mvc\n       http://www.springframework.org/schema/mvc/spring-mvc-3.1.xsd\n       http://www.springframework.org/schema/task\n       http://www.springframework.org/schema/task/spring-task-3.1.xsd">\n  <mvc:annotation-driven/>\n  <task:scheduler id="myScheduler" pool-size="10"/>\n</beans>\n\n\n注：不要忘记引入 xsd：\n\nhttp://www.springframework.org/schema/task\nhttp://www.springframework.org/schema/task/spring-task-3.1.xsd\n\n\n(2) 定义调度任务 定义实现Runnable接口的线程类。\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class DemoTask implements Runnable {\n    final Logger logger = LoggerFactory.getLogger(this.getClass());\n\n    @Override\n    public void run() {\n        logger.info("call DemoTask.run");\n    }\n}\n\n\n(3) 装配调度器，并执行调度任务 在一个Controller类中用@Autowired注解装配TaskScheduler。 然后调动 TaskScheduler 对象的 schedule 方法启动调度器，就可以执行调度任务了。\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.scheduling.TaskScheduler;\nimport org.springframework.scheduling.support.CronTrigger;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\n\n@Controller\n@RequestMapping("/scheduler")\npublic class SchedulerController {\n    @Autowired\n    TaskScheduler scheduler;\n\n    @RequestMapping(value = "/start", method = RequestMethod.POST)\n    public void start() {\n        scheduler.schedule(new DemoTask(), new CronTrigger("0/5 * * * * *"));\n    }\n}\n\n\n访问/scheduler/start 接口，启动调度器，可以看到如下日志内容：\n\n13:53:15.010 myScheduler-1 o.zp.notes.spring.scheduler.DemoTask.run - call DemoTask.run\n13:53:20.003 myScheduler-1 o.zp.notes.spring.scheduler.DemoTask.run - call DemoTask.run\n13:53:25.004 myScheduler-2 o.zp.notes.spring.scheduler.DemoTask.run - call DemoTask.run\n13:53:30.005 myScheduler-1 o.zp.notes.spring.scheduler.DemoTask.run - call DemoTask.run\n\n\n\n# @Scheduler 的使用方法\n\nSpring 的调度器一个很大的亮点在于@Scheduler注解，这可以省去很多繁琐的配置。\n\n# 启动注解\n\n使用@Scheduler 注解先要使用<task:annotation-driven>启动注解开关。 例：\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xmlns:mvc="http://www.springframework.org/schema/mvc"\n       xmlns:task="http://www.springframework.org/schema/task"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans-3.1.xsd\n       http://www.springframework.org/schema/mvc\n       http://www.springframework.org/schema/mvc/spring-mvc-3.1.xsd\n       http://www.springframework.org/schema/task\n       http://www.springframework.org/schema/task/spring-task-3.1.xsd">\n  <mvc:annotation-driven/>\n  <task:annotation-driven executor="myExecutor" scheduler="myScheduler"/>\n  <task:executor id="myExecutor" pool-size="5"/>\n  <task:scheduler id="myScheduler" pool-size="10"/>\n</beans>\n\n\n# @Scheduler 定义触发条件\n\n例：使用fixedDelay指定触发条件为每 5000 毫秒执行一次。注意：必须在上一次调度成功后的 5000 秒才能执行。\n\n@Scheduled(fixedDelay=5000)\npublic void doSomething() {\n    // something that should execute periodically\n}\n\n\n例：使用fixedRate指定触发条件为每 5000 毫秒执行一次。注意：无论上一次调度是否成功，5000 秒后必然执行。\n\n@Scheduled(fixedRate=5000)\npublic void doSomething() {\n    // something that should execute periodically\n}\n\n\n例：使用initialDelay指定方法在初始化 1000 毫秒后才开始调度。\n\n@Scheduled(initialDelay=1000, fixedRate=5000)\npublic void doSomething() {\n    // something that should execute periodically\n}\n\n\n例：使用cron表达式指定触发条件为每 5000 毫秒执行一次。cron 规则和 Quartz 中的 cron 规则一致。\n\n@Scheduled(cron="*/5 * * * * MON-FRI")\npublic void doSomething() {\n    // something that should execute on weekdays only\n}\n\n\n# 完整范例\n\n(1) 启动注解开关，并定义调度器和执行器\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xmlns:mvc="http://www.springframework.org/schema/mvc"\n       xmlns:task="http://www.springframework.org/schema/task"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans-3.1.xsd\n       http://www.springframework.org/schema/mvc\n       http://www.springframework.org/schema/mvc/spring-mvc-3.1.xsd\n       http://www.springframework.org/schema/task\n       http://www.springframework.org/schema/task/spring-task-3.1.xsd">\n\n  <mvc:annotation-driven/>\n  <task:annotation-driven executor="myExecutor" scheduler="myScheduler"/>\n  <task:executor id="myExecutor" pool-size="5"/>\n  <task:scheduler id="myScheduler" pool-size="10"/>\n</beans>\n\n\n(2) 使用@Scheduler 注解来修饰一个要调度的方法 下面的例子展示了@Scheduler 注解定义触发条件的不同方式。\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.scheduling.annotation.Scheduled;\nimport org.springframework.stereotype.Component;\n\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\n/**\n * @description 使用@Scheduler注解调度任务范例\n * @author Vicotr Zhang\n * @date 2016年8月31日\n */\n@Component\npublic class ScheduledMgr {\n    private final SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");\n\n    final Logger logger = LoggerFactory.getLogger(this.getClass());\n\n    /**\n     * 构造函数中打印初始化时间\n     */\n    public ScheduledMgr() {\n        logger.info("Current time: {}", dateFormat.format(new Date()));\n    }\n\n    /**\n     * fixedDelay属性定义调度间隔时间。调度需要等待上一次调度执行完成。\n     */\n    @Scheduled(fixedDelay = 5000)\n    public void testFixedDelay() throws Exception {\n        Thread.sleep(6000);\n        logger.info("Current time: {}", dateFormat.format(new Date()));\n    }\n\n    /**\n     * fixedRate属性定义调度间隔时间。调度不等待上一次调度执行完成。\n     */\n    @Scheduled(fixedRate = 5000)\n    public void testFixedRate() throws Exception {\n        Thread.sleep(6000);\n        logger.info("Current time: {}", dateFormat.format(new Date()));\n    }\n\n    /**\n     * initialDelay属性定义初始化后的启动延迟时间\n     */\n    @Scheduled(initialDelay = 1000, fixedRate = 5000)\n    public void testInitialDelay() throws Exception {\n        Thread.sleep(6000);\n        logger.info("Current time: {}", dateFormat.format(new Date()));\n    }\n\n    /**\n     * cron属性支持使用cron表达式定义触发条件\n     */\n    @Scheduled(cron = "0/5 * * * * ?")\n    public void testCron() throws Exception {\n        Thread.sleep(6000);\n        logger.info("Current time: {}", dateFormat.format(new Date()));\n    }\n}\n\n\n我刻意设置触发方式的间隔都是 5s，且方法中均有 Thread.sleep(6000);语句。从而确保方法在下一次调度触发时间点前无法完成执行，来看一看各种方式的表现吧。 启动 spring 项目后，spring 会扫描@Component注解，然后初始化 ScheduledMgr。 接着，spring 会扫描@Scheduler注解，初始化调度器。调度器在触发条件匹配的情况下开始工作，输出日志。 截取部分打印日志来进行分析。\n\n10:58:46.479 localhost-startStop-1 o.z.n.s.scheduler.ScheduledTasks.<init> - Current time: 2016-08-31 10:58:46\n10:58:52.523 myScheduler-1 o.z.n.s.scheduler.ScheduledTasks.testFixedRate - Current time: 2016-08-31 10:58:52\n10:58:52.523 myScheduler-3 o.z.n.s.scheduler.ScheduledTasks.testFixedDelay - Current time: 2016-08-31 10:58:52\n10:58:53.524 myScheduler-2 o.z.n.s.scheduler.ScheduledTasks.testInitialDelay - Current time: 2016-08-31 10:58:53\n10:58:55.993 myScheduler-4 o.z.n.s.scheduler.ScheduledTasks.testCron - Current time: 2016-08-31 10:58:55\n10:58:58.507 myScheduler-1 o.z.n.s.scheduler.ScheduledTasks.testFixedRate - Current time: 2016-08-31 10:58:58\n10:58:59.525 myScheduler-5 o.z.n.s.scheduler.ScheduledTasks.testInitialDelay - Current time: 2016-08-31 10:58:59\n10:59:03.536 myScheduler-3 o.z.n.s.scheduler.ScheduledTasks.testFixedDelay - Current time: 2016-08-31 10:59:03\n10:59:04.527 myScheduler-1 o.z.n.s.scheduler.ScheduledTasks.testFixedRate - Current time: 2016-08-31 10:59:04\n10:59:05.527 myScheduler-4 o.z.n.s.scheduler.ScheduledTasks.testInitialDelay - Current time: 2016-08-31 10:59:05\n10:59:06.032 myScheduler-2 o.z.n.s.scheduler.ScheduledTasks.testCron - Current time: 2016-08-31 10:59:06\n10:59:10.534 myScheduler-9 o.z.n.s.scheduler.ScheduledTasks.testFixedRate - Current time: 2016-08-31 10:59:10\n10:59:11.527 myScheduler-10 o.z.n.s.scheduler.ScheduledTasks.testInitialDelay - Current time: 2016-08-31 10:59:11\n10:59:14.524 myScheduler-4 o.z.n.s.scheduler.ScheduledTasks.testFixedDelay - Current time: 2016-08-31 10:59:14\n10:59:15.987 myScheduler-6 o.z.n.s.scheduler.ScheduledTasks.testCron - Current time: 2016-08-31 10:59:15\n\n\n构造方法打印一次，时间点在 10:58:46。 testFixedRate 打印四次，每次间隔 6 秒。说明，fixedRate 不等待上一次调度执行完成，在间隔时间达到时立即执行。 testFixedDelay 打印三次，每次间隔大于 6 秒，且时间不固定。说明，fixedDelay 等待上一次调度执行成功后，开始计算间隔时间，再执行。 testInitialDelay 第一次调度时间和构造方法调度时间相隔 7 秒。说明，initialDelay 在初始化后等待指定的延迟时间才开始调度。 testCron 打印三次，时间间隔并非 5 秒或 6 秒，显然，cron 等待上一次调度执行成功后，开始计算间隔时间，再执行。 此外，可以从日志中看出，打印日志的线程最多只有 10 个，说明 2.1 中的调度器线程池配置生效。\n\n\n# 参考\n\nSpring Framework 官方文档',normalizedContent:'# spring 集成调度器\n\n\n# 概述\n\n如果想在 spring 中使用任务调度功能，除了集成调度框架 quartz 这种方式，也可以使用 spring 自己的调度任务框架。 使用 spring 的调度框架，优点是：支持注解@scheduler，可以省去大量的配置。\n\n\n# 实时触发调度任务\n\n\n# taskscheduler 接口\n\nspring3 引入了taskscheduler接口，这个接口定义了调度任务的抽象方法。 taskscheduler 接口的声明：\n\npublic interface taskscheduler {\n\n    scheduledfuture schedule(runnable task, trigger trigger);\n\n    scheduledfuture schedule(runnable task, date starttime);\n\n    scheduledfuture scheduleatfixedrate(runnable task, date starttime, long period);\n\n    scheduledfuture scheduleatfixedrate(runnable task, long period);\n\n    scheduledfuture schedulewithfixeddelay(runnable task, date starttime, long delay);\n\n    scheduledfuture schedulewithfixeddelay(runnable task, long delay);\n\n}\n\n\n从以上方法可以看出 taskscheduler 有两类重要参数：\n\n * 一个是要调度的方法，即一个实现了 runnable 接口的线程类的 run()方法；\n * 另一个就是触发条件。\n\ntaskscheduler 接口的实现类 它有三个实现类：defaultmanagedtaskscheduler、threadpooltaskscheduler、timermanagertaskscheduler。 defaultmanagedtaskscheduler：基于 jndi 的调度器。 timermanagertaskscheduler：托管commonj.timers.timermanager实例的调度器。 threadpooltaskscheduler：提供线程池管理的调度器，它也实现了taskexecutor接口，从而使的单一的实例可以尽可能快地异步执行。\n\n# trigger 接口\n\ntrigger 接口抽象了触发条件的方法。 trigger 接口的声明：\n\npublic interface trigger {\n    date nextexecutiontime(triggercontext triggercontext);\n}\n\n\ntrigger 接口的实现类 crontrigger：实现了 cron 规则的触发器类（和 quartz 的 cron 规则相同）。 periodictrigger：实现了一个周期性规则的触发器类（例如：定义触发起始时间、间隔时间等）。\n\n# 完整范例\n\n实现一个调度任务的功能有以下几个关键点： (1) 定义调度器 在 spring-bean.xml 中进行配置 使用task:scheduler标签定义一个大小为 10 的线程池调度器，spring 会实例化一个threadpooltaskscheduler。\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n       xmlns:mvc="http://www.springframework.org/schema/mvc"\n       xmlns:task="http://www.springframework.org/schema/task"\n       xsi:schemalocation="http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans-3.1.xsd\n       http://www.springframework.org/schema/mvc\n       http://www.springframework.org/schema/mvc/spring-mvc-3.1.xsd\n       http://www.springframework.org/schema/task\n       http://www.springframework.org/schema/task/spring-task-3.1.xsd">\n  <mvc:annotation-driven/>\n  <task:scheduler id="myscheduler" pool-size="10"/>\n</beans>\n\n\n注：不要忘记引入 xsd：\n\nhttp://www.springframework.org/schema/task\nhttp://www.springframework.org/schema/task/spring-task-3.1.xsd\n\n\n(2) 定义调度任务 定义实现runnable接口的线程类。\n\nimport org.slf4j.logger;\nimport org.slf4j.loggerfactory;\n\npublic class demotask implements runnable {\n    final logger logger = loggerfactory.getlogger(this.getclass());\n\n    @override\n    public void run() {\n        logger.info("call demotask.run");\n    }\n}\n\n\n(3) 装配调度器，并执行调度任务 在一个controller类中用@autowired注解装配taskscheduler。 然后调动 taskscheduler 对象的 schedule 方法启动调度器，就可以执行调度任务了。\n\nimport org.springframework.beans.factory.annotation.autowired;\nimport org.springframework.scheduling.taskscheduler;\nimport org.springframework.scheduling.support.crontrigger;\nimport org.springframework.stereotype.controller;\nimport org.springframework.web.bind.annotation.requestmapping;\nimport org.springframework.web.bind.annotation.requestmethod;\n\n@controller\n@requestmapping("/scheduler")\npublic class schedulercontroller {\n    @autowired\n    taskscheduler scheduler;\n\n    @requestmapping(value = "/start", method = requestmethod.post)\n    public void start() {\n        scheduler.schedule(new demotask(), new crontrigger("0/5 * * * * *"));\n    }\n}\n\n\n访问/scheduler/start 接口，启动调度器，可以看到如下日志内容：\n\n13:53:15.010 myscheduler-1 o.zp.notes.spring.scheduler.demotask.run - call demotask.run\n13:53:20.003 myscheduler-1 o.zp.notes.spring.scheduler.demotask.run - call demotask.run\n13:53:25.004 myscheduler-2 o.zp.notes.spring.scheduler.demotask.run - call demotask.run\n13:53:30.005 myscheduler-1 o.zp.notes.spring.scheduler.demotask.run - call demotask.run\n\n\n\n# @scheduler 的使用方法\n\nspring 的调度器一个很大的亮点在于@scheduler注解，这可以省去很多繁琐的配置。\n\n# 启动注解\n\n使用@scheduler 注解先要使用<task:annotation-driven>启动注解开关。 例：\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n       xmlns:mvc="http://www.springframework.org/schema/mvc"\n       xmlns:task="http://www.springframework.org/schema/task"\n       xsi:schemalocation="http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans-3.1.xsd\n       http://www.springframework.org/schema/mvc\n       http://www.springframework.org/schema/mvc/spring-mvc-3.1.xsd\n       http://www.springframework.org/schema/task\n       http://www.springframework.org/schema/task/spring-task-3.1.xsd">\n  <mvc:annotation-driven/>\n  <task:annotation-driven executor="myexecutor" scheduler="myscheduler"/>\n  <task:executor id="myexecutor" pool-size="5"/>\n  <task:scheduler id="myscheduler" pool-size="10"/>\n</beans>\n\n\n# @scheduler 定义触发条件\n\n例：使用fixeddelay指定触发条件为每 5000 毫秒执行一次。注意：必须在上一次调度成功后的 5000 秒才能执行。\n\n@scheduled(fixeddelay=5000)\npublic void dosomething() {\n    // something that should execute periodically\n}\n\n\n例：使用fixedrate指定触发条件为每 5000 毫秒执行一次。注意：无论上一次调度是否成功，5000 秒后必然执行。\n\n@scheduled(fixedrate=5000)\npublic void dosomething() {\n    // something that should execute periodically\n}\n\n\n例：使用initialdelay指定方法在初始化 1000 毫秒后才开始调度。\n\n@scheduled(initialdelay=1000, fixedrate=5000)\npublic void dosomething() {\n    // something that should execute periodically\n}\n\n\n例：使用cron表达式指定触发条件为每 5000 毫秒执行一次。cron 规则和 quartz 中的 cron 规则一致。\n\n@scheduled(cron="*/5 * * * * mon-fri")\npublic void dosomething() {\n    // something that should execute on weekdays only\n}\n\n\n# 完整范例\n\n(1) 启动注解开关，并定义调度器和执行器\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n\n       xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n       xmlns:mvc="http://www.springframework.org/schema/mvc"\n       xmlns:task="http://www.springframework.org/schema/task"\n       xsi:schemalocation="http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans-3.1.xsd\n       http://www.springframework.org/schema/mvc\n       http://www.springframework.org/schema/mvc/spring-mvc-3.1.xsd\n       http://www.springframework.org/schema/task\n       http://www.springframework.org/schema/task/spring-task-3.1.xsd">\n\n  <mvc:annotation-driven/>\n  <task:annotation-driven executor="myexecutor" scheduler="myscheduler"/>\n  <task:executor id="myexecutor" pool-size="5"/>\n  <task:scheduler id="myscheduler" pool-size="10"/>\n</beans>\n\n\n(2) 使用@scheduler 注解来修饰一个要调度的方法 下面的例子展示了@scheduler 注解定义触发条件的不同方式。\n\nimport org.slf4j.logger;\nimport org.slf4j.loggerfactory;\nimport org.springframework.scheduling.annotation.scheduled;\nimport org.springframework.stereotype.component;\n\nimport java.text.simpledateformat;\nimport java.util.date;\n\n/**\n * @description 使用@scheduler注解调度任务范例\n * @author vicotr zhang\n * @date 2016年8月31日\n */\n@component\npublic class scheduledmgr {\n    private final simpledateformat dateformat = new simpledateformat("yyyy-mm-dd hh:mm:ss");\n\n    final logger logger = loggerfactory.getlogger(this.getclass());\n\n    /**\n     * 构造函数中打印初始化时间\n     */\n    public scheduledmgr() {\n        logger.info("current time: {}", dateformat.format(new date()));\n    }\n\n    /**\n     * fixeddelay属性定义调度间隔时间。调度需要等待上一次调度执行完成。\n     */\n    @scheduled(fixeddelay = 5000)\n    public void testfixeddelay() throws exception {\n        thread.sleep(6000);\n        logger.info("current time: {}", dateformat.format(new date()));\n    }\n\n    /**\n     * fixedrate属性定义调度间隔时间。调度不等待上一次调度执行完成。\n     */\n    @scheduled(fixedrate = 5000)\n    public void testfixedrate() throws exception {\n        thread.sleep(6000);\n        logger.info("current time: {}", dateformat.format(new date()));\n    }\n\n    /**\n     * initialdelay属性定义初始化后的启动延迟时间\n     */\n    @scheduled(initialdelay = 1000, fixedrate = 5000)\n    public void testinitialdelay() throws exception {\n        thread.sleep(6000);\n        logger.info("current time: {}", dateformat.format(new date()));\n    }\n\n    /**\n     * cron属性支持使用cron表达式定义触发条件\n     */\n    @scheduled(cron = "0/5 * * * * ?")\n    public void testcron() throws exception {\n        thread.sleep(6000);\n        logger.info("current time: {}", dateformat.format(new date()));\n    }\n}\n\n\n我刻意设置触发方式的间隔都是 5s，且方法中均有 thread.sleep(6000);语句。从而确保方法在下一次调度触发时间点前无法完成执行，来看一看各种方式的表现吧。 启动 spring 项目后，spring 会扫描@component注解，然后初始化 scheduledmgr。 接着，spring 会扫描@scheduler注解，初始化调度器。调度器在触发条件匹配的情况下开始工作，输出日志。 截取部分打印日志来进行分析。\n\n10:58:46.479 localhost-startstop-1 o.z.n.s.scheduler.scheduledtasks.<init> - current time: 2016-08-31 10:58:46\n10:58:52.523 myscheduler-1 o.z.n.s.scheduler.scheduledtasks.testfixedrate - current time: 2016-08-31 10:58:52\n10:58:52.523 myscheduler-3 o.z.n.s.scheduler.scheduledtasks.testfixeddelay - current time: 2016-08-31 10:58:52\n10:58:53.524 myscheduler-2 o.z.n.s.scheduler.scheduledtasks.testinitialdelay - current time: 2016-08-31 10:58:53\n10:58:55.993 myscheduler-4 o.z.n.s.scheduler.scheduledtasks.testcron - current time: 2016-08-31 10:58:55\n10:58:58.507 myscheduler-1 o.z.n.s.scheduler.scheduledtasks.testfixedrate - current time: 2016-08-31 10:58:58\n10:58:59.525 myscheduler-5 o.z.n.s.scheduler.scheduledtasks.testinitialdelay - current time: 2016-08-31 10:58:59\n10:59:03.536 myscheduler-3 o.z.n.s.scheduler.scheduledtasks.testfixeddelay - current time: 2016-08-31 10:59:03\n10:59:04.527 myscheduler-1 o.z.n.s.scheduler.scheduledtasks.testfixedrate - current time: 2016-08-31 10:59:04\n10:59:05.527 myscheduler-4 o.z.n.s.scheduler.scheduledtasks.testinitialdelay - current time: 2016-08-31 10:59:05\n10:59:06.032 myscheduler-2 o.z.n.s.scheduler.scheduledtasks.testcron - current time: 2016-08-31 10:59:06\n10:59:10.534 myscheduler-9 o.z.n.s.scheduler.scheduledtasks.testfixedrate - current time: 2016-08-31 10:59:10\n10:59:11.527 myscheduler-10 o.z.n.s.scheduler.scheduledtasks.testinitialdelay - current time: 2016-08-31 10:59:11\n10:59:14.524 myscheduler-4 o.z.n.s.scheduler.scheduledtasks.testfixeddelay - current time: 2016-08-31 10:59:14\n10:59:15.987 myscheduler-6 o.z.n.s.scheduler.scheduledtasks.testcron - current time: 2016-08-31 10:59:15\n\n\n构造方法打印一次，时间点在 10:58:46。 testfixedrate 打印四次，每次间隔 6 秒。说明，fixedrate 不等待上一次调度执行完成，在间隔时间达到时立即执行。 testfixeddelay 打印三次，每次间隔大于 6 秒，且时间不固定。说明，fixeddelay 等待上一次调度执行成功后，开始计算间隔时间，再执行。 testinitialdelay 第一次调度时间和构造方法调度时间相隔 7 秒。说明，initialdelay 在初始化后等待指定的延迟时间才开始调度。 testcron 打印三次，时间间隔并非 5 秒或 6 秒，显然，cron 等待上一次调度执行成功后，开始计算间隔时间，再执行。 此外，可以从日志中看出，打印日志的线程最多只有 10 个，说明 2.1 中的调度器线程池配置生效。\n\n\n# 参考\n\nspring framework 官方文档',charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Spring集成Dubbo",frontmatter:{title:"Spring集成Dubbo",date:"2017-10-27T17:30:41.000Z",order:3,categories:["Java","框架","Spring","Spring集成"],tags:["Java","框架","Spring","集成","Dubbo"],permalink:"/pages/274fd7/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/05.Spring%E9%9B%86%E6%88%90/03.Spring%E9%9B%86%E6%88%90Dubbo.html",relativePath:"01.Java/13.框架/01.Spring/05.Spring集成/03.Spring集成Dubbo.md",key:"v-e127b82a",path:"/pages/274fd7/",headers:[{level:2,title:"ZooKeeper",slug:"zookeeper",normalizedTitle:"zookeeper",charIndex:22},{level:2,title:"Dubbo",slug:"dubbo",normalizedTitle:"dubbo",charIndex:12},{level:2,title:"服务提供者",slug:"服务提供者",normalizedTitle:"服务提供者",charIndex:1347},{level:3,title:"定义服务接口",slug:"定义服务接口",normalizedTitle:"定义服务接口",charIndex:1377},{level:3,title:"在服务提供方实现接口",slug:"在服务提供方实现接口",normalizedTitle:"在服务提供方实现接口",charIndex:1511},{level:3,title:"用 Spring 配置声明暴露服务",slug:"用-spring-配置声明暴露服务",normalizedTitle:"用 spring 配置声明暴露服务",charIndex:1775},{level:3,title:"加载 Spring 配置",slug:"加载-spring-配置",normalizedTitle:"加载 spring 配置",charIndex:2841},{level:2,title:"服务消费者",slug:"服务消费者",normalizedTitle:"服务消费者",charIndex:3263},{level:3,title:"通过 Spring 配置引用远程服务",slug:"通过-spring-配置引用远程服务",normalizedTitle:"通过 spring 配置引用远程服务",charIndex:3293},{level:3,title:"加载 Spring 配置，并调用远程服务",slug:"加载-spring-配置-并调用远程服务",normalizedTitle:"加载 spring 配置，并调用远程服务",charIndex:4213},{level:2,title:"FAQ",slug:"faq",normalizedTitle:"faq",charIndex:4919},{level:2,title:"资料",slug:"资料",normalizedTitle:"资料",charIndex:4970}],headersStr:"ZooKeeper Dubbo 服务提供者 定义服务接口 在服务提供方实现接口 用 Spring 配置声明暴露服务 加载 Spring 配置 服务消费者 通过 Spring 配置引用远程服务 加载 Spring 配置，并调用远程服务 FAQ 资料",content:'# Spring 集成 Dubbo\n\n\n# ZooKeeper\n\nZooKeeper 可以作为 Dubbo 的注册中心。\n\nDubbo 未对 Zookeeper 服务器端做任何侵入修改，只需安装原生的 Zookeeper 服务器即可，所有注册中心逻辑适配都在调用 Zookeeper 客户端时完成。\n\n安装\n\n在 ZooKeeper 发布中心 选择需要的版本，下载后解压到本地。\n\n配置\n\nvi conf/zoo.cfg\n\n\n\n如果不需要集群，zoo.cfg 的内容如下 2：\n\ntickTime=2000\ninitLimit=10\nsyncLimit=5\ndataDir=/home/dubbo/zookeeper-3.3.3/data\nclientPort=2181\n\n\n如果需要集群，zoo.cfg 的内容如下 3：\n\ntickTime=2000\ninitLimit=10\nsyncLimit=5\ndataDir=/home/dubbo/zookeeper-3.3.3/data\nclientPort=2181\nserver.1=10.20.153.10:2555:3555\nserver.2=10.20.153.11:2555:3555\n\n\n\n并在 data 目录 4 下放置 myid 文件：\n\nmkdir data\nvi myid\n\n\n\nmyid 指明自己的 id，对应上面 zoo.cfg 中 server. 后的数字，第一台的内容为 1，第二台的内容为 2，内容如下：\n\n1\n\n\n\n启动\n\nLinux 下执行 bin/zkServer.sh ；Windows bin/zkServer.cmd 启动 ZooKeeper 。\n\n命令行\n\ntelnet 127.0.0.1 2181\ndump\n\n\n或者:\n\necho dump | nc 127.0.0.1 2181\n\n\n用法:\n\ndubbo.registry.address=zookeeper://10.20.153.10:2181?backup=10.20.153.11:2181\n\n\n\n或者:\n\n<dubbo:registry protocol="zookeeper" address="10.20.153.10:2181,10.20.153.11:2181" />\n\n\n\n>  1. Zookeeper 是 Apache Hadoop 的子项目，强度相对较好，建议生产环境使用该注册中心\n>  2. 其中 data 目录需改成你真实输出目录\n>  3. 其中 data 目录和 server 地址需改成你真实部署机器的信息\n>  4. 上面 zoo.cfg 中的 dataDir\n>  5. http://zookeeper.apache.org/doc/r3.3.3/zookeeperAdmin.html\n\n\n# Dubbo\n\nDubbo 采用全 Spring 配置方式，透明化接入应用，对应用没有任何 API 侵入，只需用 Spring 加载 Dubbo 的配置即可，Dubbo 基于 Spring 的 Schema 扩展进行加载。\n\n如果不想使用 Spring 配置，可以通过 API 的方式 进行调用。\n\n\n# 服务提供者\n\n完整安装步骤，请参见：示例提供者安装\n\n\n# 定义服务接口\n\nDemoService.java 1：\n\npackage com.alibaba.dubbo.demo;\n\npublic interface DemoService {\n    String sayHello(String name);\n}\n\n\n\n# 在服务提供方实现接口\n\nDemoServiceImpl.java 2：\n\npackage com.alibaba.dubbo.demo.provider;\n\nimport com.alibaba.dubbo.demo.DemoService;\n\npublic class DemoServiceImpl implements DemoService {\n    public String sayHello(String name) {\n        return "Hello " + name;\n    }\n}\n\n\n\n# 用 Spring 配置声明暴露服务\n\nprovider.xml：\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n    xmlns:dubbo="http://code.alibabatech.com/schema/dubbo"\n    xsi:schemaLocation="http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://code.alibabatech.com/schema/dubbo        http://code.alibabatech.com/schema/dubbo/dubbo.xsd">\n\n    \x3c!-- 提供方应用信息，用于计算依赖关系 --\x3e\n    <dubbo:application name="hello-world-app"  />\n\n    \x3c!-- 使用multicast广播注册中心暴露服务地址 --\x3e\n    <dubbo:registry address="multicast://224.5.6.7:1234" />\n\n    \x3c!-- 用dubbo协议在20880端口暴露服务 --\x3e\n    <dubbo:protocol name="dubbo" port="20880" />\n\n    \x3c!-- 声明需要暴露的服务接口 --\x3e\n    <dubbo:service interface="com.alibaba.dubbo.demo.DemoService" ref="demoService" />\n\n    \x3c!-- 和本地bean一样实现服务 --\x3e\n    <bean id="demoService" class="com.alibaba.dubbo.demo.provider.DemoServiceImpl" />\n</beans>\n\n\n如果注册中心使用 ZooKeeper，可以将 dubbo:registry 改为 zookeeper://127.0.0.1:2181\n\n\n# 加载 Spring 配置\n\nProvider.java：\n\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n\npublic class Provider {\n    public static void main(String[] args) throws Exception {\n        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(new String[] {"http://10.20.160.198/wiki/display/dubbo/provider.xml"});\n        context.start();\n        System.in.read(); // 按任意键退出\n    }\n}\n\n\n\n# 服务消费者\n\n完整安装步骤，请参见：示例消费者安装\n\n\n# 通过 Spring 配置引用远程服务\n\nconsumer.xml：\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n    xmlns:dubbo="http://code.alibabatech.com/schema/dubbo"\n    xsi:schemaLocation="http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://code.alibabatech.com/schema/dubbo        http://code.alibabatech.com/schema/dubbo/dubbo.xsd">\n\n    \x3c!-- 消费方应用名，用于计算依赖关系，不是匹配条件，不要与提供方一样 --\x3e\n    <dubbo:application name="consumer-of-helloworld-app"  />\n\n    \x3c!-- 使用multicast广播注册中心暴露发现服务地址 --\x3e\n    <dubbo:registry address="multicast://224.5.6.7:1234" />\n\n    \x3c!-- 生成远程服务代理，可以和本地bean一样使用demoService --\x3e\n    <dubbo:reference id="demoService" interface="com.alibaba.dubbo.demo.DemoService" />\n</beans>\n\n\n如果注册中心使用 ZooKeeper，可以将 dubbo:registry 改为 zookeeper://127.0.0.1:2181\n\n\n# 加载 Spring 配置，并调用远程服务\n\nConsumer.java 3：\n\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\nimport com.alibaba.dubbo.demo.DemoService;\n\npublic class Consumer {\n    public static void main(String[] args) throws Exception {\n        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(new String[] {"http://10.20.160.198/wiki/display/dubbo/consumer.xml"});\n        context.start();\n        DemoService demoService = (DemoService)context.getBean("demoService"); // 获取远程服务代理\n        String hello = demoService.sayHello("world"); // 执行远程方法\n        System.out.println( hello ); // 显示调用结果\n    }\n}\n\n\n>  1. 该接口需单独打包，在服务提供方和消费方共享\n>  2. 对服务消费方隐藏实现\n>  3. 也可以使用 IoC 注入\n\n\n# FAQ\n\n建议使用 dubbo-2.3.3 以上版本的 zookeeper 注册中心客户端。\n\n\n# 资料\n\nDubbo\n\nGithub | 用户手册 | 开发手册 | 管理员手册\n\nZooKeeper\n\n官网 | 官方文档',normalizedContent:'# spring 集成 dubbo\n\n\n# zookeeper\n\nzookeeper 可以作为 dubbo 的注册中心。\n\ndubbo 未对 zookeeper 服务器端做任何侵入修改，只需安装原生的 zookeeper 服务器即可，所有注册中心逻辑适配都在调用 zookeeper 客户端时完成。\n\n安装\n\n在 zookeeper 发布中心 选择需要的版本，下载后解压到本地。\n\n配置\n\nvi conf/zoo.cfg\n\n\n\n如果不需要集群，zoo.cfg 的内容如下 2：\n\nticktime=2000\ninitlimit=10\nsynclimit=5\ndatadir=/home/dubbo/zookeeper-3.3.3/data\nclientport=2181\n\n\n如果需要集群，zoo.cfg 的内容如下 3：\n\nticktime=2000\ninitlimit=10\nsynclimit=5\ndatadir=/home/dubbo/zookeeper-3.3.3/data\nclientport=2181\nserver.1=10.20.153.10:2555:3555\nserver.2=10.20.153.11:2555:3555\n\n\n\n并在 data 目录 4 下放置 myid 文件：\n\nmkdir data\nvi myid\n\n\n\nmyid 指明自己的 id，对应上面 zoo.cfg 中 server. 后的数字，第一台的内容为 1，第二台的内容为 2，内容如下：\n\n1\n\n\n\n启动\n\nlinux 下执行 bin/zkserver.sh ；windows bin/zkserver.cmd 启动 zookeeper 。\n\n命令行\n\ntelnet 127.0.0.1 2181\ndump\n\n\n或者:\n\necho dump | nc 127.0.0.1 2181\n\n\n用法:\n\ndubbo.registry.address=zookeeper://10.20.153.10:2181?backup=10.20.153.11:2181\n\n\n\n或者:\n\n<dubbo:registry protocol="zookeeper" address="10.20.153.10:2181,10.20.153.11:2181" />\n\n\n\n>  1. zookeeper 是 apache hadoop 的子项目，强度相对较好，建议生产环境使用该注册中心\n>  2. 其中 data 目录需改成你真实输出目录\n>  3. 其中 data 目录和 server 地址需改成你真实部署机器的信息\n>  4. 上面 zoo.cfg 中的 datadir\n>  5. http://zookeeper.apache.org/doc/r3.3.3/zookeeperadmin.html\n\n\n# dubbo\n\ndubbo 采用全 spring 配置方式，透明化接入应用，对应用没有任何 api 侵入，只需用 spring 加载 dubbo 的配置即可，dubbo 基于 spring 的 schema 扩展进行加载。\n\n如果不想使用 spring 配置，可以通过 api 的方式 进行调用。\n\n\n# 服务提供者\n\n完整安装步骤，请参见：示例提供者安装\n\n\n# 定义服务接口\n\ndemoservice.java 1：\n\npackage com.alibaba.dubbo.demo;\n\npublic interface demoservice {\n    string sayhello(string name);\n}\n\n\n\n# 在服务提供方实现接口\n\ndemoserviceimpl.java 2：\n\npackage com.alibaba.dubbo.demo.provider;\n\nimport com.alibaba.dubbo.demo.demoservice;\n\npublic class demoserviceimpl implements demoservice {\n    public string sayhello(string name) {\n        return "hello " + name;\n    }\n}\n\n\n\n# 用 spring 配置声明暴露服务\n\nprovider.xml：\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n    xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n    xmlns:dubbo="http://code.alibabatech.com/schema/dubbo"\n    xsi:schemalocation="http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://code.alibabatech.com/schema/dubbo        http://code.alibabatech.com/schema/dubbo/dubbo.xsd">\n\n    \x3c!-- 提供方应用信息，用于计算依赖关系 --\x3e\n    <dubbo:application name="hello-world-app"  />\n\n    \x3c!-- 使用multicast广播注册中心暴露服务地址 --\x3e\n    <dubbo:registry address="multicast://224.5.6.7:1234" />\n\n    \x3c!-- 用dubbo协议在20880端口暴露服务 --\x3e\n    <dubbo:protocol name="dubbo" port="20880" />\n\n    \x3c!-- 声明需要暴露的服务接口 --\x3e\n    <dubbo:service interface="com.alibaba.dubbo.demo.demoservice" ref="demoservice" />\n\n    \x3c!-- 和本地bean一样实现服务 --\x3e\n    <bean id="demoservice" class="com.alibaba.dubbo.demo.provider.demoserviceimpl" />\n</beans>\n\n\n如果注册中心使用 zookeeper，可以将 dubbo:registry 改为 zookeeper://127.0.0.1:2181\n\n\n# 加载 spring 配置\n\nprovider.java：\n\nimport org.springframework.context.support.classpathxmlapplicationcontext;\n\npublic class provider {\n    public static void main(string[] args) throws exception {\n        classpathxmlapplicationcontext context = new classpathxmlapplicationcontext(new string[] {"http://10.20.160.198/wiki/display/dubbo/provider.xml"});\n        context.start();\n        system.in.read(); // 按任意键退出\n    }\n}\n\n\n\n# 服务消费者\n\n完整安装步骤，请参见：示例消费者安装\n\n\n# 通过 spring 配置引用远程服务\n\nconsumer.xml：\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n    xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n    xmlns:dubbo="http://code.alibabatech.com/schema/dubbo"\n    xsi:schemalocation="http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://code.alibabatech.com/schema/dubbo        http://code.alibabatech.com/schema/dubbo/dubbo.xsd">\n\n    \x3c!-- 消费方应用名，用于计算依赖关系，不是匹配条件，不要与提供方一样 --\x3e\n    <dubbo:application name="consumer-of-helloworld-app"  />\n\n    \x3c!-- 使用multicast广播注册中心暴露发现服务地址 --\x3e\n    <dubbo:registry address="multicast://224.5.6.7:1234" />\n\n    \x3c!-- 生成远程服务代理，可以和本地bean一样使用demoservice --\x3e\n    <dubbo:reference id="demoservice" interface="com.alibaba.dubbo.demo.demoservice" />\n</beans>\n\n\n如果注册中心使用 zookeeper，可以将 dubbo:registry 改为 zookeeper://127.0.0.1:2181\n\n\n# 加载 spring 配置，并调用远程服务\n\nconsumer.java 3：\n\nimport org.springframework.context.support.classpathxmlapplicationcontext;\nimport com.alibaba.dubbo.demo.demoservice;\n\npublic class consumer {\n    public static void main(string[] args) throws exception {\n        classpathxmlapplicationcontext context = new classpathxmlapplicationcontext(new string[] {"http://10.20.160.198/wiki/display/dubbo/consumer.xml"});\n        context.start();\n        demoservice demoservice = (demoservice)context.getbean("demoservice"); // 获取远程服务代理\n        string hello = demoservice.sayhello("world"); // 执行远程方法\n        system.out.println( hello ); // 显示调用结果\n    }\n}\n\n\n>  1. 该接口需单独打包，在服务提供方和消费方共享\n>  2. 对服务消费方隐藏实现\n>  3. 也可以使用 ioc 注入\n\n\n# faq\n\n建议使用 dubbo-2.3.3 以上版本的 zookeeper 注册中心客户端。\n\n\n# 资料\n\ndubbo\n\ngithub | 用户手册 | 开发手册 | 管理员手册\n\nzookeeper\n\n官网 | 官方文档',charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Spring 集成",frontmatter:{title:"Spring 集成",date:"2020-02-26T23:47:47.000Z",categories:["Java","框架","Spring","Spring集成"],tags:["Java","框架","Spring","SpringBoot","集成"],permalink:"/pages/d6025b/",hidden:!0,index:!1},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/05.Spring%E9%9B%86%E6%88%90/",relativePath:"01.Java/13.框架/01.Spring/05.Spring集成/README.md",key:"v-4f10fdce",path:"/pages/d6025b/",headers:[{level:2,title:"📖 内容",slug:"📖-内容",normalizedTitle:"📖 内容",charIndex:74},{level:2,title:"📚 资料",slug:"📚-资料",normalizedTitle:"📚 资料",charIndex:142},{level:2,title:"🚪 传送",slug:"🚪-传送",normalizedTitle:"🚪 传送",charIndex:321}],headersStr:"📖 内容 📚 资料 🚪 传送",content:"# Spring 集成\n\n> 章节主要针对：Spring 与第三方框架、库集成。如：Cache、Scheduling、JMS、JMX 等。\n\n\n# 📖 内容\n\n * Spring 集成缓存中间件\n * Spring 集成定时任务中间件\n * Spring 集成 Dubbo\n\n\n# 📚 资料\n\n * 官方\n   * Spring 官网\n   * Spring Framework 官方文档\n   * Spring Github\n * 书籍\n   * 《Spring In Action》\n * 教程\n   * 《小马哥讲 Spring 核心编程思想》\n   * geekbang-lessons\n   * 跟我学 Spring3\n\n\n# 🚪 传送\n\n◾ 💧 钝悟的 IT 知识图谱 ◾ 🎯 我的博客 ◾",normalizedContent:"# spring 集成\n\n> 章节主要针对：spring 与第三方框架、库集成。如：cache、scheduling、jms、jmx 等。\n\n\n# 📖 内容\n\n * spring 集成缓存中间件\n * spring 集成定时任务中间件\n * spring 集成 dubbo\n\n\n# 📚 资料\n\n * 官方\n   * spring 官网\n   * spring framework 官方文档\n   * spring github\n * 书籍\n   * 《spring in action》\n * 教程\n   * 《小马哥讲 spring 核心编程思想》\n   * geekbang-lessons\n   * 跟我学 spring3\n\n\n# 🚪 传送\n\n◾ 💧 钝悟的 it 知识图谱 ◾ 🎯 我的博客 ◾",charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"SpringBoot 之安全快速入门",frontmatter:{title:"SpringBoot 之安全快速入门",date:"2021-05-13T18:21:56.000Z",order:1,categories:["Java","框架","Spring","Spring安全"],tags:["Java","框架","Spring","SpringBoot","安全"],permalink:"/pages/568352/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/10.Spring%E5%AE%89%E5%85%A8/01.SpringBoot%E4%B9%8B%E5%AE%89%E5%85%A8%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8.html",relativePath:"01.Java/13.框架/01.Spring/10.Spring安全/01.SpringBoot之安全快速入门.md",key:"v-ca8d6204",path:"/pages/568352/",headers:[{level:2,title:"QuickStart",slug:"quickstart",normalizedTitle:"quickstart",charIndex:25}],headersStr:"QuickStart",content:"# SpringBoot 之安全快速入门\n\n\n# QuickStart\n\n（1）添加依赖\n\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-web</artifactId>\n\t\t</dependency>\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-security</artifactId>\n\t\t</dependency>\n\n\n（2）添加配置\n\nspring.security.user.name = root\nspring.security.user.password = root\nspring.security.user.roles = USER\n\n\n（3）启动应用后，访问任意路径，都会出现以下页面，提示你先执行登录操作。输入配置的用户名、密码（root/root）即可访问应用页面。\n\n",normalizedContent:"# springboot 之安全快速入门\n\n\n# quickstart\n\n（1）添加依赖\n\n\t\t<dependency>\n\t\t\t<groupid>org.springframework.boot</groupid>\n\t\t\t<artifactid>spring-boot-starter-web</artifactid>\n\t\t</dependency>\n\t\t<dependency>\n\t\t\t<groupid>org.springframework.boot</groupid>\n\t\t\t<artifactid>spring-boot-starter-security</artifactid>\n\t\t</dependency>\n\n\n（2）添加配置\n\nspring.security.user.name = root\nspring.security.user.password = root\nspring.security.user.roles = user\n\n\n（3）启动应用后，访问任意路径，都会出现以下页面，提示你先执行登录操作。输入配置的用户名、密码（root/root）即可访问应用页面。\n\n",charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Spring 4 升级踩雷指南",frontmatter:{title:"Spring 4 升级踩雷指南",date:"2017-12-15T15:10:32.000Z",order:1,categories:["Java","框架","Spring","Spring其他"],tags:["Java","框架","Spring"],permalink:"/pages/752c6a/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/99.Spring%E5%85%B6%E4%BB%96/01.Spring4%E5%8D%87%E7%BA%A7.html",relativePath:"01.Java/13.框架/01.Spring/99.Spring其他/01.Spring4升级.md",key:"v-f62f294c",path:"/pages/752c6a/",headers:[{level:2,title:"前言",slug:"前言",normalizedTitle:"前言",charIndex:22},{level:2,title:"为什么升级 spring4",slug:"为什么升级-spring4",normalizedTitle:"为什么升级 spring4",charIndex:186},{level:2,title:"spring 4 重要新特性",slug:"spring-4-重要新特性",normalizedTitle:"spring 4 重要新特性",charIndex:471},{level:2,title:"升级 spring 4 步骤",slug:"升级-spring-4-步骤",normalizedTitle:"升级 spring 4 步骤",charIndex:873},{level:3,title:"修改 spring 版本",slug:"修改-spring-版本",normalizedTitle:"修改 spring 版本",charIndex:1090},{level:3,title:"修改 spring xml 文件的 xsd",slug:"修改-spring-xml-文件的-xsd",normalizedTitle:"修改 spring xml 文件的 xsd",charIndex:1435},{level:3,title:"修改 spring xml 文件",slug:"修改-spring-xml-文件",normalizedTitle:"修改 spring xml 文件",charIndex:1435},{level:4,title:"ref local",slug:"ref-local",normalizedTitle:"ref local",charIndex:3727},{level:3,title:"加入 spring support",slug:"加入-spring-support",normalizedTitle:"加入 spring support",charIndex:4390},{level:3,title:"更换 spring-mvc jackson",slug:"更换-spring-mvc-jackson",normalizedTitle:"更换 spring-mvc jackson",charIndex:4653},{level:3,title:"解决 ibatis 兼容问题",slug:"解决-ibatis-兼容问题",normalizedTitle:"解决 ibatis 兼容问题",charIndex:5669},{level:3,title:"升级 Dubbo",slug:"升级-dubbo",normalizedTitle:"升级 dubbo",charIndex:6055},{level:3,title:"升级 Jedis",slug:"升级-jedis",normalizedTitle:"升级 jedis",charIndex:6767},{level:2,title:"资料",slug:"资料",normalizedTitle:"资料",charIndex:8114}],headersStr:"前言 为什么升级 spring4 spring 4 重要新特性 升级 spring 4 步骤 修改 spring 版本 修改 spring xml 文件的 xsd 修改 spring xml 文件 ref local 加入 spring support 更换 spring-mvc jackson 解决 ibatis 兼容问题 升级 Dubbo 升级 Jedis 资料",content:'# Spring 4 升级踩雷指南\n\n\n# 前言\n\n最近，一直在为公司老项目做核心库升级工作。本来只是想升级一下 JDK8 ，却因为兼容性问题而不得不升级一些其他的库，而其他库本身依赖的一些库可能也要同步升级。这是一系列连锁问题，你很难一一识别，往往只有在编译时、运行时才能发现问题。\n\n总之，这是个费劲的活啊。\n\n本文小结一下升级 Spring4 的连锁问题。\n\n\n# 为什么升级 spring4\n\n升级 Spring4 的原因是：Spring 4 以前的版本不兼容 JDK8。当你的项目同时使用 Spring3 和 JDK8，如果代码中有使用 JDK8 字节码或 Lambada 表达式，那么会出问题。\n\n也许你会问，为什么不使用最新的 Spring 5 呢？因为作为企业软件，一般更倾向使用稳定的版本（bug 少），而不是最新的版本，尤其是一些核心库。\n\n更多细节可以参考：\n\nhttps://spring.io/blog/2013/05/21/spring-framework-4-0-m1-3-2-3-available/\n\n\n# spring 4 重要新特性\n\nSpring 4 相比 Spring 3，引入许多新特性，这里列举几条较为重要的：\n\n 1. 支持 JDK8 （这个是最主要的）。\n 2. Groovy Bean Definition DSL 风格配置。\n 3. 支持 WebSocket、SockJS、STOMP 消息\n 4. 移除 Deprecated 包和方法\n 5. 一些功能加强，如：核心容器、Web、Test 等等，不一一列举。\n\n更多 Spring 4 新特性可以参考：\n\nhttps://docs.spring.io/spring/docs/4.3.14.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/#spring-whats-new\n\nhttp://jinnianshilongnian.iteye.com/blog/1995111\n\n\n# 升级 spring 4 步骤\n\n了解了前面内容，我们知道了升级 Spring 4 带来的好处。现在开始真刀真枪的升级了。\n\n不要以为升级一下 Spring 4，仅仅是改一下版本号，那么简单，细节处多着呢。\n\n下面，结合我在公司项目升级 Spring4 时遇到的一系列坑，希望能帮助各位少走弯路。\n\n> 注\n> \n> 下文内容基于假设你的项目是用 maven 管理这一前提。如果不满足这一前提，那么这篇文章对你没什么太大帮助。\n\n\n# 修改 spring 版本\n\n第一步，当然是修改 pom.xml 中的 spring 版本。\n\n3.x.x.RELEASE > 4.x.x.RELEASE\n\n实例：升级 spring-core\n\n其它 spring 库的升级也如此：\n\n<properties>\n  <spring.version>4.3.13.RELEASE</spring.version>\n</properties>\n<dependency>\n  <groupId>org.springframework</groupId>\n  <artifactId>spring-core</artifactId>\n  <version>${spring.version}</version>\n</dependency>\n\n\n\n# 修改 spring xml 文件的 xsd\n\n用过 spring 的都知道，spring 通常依赖于大量的 xml 配置。\n\nspring 的 xml 解析器在解析 xml 时，需要读取 xml schema，schema 定义了 xml 的命名空间。它的好处在于可以避免命名冲突，有点像 Java 中的 package。\n\n实例：一个 spring xml 的 schema\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:util="http://www.springframework.org/schema/util" xmlns:context="http://www.springframework.org/schema/context"\n\txmlns:mvc="http://www.springframework.org/schema/mvc"\n\txsi:schemaLocation="http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.1.xsd\n\t\thttp://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd\n\t\thttp://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-3.1.xsd\n\t\thttp://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd">\n\n\n> 说明\n> \n>  * xmlns="http://www.springframework.org/schema/beans" 声明 xml 文件默认的命名空间，表示未使用其他命名空间的所有标签的默认命名空间。\n> \n>  * xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 声明 XML Schema 实例，声明后就可以使用 schemaLocation 属性了。\n> \n>  * xmlns:mvc="http://www.springframework.org/schema/mvc" 声明前缀为 mvc 的命名空间，后面的 URL 用于标示命名空间的地址不会被解析器用于查找信息。其惟一的作用是赋予命名空间一个惟一的名称。当命名空间被定义在元素的开始标签中时，所有带有相同前缀的子元素都会与同一个命名空间相关联。 其它的类似 xmlns:context 、xmlns:jdbc 等等同样如此。\n> \n>  * xsi:schemaLocation="http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.1.xsd\n>    ..."\n>    \n>    \n>    这个从命名可以看出个大概，指定 schema 位置这个属性必须结合命名空间使用。这个属性有两个值，第一个值表示需要使用的命名空间。第二个值表示供命名空间使用的 xml schema 的位置。\n\n上面示例中的 xsd 版本是 3.1.xsd ，表示 spring 的 xml 解析器会将其视为 3.1 版本的 xml 文件来处理。\n\n现在，我们使用了 Spring 4，3.1.xsd 版本显然就不正确了，我们可以根据自己引入的 Spring 4 的子版本号将其改为 4.x.xsd 。\n\n但是，还有一种更好的做法：把这个指定 xsd 版本的关键字干掉，类似这样：http://www.springframework.org/schema/tx/spring-tx.xsd 。\n\n这么做的原因如下：\n\n * Spring 默认在启动时要加载 xsd 文件来验证 xml 文件。\n * 如果没有提供 schemaLocation，那么 spring 的 xml 解析器会从 namespace 的 uri 里加载 xsd 文件。\n * schemaLocation 提供了一个 xml namespace 到对应的 xsd 文件的一个映射。\n * 如果不指定 spring xsd 的版本号，spring 取的就是当前本地 jar 里的 xsd 文件，减少了各种风险（比如 xsd 与实际 spring jar 版本不一致）。\n\n更多详细内容可以参考这篇文章：为什么在 Spring 的配置里，最好不要配置 xsd 文件的版本号\n\n\n# 修改 spring xml 文件\n\nspring 4 对 xml 做了一些改动。这里说一个最常用的改动：\n\n# ref local\n\nspring 不再支持 ref 元素的 local 属性，如果你的项目中使用了，需要改为 bean。\n\nshi\n\nspring 4 以前：\n\n<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">\n  <property name="dataSource">\n    <ref local="dataSource" />\n  </property>\n</bean>\n\n\nspring 4 以后：\n\n<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">\n  <property name="dataSource">\n    <ref bean="dataSource" />\n  </property>\n</bean>\n\n\n如果不改启动会报错：\n\nCaused by: org.xml.sax.SAXParseException: cvc-complex-type.3.2.2: Attribute \'local\' is not allowed to appear in element \'ref\'.\n\n\n当然，可能还有一些其他配置改动，这个只能说兵来将挡水来土掩，遇到了再去查官方文档吧。\n\n\n# 加入 spring support\n\nspring 3 中很多的扩展内容不需要引入 support 。但是 spring 4 中分离的更彻底了，如果不分离，会有很多ClassNotFound 。\n\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-context-support</artifactId>\n    <version>4.2.3.RELEASE</version>\n</dependency>\n\n\n\n# 更换 spring-mvc jackson\n\nspring mvc 中如果返回结果为 json 需要依赖 jackson 的 jar 包，但是他升级到了 2, 以前是 codehaus.jackson，现在换成了 fasterxml.jackson\n\n<dependency>\n    <groupId>com.fasterxml.jackson.core</groupId>\n    <artifactId>jackson-core</artifactId>\n    <version>2.7.0</version>\n</dependency>\n<dependency>\n    <groupId>com.fasterxml.jackson.core</groupId>\n    <artifactId>jackson-databind</artifactId>\n    <version>2.7.0</version>\n</dependency>\n\n\n同时修改 spring mvc 的配置文件：\n\n<bean\n\tclass="org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter">\n\t<property name="messageConverters">\n\t\t<list>\n\t\t\t <ref bean="stringHttpMessageConverter" />\n\t\t\t<bean\n\t\t\t\tclass="org.springframework.http.converter.json.MappingJackson2HttpMessageConverter">\n\t\t\t</bean>\n\t\t</list>\n\t</property>\n</bean>\n\n<bean id="stringHttpMessageConverter"\n\tclass="org.springframework.http.converter.StringHttpMessageConverter">\n\t<property name="supportedMediaTypes">\n\t\t<list>\n\t\t\t<value>text/plain;charset=UTF-8</value>\n\t\t</list>\n\t</property>\n</bean>\n\n\n\n# 解决 ibatis 兼容问题\n\n问题\n\n如果你的项目中使用了 ibatis (mybatis 的前身)这个 orm 框架，当 spring3 升级 spring4 后，会出现兼容性问题，编译都不能通过。\n\n这是因为 Spring4 官方已经不再支持 ibatis。\n\n解决方案\n\n添加兼容性 jar 包\n\n<dependency>\n    <groupId>org.mybatis</groupId>\n    <artifactId>mybatis-2-spring</artifactId>\n    <version>1.0.1</version>\n</dependency>\n\n\n更多内容可参考：https://stackoverflow.com/questions/32353286/no-support-for-ibatis-in-spring4-2-0\n\n\n# 升级 Dubbo\n\n我们的项目中使用了 soa 框架 Dubbo 。由于 Dubbo 是老版本的，具体来说是（2013 年的 2.4.10），而老版本中使用的 spirng 版本为 2.x，有兼容性问题。\n\nDubbo 项目从今年开始恢复维护了，首先把一些落后的库升级到较新版本，比如 jdk8，spring4 等，并修复了一些 bug。所以，我们可以通过升级一下 Dubbo 版本来解决问题。\n\n<dependency>\n  <groupId>com.alibaba</groupId>\n  <artifactId>dubbo</artifactId>\n  <version>2.5.8</version>\n  <exclusions>\n    <exclusion>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-context</artifactId>\n    </exclusion>\n    <exclusion>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-web</artifactId>\n    </exclusion>\n    <exclusion>\n      <groupId>org.javassist</groupId>\n      <artifactId>javassist</artifactId>\n    </exclusion>\n  </exclusions>\n</dependency>\n\n\n\n# 升级 Jedis\n\n升级 Dubbo 为当前最新的 2.5.8 版本后，运行时报错：\n\n * JedisPoolConfig 配置错误\n\nCaused by: java.lang.ClassNotFoundException: org.apache.commons.pool2.impl.GenericObjectPoolConfig\n\n\n由于项目中使用了 redis，版本为 2.0.0 ，这个问题是由于 jedis 需要升级：\n\n<dependency>\n  <groupId>redis.clients</groupId>\n  <artifactId>jedis</artifactId>\n  <version>2.9.0</version>\n</dependency>\n\n\njedis 2.4.1 以上版本的 JedisPoolConfig 已经没有了maxActive 和 maxWait 属性。\n\n修改方法如下：\n\nmaxActive > maxTotal\n\nmaxWait > maxWaitMillis\n\n<bean id="jedisPoolConfig" class="redis.clients.jedis.JedisPoolConfig">\n  <property name="maxTotal" value="200" />\n  <property name="maxIdle" value="10" />\n  <property name="maxWaitMillis" value="1000" />\n  <property name="testOnBorrow" value="true" />\n</bean>\n\n\nJedisPool 配置错误\n\nInvalidURIException: Cannot open Redis connection due invalid URI\n\n\n原来的配置如下：\n\n<bean id="jedisPool" class="redis.clients.jedis.JedisPool" destroy-method="destroy" depends-on="jedisPoolConfig">\n  <constructor-arg ref="jedisPoolConfig" />\n  <constructor-arg type="java.lang.String" value="${redis.host}" />\n  <constructor-arg type="int" value="${redis.port}" />\n</bean>\n\n\n查看源码可以发现，初始化 JedisPool 时未指定结构方法参数的类型，导致 host 字符串值被视为 URI 类型，当然类型不匹配。\n\n解决方法是修改上面的 host 配置，为：<constructor-arg type="java.lang.String" value="${redis.host}" />\n\n----------------------------------------\n\n至此，spring 4 升级结束。后面如果遇到其他升级问题再补充。\n\n\n# 资料\n\n * https://spring.io/blog/2013/05/21/spring-framework-4-0-m1-3-2-3-available/\n * https://docs.spring.io/spring/docs/4.3.14.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/#spring-whats-new\n * Spring 3.x 升级到 Spring 4.x 注意事项和步骤，错误解决方法\n * http://jinnianshilongnian.iteye.com/blog/1995111\n * 为什么在 Spring 的配置里，最好不要配置 xsd 文件的版本号\n * https://stackoverflow.com/questions/32353286/no-support-for-ibatis-in-spring4-2-0',normalizedContent:'# spring 4 升级踩雷指南\n\n\n# 前言\n\n最近，一直在为公司老项目做核心库升级工作。本来只是想升级一下 jdk8 ，却因为兼容性问题而不得不升级一些其他的库，而其他库本身依赖的一些库可能也要同步升级。这是一系列连锁问题，你很难一一识别，往往只有在编译时、运行时才能发现问题。\n\n总之，这是个费劲的活啊。\n\n本文小结一下升级 spring4 的连锁问题。\n\n\n# 为什么升级 spring4\n\n升级 spring4 的原因是：spring 4 以前的版本不兼容 jdk8。当你的项目同时使用 spring3 和 jdk8，如果代码中有使用 jdk8 字节码或 lambada 表达式，那么会出问题。\n\n也许你会问，为什么不使用最新的 spring 5 呢？因为作为企业软件，一般更倾向使用稳定的版本（bug 少），而不是最新的版本，尤其是一些核心库。\n\n更多细节可以参考：\n\nhttps://spring.io/blog/2013/05/21/spring-framework-4-0-m1-3-2-3-available/\n\n\n# spring 4 重要新特性\n\nspring 4 相比 spring 3，引入许多新特性，这里列举几条较为重要的：\n\n 1. 支持 jdk8 （这个是最主要的）。\n 2. groovy bean definition dsl 风格配置。\n 3. 支持 websocket、sockjs、stomp 消息\n 4. 移除 deprecated 包和方法\n 5. 一些功能加强，如：核心容器、web、test 等等，不一一列举。\n\n更多 spring 4 新特性可以参考：\n\nhttps://docs.spring.io/spring/docs/4.3.14.build-snapshot/spring-framework-reference/htmlsingle/#spring-whats-new\n\nhttp://jinnianshilongnian.iteye.com/blog/1995111\n\n\n# 升级 spring 4 步骤\n\n了解了前面内容，我们知道了升级 spring 4 带来的好处。现在开始真刀真枪的升级了。\n\n不要以为升级一下 spring 4，仅仅是改一下版本号，那么简单，细节处多着呢。\n\n下面，结合我在公司项目升级 spring4 时遇到的一系列坑，希望能帮助各位少走弯路。\n\n> 注\n> \n> 下文内容基于假设你的项目是用 maven 管理这一前提。如果不满足这一前提，那么这篇文章对你没什么太大帮助。\n\n\n# 修改 spring 版本\n\n第一步，当然是修改 pom.xml 中的 spring 版本。\n\n3.x.x.release > 4.x.x.release\n\n实例：升级 spring-core\n\n其它 spring 库的升级也如此：\n\n<properties>\n  <spring.version>4.3.13.release</spring.version>\n</properties>\n<dependency>\n  <groupid>org.springframework</groupid>\n  <artifactid>spring-core</artifactid>\n  <version>${spring.version}</version>\n</dependency>\n\n\n\n# 修改 spring xml 文件的 xsd\n\n用过 spring 的都知道，spring 通常依赖于大量的 xml 配置。\n\nspring 的 xml 解析器在解析 xml 时，需要读取 xml schema，schema 定义了 xml 的命名空间。它的好处在于可以避免命名冲突，有点像 java 中的 package。\n\n实例：一个 spring xml 的 schema\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/xmlschema-instance" xmlns:util="http://www.springframework.org/schema/util" xmlns:context="http://www.springframework.org/schema/context"\n\txmlns:mvc="http://www.springframework.org/schema/mvc"\n\txsi:schemalocation="http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.1.xsd\n\t\thttp://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd\n\t\thttp://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-3.1.xsd\n\t\thttp://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd">\n\n\n> 说明\n> \n>  * xmlns="http://www.springframework.org/schema/beans" 声明 xml 文件默认的命名空间，表示未使用其他命名空间的所有标签的默认命名空间。\n> \n>  * xmlns:xsi="http://www.w3.org/2001/xmlschema-instance" 声明 xml schema 实例，声明后就可以使用 schemalocation 属性了。\n> \n>  * xmlns:mvc="http://www.springframework.org/schema/mvc" 声明前缀为 mvc 的命名空间，后面的 url 用于标示命名空间的地址不会被解析器用于查找信息。其惟一的作用是赋予命名空间一个惟一的名称。当命名空间被定义在元素的开始标签中时，所有带有相同前缀的子元素都会与同一个命名空间相关联。 其它的类似 xmlns:context 、xmlns:jdbc 等等同样如此。\n> \n>  * xsi:schemalocation="http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.1.xsd\n>    ..."\n>    \n>    \n>    这个从命名可以看出个大概，指定 schema 位置这个属性必须结合命名空间使用。这个属性有两个值，第一个值表示需要使用的命名空间。第二个值表示供命名空间使用的 xml schema 的位置。\n\n上面示例中的 xsd 版本是 3.1.xsd ，表示 spring 的 xml 解析器会将其视为 3.1 版本的 xml 文件来处理。\n\n现在，我们使用了 spring 4，3.1.xsd 版本显然就不正确了，我们可以根据自己引入的 spring 4 的子版本号将其改为 4.x.xsd 。\n\n但是，还有一种更好的做法：把这个指定 xsd 版本的关键字干掉，类似这样：http://www.springframework.org/schema/tx/spring-tx.xsd 。\n\n这么做的原因如下：\n\n * spring 默认在启动时要加载 xsd 文件来验证 xml 文件。\n * 如果没有提供 schemalocation，那么 spring 的 xml 解析器会从 namespace 的 uri 里加载 xsd 文件。\n * schemalocation 提供了一个 xml namespace 到对应的 xsd 文件的一个映射。\n * 如果不指定 spring xsd 的版本号，spring 取的就是当前本地 jar 里的 xsd 文件，减少了各种风险（比如 xsd 与实际 spring jar 版本不一致）。\n\n更多详细内容可以参考这篇文章：为什么在 spring 的配置里，最好不要配置 xsd 文件的版本号\n\n\n# 修改 spring xml 文件\n\nspring 4 对 xml 做了一些改动。这里说一个最常用的改动：\n\n# ref local\n\nspring 不再支持 ref 元素的 local 属性，如果你的项目中使用了，需要改为 bean。\n\nshi\n\nspring 4 以前：\n\n<bean id="transactionmanager" class="org.springframework.jdbc.datasource.datasourcetransactionmanager">\n  <property name="datasource">\n    <ref local="datasource" />\n  </property>\n</bean>\n\n\nspring 4 以后：\n\n<bean id="transactionmanager" class="org.springframework.jdbc.datasource.datasourcetransactionmanager">\n  <property name="datasource">\n    <ref bean="datasource" />\n  </property>\n</bean>\n\n\n如果不改启动会报错：\n\ncaused by: org.xml.sax.saxparseexception: cvc-complex-type.3.2.2: attribute \'local\' is not allowed to appear in element \'ref\'.\n\n\n当然，可能还有一些其他配置改动，这个只能说兵来将挡水来土掩，遇到了再去查官方文档吧。\n\n\n# 加入 spring support\n\nspring 3 中很多的扩展内容不需要引入 support 。但是 spring 4 中分离的更彻底了，如果不分离，会有很多classnotfound 。\n\n<dependency>\n    <groupid>org.springframework</groupid>\n    <artifactid>spring-context-support</artifactid>\n    <version>4.2.3.release</version>\n</dependency>\n\n\n\n# 更换 spring-mvc jackson\n\nspring mvc 中如果返回结果为 json 需要依赖 jackson 的 jar 包，但是他升级到了 2, 以前是 codehaus.jackson，现在换成了 fasterxml.jackson\n\n<dependency>\n    <groupid>com.fasterxml.jackson.core</groupid>\n    <artifactid>jackson-core</artifactid>\n    <version>2.7.0</version>\n</dependency>\n<dependency>\n    <groupid>com.fasterxml.jackson.core</groupid>\n    <artifactid>jackson-databind</artifactid>\n    <version>2.7.0</version>\n</dependency>\n\n\n同时修改 spring mvc 的配置文件：\n\n<bean\n\tclass="org.springframework.web.servlet.mvc.annotation.annotationmethodhandleradapter">\n\t<property name="messageconverters">\n\t\t<list>\n\t\t\t <ref bean="stringhttpmessageconverter" />\n\t\t\t<bean\n\t\t\t\tclass="org.springframework.http.converter.json.mappingjackson2httpmessageconverter">\n\t\t\t</bean>\n\t\t</list>\n\t</property>\n</bean>\n\n<bean id="stringhttpmessageconverter"\n\tclass="org.springframework.http.converter.stringhttpmessageconverter">\n\t<property name="supportedmediatypes">\n\t\t<list>\n\t\t\t<value>text/plain;charset=utf-8</value>\n\t\t</list>\n\t</property>\n</bean>\n\n\n\n# 解决 ibatis 兼容问题\n\n问题\n\n如果你的项目中使用了 ibatis (mybatis 的前身)这个 orm 框架，当 spring3 升级 spring4 后，会出现兼容性问题，编译都不能通过。\n\n这是因为 spring4 官方已经不再支持 ibatis。\n\n解决方案\n\n添加兼容性 jar 包\n\n<dependency>\n    <groupid>org.mybatis</groupid>\n    <artifactid>mybatis-2-spring</artifactid>\n    <version>1.0.1</version>\n</dependency>\n\n\n更多内容可参考：https://stackoverflow.com/questions/32353286/no-support-for-ibatis-in-spring4-2-0\n\n\n# 升级 dubbo\n\n我们的项目中使用了 soa 框架 dubbo 。由于 dubbo 是老版本的，具体来说是（2013 年的 2.4.10），而老版本中使用的 spirng 版本为 2.x，有兼容性问题。\n\ndubbo 项目从今年开始恢复维护了，首先把一些落后的库升级到较新版本，比如 jdk8，spring4 等，并修复了一些 bug。所以，我们可以通过升级一下 dubbo 版本来解决问题。\n\n<dependency>\n  <groupid>com.alibaba</groupid>\n  <artifactid>dubbo</artifactid>\n  <version>2.5.8</version>\n  <exclusions>\n    <exclusion>\n      <groupid>org.springframework</groupid>\n      <artifactid>spring-context</artifactid>\n    </exclusion>\n    <exclusion>\n      <groupid>org.springframework</groupid>\n      <artifactid>spring-web</artifactid>\n    </exclusion>\n    <exclusion>\n      <groupid>org.javassist</groupid>\n      <artifactid>javassist</artifactid>\n    </exclusion>\n  </exclusions>\n</dependency>\n\n\n\n# 升级 jedis\n\n升级 dubbo 为当前最新的 2.5.8 版本后，运行时报错：\n\n * jedispoolconfig 配置错误\n\ncaused by: java.lang.classnotfoundexception: org.apache.commons.pool2.impl.genericobjectpoolconfig\n\n\n由于项目中使用了 redis，版本为 2.0.0 ，这个问题是由于 jedis 需要升级：\n\n<dependency>\n  <groupid>redis.clients</groupid>\n  <artifactid>jedis</artifactid>\n  <version>2.9.0</version>\n</dependency>\n\n\njedis 2.4.1 以上版本的 jedispoolconfig 已经没有了maxactive 和 maxwait 属性。\n\n修改方法如下：\n\nmaxactive > maxtotal\n\nmaxwait > maxwaitmillis\n\n<bean id="jedispoolconfig" class="redis.clients.jedis.jedispoolconfig">\n  <property name="maxtotal" value="200" />\n  <property name="maxidle" value="10" />\n  <property name="maxwaitmillis" value="1000" />\n  <property name="testonborrow" value="true" />\n</bean>\n\n\njedispool 配置错误\n\ninvaliduriexception: cannot open redis connection due invalid uri\n\n\n原来的配置如下：\n\n<bean id="jedispool" class="redis.clients.jedis.jedispool" destroy-method="destroy" depends-on="jedispoolconfig">\n  <constructor-arg ref="jedispoolconfig" />\n  <constructor-arg type="java.lang.string" value="${redis.host}" />\n  <constructor-arg type="int" value="${redis.port}" />\n</bean>\n\n\n查看源码可以发现，初始化 jedispool 时未指定结构方法参数的类型，导致 host 字符串值被视为 uri 类型，当然类型不匹配。\n\n解决方法是修改上面的 host 配置，为：<constructor-arg type="java.lang.string" value="${redis.host}" />\n\n----------------------------------------\n\n至此，spring 4 升级结束。后面如果遇到其他升级问题再补充。\n\n\n# 资料\n\n * https://spring.io/blog/2013/05/21/spring-framework-4-0-m1-3-2-3-available/\n * https://docs.spring.io/spring/docs/4.3.14.build-snapshot/spring-framework-reference/htmlsingle/#spring-whats-new\n * spring 3.x 升级到 spring 4.x 注意事项和步骤，错误解决方法\n * http://jinnianshilongnian.iteye.com/blog/1995111\n * 为什么在 spring 的配置里，最好不要配置 xsd 文件的版本号\n * https://stackoverflow.com/questions/32353286/no-support-for-ibatis-in-spring4-2-0',charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"SpringBoot 之 banner 定制",frontmatter:{title:"SpringBoot 之 banner 定制",date:"2018-12-21T23:22:44.000Z",order:21,categories:["Java","框架","Spring","Spring其他"],tags:["Java","框架","Spring","SpringBoot"],permalink:"/pages/bac2ce/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/99.Spring%E5%85%B6%E4%BB%96/21.SpringBoot%E4%B9%8Bbanner.html",relativePath:"01.Java/13.框架/01.Spring/99.Spring其他/21.SpringBoot之banner.md",key:"v-25a234c6",path:"/pages/bac2ce/",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:29},{level:2,title:"变量",slug:"变量",normalizedTitle:"变量",charIndex:632},{level:2,title:"配置",slug:"配置",normalizedTitle:"配置",charIndex:2202},{level:2,title:"编程",slug:"编程",normalizedTitle:"编程",charIndex:2849},{level:2,title:"示例源码",slug:"示例源码",normalizedTitle:"示例源码",charIndex:3070},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:3106}],headersStr:"简介 变量 配置 编程 示例源码 参考资料",content:"# SpringBoot 之 banner 定制\n\n\n# 简介\n\nSpring Boot 启动时默认会显示以下 LOGO：\n\n  .   ____          _            __ _ _\n /\\\\ / ___'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\\n( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\\n \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )\n  '  |____| .__|_| |_|_| |_\\__, | / / / /\n =========|_|==============|___/=/_/_/_/\n :: Spring Boot ::        (v2.1.1.RELEASE)\n\n\n实际上，Spring Boot 支持自定义 logo 的功能。\n\n让我们来看看如何实现的。\n\n只要你在 resources 目录下放置名为 banner.txt、banner.gif 、banner.jpg 或 banner.png 的文件，Spring Boot 会自动加载，将其作为启动时打印的 logo。\n\n * 对于文本文件，Spring Boot 会将其直接输出。\n * 对于图像文件（ banner.gif 、banner.jpg 或 banner.png ），Spring Boot 会将图像转为 ASCII 字符，然后输出。\n\n\n# 变量\n\nbanner.txt 文件中还可以使用变量来设置字体、颜色、版本号。\n\n变量                                                            描述\n${application.version}                                        MANIFEST.MF 中定义的版本。如：1.0\n${application.formatted-version}                              MANIFEST.MF 中定义的版本，并添加一个 v 前缀。如：v1.0\n${spring-boot.version}                                        Spring Boot 版本。如：2.1.1.RELEASE.\n${spring-boot.formatted-version}                              Spring Boot 版本，并添加一个 v 前缀。如：v2.1.1.RELEASE\n${Ansi.NAME} (or ${AnsiColor.NAME}, ${AnsiBackground.NAME},   ANSI 颜色、字体。更多细节，参考：AnsiPropertySource。\n${AnsiStyle.NAME})\n${application.title}                                          MANIFEST.MF 中定义的应用名。\n\n示例：\n\n在 Spring Boot 项目中的 resources 目录下添加一个名为 banner.txt 的文件，内容如下：\n\n${AnsiColor.BRIGHT_YELLOW}${AnsiStyle.BOLD}\n ________  ___  ___  ________   ___       __   ___  ___\n|\\   ___ \\|\\  \\|\\  \\|\\   ___  \\|\\  \\     |\\  \\|\\  \\|\\  \\\n\\ \\  \\_|\\ \\ \\  \\\\\\  \\ \\  \\\\ \\  \\ \\  \\    \\ \\  \\ \\  \\\\\\  \\\n \\ \\  \\ \\\\ \\ \\  \\\\\\  \\ \\  \\\\ \\  \\ \\  \\  __\\ \\  \\ \\  \\\\\\  \\\n  \\ \\  \\_\\\\ \\ \\  \\\\\\  \\ \\  \\\\ \\  \\ \\  \\|\\__\\_\\  \\ \\  \\\\\\  \\\n   \\ \\_______\\ \\_______\\ \\__\\\\ \\__\\ \\____________\\ \\_______\\\n    \\|_______|\\|_______|\\|__| \\|__|\\|____________|\\|_______|\n${AnsiBackground.WHITE}${AnsiColor.RED}${AnsiStyle.UNDERLINE}\n:: Spring Boot ::             (v${spring-boot.version})\n:: Spring Boot Tutorial ::    (v1.0.0)\n\n\n> 注：${} 设置字体颜色的变量之间不能换行或空格分隔，否则会导致除最后一个变量外，都不生效。\n\n启动应用后，控制台将打印如下 logo：\n\n推荐两个生成字符画的网站，可以将生成的字符串放入这个banner.txt 文件：\n\n * http://www.network-science.de/ascii/\n * http://patorjk.com/software/taag/\n\n\n# 配置\n\napplication.properties 中与 Banner 相关的配置：\n\n# banner 模式。有三种模式：console/log/off\n# console 打印到控制台（通过 System.out）\n# log - 打印到日志中\n# off - 关闭打印\nspring.main.banner-mode = off\n# banner 文件编码\nspring.banner.charset = UTF-8\n# banner 文本文件路径\nspring.banner.location = classpath:banner.txt\n# banner 图像文件路径（可以选择 png,jpg,gif 文件）\nspring.banner.image.location = classpath:banner.gif\nused).\n# 图像 banner 的宽度（字符数）\nspring.banner.image.width = 76\n# 图像 banner 的高度（字符数）\nspring.banner.image.height =\n# 图像 banner 的左边界（字符数）\nspring.banner.image.margin = 2\n# 是否将图像转为黑色控制台主题\nspring.banner.image.invert = false\n\n\n当然，你也可以在 YAML 文件中配置，例如：\n\nspring:\n  main:\n    banner-mode: off\n\n\n\n# 编程\n\n默认，Spring Boot 会注册一个 SpringBootBanner 的单例 Bean，用来负责打印 Banner。\n\n如果想完全个人定制 Banner，可以这么做：先实现 org.springframework.boot.Banner#printBanner 接口来自己定制 Banner。在将这个 Banner 通过 SpringApplication.setBanner(…) 方法注入 Spring Boot。\n\n\n# 示例源码\n\n> 示例源码：spring-boot-banner\n\n\n# 参考资料\n\n * Spring Boot 官方文档之 Customizing the Banner",normalizedContent:"# springboot 之 banner 定制\n\n\n# 简介\n\nspring boot 启动时默认会显示以下 logo：\n\n  .   ____          _            __ _ _\n /\\\\ / ___'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\\n( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\\n \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )\n  '  |____| .__|_| |_|_| |_\\__, | / / / /\n =========|_|==============|___/=/_/_/_/\n :: spring boot ::        (v2.1.1.release)\n\n\n实际上，spring boot 支持自定义 logo 的功能。\n\n让我们来看看如何实现的。\n\n只要你在 resources 目录下放置名为 banner.txt、banner.gif 、banner.jpg 或 banner.png 的文件，spring boot 会自动加载，将其作为启动时打印的 logo。\n\n * 对于文本文件，spring boot 会将其直接输出。\n * 对于图像文件（ banner.gif 、banner.jpg 或 banner.png ），spring boot 会将图像转为 ascii 字符，然后输出。\n\n\n# 变量\n\nbanner.txt 文件中还可以使用变量来设置字体、颜色、版本号。\n\n变量                                                            描述\n${application.version}                                        manifest.mf 中定义的版本。如：1.0\n${application.formatted-version}                              manifest.mf 中定义的版本，并添加一个 v 前缀。如：v1.0\n${spring-boot.version}                                        spring boot 版本。如：2.1.1.release.\n${spring-boot.formatted-version}                              spring boot 版本，并添加一个 v 前缀。如：v2.1.1.release\n${ansi.name} (or ${ansicolor.name}, ${ansibackground.name},   ansi 颜色、字体。更多细节，参考：ansipropertysource。\n${ansistyle.name})\n${application.title}                                          manifest.mf 中定义的应用名。\n\n示例：\n\n在 spring boot 项目中的 resources 目录下添加一个名为 banner.txt 的文件，内容如下：\n\n${ansicolor.bright_yellow}${ansistyle.bold}\n ________  ___  ___  ________   ___       __   ___  ___\n|\\   ___ \\|\\  \\|\\  \\|\\   ___  \\|\\  \\     |\\  \\|\\  \\|\\  \\\n\\ \\  \\_|\\ \\ \\  \\\\\\  \\ \\  \\\\ \\  \\ \\  \\    \\ \\  \\ \\  \\\\\\  \\\n \\ \\  \\ \\\\ \\ \\  \\\\\\  \\ \\  \\\\ \\  \\ \\  \\  __\\ \\  \\ \\  \\\\\\  \\\n  \\ \\  \\_\\\\ \\ \\  \\\\\\  \\ \\  \\\\ \\  \\ \\  \\|\\__\\_\\  \\ \\  \\\\\\  \\\n   \\ \\_______\\ \\_______\\ \\__\\\\ \\__\\ \\____________\\ \\_______\\\n    \\|_______|\\|_______|\\|__| \\|__|\\|____________|\\|_______|\n${ansibackground.white}${ansicolor.red}${ansistyle.underline}\n:: spring boot ::             (v${spring-boot.version})\n:: spring boot tutorial ::    (v1.0.0)\n\n\n> 注：${} 设置字体颜色的变量之间不能换行或空格分隔，否则会导致除最后一个变量外，都不生效。\n\n启动应用后，控制台将打印如下 logo：\n\n推荐两个生成字符画的网站，可以将生成的字符串放入这个banner.txt 文件：\n\n * http://www.network-science.de/ascii/\n * http://patorjk.com/software/taag/\n\n\n# 配置\n\napplication.properties 中与 banner 相关的配置：\n\n# banner 模式。有三种模式：console/log/off\n# console 打印到控制台（通过 system.out）\n# log - 打印到日志中\n# off - 关闭打印\nspring.main.banner-mode = off\n# banner 文件编码\nspring.banner.charset = utf-8\n# banner 文本文件路径\nspring.banner.location = classpath:banner.txt\n# banner 图像文件路径（可以选择 png,jpg,gif 文件）\nspring.banner.image.location = classpath:banner.gif\nused).\n# 图像 banner 的宽度（字符数）\nspring.banner.image.width = 76\n# 图像 banner 的高度（字符数）\nspring.banner.image.height =\n# 图像 banner 的左边界（字符数）\nspring.banner.image.margin = 2\n# 是否将图像转为黑色控制台主题\nspring.banner.image.invert = false\n\n\n当然，你也可以在 yaml 文件中配置，例如：\n\nspring:\n  main:\n    banner-mode: off\n\n\n\n# 编程\n\n默认，spring boot 会注册一个 springbootbanner 的单例 bean，用来负责打印 banner。\n\n如果想完全个人定制 banner，可以这么做：先实现 org.springframework.boot.banner#printbanner 接口来自己定制 banner。在将这个 banner 通过 springapplication.setbanner(…) 方法注入 spring boot。\n\n\n# 示例源码\n\n> 示例源码：spring-boot-banner\n\n\n# 参考资料\n\n * spring boot 官方文档之 customizing the banner",charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"SpringBoot Actuator 快速入门",frontmatter:{title:"SpringBoot Actuator 快速入门",date:"2022-06-14T20:51:22.000Z",order:22,categories:["Java","框架","Spring","Spring其他"],tags:["Java","框架","Spring","SpringBoot"],permalink:"/pages/c013cc/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/99.Spring%E5%85%B6%E4%BB%96/22.SpringBoot%E4%B9%8BActuator.html",relativePath:"01.Java/13.框架/01.Spring/99.Spring其他/22.SpringBoot之Actuator.md",key:"v-6a3ca52c",path:"/pages/c013cc/",headers:[{level:2,title:"端点（Endpoint）",slug:"端点-endpoint",normalizedTitle:"端点（endpoint）",charIndex:450},{level:3,title:"启用端点",slug:"启用端点",normalizedTitle:"启用端点",charIndex:718},{level:3,title:"暴露端点",slug:"暴露端点",normalizedTitle:"暴露端点",charIndex:1051},{level:3,title:"安全",slug:"安全",normalizedTitle:"安全",charIndex:2328},{level:3,title:"配置端点",slug:"配置端点",normalizedTitle:"配置端点",charIndex:755},{level:3,title:"Actuator Web 端点的超媒体",slug:"actuator-web-端点的超媒体",normalizedTitle:"actuator web 端点的超媒体",charIndex:4222},{level:3,title:"跨域支持",slug:"跨域支持",normalizedTitle:"跨域支持",charIndex:4548},{level:3,title:"自定义端点",slug:"自定义端点",normalizedTitle:"自定义端点",charIndex:540},{level:2,title:"通过 HTTP 进行监控和管理",slug:"通过-http-进行监控和管理",normalizedTitle:"通过 http 进行监控和管理",charIndex:5542},{level:3,title:"自定义管理端点路径",slug:"自定义管理端点路径",normalizedTitle:"自定义管理端点路径",charIndex:5562},{level:3,title:"自定义管理服务器端口",slug:"自定义管理服务器端口",normalizedTitle:"自定义管理服务器端口",charIndex:5916},{level:3,title:"配置 SSL",slug:"配置-ssl",normalizedTitle:"配置 ssl",charIndex:5961},{level:3,title:"自定义管理服务器地址",slug:"自定义管理服务器地址",normalizedTitle:"自定义管理服务器地址",charIndex:6584},{level:3,title:"禁用 HTTP 端点",slug:"禁用-http-端点",normalizedTitle:"禁用 http 端点",charIndex:6665},{level:2,title:"通过 JMX 进行监控和管理",slug:"通过-jmx-进行监控和管理",normalizedTitle:"通过 jmx 进行监控和管理",charIndex:6867},{level:3,title:"定制化 MBean Names",slug:"定制化-mbean-names",normalizedTitle:"定制化 mbean names",charIndex:7393},{level:3,title:"禁用 JMX 端点",slug:"禁用-jmx-端点",normalizedTitle:"禁用 jmx 端点",charIndex:7714},{level:3,title:"将 Jolokia 用于基于 HTTP 的 JMX",slug:"将-jolokia-用于基于-http-的-jmx",normalizedTitle:"将 jolokia 用于基于 http 的 jmx",charIndex:7795},{level:2,title:"日志",slug:"日志",normalizedTitle:"日志",charIndex:8133},{level:2,title:"指标",slug:"指标",normalizedTitle:"指标",charIndex:8274},{level:2,title:"审计",slug:"审计",normalizedTitle:"审计",charIndex:8281},{level:2,title:"HTTP 追踪",slug:"http-追踪",normalizedTitle:"http 追踪",charIndex:8814},{level:2,title:"处理监控",slug:"处理监控",normalizedTitle:"处理监控",charIndex:9090},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:9328}],headersStr:"端点（Endpoint） 启用端点 暴露端点 安全 配置端点 Actuator Web 端点的超媒体 跨域支持 自定义端点 通过 HTTP 进行监控和管理 自定义管理端点路径 自定义管理服务器端口 配置 SSL 自定义管理服务器地址 禁用 HTTP 端点 通过 JMX 进行监控和管理 定制化 MBean Names 禁用 JMX 端点 将 Jolokia 用于基于 HTTP 的 JMX 日志 指标 审计 HTTP 追踪 处理监控 参考资料",content:'# SpringBoot Actuator 快速入门\n\nspring-boot-actuator 模块提供了 Spring Boot 的所有生产就绪功能。启用这些功能的推荐方法是添加 spring-boot-starter-actuator 依赖。\n\n如果是 Maven 项目，添加以下依赖：\n\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-actuator</artifactId>\n    </dependency>\n</dependencies>\n\n\n如果是 Gradle 项目，添加以下声明：\n\ndependencies {\n    implementation \'org.springframework.boot:spring-boot-starter-actuator\'\n}\n\n\n\n# 端点（Endpoint）\n\nActuator Endpoint 使 Spring Boot 用户可以监控应用，并和应用进行交互。Spring Boot 内置了许多 端点，并允许用户自定义端点。例如，health 端点提供基本的应用健康信息。\n\n用户可以启用或禁用每个单独的端点并通过 HTTP 或 JMX 暴露它们（使它们可远程访问）。当端点被启用和公开时，它被认为是可用的。内置端点仅在可用时才会自动配置。大多数应用程序选择通过 HTTP 公开。例如，默认情况下，health 端点映射到 /actuator/health。\n\n\n# 启用端点\n\n默认情况下，除了 shutdown 之外的所有端点都已启用。要配置端点的启用，请使用 management.endpoint.<id>.enabled 属性。以下示例启用 shutdown 端点：\n\nmanagement.endpoint.shutdown.enabled=true\n\n\n如果您希望端点是明确指定才启用，请将 management.endpoints.enabled-by-default 属性设置为 false 并根据需要明确指定启用的端点，以下为示例：\n\nmanagement.endpoints.enabled-by-default=false\nmanagement.endpoint.info.enabled=true\n\n\n\n# 暴露端点\n\n由于端点可能包含敏感信息，您应该仔细考虑何时暴露它们。下表显示了内置端点的默认曝光：\n\nID                 JMX   WEB\nauditevents        Yes   No\nbeans              Yes   No\ncaches             Yes   No\nconditions         Yes   No\nconfigprops        Yes   No\nenv                Yes   No\nflyway             Yes   No\nhealth             Yes   Yes\nheapdump           N/A   No\nhttptrace          Yes   No\ninfo               Yes   No\nintegrationgraph   Yes   No\njolokia            N/A   No\nlogfile            N/A   No\nloggers            Yes   No\nliquibase          Yes   No\nmetrics            Yes   No\nmappings           Yes   No\nprometheus         N/A   No\nquartz             Yes   No\nscheduledtasks     Yes   No\nsessions           Yes   No\nshutdown           Yes   No\nstartup            Yes   No\nthreaddump         Yes   No\n\n要更改暴露的端点，请使用以下特定于技术的包含和排除属性：\n\nPROPERTY                                    DEFAULT\nmanagement.endpoints.jmx.exposure.exclude   \nmanagement.endpoints.jmx.exposure.include   *\nmanagement.endpoints.web.exposure.exclude   \nmanagement.endpoints.web.exposure.include   health\n\ninclude 属性列出了暴露的端点的 ID。 exclude 属性列出了不应暴露的端点的 ID。 exclude 属性优先于 include 属性。您可以使用端点 ID 列表配置包含和排除属性。\n\n例如，仅暴露 health 和 info 端点，其他端点都不通过 JMX 暴露，可以按如下配置：\n\nmanagement.endpoints.jmx.exposure.include=health,info\n\n\n注意：* 可用于选择所有端点。\n\n\n# 安全\n\n出于安全考虑，只有 /health 端点会通过 HTTP 方式暴露。用户可以通过 management.endpoints.web.exposure.include 决定哪些端点可以通过 HTTP 方式暴露。\n\n如果 Spring Security 在类路径上并且不存在其他 WebSecurityConfigurerAdapter 或 SecurityFilterChain bean，则除 /health 之外的所有 actuator 都由 Spring Boot 自动启用安全控制。如果用户自定义了 WebSecurityConfigurerAdapter 或 SecurityFilterChain bean，Spring Boot 不再启用安全控制，由用户自行控制访问规则。\n\n如果您希望为 HTTP 端点定义安全控制（例如，只允许具有特定角色的用户访问它们），Spring Boot 提供了一些方便的 RequestMatcher 对象，您可以将它们与 Spring Security 结合使用。\n\n下面是一个典型的 Spring Security 配置示例：\n\n@Configuration(proxyBeanMethods = false)\npublic class MySecurityConfiguration {\n\n    @Bean\n    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {\n        http.requestMatcher(EndpointRequest.toAnyEndpoint())\n                .authorizeRequests((requests) -> requests.anyRequest().hasRole("ENDPOINT_ADMIN"));\n        http.httpBasic();\n        return http.build();\n    }\n\n}\n\n\n前面的示例使用 EndpointRequest.toAnyEndpoint() 将请求匹配到任何端点，然后确保所有端点都具有 ENDPOINT_ADMIN 角色。 EndpointRequest 上还提供了其他几种匹配器方法。\n\n如果希望无需身份验证即可访问所有执行器端点。可以通过更改 management.endpoints.web.exposure.include 属性来做到这一点，如下所示：\n\nmanagement.endpoints.web.exposure.include=*\n\n\n此外，如果存在 Spring Security，您将需要添加自定义安全配置，以允许未经身份验证的访问端点，如以下示例所示：\n\n@Configuration(proxyBeanMethods = false)\npublic class MySecurityConfiguration {\n\n    @Bean\n    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {\n        http.requestMatcher(EndpointRequest.toAnyEndpoint())\n                .authorizeRequests((requests) -> requests.anyRequest().permitAll());\n        return http.build();\n    }\n\n}\n\n\n由于 Spring Boot 依赖于 Spring Security 的默认设置，因此 CSRF 保护默认开启。这意味着在使用默认安全配置时，需要 POST（关闭和记录器端点）、PUT 或 DELETE 的执行器端点会收到 403（禁止）错误。\n\n> 建议仅在创建非浏览器客户端使用的服务时完全禁用 CSRF 保护。\n\n\n# 配置端点\n\n端点会自动缓存对不带任何参数的读操作的响应数据。要配置端点缓存响应的时间量，请使用其 cache.time-to-live 属性。以下示例将 bean 端点缓存的生存时间设置为 10 秒：\n\nmanagement.endpoint.beans.cache.time-to-live=10s\n\n\n\n# Actuator Web 端点的超媒体\n\nSpring Boot Actuator 中内置了一个“发现页面”端点，其中包含了所有端点的链接。默认情况下，“发现页面”在 /actuator 上可用。\n\n要禁用“发现页面”，请将以下属性添加到您的应用程序属性中：\n\nmanagement.endpoints.web.discovery.enabled=false\n\n\n配置自定义管理上下文路径后，“发现页面”会自动从 /actuator 移动到应用管理上下文的根目录。例如，如果管理上下文路径是 /management，则发现页面可从 /management 获得。当管理上下文路径设置为 / 时，发现页面被禁用以防止与其他映射发生冲突的可能性。\n\n\n# 跨域支持\n\nCORS 是一种 W3C 规范，可让用户以灵活的方式指定授权哪种跨域请求。如果使用 Spring MVC 或 Spring WebFlux，则可以配置 Actuator 的 Web 端点以支持此类场景。\n\nCORS 支持默认是禁用的，只有在设置 management.endpoints.web.cors.allowed-origins 属性后才会启用。以下配置允许来自 example.com 域的 GET 和 POST 调用：\n\nmanagement.endpoints.web.cors.allowed-origins=https://example.com\nmanagement.endpoints.web.cors.allowed-methods=GET,POST\n\n\n\n# 自定义端点\n\n如果添加带有 @Endpoint 注释的 @Bean，则任何带有 @ReadOperation、@WriteOperation 或 @DeleteOperation 注释的方法都会自动通过 JMX 公开，并且在 Web 应用程序中，也可以通过 HTTP 公开。可以使用 Jersey、Spring MVC 或 Spring WebFlux 通过 HTTP 公开端点。如果 Jersey 和 Spring MVC 都可用，则使用 Spring MVC。\n\n以下示例公开了一个返回自定义对象的读取操作：\n\n@ReadOperation\npublic CustomData getData() {\n    return new CustomData("test", 5);\n}\n\n\n您还可以使用 @JmxEndpoint 或 @WebEndpoint 编写特定技术的端点。这些端点仅限于各自的技术。例如，@WebEndpoint 仅通过 HTTP 而不是通过 JMX 公开。\n\n您可以使用 @EndpointWebExtension 和 @EndpointJmxExtension 编写特定技术的扩展。这些注释让您可以提供特定技术的操作来扩充现有端点。\n\n最后，如果您需要访问 Web 框架的功能，您可以实现 servlet 或 Spring @Controller 和 @RestController 端点，但代价是它们无法通过 JMX 或使用不同的 Web 框架获得。\n\n\n# 通过 HTTP 进行监控和管理\n\n\n# 自定义管理端点路径\n\n如果是 Web 应用，Spring Boot Actuator 会自动将所有启用的端点通过 HTTP 方式暴露。默认约定是使用前缀为 /actuator 的端点的 id 作为 URL 路径。例如，健康被暴露为 /actuator/health。\n\n有时，自定义管理端点的前缀很有用。例如，您的应用程序可能已经将 /actuator 用于其他目的。您可以使用 management.endpoints.web.base-path 属性更改管理端点的前缀，如以下示例所示：\n\nmanagement.endpoints.web.base-path=/manage\n\n\n该示例将端点从 /actuator/{id} 更改为 /manage/{id}（例如，/manage/info）。\n\n\n# 自定义管理服务器端口\n\nmanagement.server.port=8081\n\n\n\n# 配置 SSL\n\n当配置为使用自定义端口时，还可以使用各种 management.server.ssl.* 属性为管理服务器配置自己的 SSL。例如，这样做可以让管理服务器在主应用程序使用 HTTPS 时通过 HTTP 可用，如以下属性设置所示：\n\nserver.port=8443\nserver.ssl.enabled=true\nserver.ssl.key-store=classpath:store.jks\nserver.ssl.key-password=secret\nmanagement.server.port=8080\nmanagement.server.ssl.enabled=false\n\n\n或者，主服务器和管理服务器都可以使用 SSL，但使用不同的密钥存储，如下所示：\n\nserver.port=8443\nserver.ssl.enabled=true\nserver.ssl.key-store=classpath:main.jks\nserver.ssl.key-password=secret\nmanagement.server.port=8080\nmanagement.server.ssl.enabled=true\nmanagement.server.ssl.key-store=classpath:management.jks\nmanagement.server.ssl.key-password=secret\n\n\n\n# 自定义管理服务器地址\n\nmanagement.server.port=8081\nmanagement.server.address=127.0.0.1\n\n\n\n# 禁用 HTTP 端点\n\n如果您不想通过 HTTP 方式暴露端点，可以将管理端口设置为 -1，如以下示例所示：\n\nmanagement.server.port=-1\n\n\n也可以通过使用 management.endpoints.web.exposure.exclude 属性来实现这一点，如以下示例所示：\n\nmanagement.endpoints.web.exposure.exclude=*\n\n\n\n# 通过 JMX 进行监控和管理\n\nJava 管理扩展 (JMX) 提供了一种标准机制来监视和管理应用程序。默认情况下，此功能未启用。您可以通过将 spring.jmx.enabled 配置属性设置为 true 来打开它。 Spring Boot 将最合适的 MBeanServer 暴露为 ID 为 mbeanServer 的 bean。使用 Spring JMX 注释（@ManagedResource、@ManagedAttribute 或 @ManagedOperation）注释的任何 bean 都会暴露给它。\n\n如果您的平台提供标准 MBeanServer，则 Spring Boot 会使用该标准并在必要时默认使用 VM MBeanServer。如果一切都失败了，则创建一个新的 MBeanServer。\n\n有关更多详细信息，请参阅 JmxAutoConfiguration 类。\n\n默认情况下，Spring Boot 还将管理端点公开为 org.springframework.boot 域下的 JMX MBean。要完全控制 JMX 域中的端点注册，请考虑注册您自己的 EndpointObjectNameFactory 实现。\n\n\n# 定制化 MBean Names\n\nMBean 的名称通常由端点的 id 生成。例如，健康端点公开为 org.springframework.boot:type=Endpoint,name=Health。\n\n如果您的应用程序包含多个 Spring ApplicationContext，您可能会发现名称冲突。要解决此问题，您可以将 spring.jmx.unique-names 属性设置为 true，以便 MBean 名称始终是唯一的。\n\n如果需要定制，跨域按如下配置：\n\nspring.jmx.unique-names=true\nmanagement.endpoints.jmx.domain=com.example.myapp\n\n\n\n# 禁用 JMX 端点\n\n想禁用 JMX 端点，可以按如下配置：\n\nmanagement.endpoints.jmx.exposure.exclude=*\n\n\n\n# 将 Jolokia 用于基于 HTTP 的 JMX\n\nJolokia 是一个 JMX-HTTP 的桥接工具，它提供了另一种访问 JMX bean 的方法。要使用 Jolokia，需要先添加依赖：\n\n<dependency>\n    <groupId>org.jolokia</groupId>\n    <artifactId>jolokia-core</artifactId>\n</dependency\n\n\n然后，您可以通过将 jolokia 或 * 添加到 Management.Endpoints.web.exposure.include 属性来暴露 Jolokia 端点。然后，您可以在管理 HTTP 服务器上使用 /actuator/jolokia 访问它。\n\n\n# 日志\n\nSpring Boot Actuator 支持查看和配置应用日志级别。\n\n日志级别的可选值如下：\n\n * TRACE\n * DEBUG\n * INFO\n * WARN\n * ERROR\n * FATAL\n * OFF\n * null\n\nnull 表示没有显式配置。\n\n\n# 指标\n\n\n# 审计\n\nSpring Boot Actuator 支持简单的审计功能。如果应用中启用了 Spring Security，Spring Boot Actuator 就会发布安全事件（如：“身份验证成功”、“失败”和“访问被拒绝”异常）。\n\n可以通过在应用的配置中提供 AuditEventRepository 类型的 bean 来启用审计。为方便起见，Spring Boot 提供了一个 InMemoryAuditEventRepository。 InMemoryAuditEventRepository 的功能有限，建议仅将其用于开发环境。\n\n如果要自定义安全事件，可以提供 AbstractAuthenticationAuditListener 和 AbstractAuthorizationAuditListener 实现。\n\n此外，还可以将审计服务用于业务活动。为此，要么将 AuditEventRepository bean 注入组件并直接使用它，要么使用 Spring ApplicationEventPublisher 发布 AuditApplicationEvent（通过实现 ApplicationEventPublisherAware）。\n\n\n# HTTP 追踪\n\n用户可以通过在应用中提供 HttpTraceRepository 类型的 bean 来启用 HTTP 跟踪。Spring Boot 提供了内置的 InMemoryHttpTraceRepository，它可以存储最近 100 次（默认）请求-响应的追踪数据。与其他 HTTP 追踪解决方案相比，InMemoryHttpTraceRepository 比较受限，建议仅用于开发环境。对于生产环境，建议使用 Zipkin 或 Spring Cloud Sleuth。\n\n或者，可以自定义 HttpTraceRepository。\n\n\n# 处理监控\n\n在 spring-boot 模块中，您可以找到两个类来创建对进程监控有用的文件：\n\n * ApplicationPidFileWriter 创建一个包含应用程序 PID 的文件（默认情况下，在应用程序目录中，文件名为 application.pid）。\n * WebServerPortFileWriter 创建一个文件（或多个文件），其中包含正在运行的 Web 服务器的端口（默认情况下，在应用程序目录中，文件名为 application.port）。\n\n\n# 参考资料\n\n * Spring Boot 官方文档之 Production-ready Features',normalizedContent:'# springboot actuator 快速入门\n\nspring-boot-actuator 模块提供了 spring boot 的所有生产就绪功能。启用这些功能的推荐方法是添加 spring-boot-starter-actuator 依赖。\n\n如果是 maven 项目，添加以下依赖：\n\n<dependencies>\n    <dependency>\n        <groupid>org.springframework.boot</groupid>\n        <artifactid>spring-boot-starter-actuator</artifactid>\n    </dependency>\n</dependencies>\n\n\n如果是 gradle 项目，添加以下声明：\n\ndependencies {\n    implementation \'org.springframework.boot:spring-boot-starter-actuator\'\n}\n\n\n\n# 端点（endpoint）\n\nactuator endpoint 使 spring boot 用户可以监控应用，并和应用进行交互。spring boot 内置了许多 端点，并允许用户自定义端点。例如，health 端点提供基本的应用健康信息。\n\n用户可以启用或禁用每个单独的端点并通过 http 或 jmx 暴露它们（使它们可远程访问）。当端点被启用和公开时，它被认为是可用的。内置端点仅在可用时才会自动配置。大多数应用程序选择通过 http 公开。例如，默认情况下，health 端点映射到 /actuator/health。\n\n\n# 启用端点\n\n默认情况下，除了 shutdown 之外的所有端点都已启用。要配置端点的启用，请使用 management.endpoint.<id>.enabled 属性。以下示例启用 shutdown 端点：\n\nmanagement.endpoint.shutdown.enabled=true\n\n\n如果您希望端点是明确指定才启用，请将 management.endpoints.enabled-by-default 属性设置为 false 并根据需要明确指定启用的端点，以下为示例：\n\nmanagement.endpoints.enabled-by-default=false\nmanagement.endpoint.info.enabled=true\n\n\n\n# 暴露端点\n\n由于端点可能包含敏感信息，您应该仔细考虑何时暴露它们。下表显示了内置端点的默认曝光：\n\nid                 jmx   web\nauditevents        yes   no\nbeans              yes   no\ncaches             yes   no\nconditions         yes   no\nconfigprops        yes   no\nenv                yes   no\nflyway             yes   no\nhealth             yes   yes\nheapdump           n/a   no\nhttptrace          yes   no\ninfo               yes   no\nintegrationgraph   yes   no\njolokia            n/a   no\nlogfile            n/a   no\nloggers            yes   no\nliquibase          yes   no\nmetrics            yes   no\nmappings           yes   no\nprometheus         n/a   no\nquartz             yes   no\nscheduledtasks     yes   no\nsessions           yes   no\nshutdown           yes   no\nstartup            yes   no\nthreaddump         yes   no\n\n要更改暴露的端点，请使用以下特定于技术的包含和排除属性：\n\nproperty                                    default\nmanagement.endpoints.jmx.exposure.exclude   \nmanagement.endpoints.jmx.exposure.include   *\nmanagement.endpoints.web.exposure.exclude   \nmanagement.endpoints.web.exposure.include   health\n\ninclude 属性列出了暴露的端点的 id。 exclude 属性列出了不应暴露的端点的 id。 exclude 属性优先于 include 属性。您可以使用端点 id 列表配置包含和排除属性。\n\n例如，仅暴露 health 和 info 端点，其他端点都不通过 jmx 暴露，可以按如下配置：\n\nmanagement.endpoints.jmx.exposure.include=health,info\n\n\n注意：* 可用于选择所有端点。\n\n\n# 安全\n\n出于安全考虑，只有 /health 端点会通过 http 方式暴露。用户可以通过 management.endpoints.web.exposure.include 决定哪些端点可以通过 http 方式暴露。\n\n如果 spring security 在类路径上并且不存在其他 websecurityconfigureradapter 或 securityfilterchain bean，则除 /health 之外的所有 actuator 都由 spring boot 自动启用安全控制。如果用户自定义了 websecurityconfigureradapter 或 securityfilterchain bean，spring boot 不再启用安全控制，由用户自行控制访问规则。\n\n如果您希望为 http 端点定义安全控制（例如，只允许具有特定角色的用户访问它们），spring boot 提供了一些方便的 requestmatcher 对象，您可以将它们与 spring security 结合使用。\n\n下面是一个典型的 spring security 配置示例：\n\n@configuration(proxybeanmethods = false)\npublic class mysecurityconfiguration {\n\n    @bean\n    public securityfilterchain securityfilterchain(httpsecurity http) throws exception {\n        http.requestmatcher(endpointrequest.toanyendpoint())\n                .authorizerequests((requests) -> requests.anyrequest().hasrole("endpoint_admin"));\n        http.httpbasic();\n        return http.build();\n    }\n\n}\n\n\n前面的示例使用 endpointrequest.toanyendpoint() 将请求匹配到任何端点，然后确保所有端点都具有 endpoint_admin 角色。 endpointrequest 上还提供了其他几种匹配器方法。\n\n如果希望无需身份验证即可访问所有执行器端点。可以通过更改 management.endpoints.web.exposure.include 属性来做到这一点，如下所示：\n\nmanagement.endpoints.web.exposure.include=*\n\n\n此外，如果存在 spring security，您将需要添加自定义安全配置，以允许未经身份验证的访问端点，如以下示例所示：\n\n@configuration(proxybeanmethods = false)\npublic class mysecurityconfiguration {\n\n    @bean\n    public securityfilterchain securityfilterchain(httpsecurity http) throws exception {\n        http.requestmatcher(endpointrequest.toanyendpoint())\n                .authorizerequests((requests) -> requests.anyrequest().permitall());\n        return http.build();\n    }\n\n}\n\n\n由于 spring boot 依赖于 spring security 的默认设置，因此 csrf 保护默认开启。这意味着在使用默认安全配置时，需要 post（关闭和记录器端点）、put 或 delete 的执行器端点会收到 403（禁止）错误。\n\n> 建议仅在创建非浏览器客户端使用的服务时完全禁用 csrf 保护。\n\n\n# 配置端点\n\n端点会自动缓存对不带任何参数的读操作的响应数据。要配置端点缓存响应的时间量，请使用其 cache.time-to-live 属性。以下示例将 bean 端点缓存的生存时间设置为 10 秒：\n\nmanagement.endpoint.beans.cache.time-to-live=10s\n\n\n\n# actuator web 端点的超媒体\n\nspring boot actuator 中内置了一个“发现页面”端点，其中包含了所有端点的链接。默认情况下，“发现页面”在 /actuator 上可用。\n\n要禁用“发现页面”，请将以下属性添加到您的应用程序属性中：\n\nmanagement.endpoints.web.discovery.enabled=false\n\n\n配置自定义管理上下文路径后，“发现页面”会自动从 /actuator 移动到应用管理上下文的根目录。例如，如果管理上下文路径是 /management，则发现页面可从 /management 获得。当管理上下文路径设置为 / 时，发现页面被禁用以防止与其他映射发生冲突的可能性。\n\n\n# 跨域支持\n\ncors 是一种 w3c 规范，可让用户以灵活的方式指定授权哪种跨域请求。如果使用 spring mvc 或 spring webflux，则可以配置 actuator 的 web 端点以支持此类场景。\n\ncors 支持默认是禁用的，只有在设置 management.endpoints.web.cors.allowed-origins 属性后才会启用。以下配置允许来自 example.com 域的 get 和 post 调用：\n\nmanagement.endpoints.web.cors.allowed-origins=https://example.com\nmanagement.endpoints.web.cors.allowed-methods=get,post\n\n\n\n# 自定义端点\n\n如果添加带有 @endpoint 注释的 @bean，则任何带有 @readoperation、@writeoperation 或 @deleteoperation 注释的方法都会自动通过 jmx 公开，并且在 web 应用程序中，也可以通过 http 公开。可以使用 jersey、spring mvc 或 spring webflux 通过 http 公开端点。如果 jersey 和 spring mvc 都可用，则使用 spring mvc。\n\n以下示例公开了一个返回自定义对象的读取操作：\n\n@readoperation\npublic customdata getdata() {\n    return new customdata("test", 5);\n}\n\n\n您还可以使用 @jmxendpoint 或 @webendpoint 编写特定技术的端点。这些端点仅限于各自的技术。例如，@webendpoint 仅通过 http 而不是通过 jmx 公开。\n\n您可以使用 @endpointwebextension 和 @endpointjmxextension 编写特定技术的扩展。这些注释让您可以提供特定技术的操作来扩充现有端点。\n\n最后，如果您需要访问 web 框架的功能，您可以实现 servlet 或 spring @controller 和 @restcontroller 端点，但代价是它们无法通过 jmx 或使用不同的 web 框架获得。\n\n\n# 通过 http 进行监控和管理\n\n\n# 自定义管理端点路径\n\n如果是 web 应用，spring boot actuator 会自动将所有启用的端点通过 http 方式暴露。默认约定是使用前缀为 /actuator 的端点的 id 作为 url 路径。例如，健康被暴露为 /actuator/health。\n\n有时，自定义管理端点的前缀很有用。例如，您的应用程序可能已经将 /actuator 用于其他目的。您可以使用 management.endpoints.web.base-path 属性更改管理端点的前缀，如以下示例所示：\n\nmanagement.endpoints.web.base-path=/manage\n\n\n该示例将端点从 /actuator/{id} 更改为 /manage/{id}（例如，/manage/info）。\n\n\n# 自定义管理服务器端口\n\nmanagement.server.port=8081\n\n\n\n# 配置 ssl\n\n当配置为使用自定义端口时，还可以使用各种 management.server.ssl.* 属性为管理服务器配置自己的 ssl。例如，这样做可以让管理服务器在主应用程序使用 https 时通过 http 可用，如以下属性设置所示：\n\nserver.port=8443\nserver.ssl.enabled=true\nserver.ssl.key-store=classpath:store.jks\nserver.ssl.key-password=secret\nmanagement.server.port=8080\nmanagement.server.ssl.enabled=false\n\n\n或者，主服务器和管理服务器都可以使用 ssl，但使用不同的密钥存储，如下所示：\n\nserver.port=8443\nserver.ssl.enabled=true\nserver.ssl.key-store=classpath:main.jks\nserver.ssl.key-password=secret\nmanagement.server.port=8080\nmanagement.server.ssl.enabled=true\nmanagement.server.ssl.key-store=classpath:management.jks\nmanagement.server.ssl.key-password=secret\n\n\n\n# 自定义管理服务器地址\n\nmanagement.server.port=8081\nmanagement.server.address=127.0.0.1\n\n\n\n# 禁用 http 端点\n\n如果您不想通过 http 方式暴露端点，可以将管理端口设置为 -1，如以下示例所示：\n\nmanagement.server.port=-1\n\n\n也可以通过使用 management.endpoints.web.exposure.exclude 属性来实现这一点，如以下示例所示：\n\nmanagement.endpoints.web.exposure.exclude=*\n\n\n\n# 通过 jmx 进行监控和管理\n\njava 管理扩展 (jmx) 提供了一种标准机制来监视和管理应用程序。默认情况下，此功能未启用。您可以通过将 spring.jmx.enabled 配置属性设置为 true 来打开它。 spring boot 将最合适的 mbeanserver 暴露为 id 为 mbeanserver 的 bean。使用 spring jmx 注释（@managedresource、@managedattribute 或 @managedoperation）注释的任何 bean 都会暴露给它。\n\n如果您的平台提供标准 mbeanserver，则 spring boot 会使用该标准并在必要时默认使用 vm mbeanserver。如果一切都失败了，则创建一个新的 mbeanserver。\n\n有关更多详细信息，请参阅 jmxautoconfiguration 类。\n\n默认情况下，spring boot 还将管理端点公开为 org.springframework.boot 域下的 jmx mbean。要完全控制 jmx 域中的端点注册，请考虑注册您自己的 endpointobjectnamefactory 实现。\n\n\n# 定制化 mbean names\n\nmbean 的名称通常由端点的 id 生成。例如，健康端点公开为 org.springframework.boot:type=endpoint,name=health。\n\n如果您的应用程序包含多个 spring applicationcontext，您可能会发现名称冲突。要解决此问题，您可以将 spring.jmx.unique-names 属性设置为 true，以便 mbean 名称始终是唯一的。\n\n如果需要定制，跨域按如下配置：\n\nspring.jmx.unique-names=true\nmanagement.endpoints.jmx.domain=com.example.myapp\n\n\n\n# 禁用 jmx 端点\n\n想禁用 jmx 端点，可以按如下配置：\n\nmanagement.endpoints.jmx.exposure.exclude=*\n\n\n\n# 将 jolokia 用于基于 http 的 jmx\n\njolokia 是一个 jmx-http 的桥接工具，它提供了另一种访问 jmx bean 的方法。要使用 jolokia，需要先添加依赖：\n\n<dependency>\n    <groupid>org.jolokia</groupid>\n    <artifactid>jolokia-core</artifactid>\n</dependency\n\n\n然后，您可以通过将 jolokia 或 * 添加到 management.endpoints.web.exposure.include 属性来暴露 jolokia 端点。然后，您可以在管理 http 服务器上使用 /actuator/jolokia 访问它。\n\n\n# 日志\n\nspring boot actuator 支持查看和配置应用日志级别。\n\n日志级别的可选值如下：\n\n * trace\n * debug\n * info\n * warn\n * error\n * fatal\n * off\n * null\n\nnull 表示没有显式配置。\n\n\n# 指标\n\n\n# 审计\n\nspring boot actuator 支持简单的审计功能。如果应用中启用了 spring security，spring boot actuator 就会发布安全事件（如：“身份验证成功”、“失败”和“访问被拒绝”异常）。\n\n可以通过在应用的配置中提供 auditeventrepository 类型的 bean 来启用审计。为方便起见，spring boot 提供了一个 inmemoryauditeventrepository。 inmemoryauditeventrepository 的功能有限，建议仅将其用于开发环境。\n\n如果要自定义安全事件，可以提供 abstractauthenticationauditlistener 和 abstractauthorizationauditlistener 实现。\n\n此外，还可以将审计服务用于业务活动。为此，要么将 auditeventrepository bean 注入组件并直接使用它，要么使用 spring applicationeventpublisher 发布 auditapplicationevent（通过实现 applicationeventpublisheraware）。\n\n\n# http 追踪\n\n用户可以通过在应用中提供 httptracerepository 类型的 bean 来启用 http 跟踪。spring boot 提供了内置的 inmemoryhttptracerepository，它可以存储最近 100 次（默认）请求-响应的追踪数据。与其他 http 追踪解决方案相比，inmemoryhttptracerepository 比较受限，建议仅用于开发环境。对于生产环境，建议使用 zipkin 或 spring cloud sleuth。\n\n或者，可以自定义 httptracerepository。\n\n\n# 处理监控\n\n在 spring-boot 模块中，您可以找到两个类来创建对进程监控有用的文件：\n\n * applicationpidfilewriter 创建一个包含应用程序 pid 的文件（默认情况下，在应用程序目录中，文件名为 application.pid）。\n * webserverportfilewriter 创建一个文件（或多个文件），其中包含正在运行的 web 服务器的端口（默认情况下，在应用程序目录中，文件名为 application.port）。\n\n\n# 参考资料\n\n * spring boot 官方文档之 production-ready features',charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Spring 其他",frontmatter:{title:"Spring 其他",date:"2020-02-26T23:48:06.000Z",categories:["Java","框架","Spring","Spring其他"],tags:["Java","框架","Spring","SpringBoot"],permalink:"/pages/6bb8c1/",hidden:!0,index:!1},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/99.Spring%E5%85%B6%E4%BB%96/",relativePath:"01.Java/13.框架/01.Spring/99.Spring其他/README.md",key:"v-16e36653",path:"/pages/6bb8c1/",headers:[{level:2,title:"📖 内容",slug:"📖-内容",normalizedTitle:"📖 内容",charIndex:16},{level:2,title:"📚 资料",slug:"📚-资料",normalizedTitle:"📚 资料",charIndex:89},{level:2,title:"🚪 传送",slug:"🚪-传送",normalizedTitle:"🚪 传送",charIndex:268}],headersStr:"📖 内容 📚 资料 🚪 传送",content:"# Spring 其他\n\n\n# 📖 内容\n\n * Spring4 升级\n * SpringBoot 之 banner\n * SpringBoot 之 Actuator\n\n\n# 📚 资料\n\n * 官方\n   * Spring 官网\n   * Spring Framework 官方文档\n   * Spring Github\n * 书籍\n   * 《Spring In Action》\n * 教程\n   * 《小马哥讲 Spring 核心编程思想》\n   * geekbang-lessons\n   * 跟我学 Spring3\n\n\n# 🚪 传送\n\n◾ 💧 钝悟的 IT 知识图谱 ◾ 🎯 我的博客 ◾",normalizedContent:"# spring 其他\n\n\n# 📖 内容\n\n * spring4 升级\n * springboot 之 banner\n * springboot 之 actuator\n\n\n# 📚 资料\n\n * 官方\n   * spring 官网\n   * spring framework 官方文档\n   * spring github\n * 书籍\n   * 《spring in action》\n * 教程\n   * 《小马哥讲 spring 核心编程思想》\n   * geekbang-lessons\n   * 跟我学 spring3\n\n\n# 🚪 传送\n\n◾ 💧 钝悟的 it 知识图谱 ◾ 🎯 我的博客 ◾",charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Mybatis快速入门",frontmatter:{title:"Mybatis快速入门",date:"2022-02-17T22:34:30.000Z",order:1,categories:["Java","框架","ORM"],tags:["Java","框架","ORM","Mybatis"],permalink:"/pages/d4e6ee/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/11.ORM/01.Mybatis%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8.html",relativePath:"01.Java/13.框架/11.ORM/01.Mybatis快速入门.md",key:"v-dde25f08",path:"/pages/d4e6ee/",headers:[{level:2,title:"Mybatis 简介",slug:"mybatis-简介",normalizedTitle:"mybatis 简介",charIndex:102},{level:3,title:"什么是 MyBatis",slug:"什么是-mybatis",normalizedTitle:"什么是 mybatis",charIndex:119},{level:3,title:"MyBatis vs. Hibernate",slug:"mybatis-vs-hibernate",normalizedTitle:"mybatis vs. hibernate",charIndex:310},{level:2,title:"快速入门",slug:"快速入门",normalizedTitle:"快速入门",charIndex:10},{level:3,title:"数据库准备",slug:"数据库准备",normalizedTitle:"数据库准备",charIndex:821},{level:3,title:"添加 Mybatis",slug:"添加-mybatis",normalizedTitle:"添加 mybatis",charIndex:1448},{level:3,title:"Mybatis 配置",slug:"mybatis-配置",normalizedTitle:"mybatis 配置",charIndex:1631},{level:3,title:"Mapper",slug:"mapper",normalizedTitle:"mapper",charIndex:2506},{level:4,title:"Mapper.xml",slug:"mapper-xml",normalizedTitle:"mapper.xml",charIndex:2506},{level:4,title:"Mapper.java",slug:"mapper-java",normalizedTitle:"mapper.java",charIndex:4443},{level:4,title:"数据实体.java",slug:"数据实体-java",normalizedTitle:"数据实体.java",charIndex:4914},{level:3,title:"测试程序",slug:"测试程序",normalizedTitle:"测试程序",charIndex:5237},{level:2,title:"Mybatis xml 配置",slug:"mybatis-xml-配置",normalizedTitle:"mybatis xml 配置",charIndex:6290},{level:2,title:"Mybatis xml 映射器",slug:"mybatis-xml-映射器",normalizedTitle:"mybatis xml 映射器",charIndex:6662},{level:2,title:"Mybatis 扩展",slug:"mybatis-扩展",normalizedTitle:"mybatis 扩展",charIndex:7030},{level:3,title:"Mybatis 类型处理器",slug:"mybatis-类型处理器",normalizedTitle:"mybatis 类型处理器",charIndex:7045},{level:3,title:"Mybatis 插件",slug:"mybatis-插件",normalizedTitle:"mybatis 插件",charIndex:8426},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:9825}],headersStr:"Mybatis 简介 什么是 MyBatis MyBatis vs. Hibernate 快速入门 数据库准备 添加 Mybatis Mybatis 配置 Mapper Mapper.xml Mapper.java 数据实体.java 测试程序 Mybatis xml 配置 Mybatis xml 映射器 Mybatis 扩展 Mybatis 类型处理器 Mybatis 插件 参考资料",content:'# MyBatis 快速入门\n\n> MyBatis 的前身就是 iBatis ，是一个作用在数据持久层的对象关系映射（Object Relational Mapping，简称 ORM）框架。\n\n\n\n\n# Mybatis 简介\n\n\n\n\n# 什么是 MyBatis\n\nMyBatis 是一款持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。\n\n\n# MyBatis vs. Hibernate\n\nMyBatis 和 Hibernate 都是 Java 世界中比较流行的 ORM 框架。我们应该了解其各自的优势，根据项目的需要去抉择在开发中使用哪个框架。\n\nMybatis 优势\n\n * MyBatis 可以进行更为细致的 SQL 优化，可以减少查询字段。\n * MyBatis 容易掌握，而 Hibernate 门槛较高。\n\nHibernate 优势\n\n * Hibernate 的 DAO 层开发比 MyBatis 简单，Mybatis 需要维护 SQL 和结果映射。\n * Hibernate 对对象的维护和缓存要比 MyBatis 好，对增删改查的对象的维护要方便。\n * Hibernate 数据库移植性很好，MyBatis 的数据库移植性不好，不同的数据库需要写不同 SQL。\n * Hibernate 有更好的二级缓存机制，可以使用第三方缓存。MyBatis 本身提供的缓存机制不佳。\n\n\n# 快速入门\n\n> 这里，我将以一个入门级的示例来演示 Mybatis 是如何工作的。\n> \n> 注：本文后面章节中的原理、源码部分也将基于这个示例来进行讲解。\n\n\n# 数据库准备\n\n在本示例中，需要针对一张用户表进行 CRUD 操作。其数据模型如下：\n\nCREATE TABLE IF NOT EXISTS user (\n    id      BIGINT(10) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT \'Id\',\n    name    VARCHAR(10)         NOT NULL DEFAULT \'\' COMMENT \'用户名\',\n    age     INT(3)              NOT NULL DEFAULT 0 COMMENT \'年龄\',\n    address VARCHAR(32)         NOT NULL DEFAULT \'\' COMMENT \'地址\',\n    email   VARCHAR(32)         NOT NULL DEFAULT \'\' COMMENT \'邮件\',\n    PRIMARY KEY (id)\n) COMMENT = \'用户表\';\n\nINSERT INTO user (name, age, address, email)\nVALUES (\'张三\', 18, \'北京\', \'xxx@163.com\');\nINSERT INTO user (name, age, address, email)\nVALUES (\'李四\', 19, \'上海\', \'xxx@163.com\');\n\n\n\n# 添加 Mybatis\n\n如果使用 Maven 来构建项目，则需将下面的依赖代码置于 pom.xml 文件中：\n\n<dependency>\n  <groupId>org.mybatis</groupId>\n  <artifactId>mybatis</artifactId>\n  <version>x.x.x</version>\n</dependency>\n\n\n\n# Mybatis 配置\n\nXML 配置文件中包含了对 MyBatis 系统的核心设置，包括获取数据库连接实例的数据源（DataSource）以及决定事务作用域和控制方式的事务管理器（TransactionManager）。\n\n本示例中只是给出最简化的配置。\n\n【示例】mybatis-config.xml 文件\n\n<?xml version="1.0" encoding="utf-8"?>\n<!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN"\n  "http://mybatis.org/dtd/mybatis-3-config.dtd">\n<configuration>\n  <environments default="development">\n    <environment id="development">\n      <transactionManager type="JDBC" />\n      <dataSource type="POOLED">\n        <property name="driver" value="com.mysql.cj.jdbc.Driver" />\n        <property name="url"\n                  value="jdbc:mysql://127.0.0.1:3306/spring_tutorial?serverTimezone=UTC" />\n        <property name="username" value="root" />\n        <property name="password" value="root" />\n      </dataSource>\n    </environment>\n  </environments>\n  <mappers>\n    <mapper resource="mybatis/mapper/UserMapper.xml" />\n  </mappers>\n</configuration>\n\n\n> 说明：上面的配置文件中仅仅指定了数据源连接方式和 User 表的映射配置文件。\n\n\n# Mapper\n\n# Mapper.xml\n\n个人理解，Mapper.xml 文件可以看做是 Mybatis 的 JDBC SQL 模板。\n\n【示例】UserMapper.xml 文件\n\n下面是一个通过 Mybatis Generator 自动生成的完整的 Mapper 文件。\n\n<?xml version="1.0" encoding="UTF-8"?>\n<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">\n<mapper namespace="io.github.dunwu.spring.orm.mapper.UserMapper">\n  <resultMap id="BaseResultMap" type="io.github.dunwu.spring.orm.entity.User">\n    <id column="id" jdbcType="BIGINT" property="id" />\n    <result column="name" jdbcType="VARCHAR" property="name" />\n    <result column="age" jdbcType="INTEGER" property="age" />\n    <result column="address" jdbcType="VARCHAR" property="address" />\n    <result column="email" jdbcType="VARCHAR" property="email" />\n  </resultMap>\n  <delete id="deleteByPrimaryKey" parameterType="java.lang.Long">\n    delete from user\n    where id = #{id,jdbcType=BIGINT}\n  </delete>\n  <insert id="insert" parameterType="io.github.dunwu.spring.orm.entity.User">\n    insert into user (id, name, age,\n      address, email)\n    values (#{id,jdbcType=BIGINT}, #{name,jdbcType=VARCHAR}, #{age,jdbcType=INTEGER},\n      #{address,jdbcType=VARCHAR}, #{email,jdbcType=VARCHAR})\n  </insert>\n  <update id="updateByPrimaryKey" parameterType="io.github.dunwu.spring.orm.entity.User">\n    update user\n    set name = #{name,jdbcType=VARCHAR},\n      age = #{age,jdbcType=INTEGER},\n      address = #{address,jdbcType=VARCHAR},\n      email = #{email,jdbcType=VARCHAR}\n    where id = #{id,jdbcType=BIGINT}\n  </update>\n  <select id="selectByPrimaryKey" parameterType="java.lang.Long" resultMap="BaseResultMap">\n    select id, name, age, address, email\n    from user\n    where id = #{id,jdbcType=BIGINT}\n  </select>\n  <select id="selectAll" resultMap="BaseResultMap">\n    select id, name, age, address, email\n    from user\n  </select>\n</mapper>\n\n\n# Mapper.java\n\nMapper.java 文件是 Mapper.xml 对应的 Java 对象。\n\n【示例】UserMapper.java 文件\n\npublic interface UserMapper {\n\n    int deleteByPrimaryKey(Long id);\n\n    int insert(User record);\n\n    User selectByPrimaryKey(Long id);\n\n    List<User> selectAll();\n\n    int updateByPrimaryKey(User record);\n\n}\n\n\n对比 UserMapper.java 和 UserMapper.xml 文件，不难发现：\n\nUserMapper.java 中的方法和 UserMapper.xml 的 CRUD 语句元素（ <insert>、<delete>、<update>、<select>）存在一一对应关系。\n\n在 Mybatis 中，正是通过方法的全限定名，将二者绑定在一起。\n\n# 数据实体.java\n\n【示例】User.java 文件\n\npublic class User {\n    private Long id;\n\n    private String name;\n\n    private Integer age;\n\n    private String address;\n\n    private String email;\n\n}\n\n\n<insert>、<delete>、<update>、<select> 的 parameterType 属性以及 <resultMap> 的 type 属性都可能会绑定到数据实体。这样就可以把 JDBC 操作的输入输出和 JavaBean 结合起来，更加方便、易于理解。\n\n\n# 测试程序\n\n【示例】MybatisDemo.java 文件\n\npublic class MybatisDemo {\n\n    public static void main(String[] args) throws Exception {\n        // 1. 加载 mybatis 配置文件，创建 SqlSessionFactory\n        // 注：在实际的应用中，SqlSessionFactory 应该是单例\n        InputStream inputStream = Resources.getResourceAsStream("mybatis/mybatis-config.xml");\n        SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();\n        SqlSessionFactory factory = builder.build(inputStream);\n\n        // 2. 创建一个 SqlSession 实例，进行数据库操作\n        SqlSession sqlSession = factory.openSession();\n\n        // 3. Mapper 映射并执行\n        Long params = 1L;\n        List<User> list = sqlSession.selectList("io.github.dunwu.spring.orm.mapper.UserMapper.selectByPrimaryKey", params);\n        for (User user : list) {\n            System.out.println("user name: " + user.getName());\n        }\n        // 输出：user name: 张三\n    }\n\n}\n\n\n> 说明：\n> \n> SqlSession 接口是 Mybatis API 核心中的核心，它代表了 Mybatis 和数据库的一次完整会话。\n> \n>  * Mybatis 会解析配置，并根据配置创建 SqlSession 。\n>  * 然后，Mybatis 将 Mapper 映射为 SqlSession，然后传递参数，执行 SQL 语句并获取结果。\n\n\n# Mybatis xml 配置\n\n> 配置的详细内容请参考：“ Mybatis 官方文档之配置 ” 。\n\nMyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息。主要配置项有以下：\n\n * properties（属性）\n * settings（设置）\n * typeAliases（类型别名）\n * typeHandlers（类型处理器）\n * objectFactory（对象工厂）\n * plugins（插件）\n * environments（环境配置）\n   * environment（环境变量）\n     * transactionManager（事务管理器）\n     * dataSource（数据源）\n * databaseIdProvider（数据库厂商标识）\n * mappers（映射器）\n\n\n# Mybatis xml 映射器\n\n> SQL XML 映射文件详细内容请参考：“ Mybatis 官方文档之 XML 映射文件 ”。\n\nXML 映射文件只有几个顶级元素：\n\n * cache – 对给定命名空间的缓存配置。\n * cache-ref – 对其他命名空间缓存配置的引用。\n * resultMap – 是最复杂也是最强大的元素，用来描述如何从数据库结果集中来加载对象。\n * parameterMap – 已被废弃！老式风格的参数映射。更好的办法是使用内联参数，此元素可能在将来被移除。文档中不会介绍此元素。\n * sql – 可被其他语句引用的可重用语句块。\n * insert – 映射插入语句\n * update – 映射更新语句\n * delete – 映射删除语句\n * select – 映射查询语句\n\n\n# Mybatis 扩展\n\n\n# Mybatis 类型处理器\n\nMyBatis 在设置预处理语句（PreparedStatement）中的参数或从结果集中取出一个值时， 都会用类型处理器将获取到的值以合适的方式转换成 Java 类型。下表描述了一些默认的类型处理器。\n\n从 3.4.5 开始，MyBatis 默认支持 JSR-310（日期和时间 API） 。\n\n你可以重写已有的类型处理器或创建你自己的类型处理器来处理不支持的或非标准的类型。 具体做法为：实现 org.apache.ibatis.type.TypeHandler 接口， 或继承一个很便利的类 org.apache.ibatis.type.BaseTypeHandler， 并且可以（可选地）将它映射到一个 JDBC 类型。比如：\n\n// ExampleTypeHandler.java\n@MappedJdbcTypes(JdbcType.VARCHAR)\npublic class ExampleTypeHandler extends BaseTypeHandler<String> {\n\n  @Override\n  public void setNonNullParameter(PreparedStatement ps, int i, String parameter, JdbcType jdbcType) throws SQLException {\n    ps.setString(i, parameter);\n  }\n\n  @Override\n  public String getNullableResult(ResultSet rs, String columnName) throws SQLException {\n    return rs.getString(columnName);\n  }\n\n  @Override\n  public String getNullableResult(ResultSet rs, int columnIndex) throws SQLException {\n    return rs.getString(columnIndex);\n  }\n\n  @Override\n  public String getNullableResult(CallableStatement cs, int columnIndex) throws SQLException {\n    return cs.getString(columnIndex);\n  }\n}\n\n\n\x3c!-- mybatis-config.xml --\x3e\n<typeHandlers>\n  <typeHandler handler="org.mybatis.example.ExampleTypeHandler"/>\n</typeHandlers>\n\n\n使用上述的类型处理器将会覆盖已有的处理 Java String 类型的属性以及 VARCHAR 类型的参数和结果的类型处理器。 要注意 MyBatis 不会通过检测数据库元信息来决定使用哪种类型，所以你必须在参数和结果映射中指明字段是 VARCHAR 类型， 以使其能够绑定到正确的类型处理器上。这是因为 MyBatis 直到语句被执行时才清楚数据类型。\n\n\n# Mybatis 插件\n\nMyBatis 允许你在映射语句执行过程中的某一点进行拦截调用。默认情况下，MyBatis 允许使用插件来拦截的方法调用包括：\n\n * Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)\n * ParameterHandler (getParameterObject, setParameters)\n * ResultSetHandler (handleResultSets, handleOutputParameters)\n * StatementHandler (prepare, parameterize, batch, update, query)\n\n这些类中方法的细节可以通过查看每个方法的签名来发现，或者直接查看 MyBatis 发行包中的源代码。 如果你想做的不仅仅是监控方法的调用，那么你最好相当了解要重写的方法的行为。 因为在试图修改或重写已有方法的行为时，很可能会破坏 MyBatis 的核心模块。 这些都是更底层的类和方法，所以使用插件的时候要特别当心。\n\n通过 MyBatis 提供的强大机制，使用插件是非常简单的，只需实现 Interceptor 接口，并指定想要拦截的方法签名即可。\n\n// ExamplePlugin.java\n@Intercepts({@Signature(\n  type= Executor.class,\n  method = "update",\n  args = {MappedStatement.class,Object.class})})\npublic class ExamplePlugin implements Interceptor {\n  private Properties properties = new Properties();\n  public Object intercept(Invocation invocation) throws Throwable {\n    // implement pre processing if need\n    Object returnObject = invocation.proceed();\n    // implement post processing if need\n    return returnObject;\n  }\n  public void setProperties(Properties properties) {\n    this.properties = properties;\n  }\n}\n\n\n\x3c!-- mybatis-config.xml --\x3e\n<plugins>\n  <plugin interceptor="org.mybatis.example.ExamplePlugin">\n    <property name="someProperty" value="100"/>\n  </plugin>\n</plugins>\n\n\n上面的插件将会拦截在 Executor 实例中所有的 “update” 方法调用， 这里的 Executor 是负责执行底层映射语句的内部对象。\n\n\n# 参考资料\n\n * 官方\n   * Mybatis Github\n   * Mybatis 官网\n   * MyBatis 官方代码生成（mybatis-generator）\n   * MyBatis 官方集成 Spring（mybatis-spring）\n   * Mybatis 官方集成 Spring Boot（mybatis-spring-boot）\n * 扩展插件\n   * MyBatis-Plus - CRUD 扩展插件、代码生成器、分页器等多功能\n   * Mapper - CRUD 扩展插件\n   * Mybatis-PageHelper - Mybatis 通用分页插件\n * 文章\n   * 深入理解 mybatis 原理\n   * mybatis 源码中文注释\n   * MyBatis Generator 详解\n   * Mybatis 常见面试题\n   * Mybatis 中强大的 resultMap',normalizedContent:'# mybatis 快速入门\n\n> mybatis 的前身就是 ibatis ，是一个作用在数据持久层的对象关系映射（object relational mapping，简称 orm）框架。\n\n\n\n\n# mybatis 简介\n\n\n\n\n# 什么是 mybatis\n\nmybatis 是一款持久层框架，它支持定制化 sql、存储过程以及高级映射。mybatis 避免了几乎所有的 jdbc 代码和手动设置参数以及获取结果集。mybatis 可以使用简单的 xml 或注解来配置和映射原生类型、接口和 java 的 pojo（plain old java objects，普通老式 java 对象）为数据库中的记录。\n\n\n# mybatis vs. hibernate\n\nmybatis 和 hibernate 都是 java 世界中比较流行的 orm 框架。我们应该了解其各自的优势，根据项目的需要去抉择在开发中使用哪个框架。\n\nmybatis 优势\n\n * mybatis 可以进行更为细致的 sql 优化，可以减少查询字段。\n * mybatis 容易掌握，而 hibernate 门槛较高。\n\nhibernate 优势\n\n * hibernate 的 dao 层开发比 mybatis 简单，mybatis 需要维护 sql 和结果映射。\n * hibernate 对对象的维护和缓存要比 mybatis 好，对增删改查的对象的维护要方便。\n * hibernate 数据库移植性很好，mybatis 的数据库移植性不好，不同的数据库需要写不同 sql。\n * hibernate 有更好的二级缓存机制，可以使用第三方缓存。mybatis 本身提供的缓存机制不佳。\n\n\n# 快速入门\n\n> 这里，我将以一个入门级的示例来演示 mybatis 是如何工作的。\n> \n> 注：本文后面章节中的原理、源码部分也将基于这个示例来进行讲解。\n\n\n# 数据库准备\n\n在本示例中，需要针对一张用户表进行 crud 操作。其数据模型如下：\n\ncreate table if not exists user (\n    id      bigint(10) unsigned not null auto_increment comment \'id\',\n    name    varchar(10)         not null default \'\' comment \'用户名\',\n    age     int(3)              not null default 0 comment \'年龄\',\n    address varchar(32)         not null default \'\' comment \'地址\',\n    email   varchar(32)         not null default \'\' comment \'邮件\',\n    primary key (id)\n) comment = \'用户表\';\n\ninsert into user (name, age, address, email)\nvalues (\'张三\', 18, \'北京\', \'xxx@163.com\');\ninsert into user (name, age, address, email)\nvalues (\'李四\', 19, \'上海\', \'xxx@163.com\');\n\n\n\n# 添加 mybatis\n\n如果使用 maven 来构建项目，则需将下面的依赖代码置于 pom.xml 文件中：\n\n<dependency>\n  <groupid>org.mybatis</groupid>\n  <artifactid>mybatis</artifactid>\n  <version>x.x.x</version>\n</dependency>\n\n\n\n# mybatis 配置\n\nxml 配置文件中包含了对 mybatis 系统的核心设置，包括获取数据库连接实例的数据源（datasource）以及决定事务作用域和控制方式的事务管理器（transactionmanager）。\n\n本示例中只是给出最简化的配置。\n\n【示例】mybatis-config.xml 文件\n\n<?xml version="1.0" encoding="utf-8"?>\n<!doctype configuration public "-//mybatis.org//dtd config 3.0//en"\n  "http://mybatis.org/dtd/mybatis-3-config.dtd">\n<configuration>\n  <environments default="development">\n    <environment id="development">\n      <transactionmanager type="jdbc" />\n      <datasource type="pooled">\n        <property name="driver" value="com.mysql.cj.jdbc.driver" />\n        <property name="url"\n                  value="jdbc:mysql://127.0.0.1:3306/spring_tutorial?servertimezone=utc" />\n        <property name="username" value="root" />\n        <property name="password" value="root" />\n      </datasource>\n    </environment>\n  </environments>\n  <mappers>\n    <mapper resource="mybatis/mapper/usermapper.xml" />\n  </mappers>\n</configuration>\n\n\n> 说明：上面的配置文件中仅仅指定了数据源连接方式和 user 表的映射配置文件。\n\n\n# mapper\n\n# mapper.xml\n\n个人理解，mapper.xml 文件可以看做是 mybatis 的 jdbc sql 模板。\n\n【示例】usermapper.xml 文件\n\n下面是一个通过 mybatis generator 自动生成的完整的 mapper 文件。\n\n<?xml version="1.0" encoding="utf-8"?>\n<!doctype mapper public "-//mybatis.org//dtd mapper 3.0//en" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">\n<mapper namespace="io.github.dunwu.spring.orm.mapper.usermapper">\n  <resultmap id="baseresultmap" type="io.github.dunwu.spring.orm.entity.user">\n    <id column="id" jdbctype="bigint" property="id" />\n    <result column="name" jdbctype="varchar" property="name" />\n    <result column="age" jdbctype="integer" property="age" />\n    <result column="address" jdbctype="varchar" property="address" />\n    <result column="email" jdbctype="varchar" property="email" />\n  </resultmap>\n  <delete id="deletebyprimarykey" parametertype="java.lang.long">\n    delete from user\n    where id = #{id,jdbctype=bigint}\n  </delete>\n  <insert id="insert" parametertype="io.github.dunwu.spring.orm.entity.user">\n    insert into user (id, name, age,\n      address, email)\n    values (#{id,jdbctype=bigint}, #{name,jdbctype=varchar}, #{age,jdbctype=integer},\n      #{address,jdbctype=varchar}, #{email,jdbctype=varchar})\n  </insert>\n  <update id="updatebyprimarykey" parametertype="io.github.dunwu.spring.orm.entity.user">\n    update user\n    set name = #{name,jdbctype=varchar},\n      age = #{age,jdbctype=integer},\n      address = #{address,jdbctype=varchar},\n      email = #{email,jdbctype=varchar}\n    where id = #{id,jdbctype=bigint}\n  </update>\n  <select id="selectbyprimarykey" parametertype="java.lang.long" resultmap="baseresultmap">\n    select id, name, age, address, email\n    from user\n    where id = #{id,jdbctype=bigint}\n  </select>\n  <select id="selectall" resultmap="baseresultmap">\n    select id, name, age, address, email\n    from user\n  </select>\n</mapper>\n\n\n# mapper.java\n\nmapper.java 文件是 mapper.xml 对应的 java 对象。\n\n【示例】usermapper.java 文件\n\npublic interface usermapper {\n\n    int deletebyprimarykey(long id);\n\n    int insert(user record);\n\n    user selectbyprimarykey(long id);\n\n    list<user> selectall();\n\n    int updatebyprimarykey(user record);\n\n}\n\n\n对比 usermapper.java 和 usermapper.xml 文件，不难发现：\n\nusermapper.java 中的方法和 usermapper.xml 的 crud 语句元素（ <insert>、<delete>、<update>、<select>）存在一一对应关系。\n\n在 mybatis 中，正是通过方法的全限定名，将二者绑定在一起。\n\n# 数据实体.java\n\n【示例】user.java 文件\n\npublic class user {\n    private long id;\n\n    private string name;\n\n    private integer age;\n\n    private string address;\n\n    private string email;\n\n}\n\n\n<insert>、<delete>、<update>、<select> 的 parametertype 属性以及 <resultmap> 的 type 属性都可能会绑定到数据实体。这样就可以把 jdbc 操作的输入输出和 javabean 结合起来，更加方便、易于理解。\n\n\n# 测试程序\n\n【示例】mybatisdemo.java 文件\n\npublic class mybatisdemo {\n\n    public static void main(string[] args) throws exception {\n        // 1. 加载 mybatis 配置文件，创建 sqlsessionfactory\n        // 注：在实际的应用中，sqlsessionfactory 应该是单例\n        inputstream inputstream = resources.getresourceasstream("mybatis/mybatis-config.xml");\n        sqlsessionfactorybuilder builder = new sqlsessionfactorybuilder();\n        sqlsessionfactory factory = builder.build(inputstream);\n\n        // 2. 创建一个 sqlsession 实例，进行数据库操作\n        sqlsession sqlsession = factory.opensession();\n\n        // 3. mapper 映射并执行\n        long params = 1l;\n        list<user> list = sqlsession.selectlist("io.github.dunwu.spring.orm.mapper.usermapper.selectbyprimarykey", params);\n        for (user user : list) {\n            system.out.println("user name: " + user.getname());\n        }\n        // 输出：user name: 张三\n    }\n\n}\n\n\n> 说明：\n> \n> sqlsession 接口是 mybatis api 核心中的核心，它代表了 mybatis 和数据库的一次完整会话。\n> \n>  * mybatis 会解析配置，并根据配置创建 sqlsession 。\n>  * 然后，mybatis 将 mapper 映射为 sqlsession，然后传递参数，执行 sql 语句并获取结果。\n\n\n# mybatis xml 配置\n\n> 配置的详细内容请参考：“ mybatis 官方文档之配置 ” 。\n\nmybatis 的配置文件包含了会深深影响 mybatis 行为的设置和属性信息。主要配置项有以下：\n\n * properties（属性）\n * settings（设置）\n * typealiases（类型别名）\n * typehandlers（类型处理器）\n * objectfactory（对象工厂）\n * plugins（插件）\n * environments（环境配置）\n   * environment（环境变量）\n     * transactionmanager（事务管理器）\n     * datasource（数据源）\n * databaseidprovider（数据库厂商标识）\n * mappers（映射器）\n\n\n# mybatis xml 映射器\n\n> sql xml 映射文件详细内容请参考：“ mybatis 官方文档之 xml 映射文件 ”。\n\nxml 映射文件只有几个顶级元素：\n\n * cache – 对给定命名空间的缓存配置。\n * cache-ref – 对其他命名空间缓存配置的引用。\n * resultmap – 是最复杂也是最强大的元素，用来描述如何从数据库结果集中来加载对象。\n * parametermap – 已被废弃！老式风格的参数映射。更好的办法是使用内联参数，此元素可能在将来被移除。文档中不会介绍此元素。\n * sql – 可被其他语句引用的可重用语句块。\n * insert – 映射插入语句\n * update – 映射更新语句\n * delete – 映射删除语句\n * select – 映射查询语句\n\n\n# mybatis 扩展\n\n\n# mybatis 类型处理器\n\nmybatis 在设置预处理语句（preparedstatement）中的参数或从结果集中取出一个值时， 都会用类型处理器将获取到的值以合适的方式转换成 java 类型。下表描述了一些默认的类型处理器。\n\n从 3.4.5 开始，mybatis 默认支持 jsr-310（日期和时间 api） 。\n\n你可以重写已有的类型处理器或创建你自己的类型处理器来处理不支持的或非标准的类型。 具体做法为：实现 org.apache.ibatis.type.typehandler 接口， 或继承一个很便利的类 org.apache.ibatis.type.basetypehandler， 并且可以（可选地）将它映射到一个 jdbc 类型。比如：\n\n// exampletypehandler.java\n@mappedjdbctypes(jdbctype.varchar)\npublic class exampletypehandler extends basetypehandler<string> {\n\n  @override\n  public void setnonnullparameter(preparedstatement ps, int i, string parameter, jdbctype jdbctype) throws sqlexception {\n    ps.setstring(i, parameter);\n  }\n\n  @override\n  public string getnullableresult(resultset rs, string columnname) throws sqlexception {\n    return rs.getstring(columnname);\n  }\n\n  @override\n  public string getnullableresult(resultset rs, int columnindex) throws sqlexception {\n    return rs.getstring(columnindex);\n  }\n\n  @override\n  public string getnullableresult(callablestatement cs, int columnindex) throws sqlexception {\n    return cs.getstring(columnindex);\n  }\n}\n\n\n\x3c!-- mybatis-config.xml --\x3e\n<typehandlers>\n  <typehandler handler="org.mybatis.example.exampletypehandler"/>\n</typehandlers>\n\n\n使用上述的类型处理器将会覆盖已有的处理 java string 类型的属性以及 varchar 类型的参数和结果的类型处理器。 要注意 mybatis 不会通过检测数据库元信息来决定使用哪种类型，所以你必须在参数和结果映射中指明字段是 varchar 类型， 以使其能够绑定到正确的类型处理器上。这是因为 mybatis 直到语句被执行时才清楚数据类型。\n\n\n# mybatis 插件\n\nmybatis 允许你在映射语句执行过程中的某一点进行拦截调用。默认情况下，mybatis 允许使用插件来拦截的方法调用包括：\n\n * executor (update, query, flushstatements, commit, rollback, gettransaction, close, isclosed)\n * parameterhandler (getparameterobject, setparameters)\n * resultsethandler (handleresultsets, handleoutputparameters)\n * statementhandler (prepare, parameterize, batch, update, query)\n\n这些类中方法的细节可以通过查看每个方法的签名来发现，或者直接查看 mybatis 发行包中的源代码。 如果你想做的不仅仅是监控方法的调用，那么你最好相当了解要重写的方法的行为。 因为在试图修改或重写已有方法的行为时，很可能会破坏 mybatis 的核心模块。 这些都是更底层的类和方法，所以使用插件的时候要特别当心。\n\n通过 mybatis 提供的强大机制，使用插件是非常简单的，只需实现 interceptor 接口，并指定想要拦截的方法签名即可。\n\n// exampleplugin.java\n@intercepts({@signature(\n  type= executor.class,\n  method = "update",\n  args = {mappedstatement.class,object.class})})\npublic class exampleplugin implements interceptor {\n  private properties properties = new properties();\n  public object intercept(invocation invocation) throws throwable {\n    // implement pre processing if need\n    object returnobject = invocation.proceed();\n    // implement post processing if need\n    return returnobject;\n  }\n  public void setproperties(properties properties) {\n    this.properties = properties;\n  }\n}\n\n\n\x3c!-- mybatis-config.xml --\x3e\n<plugins>\n  <plugin interceptor="org.mybatis.example.exampleplugin">\n    <property name="someproperty" value="100"/>\n  </plugin>\n</plugins>\n\n\n上面的插件将会拦截在 executor 实例中所有的 “update” 方法调用， 这里的 executor 是负责执行底层映射语句的内部对象。\n\n\n# 参考资料\n\n * 官方\n   * mybatis github\n   * mybatis 官网\n   * mybatis 官方代码生成（mybatis-generator）\n   * mybatis 官方集成 spring（mybatis-spring）\n   * mybatis 官方集成 spring boot（mybatis-spring-boot）\n * 扩展插件\n   * mybatis-plus - crud 扩展插件、代码生成器、分页器等多功能\n   * mapper - crud 扩展插件\n   * mybatis-pagehelper - mybatis 通用分页插件\n * 文章\n   * 深入理解 mybatis 原理\n   * mybatis 源码中文注释\n   * mybatis generator 详解\n   * mybatis 常见面试题\n   * mybatis 中强大的 resultmap',charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"SPRING-TUTORIAL",frontmatter:{title:"SPRING-TUTORIAL",date:"2022-06-14T09:37:30.000Z",categories:["Java","框架","Spring"],tags:["Java","框架","Spring","SpringBoot"],permalink:"/pages/a1a3d3/",hidden:!0,index:!1},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/",relativePath:"01.Java/13.框架/01.Spring/README.md",key:"v-938fb0a0",path:"/pages/a1a3d3/",headers:[{level:2,title:"📖 内容",slug:"📖-内容",normalizedTitle:"📖 内容",charIndex:149},{level:3,title:"综合",slug:"综合",normalizedTitle:"综合",charIndex:159},{level:3,title:"核心",slug:"核心",normalizedTitle:"核心",charIndex:231},{level:3,title:"数据",slug:"数据",normalizedTitle:"数据",charIndex:365},{level:3,title:"Web",slug:"web",normalizedTitle:"web",charIndex:765},{level:3,title:"IO",slug:"io",normalizedTitle:"io",charIndex:816},{level:3,title:"集成",slug:"集成",normalizedTitle:"集成",charIndex:683},{level:3,title:"其他",slug:"其他",normalizedTitle:"其他",charIndex:948},{level:2,title:"💻 示例",slug:"💻-示例",normalizedTitle:"💻 示例",charIndex:1018},{level:3,title:"核心篇示例",slug:"核心篇示例",normalizedTitle:"核心篇示例",charIndex:1028},{level:3,title:"数据篇示例",slug:"数据篇示例",normalizedTitle:"数据篇示例",charIndex:1650},{level:2,title:"📚 资料",slug:"📚-资料",normalizedTitle:"📚 资料",charIndex:3026},{level:2,title:"🚪 传送",slug:"🚪-传送",normalizedTitle:"🚪 传送",charIndex:3228}],headersStr:"📖 内容 综合 核心 数据 Web IO 集成 其他 💻 示例 核心篇示例 数据篇示例 📚 资料 🚪 传送",content:"# SPRING-TUTORIAL\n\n\n\n> 🍃 spring-tutorial 是一个 Spring & Spring Boot 教程。\n> \n>  * 🔁 项目同步维护：Github | Gitee\n>  * 📖 电子书阅读：Github Pages | Gitee Pages\n\n\n# 📖 内容\n\n\n# 综合\n\n * Spring 概述\n * SpringBoot 知识图谱\n * SpringBoot 基本原理\n * Spring 面试\n\n\n# 核心\n\n * Spring Bean\n * Spring IoC\n * Spring 依赖查找\n * Spring 依赖注入\n * Spring IoC 依赖来源\n * Spring Bean 作用域\n * Spring Bean 生命周期\n * Spring 配置元数据\n * Spring AOP\n * Spring 资源管理\n * Spring 校验\n * Spring 数据绑定\n * Spring 类型转换\n * Spring EL 表达式\n * Spring 事件\n * Spring 国际化\n * Spring 泛型处理\n * Spring 注解\n * Spring Environment 抽象\n * SpringBoot 教程之快速入门\n * SpringBoot 之属性加载\n * SpringBoot 之 Profile\n\n\n# 数据\n\n * Spring 之数据源\n * Spring 之 JDBC\n * Spring 之事务\n * Spring 之 JPA\n * Spring 集成 Mybatis\n * Spring 访问 Redis\n * Spring 访问 MongoDB\n * Spring 访问 Elasticsearch\n\n\n# Web\n\n * Spring WebMvc\n * SpringBoot 之应用 EasyUI\n\n\n# IO\n\n * SpringBoot 之异步请求\n * SpringBoot 之 Json\n * SpringBoot 之邮件\n\n\n# 集成\n\n * Spring 集成缓存中间件\n * Spring 集成定时任务中间件\n * Spring 集成 Dubbo\n\n\n# 其他\n\n * Spring4 升级\n * SpringBoot 之 banner\n * SpringBoot 之 Actuator\n\n\n# 💻 示例\n\n\n# 核心篇示例\n\n * spring-core-actuator - Spring 应用监控示例。\n * spring-core-aop - Spring AOP 编程示例。\n * spring-core-async - Spring 使用异步接口示例。\n * spring-core-banner - Spring 定制启动时的输出 Logo。\n * spring-core-bean - Spring 管理 JavaBean 生命周期示例。\n * spring-core-conversion - Spring 数据转换示例。\n * spring-core-data-binding - Spring 数据绑定示例。\n * spring-core-ioc - Spring IOC 示例。\n * spring-core-profile - 在 Spring 中根据 profile 在不同的环境下执行不同的行为。\n * spring-core-property - 全方位的演示 Spring 加载属性的方式：记载 properties 和 yaml 两种文件；通过 @Value、@ConfigurationProperties、Environment 读取属性。\n * spring-core-resource - Spring 资源加载示例。\n * spring-core-validation - Spring 数据校验示例。\n\n\n# 数据篇示例\n\n * JDBC\n   * spring-data-jdbc-basics - Spring Boot 以 JDBC 方式访问关系型数据库，通过 JdbcTemplate 执行基本的 CRUD 操作。\n   * spring-data-jdbc-druid - SpringBoot 使用 Druid 作为数据库连接池。\n   * spring-data-jdbc-multi-datasource - SpringBoot 连接多数据源示例。\n   * spring-data-jdbc-xml - Spring 以 JDBC 方式访问关系型数据库，通过 JdbcTemplate 执行基本的 CRUD 操作。\n * ORM\n   * spring-data-orm-jpa - SpringBoot 使用 JPA 作为 ORM 框架访问数据库示例。\n   * spring-data-orm-mybatis - Spring 使用 MyBatis 作为 ORM 框架访问数据库示例。\n   * spring-data-orm-mybatis-mapper - SpringBoot 使用 MyBatis + Mapper + PageHelper 作为 ORM 框架访问数据库示例。\n   * spring-data-orm-mybatis-multi-datasource - SpringBoot 连接多数据源，并使用 MyBatis Plus 作为 ORM 框架访问数据库示例。\n   * spring-data-orm-mybatis-plus - SpringBoot 使用 MyBatis Plus 作为 ORM 框架访问数据库示例。\n * Nosql\n   * spring-data-nosql-basics - Spring 访问各种 NoSQL 的示例。\n   * spring-data-nosql-mongodb - SpringBoot 访问 MongoDB 的示例。\n   * spring-data-nosql-redis - SpringBoot 访问 Redis 单节点、集群的示例。\n   * spring-data-nosql-elasticsearch - SpringBoot 访问 Elasticsearch 的示例。\n   * spring-data-nosql-hdfs - SpringBoot 访问 HDFS 的示例。\n * Cache\n   * spring-data-cache-basics - SpringBoot 默认缓存框架的示例。\n   * spring-data-cache-j2cache - SpringBoot 使用 j2cache 作为缓存框架的示例。\n   * spring-data-cache-jetcache - SpringBoot 使用 jetcache 作为缓存框架的示例。\n * 中间件\n   * spring-data-middleware-flyway - Spring 使用版本管理中间件 Flyway 示例。\n   * spring-data-middleware-sharding - Spring 使用分库分表中间件示例。\n\n\n# 📚 资料\n\n * 官方\n   * Spring 官网\n   * Spring Github\n   * Spring Framework 官方文档\n   * Spring Boot 官方文档\n * 书籍\n   * 《 Spring 实战（第 5 版）》\n * 教程\n   * 《小马哥讲 Spring 核心编程思想》\n   * geekbang-lessons\n   * 跟我学 Spring3\n\n\n# 🚪 传送\n\n◾ 💧 钝悟的 IT 知识图谱 ◾",normalizedContent:"# spring-tutorial\n\n\n\n> 🍃 spring-tutorial 是一个 spring & spring boot 教程。\n> \n>  * 🔁 项目同步维护：github | gitee\n>  * 📖 电子书阅读：github pages | gitee pages\n\n\n# 📖 内容\n\n\n# 综合\n\n * spring 概述\n * springboot 知识图谱\n * springboot 基本原理\n * spring 面试\n\n\n# 核心\n\n * spring bean\n * spring ioc\n * spring 依赖查找\n * spring 依赖注入\n * spring ioc 依赖来源\n * spring bean 作用域\n * spring bean 生命周期\n * spring 配置元数据\n * spring aop\n * spring 资源管理\n * spring 校验\n * spring 数据绑定\n * spring 类型转换\n * spring el 表达式\n * spring 事件\n * spring 国际化\n * spring 泛型处理\n * spring 注解\n * spring environment 抽象\n * springboot 教程之快速入门\n * springboot 之属性加载\n * springboot 之 profile\n\n\n# 数据\n\n * spring 之数据源\n * spring 之 jdbc\n * spring 之事务\n * spring 之 jpa\n * spring 集成 mybatis\n * spring 访问 redis\n * spring 访问 mongodb\n * spring 访问 elasticsearch\n\n\n# web\n\n * spring webmvc\n * springboot 之应用 easyui\n\n\n# io\n\n * springboot 之异步请求\n * springboot 之 json\n * springboot 之邮件\n\n\n# 集成\n\n * spring 集成缓存中间件\n * spring 集成定时任务中间件\n * spring 集成 dubbo\n\n\n# 其他\n\n * spring4 升级\n * springboot 之 banner\n * springboot 之 actuator\n\n\n# 💻 示例\n\n\n# 核心篇示例\n\n * spring-core-actuator - spring 应用监控示例。\n * spring-core-aop - spring aop 编程示例。\n * spring-core-async - spring 使用异步接口示例。\n * spring-core-banner - spring 定制启动时的输出 logo。\n * spring-core-bean - spring 管理 javabean 生命周期示例。\n * spring-core-conversion - spring 数据转换示例。\n * spring-core-data-binding - spring 数据绑定示例。\n * spring-core-ioc - spring ioc 示例。\n * spring-core-profile - 在 spring 中根据 profile 在不同的环境下执行不同的行为。\n * spring-core-property - 全方位的演示 spring 加载属性的方式：记载 properties 和 yaml 两种文件；通过 @value、@configurationproperties、environment 读取属性。\n * spring-core-resource - spring 资源加载示例。\n * spring-core-validation - spring 数据校验示例。\n\n\n# 数据篇示例\n\n * jdbc\n   * spring-data-jdbc-basics - spring boot 以 jdbc 方式访问关系型数据库，通过 jdbctemplate 执行基本的 crud 操作。\n   * spring-data-jdbc-druid - springboot 使用 druid 作为数据库连接池。\n   * spring-data-jdbc-multi-datasource - springboot 连接多数据源示例。\n   * spring-data-jdbc-xml - spring 以 jdbc 方式访问关系型数据库，通过 jdbctemplate 执行基本的 crud 操作。\n * orm\n   * spring-data-orm-jpa - springboot 使用 jpa 作为 orm 框架访问数据库示例。\n   * spring-data-orm-mybatis - spring 使用 mybatis 作为 orm 框架访问数据库示例。\n   * spring-data-orm-mybatis-mapper - springboot 使用 mybatis + mapper + pagehelper 作为 orm 框架访问数据库示例。\n   * spring-data-orm-mybatis-multi-datasource - springboot 连接多数据源，并使用 mybatis plus 作为 orm 框架访问数据库示例。\n   * spring-data-orm-mybatis-plus - springboot 使用 mybatis plus 作为 orm 框架访问数据库示例。\n * nosql\n   * spring-data-nosql-basics - spring 访问各种 nosql 的示例。\n   * spring-data-nosql-mongodb - springboot 访问 mongodb 的示例。\n   * spring-data-nosql-redis - springboot 访问 redis 单节点、集群的示例。\n   * spring-data-nosql-elasticsearch - springboot 访问 elasticsearch 的示例。\n   * spring-data-nosql-hdfs - springboot 访问 hdfs 的示例。\n * cache\n   * spring-data-cache-basics - springboot 默认缓存框架的示例。\n   * spring-data-cache-j2cache - springboot 使用 j2cache 作为缓存框架的示例。\n   * spring-data-cache-jetcache - springboot 使用 jetcache 作为缓存框架的示例。\n * 中间件\n   * spring-data-middleware-flyway - spring 使用版本管理中间件 flyway 示例。\n   * spring-data-middleware-sharding - spring 使用分库分表中间件示例。\n\n\n# 📚 资料\n\n * 官方\n   * spring 官网\n   * spring github\n   * spring framework 官方文档\n   * spring boot 官方文档\n * 书籍\n   * 《 spring 实战（第 5 版）》\n * 教程\n   * 《小马哥讲 spring 核心编程思想》\n   * geekbang-lessons\n   * 跟我学 spring3\n\n\n# 🚪 传送\n\n◾ 💧 钝悟的 it 知识图谱 ◾",charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Mybatis原理",frontmatter:{title:"Mybatis原理",date:"2022-02-17T22:34:30.000Z",order:2,categories:["Java","框架","ORM"],tags:["Java","框架","ORM","Mybatis"],permalink:"/pages/d55184/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/11.ORM/02.Mybatis%E5%8E%9F%E7%90%86.html",relativePath:"01.Java/13.框架/11.ORM/02.Mybatis原理.md",key:"v-5cf98845",path:"/pages/d55184/",headers:[{level:2,title:"Mybatis 完整示例",slug:"mybatis-完整示例",normalizedTitle:"mybatis 完整示例",charIndex:78},{level:3,title:"数据库准备",slug:"数据库准备",normalizedTitle:"数据库准备",charIndex:247},{level:3,title:"添加 Mybatis",slug:"添加-mybatis",normalizedTitle:"添加 mybatis",charIndex:874},{level:3,title:"Mybatis 配置",slug:"mybatis-配置",normalizedTitle:"mybatis 配置",charIndex:1057},{level:3,title:"Mapper",slug:"mapper",normalizedTitle:"mapper",charIndex:1932},{level:4,title:"Mapper.xml",slug:"mapper-xml",normalizedTitle:"mapper.xml",charIndex:1932},{level:4,title:"Mapper.java",slug:"mapper-java",normalizedTitle:"mapper.java",charIndex:3869},{level:4,title:"数据实体.java",slug:"数据实体-java",normalizedTitle:"数据实体.java",charIndex:4340},{level:3,title:"测试程序",slug:"测试程序",normalizedTitle:"测试程序",charIndex:4663},{level:2,title:"Mybatis 生命周期",slug:"mybatis-生命周期",normalizedTitle:"mybatis 生命周期",charIndex:5716},{level:3,title:"SqlSessionFactoryBuilder",slug:"sqlsessionfactorybuilder",normalizedTitle:"sqlsessionfactorybuilder",charIndex:4983},{level:4,title:"SqlSessionFactoryBuilder 的职责",slug:"sqlsessionfactorybuilder-的职责",normalizedTitle:"sqlsessionfactorybuilder 的职责",charIndex:5763},{level:4,title:"SqlSessionFactoryBuilder 的生命周期",slug:"sqlsessionfactorybuilder-的生命周期",normalizedTitle:"sqlsessionfactorybuilder 的生命周期",charIndex:6397},{level:3,title:"SqlSessionFactory",slug:"sqlsessionfactory",normalizedTitle:"sqlsessionfactory",charIndex:4817},{level:4,title:"SqlSessionFactory 职责",slug:"sqlsessionfactory-职责",normalizedTitle:"sqlsessionfactory 职责",charIndex:6680},{level:4,title:"SqlSessionFactory 生命周期",slug:"sqlsessionfactory-生命周期",normalizedTitle:"sqlsessionfactory 生命周期",charIndex:7734},{level:3,title:"SqlSession",slug:"sqlsession",normalizedTitle:"sqlsession",charIndex:4817},{level:4,title:"SqlSession 职责",slug:"sqlsession-职责",normalizedTitle:"sqlsession 职责",charIndex:7815},{level:4,title:"SqlSession 生命周期",slug:"sqlsession-生命周期",normalizedTitle:"sqlsession 生命周期",charIndex:7968},{level:3,title:"映射器",slug:"映射器",normalizedTitle:"映射器",charIndex:7876},{level:4,title:"映射器职责",slug:"映射器职责",normalizedTitle:"映射器职责",charIndex:8576},{level:4,title:"映射器生命周期",slug:"映射器生命周期",normalizedTitle:"映射器生命周期",charIndex:9331},{level:2,title:"Mybatis 的架构",slug:"mybatis-的架构",normalizedTitle:"mybatis 的架构",charIndex:9864},{level:3,title:"配置层",slug:"配置层",normalizedTitle:"配置层",charIndex:10601},{level:3,title:"接口层",slug:"接口层",normalizedTitle:"接口层",charIndex:10782},{level:3,title:"数据处理层",slug:"数据处理层",normalizedTitle:"数据处理层",charIndex:11128},{level:3,title:"框架支撑层",slug:"框架支撑层",normalizedTitle:"框架支撑层",charIndex:11658},{level:2,title:"SqlSession 内部工作机制",slug:"sqlsession-内部工作机制",normalizedTitle:"sqlsession 内部工作机制",charIndex:12447},{level:3,title:"SqlSession 子组件",slug:"sqlsession-子组件",normalizedTitle:"sqlsession 子组件",charIndex:12720},{level:4,title:"Executor",slug:"executor",normalizedTitle:"executor",charIndex:6994},{level:4,title:"StatementHandler",slug:"statementhandler",normalizedTitle:"statementhandler",charIndex:10051},{level:4,title:"ParameterHandler",slug:"parameterhandler",normalizedTitle:"parameterhandler",charIndex:10152},{level:4,title:"ResultSetHandler",slug:"resultsethandler",normalizedTitle:"resultsethandler",charIndex:10211},{level:4,title:"TypeHandler",slug:"typehandler",normalizedTitle:"typehandler",charIndex:10277},{level:3,title:"SqlSession 和 Mapper",slug:"sqlsession-和-mapper",normalizedTitle:"sqlsession 和 mapper",charIndex:14308},{level:3,title:"SqlSession 和 Executor",slug:"sqlsession-和-executor",normalizedTitle:"sqlsession 和 executor",charIndex:15167},{level:3,title:"Executor 工作流程",slug:"executor-工作流程",normalizedTitle:"executor 工作流程",charIndex:16589},{level:3,title:"StatementHandler 工作流程",slug:"statementhandler-工作流程",normalizedTitle:"statementhandler 工作流程",charIndex:20173},{level:3,title:"ParameterHandler 工作流程",slug:"parameterhandler-工作流程",normalizedTitle:"parameterhandler 工作流程",charIndex:21804},{level:3,title:"ResultSetHandler 工作流程",slug:"resultsethandler-工作流程",normalizedTitle:"resultsethandler 工作流程",charIndex:23661},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:25345}],headersStr:"Mybatis 完整示例 数据库准备 添加 Mybatis Mybatis 配置 Mapper Mapper.xml Mapper.java 数据实体.java 测试程序 Mybatis 生命周期 SqlSessionFactoryBuilder SqlSessionFactoryBuilder 的职责 SqlSessionFactoryBuilder 的生命周期 SqlSessionFactory SqlSessionFactory 职责 SqlSessionFactory 生命周期 SqlSession SqlSession 职责 SqlSession 生命周期 映射器 映射器职责 映射器生命周期 Mybatis 的架构 配置层 接口层 数据处理层 框架支撑层 SqlSession 内部工作机制 SqlSession 子组件 Executor StatementHandler ParameterHandler ResultSetHandler TypeHandler SqlSession 和 Mapper SqlSession 和 Executor Executor 工作流程 StatementHandler 工作流程 ParameterHandler 工作流程 ResultSetHandler 工作流程 参考资料",content:'# Mybatis 原理\n\n> Mybatis 的前身就是 iBatis ，是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。本文以一个 Mybatis 完整示例为切入点，结合 Mybatis 底层源码分析，图文并茂的讲解 Mybatis 的核心工作机制。\n\n\n# Mybatis 完整示例\n\n> 这里，我将以一个入门级的示例来演示 Mybatis 是如何工作的。\n> \n> 注：本文后面章节中的原理、源码部分也将基于这个示例来进行讲解。\n> \n> 完整示例源码地址\n\n\n# 数据库准备\n\n在本示例中，需要针对一张用户表进行 CRUD 操作。其数据模型如下：\n\nCREATE TABLE IF NOT EXISTS user (\n    id      BIGINT(10) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT \'Id\',\n    name    VARCHAR(10)         NOT NULL DEFAULT \'\' COMMENT \'用户名\',\n    age     INT(3)              NOT NULL DEFAULT 0 COMMENT \'年龄\',\n    address VARCHAR(32)         NOT NULL DEFAULT \'\' COMMENT \'地址\',\n    email   VARCHAR(32)         NOT NULL DEFAULT \'\' COMMENT \'邮件\',\n    PRIMARY KEY (id)\n) COMMENT = \'用户表\';\n\nINSERT INTO user (name, age, address, email)\nVALUES (\'张三\', 18, \'北京\', \'xxx@163.com\');\nINSERT INTO user (name, age, address, email)\nVALUES (\'李四\', 19, \'上海\', \'xxx@163.com\');\n\n\n\n# 添加 Mybatis\n\n如果使用 Maven 来构建项目，则需将下面的依赖代码置于 pom.xml 文件中：\n\n<dependency>\n  <groupId>org.Mybatis</groupId>\n  <artifactId>Mybatis</artifactId>\n  <version>x.x.x</version>\n</dependency>\n\n\n\n# Mybatis 配置\n\nXML 配置文件中包含了对 Mybatis 系统的核心设置，包括获取数据库连接实例的数据源（DataSource）以及决定事务作用域和控制方式的事务管理器（TransactionManager）。\n\n本示例中只是给出最简化的配置。\n\n【示例】Mybatis-config.xml 文件\n\n<?xml version="1.0" encoding="utf-8"?>\n<!DOCTYPE configuration PUBLIC "-//Mybatis.org//DTD Config 3.0//EN"\n  "http://Mybatis.org/dtd/Mybatis-3-config.dtd">\n<configuration>\n  <environments default="development">\n    <environment id="development">\n      <transactionManager type="JDBC" />\n      <dataSource type="POOLED">\n        <property name="driver" value="com.mysql.cj.jdbc.Driver" />\n        <property name="url"\n                  value="jdbc:mysql://127.0.0.1:3306/spring_tutorial?serverTimezone=UTC" />\n        <property name="username" value="root" />\n        <property name="password" value="root" />\n      </dataSource>\n    </environment>\n  </environments>\n  <mappers>\n    <mapper resource="Mybatis/mapper/UserMapper.xml" />\n  </mappers>\n</configuration>\n\n\n> 说明：上面的配置文件中仅仅指定了数据源连接方式和 User 表的映射配置文件。\n\n\n# Mapper\n\n# Mapper.xml\n\n个人理解，Mapper.xml 文件可以看做是 Mybatis 的 JDBC SQL 模板。\n\n【示例】UserMapper.xml 文件\n\n下面是一个通过 Mybatis Generator 自动生成的完整的 Mapper 文件。\n\n<?xml version="1.0" encoding="UTF-8"?>\n<!DOCTYPE mapper PUBLIC "-//Mybatis.org//DTD Mapper 3.0//EN" "http://Mybatis.org/dtd/Mybatis-3-mapper.dtd">\n<mapper namespace="io.github.dunwu.spring.orm.mapper.UserMapper">\n  <resultMap id="BaseResultMap" type="io.github.dunwu.spring.orm.entity.User">\n    <id column="id" jdbcType="BIGINT" property="id" />\n    <result column="name" jdbcType="VARCHAR" property="name" />\n    <result column="age" jdbcType="INTEGER" property="age" />\n    <result column="address" jdbcType="VARCHAR" property="address" />\n    <result column="email" jdbcType="VARCHAR" property="email" />\n  </resultMap>\n  <delete id="deleteByPrimaryKey" parameterType="java.lang.Long">\n    delete from user\n    where id = #{id,jdbcType=BIGINT}\n  </delete>\n  <insert id="insert" parameterType="io.github.dunwu.spring.orm.entity.User">\n    insert into user (id, name, age,\n      address, email)\n    values (#{id,jdbcType=BIGINT}, #{name,jdbcType=VARCHAR}, #{age,jdbcType=INTEGER},\n      #{address,jdbcType=VARCHAR}, #{email,jdbcType=VARCHAR})\n  </insert>\n  <update id="updateByPrimaryKey" parameterType="io.github.dunwu.spring.orm.entity.User">\n    update user\n    set name = #{name,jdbcType=VARCHAR},\n      age = #{age,jdbcType=INTEGER},\n      address = #{address,jdbcType=VARCHAR},\n      email = #{email,jdbcType=VARCHAR}\n    where id = #{id,jdbcType=BIGINT}\n  </update>\n  <select id="selectByPrimaryKey" parameterType="java.lang.Long" resultMap="BaseResultMap">\n    select id, name, age, address, email\n    from user\n    where id = #{id,jdbcType=BIGINT}\n  </select>\n  <select id="selectAll" resultMap="BaseResultMap">\n    select id, name, age, address, email\n    from user\n  </select>\n</mapper>\n\n\n# Mapper.java\n\nMapper.java 文件是 Mapper.xml 对应的 Java 对象。\n\n【示例】UserMapper.java 文件\n\npublic interface UserMapper {\n\n    int deleteByPrimaryKey(Long id);\n\n    int insert(User record);\n\n    User selectByPrimaryKey(Long id);\n\n    List<User> selectAll();\n\n    int updateByPrimaryKey(User record);\n\n}\n\n\n对比 UserMapper.java 和 UserMapper.xml 文件，不难发现：\n\nUserMapper.java 中的方法和 UserMapper.xml 的 CRUD 语句元素（ <insert>、<delete>、<update>、<select>）存在一一对应关系。\n\n在 Mybatis 中，正是通过方法的全限定名，将二者绑定在一起。\n\n# 数据实体.java\n\n【示例】User.java 文件\n\npublic class User {\n    private Long id;\n\n    private String name;\n\n    private Integer age;\n\n    private String address;\n\n    private String email;\n\n}\n\n\n<insert>、<delete>、<update>、<select> 的 parameterType 属性以及 <resultMap> 的 type 属性都可能会绑定到数据实体。这样就可以把 JDBC 操作的输入输出和 JavaBean 结合起来，更加方便、易于理解。\n\n\n# 测试程序\n\n【示例】MybatisDemo.java 文件\n\npublic class MybatisDemo {\n\n    public static void main(String[] args) throws Exception {\n        // 1. 加载 Mybatis 配置文件，创建 SqlSessionFactory\n        // 注：在实际的应用中，SqlSessionFactory 应该是单例\n        InputStream inputStream = Resources.getResourceAsStream("Mybatis/Mybatis-config.xml");\n        SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();\n        SqlSessionFactory factory = builder.build(inputStream);\n\n        // 2. 创建一个 SqlSession 实例，进行数据库操作\n        SqlSession sqlSession = factory.openSession();\n\n        // 3. Mapper 映射并执行\n        Long params = 1L;\n        List<User> list = sqlSession.selectList("io.github.dunwu.spring.orm.mapper.UserMapper.selectByPrimaryKey", params);\n        for (User user : list) {\n            System.out.println("user name: " + user.getName());\n        }\n        // 输出：user name: 张三\n    }\n\n}\n\n\n> 说明：\n> \n> SqlSession 接口是 Mybatis API 核心中的核心，它代表了 Mybatis 和数据库的一次完整会话。\n> \n>  * Mybatis 会解析配置，并根据配置创建 SqlSession 。\n>  * 然后，Mybatis 将 Mapper 映射为 SqlSession，然后传递参数，执行 SQL 语句并获取结果。\n\n\n# Mybatis 生命周期\n\n\n\n\n# SqlSessionFactoryBuilder\n\n# SqlSessionFactoryBuilder 的职责\n\nSqlSessionFactoryBuilder 负责创建 SqlSessionFactory 实例。SqlSessionFactoryBuilder 可以从 XML 配置文件或一个预先定制的 Configuration 的实例构建出 SqlSessionFactory 的实例。\n\nConfiguration 类包含了对一个 SqlSessionFactory 实例你可能关心的所有内容。\n\n\n\nSqlSessionFactoryBuilder 应用了建造者设计模式，它有五个 build 方法，允许你通过不同的资源创建 SqlSessionFactory 实例。\n\nSqlSessionFactory build(InputStream inputStream)\nSqlSessionFactory build(InputStream inputStream, String environment)\nSqlSessionFactory build(InputStream inputStream, Properties properties)\nSqlSessionFactory build(InputStream inputStream, String env, Properties props)\nSqlSessionFactory build(Configuration config)\n\n\n# SqlSessionFactoryBuilder 的生命周期\n\nSqlSessionFactoryBuilder 可以被实例化、使用和丢弃，一旦创建了 SqlSessionFactory，就不再需要它了。 因此 SqlSessionFactoryBuilder 实例的最佳作用域是方法作用域（也就是局部方法变量）。你可以重用 SqlSessionFactoryBuilder 来创建多个 SqlSessionFactory 实例，但最好还是不要一直保留着它，以保证所有的 XML 解析资源可以被释放给更重要的事情。\n\n\n# SqlSessionFactory\n\n# SqlSessionFactory 职责\n\nSqlSessionFactory 负责创建 SqlSession 实例。\n\n\n\nSqlSessionFactory 应用了工厂设计模式，它提供了一组方法，用于创建 SqlSession 实例。\n\nSqlSession openSession()\nSqlSession openSession(boolean autoCommit)\nSqlSession openSession(Connection connection)\nSqlSession openSession(TransactionIsolationLevel level)\nSqlSession openSession(ExecutorType execType, TransactionIsolationLevel level)\nSqlSession openSession(ExecutorType execType)\nSqlSession openSession(ExecutorType execType, boolean autoCommit)\nSqlSession openSession(ExecutorType execType, Connection connection)\nConfiguration getConfiguration();\n\n\n方法说明：\n\n * 默认的 openSession() 方法没有参数，它会创建具备如下特性的 SqlSession：\n   * 事务作用域将会开启（也就是不自动提交）。\n   * 将由当前环境配置的 DataSource 实例中获取 Connection 对象。\n   * 事务隔离级别将会使用驱动或数据源的默认设置。\n   * 预处理语句不会被复用，也不会批量处理更新。\n * TransactionIsolationLevel 表示事务隔离级别，它对应着 JDBC 的五个事务隔离级别。\n * ExecutorType 枚举类型定义了三个值:\n   * ExecutorType.SIMPLE：该类型的执行器没有特别的行为。它为每个语句的执行创建一个新的预处理语句。\n   * ExecutorType.REUSE：该类型的执行器会复用预处理语句。\n   * ExecutorType.BATCH：该类型的执行器会批量执行所有更新语句，如果 SELECT 在多个更新中间执行，将在必要时将多条更新语句分隔开来，以方便理解。\n\n# SqlSessionFactory 生命周期\n\nSqlSessionFactory 应该以单例形式在应用的运行期间一直存在。\n\n\n# SqlSession\n\n# SqlSession 职责\n\nMybatis 的主要 Java 接口就是 SqlSession。它包含了所有执行语句，获取映射器和管理事务等方法。\n\n> 详细内容可以参考：“ Mybatis 官方文档之 SqlSessions ” 。\n\nSqlSession 类的方法可以按照下图进行大致分类：\n\n\n\n# SqlSession 生命周期\n\nSqlSessions 是由 SqlSessionFactory 实例创建的；而 SqlSessionFactory 是由 SqlSessionFactoryBuilder 创建的。\n\n> 🔔 注意：当 Mybatis 与一些依赖注入框架（如 Spring 或者 Guice）同时使用时，SqlSessions 将被依赖注入框架所创建，所以你不需要使用 SqlSessionFactoryBuilder 或者 SqlSessionFactory。\n\n每个线程都应该有它自己的 SqlSession 实例。\n\nSqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。 绝对不能将 SqlSession 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。 也绝不能将 SqlSession 实例的引用放在任何类型的托管作用域中，比如 Servlet 框架中的 HttpSession。 正确在 Web 中使用 SqlSession 的场景是：每次收到的 HTTP 请求，就可以打开一个 SqlSession，返回一个响应，就关闭它。\n\n编程模式：\n\ntry (SqlSession session = sqlSessionFactory.openSession()) {\n  // 你的应用逻辑代码\n}\n\n\n\n# 映射器\n\n# 映射器职责\n\n映射器是一些由用户创建的、绑定 SQL 语句的接口。\n\nSqlSession 中的 insert、update、delete 和 select 方法都很强大，但也有些繁琐。更通用的方式是使用映射器类来执行映射语句。一个映射器类就是一个仅需声明与 SqlSession 方法相匹配的方法的接口类。\n\nMybatis 将配置文件中的每一个 <mapper> 节点抽象为一个 Mapper 接口，而这个接口中声明的方法和跟 <mapper> 节点中的 <select|update|delete|insert> 节点相对应，即 <select|update|delete|insert> 节点的 id 值为 Mapper 接口中的方法名称，parameterType 值表示 Mapper 对应方法的入参类型，而 resultMap 值则对应了 Mapper 接口表示的返回值类型或者返回结果集的元素类型。\n\nMybatis 会根据相应的接口声明的方法信息，通过动态代理机制生成一个 Mapper 实例；Mybatis 会根据这个方法的方法名和参数类型，确定 Statement Id，然后和 SqlSession 进行映射，底层还是通过 SqlSession 完成和数据库的交互。\n\n下面的示例展示了一些方法签名以及它们是如何映射到 SqlSession 上的。\n\n\n\n> 注意\n> \n>  * 映射器接口不需要去实现任何接口或继承自任何类。只要方法可以被唯一标识对应的映射语句就可以了。\n>  * 映射器接口可以继承自其他接口。当使用 XML 来构建映射器接口时要保证语句被包含在合适的命名空间中。而且，唯一的限制就是你不能在两个继承关系的接口中拥有相同的方法签名（潜在的危险做法不可取）。\n\n# 映射器生命周期\n\n映射器接口的实例是从 SqlSession 中获得的。因此从技术层面讲，任何映射器实例的最大作用域是和请求它们的 SqlSession 相同的。尽管如此，映射器实例的最佳作用域是方法作用域。 也就是说，映射器实例应该在调用它们的方法中被请求，用过之后即可丢弃。\n\n编程模式：\n\ntry (SqlSession session = sqlSessionFactory.openSession()) {\n  BlogMapper mapper = session.getMapper(BlogMapper.class);\n  // 你的应用逻辑代码\n}\n\n\n * 映射器注解\n\nMybatis 是一个 XML 驱动的框架。配置信息是基于 XML 的，而且映射语句也是定义在 XML 中的。Mybatis 3 以后，支持注解配置。注解配置基于配置 API；而配置 API 基于 XML 配置。\n\nMybatis 支持诸如 @Insert、@Update、@Delete、@Select、@Result 等注解。\n\n> 详细内容请参考：Mybatis 官方文档之 sqlSessions，其中列举了 Mybatis 支持的注解清单，以及基本用法。\n\n\n# Mybatis 的架构\n\n从 Mybatis 代码实现的角度来看，Mybatis 的主要组件有以下几个：\n\n * SqlSession - 作为 Mybatis 工作的主要顶层 API，表示和数据库交互的会话，完成必要数据库增删改查功能。\n * Executor - Mybatis 执行器，是 Mybatis 调度的核心，负责 SQL 语句的生成和查询缓存的维护。\n * StatementHandler - 封装了 JDBC Statement 操作，负责对 JDBC statement 的操作，如设置参数、将 Statement 结果集转换成 List 集合。\n * ParameterHandler - 负责对用户传递的参数转换成 JDBC Statement 所需要的参数。\n * ResultSetHandler - 负责将 JDBC 返回的 ResultSet 结果集对象转换成 List 类型的集合。\n * TypeHandler - 负责 java 数据类型和 jdbc 数据类型之间的映射和转换。\n * MappedStatement - MappedStatement 维护了一条 <select|update|delete|insert> 节点的封装。\n * SqlSource - 负责根据用户传递的 parameterObject，动态地生成 SQL 语句，将信息封装到 BoundSql 对象中，并返回。\n * BoundSql - 表示动态生成的 SQL 语句以及相应的参数信息。\n * Configuration - Mybatis 所有的配置信息都维持在 Configuration 对象之中。\n\n这些组件的架构层次如下：\n\n\n\n\n# 配置层\n\n配置层决定了 Mybatis 的工作方式。\n\nMybatis 提供了两种配置方式：\n\n * 基于 XML 配置文件的方式\n * 基于 Java API 的方式\n\nSqlSessionFactoryBuilder 会根据配置创建 SqlSessionFactory ；\n\nSqlSessionFactory 负责创建 SqlSessions 。\n\n\n# 接口层\n\n接口层负责和数据库交互的方式。\n\nMybatis 和数据库的交互有两种方式：\n\n * 使用 SqlSession：SqlSession 封装了所有执行语句，获取映射器和管理事务的方法。\n   * 用户只需要传入 Statement Id 和查询参数给 SqlSession 对象，就可以很方便的和数据库进行交互。\n   * 这种方式的缺点是不符合面向对象编程的范式。\n * 使用 Mapper 接口：Mybatis 会根据相应的接口声明的方法信息，通过动态代理机制生成一个 Mapper 实例；Mybatis 会根据这个方法的方法名和参数类型，确定 Statement Id，然后和 SqlSession 进行映射，底层还是通过 SqlSession 完成和数据库的交互。\n\n\n# 数据处理层\n\n数据处理层可以说是 Mybatis 的核心，从大的方面上讲，它要完成两个功能：\n\n * 根据传参 Statement 和参数构建动态 SQL 语句\n   * 动态语句生成可以说是 Mybatis 框架非常优雅的一个设计，Mybatis 通过传入的参数值，使用 Ognl 来动态地构造 SQL 语句，使得 Mybatis 有很强的灵活性和扩展性。\n   * 参数映射指的是对于 java 数据类型和 jdbc 数据类型之间的转换：这里有包括两个过程：查询阶段，我们要将 java 类型的数据，转换成 jdbc 类型的数据，通过 preparedStatement.setXXX() 来设值；另一个就是对 resultset 查询结果集的 jdbcType 数据转换成 java 数据类型。\n * 执行 SQL 语句以及处理响应结果集 ResultSet\n   * 动态 SQL 语句生成之后，Mybatis 将执行 SQL 语句，并将可能返回的结果集转换成 List<E> 列表。\n   * Mybatis 在对结果集的处理中，支持结果集关系一对多和多对一的转换，并且有两种支持方式，一种为嵌套查询语句的查询，还有一种是嵌套结果集的查询。\n\n\n# 框架支撑层\n\n * 事务管理机制 - Mybatis 将事务抽象成了 Transaction 接口。Mybatis 的事务管理分为两种形式：\n   \n   * 使用 JDBC 的事务管理机制：即利用 java.sql.Connection 对象完成对事务的提交（commit）、回滚（rollback）、关闭（close）等。\n   * 使用 MANAGED 的事务管理机制：Mybatis 自身不会去实现事务管理，而是让程序的容器如（JBOSS，Weblogic）来实现对事务的管理。\n\n * 连接池管理\n\n * SQL 语句的配置 - 支持两种方式：\n   \n   * xml 配置\n   * 注解配置\n\n * 缓存机制 - Mybatis 采用两级缓存结构\n   \n   * 一级缓存是 Session 会话级别的缓存 - 一级缓存又被称之为本地缓存。一般而言，一个 SqlSession 对象会使用一个 Executor 对象来完成会话操作，Executor 对象会维护一个 Cache 缓存，以提高查询性能。\n     * 一级缓存的生命周期是 Session 会话级别的。\n   * 二级缓存是 Application 应用级别的缓存 - 用户配置了 "cacheEnabled=true"，才会开启二级缓存。\n     * 如果开启了二级缓存，SqlSession 会先使用 CachingExecutor 对象来处理查询请求。CachingExecutor 会在二级缓存中查看是否有匹配的数据，如果匹配，则直接返回缓存结果；如果缓存中没有，再交给真正的 Executor 对象来完成查询，之后 CachingExecutor 会将真正 Executor 返回的查询结果放置到缓存中，然后在返回给用户。\n     * 二级缓存的生命周期是应用级别的。\n\n\n\n\n# SqlSession 内部工作机制\n\n从前文，我们已经了解了，Mybatis 封装了对数据库的访问，把对数据库的会话和事务控制放到了 SqlSession 对象中。那么具体是如何工作的呢？接下来，我们通过源码解读来进行分析。\n\n\n\nSqlSession 对于 insert、update、delete、select 的内部处理机制基本上大同小异。所以，接下来，我会以一次完整的 select 查询流程为例讲解 SqlSession 内部的工作机制。相信读者如果理解了 select 的处理流程，对于其他 CRUD 操作也能做到一通百通。\n\n\n# SqlSession 子组件\n\n前面的内容已经介绍了：SqlSession 是 Mybatis 的顶层接口，它提供了所有执行语句，获取映射器和管理事务等方法。\n\n实际上，SqlSession 是通过聚合多个子组件，让每个子组件负责各自功能的方式，实现了任务的下发。\n\n在了解各个子组件工作机制前，先让我们简单认识一下 SqlSession 的核心子组件。\n\n# Executor\n\nExecutor 即执行器，它负责生成动态 SQL 以及管理缓存。\n\n\n\n * Executor 即执行器接口。\n * BaseExecutor 是 Executor 的抽象类，它采用了模板方法设计模式，内置了一些共性方法，而将定制化方法留给子类去实现。\n * SimpleExecutor 是最简单的执行器。它只会直接执行 SQL，不会做额外的事。\n * BatchExecutor 是批处理执行器。它的作用是通过批处理来优化性能。值得注意的是，批量更新操作，由于内部有缓存机制，使用完后需要调用 flushStatements 来清除缓存。\n * ReuseExecutor 是可重用的执行器。重用的对象是 Statement，也就是说，该执行器会缓存同一个 SQL 的 Statement，避免重复创建 Statement。其内部的实现是通过一个 HashMap 来维护 Statement 对象的。由于当前 Map 只在该 session 中有效，所以使用完后需要调用 flushStatements 来清除 Map。\n * CachingExecutor 是缓存执行器。它只在启用二级缓存时才会用到。\n\n# StatementHandler\n\nStatementHandler 对象负责设置 Statement 对象中的查询参数、处理 JDBC 返回的 resultSet，将 resultSet 加工为 List 集合返回。\n\nStatementHandler 的家族成员：\n\n\n\n * StatementHandler 是接口；\n * BaseStatementHandler 是实现 StatementHandler 的抽象类，内置一些共性方法；\n * SimpleStatementHandler 负责处理 Statement；\n * PreparedStatementHandler 负责处理 PreparedStatement；\n * CallableStatementHandler 负责处理 CallableStatement。\n * RoutingStatementHandler 负责代理 StatementHandler 具体子类，根据 Statement 类型，选择实例化 SimpleStatementHandler、PreparedStatementHandler、CallableStatementHandler。\n\n# ParameterHandler\n\nParameterHandler 负责将传入的 Java 对象转换 JDBC 类型对象，并为 PreparedStatement 的动态 SQL 填充数值。\n\nParameterHandler 只有一个具体实现类，即 DefaultParameterHandler。\n\n# ResultSetHandler\n\nResultSetHandler 负责两件事：\n\n * 处理 Statement 执行后产生的结果集，生成结果列表\n * 处理存储过程执行后的输出参数\n\nResultSetHandler 只有一个具体实现类，即 DefaultResultSetHandler。\n\n# TypeHandler\n\nTypeHandler 负责将 Java 对象类型和 JDBC 类型进行相互转换。\n\n\n# SqlSession 和 Mapper\n\n先来回忆一下 Mybatis 完整示例章节的 测试程序部分的代码。\n\nMybatisDemo.java 文件中的代码片段：\n\n// 2. 创建一个 SqlSession 实例，进行数据库操作\nSqlSession sqlSession = factory.openSession();\n\n// 3. Mapper 映射并执行\nLong params = 1L;\nList<User> list = sqlSession.selectList("io.github.dunwu.spring.orm.mapper.UserMapper.selectByPrimaryKey", params);\nfor (User user : list) {\n    System.out.println("user name: " + user.getName());\n}\n\n\n示例代码中，给 sqlSession 对象的传递一个配置的 Sql 语句的 Statement Id 和参数，然后返回结果\n\nio.github.dunwu.spring.orm.mapper.UserMapper.selectByPrimaryKey 是配置在 UserMapper.xml 的 Statement ID，params 是 SQL 参数。\n\nUserMapper.xml 文件中的代码片段：\n\n  <select id="selectByPrimaryKey" parameterType="java.lang.Long" resultMap="BaseResultMap">\n    select id, name, age, address, email\n    from user\n    where id = #{id,jdbcType=BIGINT}\n  </select>\n\n\nMybatis 通过方法的全限定名，将 SqlSession 和 Mapper 相互映射起来。\n\n\n# SqlSession 和 Executor\n\norg.apache.ibatis.session.defaults.DefaultSqlSession 中 selectList 方法的源码：\n\n@Override\npublic <E> List<E> selectList(String statement) {\n  return this.selectList(statement, null);\n}\n\n@Override\npublic <E> List<E> selectList(String statement, Object parameter) {\n  return this.selectList(statement, parameter, RowBounds.DEFAULT);\n}\n\n@Override\npublic <E> List<E> selectList(String statement, Object parameter, RowBounds rowBounds) {\n  try {\n    // 1. 根据 Statement Id，在配置对象 Configuration 中查找和配置文件相对应的 MappedStatement\n    MappedStatement ms = configuration.getMappedStatement(statement);\n    // 2. 将 SQL 语句交由执行器 Executor 处理\n    return executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);\n  } catch (Exception e) {\n    throw ExceptionFactory.wrapException("Error querying database.  Cause: " + e, e);\n  } finally {\n    ErrorContext.instance().reset();\n  }\n}\n\n\n说明：\n\nMybatis 所有的配置信息都维持在 Configuration 对象之中。中维护了一个 Map<String, MappedStatement> 对象。其中，key 为 Mapper 方法的全限定名（对于本例而言，key 就是 io.github.dunwu.spring.orm.mapper.UserMapper.selectByPrimaryKey ），value 为 MappedStatement 对象。所以，传入 Statement Id 就可以从 Map 中找到对应的 MappedStatement。\n\nMappedStatement 维护了一个 Mapper 方法的元数据信息，其数据组织可以参考下面的 debug 截图：\n\n\n\n> 小结：\n> \n> 通过 "SqlSession 和 Mapper" 以及 "SqlSession 和 Executor" 这两节，我们已经知道：\n> \n> SqlSession 的职能是：根据 Statement ID, 在 Configuration 中获取到对应的 MappedStatement 对象，然后调用 Executor 来执行具体的操作。\n\n\n# Executor 工作流程\n\n继续上一节的流程，SqlSession 将 SQL 语句交由执行器 Executor 处理。Executor 又做了哪些事儿呢？\n\n（1）执行器查询入口\n\npublic <E> List<E> query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException {\n\t// 1. 根据传参，动态生成需要执行的 SQL 语句，用 BoundSql 对象表示\n    BoundSql boundSql = ms.getBoundSql(parameter);\n    // 2. 根据传参，创建一个缓存Key\n    CacheKey key = createCacheKey(ms, parameter, rowBounds, boundSql);\n    return query(ms, parameter, rowBounds, resultHandler, key, boundSql);\n }\n\n\n执行器查询入口主要做两件事：\n\n * 生成动态 SQL：根据传参，动态生成需要执行的 SQL 语句，用 BoundSql 对象表示。\n * 管理缓存：根据传参，创建一个缓存 Key。\n\n（2）执行器查询第二入口\n\n  @SuppressWarnings("unchecked")\n  @Override\n  public <E> List<E> query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException {\n    // 略\n    List<E> list;\n    try {\n      queryStack++;\n      list = resultHandler == null ? (List<E>) localCache.getObject(key) : null;\n      // 3. 缓存中有值，则直接从缓存中取数据；否则，查询数据库\n      if (list != null) {\n        handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);\n      } else {\n        list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);\n      }\n    } finally {\n      queryStack--;\n    }\n    // 略\n    return list;\n  }\n\n\n实际查询方法主要的职能是判断缓存 key 是否能命中缓存：\n\n * 命中，则将缓存中数据返回；\n * 不命中，则查询数据库：\n\n（3）查询数据库\n\n  private <E> List<E> queryFromDatabase(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException {\n    List<E> list;\n    localCache.putObject(key, EXECUTION_PLACEHOLDER);\n    try {\n      // 4. 执行查询，获取 List 结果，并将查询的结果更新本地缓存中\n      list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);\n    } finally {\n      localCache.removeObject(key);\n    }\n    localCache.putObject(key, list);\n    if (ms.getStatementType() == StatementType.CALLABLE) {\n      localOutputParameterCache.putObject(key, parameter);\n    }\n    return list;\n  }\n\n\nqueryFromDatabase 方法的职责是调用 doQuery，向数据库发起查询，并将返回的结果更新到本地缓存。\n\n（4）实际查询方法\n\nSimpleExecutor 类的 doQuery()方法实现\n\n  @Override\n  public <E> List<E> doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException {\n    Statement stmt = null;\n    try {\n      Configuration configuration = ms.getConfiguration();\n      // 5. 根据既有的参数，创建StatementHandler对象来执行查询操作\n      StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);\n      // 6. 创建java.Sql.Statement对象，传递给StatementHandler对象\n      stmt = prepareStatement(handler, ms.getStatementLog());\n      // 7. 调用StatementHandler.query()方法，返回List结果\n      return handler.query(stmt, resultHandler);\n    } finally {\n      closeStatement(stmt);\n    }\n  }\n\n\n上述的 Executor.query()方法几经转折，最后会创建一个 StatementHandler 对象，然后将必要的参数传递给 StatementHandler，使用 StatementHandler 来完成对数据库的查询，最终返回 List 结果集。 从上面的代码中我们可以看出，Executor 的功能和作用是：\n\n 1. 根据传递的参数，完成 SQL 语句的动态解析，生成 BoundSql 对象，供 StatementHandler 使用；\n\n 2. 为查询创建缓存，以提高性能\n\n 3. 创建 JDBC 的 Statement 连接对象，传递给 StatementHandler 对象，返回 List 查询结果。\n\nprepareStatement() 方法的实现：\n\n  private Statement prepareStatement(StatementHandler handler, Log statementLog) throws SQLException {\n    Statement stmt;\n    Connection connection = getConnection(statementLog);\n    stmt = handler.prepare(connection, transaction.getTimeout());\n    //对创建的Statement对象设置参数，即设置SQL 语句中 ? 设置为指定的参数\n    handler.parameterize(stmt);\n    return stmt;\n  }\n\n\n对于 JDBC 的 PreparedStatement 类型的对象，创建的过程中，我们使用的是 SQL 语句字符串会包含 若干个? 占位符，我们其后再对占位符进行设值。\n\n\n# StatementHandler 工作流程\n\nStatementHandler 有一个子类 RoutingStatementHandler，它负责代理其他 StatementHandler 子类的工作。\n\n它会根据配置的 Statement 类型，选择实例化相应的 StatementHandler，然后由其代理对象完成工作。\n\n【源码】RoutingStatementHandler\n\npublic RoutingStatementHandler(Executor executor, MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) {\n\n  switch (ms.getStatementType()) {\n    case STATEMENT:\n      delegate = new SimpleStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);\n      break;\n    case PREPARED:\n      delegate = new PreparedStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);\n      break;\n    case CALLABLE:\n      delegate = new CallableStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);\n      break;\n    default:\n      throw new ExecutorException("Unknown statement type: " + ms.getStatementType());\n  }\n\n}\n\n\n【源码】RoutingStatementHandler 的 parameterize 方法源码\n\n【源码】PreparedStatementHandler 的 parameterize 方法源码\n\nStatementHandler 使用 ParameterHandler 对象来完成对 Statement 的赋值。\n\n@Override\npublic void parameterize(Statement statement) throws SQLException {\n  // 使用 ParameterHandler 对象来完成对 Statement 的设值\n  parameterHandler.setParameters((PreparedStatement) statement);\n}\n\n\n【源码】StatementHandler 的 query 方法源码\n\nStatementHandler 使用 ResultSetHandler 对象来完成对 ResultSet 的处理。\n\n@Override\npublic <E> List<E> query(Statement statement, ResultHandler resultHandler) throws SQLException {\n  PreparedStatement ps = (PreparedStatement) statement;\n  ps.execute();\n  // 使用ResultHandler来处理ResultSet\n  return resultSetHandler.handleResultSets(ps);\n}\n\n\n\n# ParameterHandler 工作流程\n\n【源码】DefaultParameterHandler 的 setParameters 方法\n\n  @Override\n  public void setParameters(PreparedStatement ps) {\n\t// parameterMappings 是对占位符 #{} 对应参数的封装\n    List<ParameterMapping> parameterMappings = boundSql.getParameterMappings();\n    if (parameterMappings != null) {\n      for (int i = 0; i < parameterMappings.size(); i++) {\n        ParameterMapping parameterMapping = parameterMappings.get(i);\n        // 不处理存储过程中的参数\n        if (parameterMapping.getMode() != ParameterMode.OUT) {\n          Object value;\n          String propertyName = parameterMapping.getProperty();\n          if (boundSql.hasAdditionalParameter(propertyName)) { // issue #448 ask first for additional params\n            // 获取对应的实际数值\n            value = boundSql.getAdditionalParameter(propertyName);\n          } else if (parameterObject == null) {\n            value = null;\n          } else if (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) {\n            value = parameterObject;\n          } else {\n            // 获取对象中相应的属性或查找 Map 对象中的值\n            MetaObject metaObject = configuration.newMetaObject(parameterObject);\n            value = metaObject.getValue(propertyName);\n          }\n\n          TypeHandler typeHandler = parameterMapping.getTypeHandler();\n          JdbcType jdbcType = parameterMapping.getJdbcType();\n          if (value == null && jdbcType == null) {\n            jdbcType = configuration.getJdbcTypeForNull();\n          }\n          try {\n            // 通过 TypeHandler 将 Java 对象参数转为 JDBC 类型的参数\n            // 然后，将数值动态绑定到 PreparedStaement 中\n            typeHandler.setParameter(ps, i + 1, value, jdbcType);\n          } catch (TypeException | SQLException e) {\n            throw new TypeException("Could not set parameters for mapping: " + parameterMapping + ". Cause: " + e, e);\n          }\n        }\n      }\n    }\n  }\n\n\n\n# ResultSetHandler 工作流程\n\nResultSetHandler 的实现可以概括为：将 Statement 执行后的结果集，按照 Mapper 文件中配置的 ResultType 或 ResultMap 来转换成对应的 JavaBean 对象，最后将结果返回。\n\n【源码】DefaultResultSetHandler 的 handleResultSets 方法\n\nhandleResultSets 方法是 DefaultResultSetHandler 的最关键方法。其实现如下：\n\n@Override\npublic List<Object> handleResultSets(Statement stmt) throws SQLException {\n  ErrorContext.instance().activity("handling results").object(mappedStatement.getId());\n\n  final List<Object> multipleResults = new ArrayList<>();\n\n  int resultSetCount = 0;\n  // 第一个结果集\n  ResultSetWrapper rsw = getFirstResultSet(stmt);\n  List<ResultMap> resultMaps = mappedStatement.getResultMaps();\n  // 判断结果集的数量\n  int resultMapCount = resultMaps.size();\n  validateResultMapsCount(rsw, resultMapCount);\n  // 遍历处理结果集\n  while (rsw != null && resultMapCount > resultSetCount) {\n    ResultMap resultMap = resultMaps.get(resultSetCount);\n    handleResultSet(rsw, resultMap, multipleResults, null);\n    rsw = getNextResultSet(stmt);\n    cleanUpAfterHandlingResultSet();\n    resultSetCount++;\n  }\n\n  String[] resultSets = mappedStatement.getResultSets();\n  if (resultSets != null) {\n    while (rsw != null && resultSetCount < resultSets.length) {\n      ResultMapping parentMapping = nextResultMaps.get(resultSets[resultSetCount]);\n      if (parentMapping != null) {\n        String nestedResultMapId = parentMapping.getNestedResultMapId();\n        ResultMap resultMap = configuration.getResultMap(nestedResultMapId);\n        handleResultSet(rsw, resultMap, null, parentMapping);\n      }\n      rsw = getNextResultSet(stmt);\n      cleanUpAfterHandlingResultSet();\n      resultSetCount++;\n    }\n  }\n\n  return collapseSingleResultList(multipleResults);\n}\n\n\n\n# 参考资料\n\n * 官方\n   * Mybatis Github\n   * Mybatis 官网\n * 文章\n   * 深入理解 Mybatis 原理\n   * Mybatis 源码中文注释\n   * Mybatis 中强大的 resultMap',normalizedContent:'# mybatis 原理\n\n> mybatis 的前身就是 ibatis ，是一款优秀的持久层框架，它支持自定义 sql、存储过程以及高级映射。本文以一个 mybatis 完整示例为切入点，结合 mybatis 底层源码分析，图文并茂的讲解 mybatis 的核心工作机制。\n\n\n# mybatis 完整示例\n\n> 这里，我将以一个入门级的示例来演示 mybatis 是如何工作的。\n> \n> 注：本文后面章节中的原理、源码部分也将基于这个示例来进行讲解。\n> \n> 完整示例源码地址\n\n\n# 数据库准备\n\n在本示例中，需要针对一张用户表进行 crud 操作。其数据模型如下：\n\ncreate table if not exists user (\n    id      bigint(10) unsigned not null auto_increment comment \'id\',\n    name    varchar(10)         not null default \'\' comment \'用户名\',\n    age     int(3)              not null default 0 comment \'年龄\',\n    address varchar(32)         not null default \'\' comment \'地址\',\n    email   varchar(32)         not null default \'\' comment \'邮件\',\n    primary key (id)\n) comment = \'用户表\';\n\ninsert into user (name, age, address, email)\nvalues (\'张三\', 18, \'北京\', \'xxx@163.com\');\ninsert into user (name, age, address, email)\nvalues (\'李四\', 19, \'上海\', \'xxx@163.com\');\n\n\n\n# 添加 mybatis\n\n如果使用 maven 来构建项目，则需将下面的依赖代码置于 pom.xml 文件中：\n\n<dependency>\n  <groupid>org.mybatis</groupid>\n  <artifactid>mybatis</artifactid>\n  <version>x.x.x</version>\n</dependency>\n\n\n\n# mybatis 配置\n\nxml 配置文件中包含了对 mybatis 系统的核心设置，包括获取数据库连接实例的数据源（datasource）以及决定事务作用域和控制方式的事务管理器（transactionmanager）。\n\n本示例中只是给出最简化的配置。\n\n【示例】mybatis-config.xml 文件\n\n<?xml version="1.0" encoding="utf-8"?>\n<!doctype configuration public "-//mybatis.org//dtd config 3.0//en"\n  "http://mybatis.org/dtd/mybatis-3-config.dtd">\n<configuration>\n  <environments default="development">\n    <environment id="development">\n      <transactionmanager type="jdbc" />\n      <datasource type="pooled">\n        <property name="driver" value="com.mysql.cj.jdbc.driver" />\n        <property name="url"\n                  value="jdbc:mysql://127.0.0.1:3306/spring_tutorial?servertimezone=utc" />\n        <property name="username" value="root" />\n        <property name="password" value="root" />\n      </datasource>\n    </environment>\n  </environments>\n  <mappers>\n    <mapper resource="mybatis/mapper/usermapper.xml" />\n  </mappers>\n</configuration>\n\n\n> 说明：上面的配置文件中仅仅指定了数据源连接方式和 user 表的映射配置文件。\n\n\n# mapper\n\n# mapper.xml\n\n个人理解，mapper.xml 文件可以看做是 mybatis 的 jdbc sql 模板。\n\n【示例】usermapper.xml 文件\n\n下面是一个通过 mybatis generator 自动生成的完整的 mapper 文件。\n\n<?xml version="1.0" encoding="utf-8"?>\n<!doctype mapper public "-//mybatis.org//dtd mapper 3.0//en" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">\n<mapper namespace="io.github.dunwu.spring.orm.mapper.usermapper">\n  <resultmap id="baseresultmap" type="io.github.dunwu.spring.orm.entity.user">\n    <id column="id" jdbctype="bigint" property="id" />\n    <result column="name" jdbctype="varchar" property="name" />\n    <result column="age" jdbctype="integer" property="age" />\n    <result column="address" jdbctype="varchar" property="address" />\n    <result column="email" jdbctype="varchar" property="email" />\n  </resultmap>\n  <delete id="deletebyprimarykey" parametertype="java.lang.long">\n    delete from user\n    where id = #{id,jdbctype=bigint}\n  </delete>\n  <insert id="insert" parametertype="io.github.dunwu.spring.orm.entity.user">\n    insert into user (id, name, age,\n      address, email)\n    values (#{id,jdbctype=bigint}, #{name,jdbctype=varchar}, #{age,jdbctype=integer},\n      #{address,jdbctype=varchar}, #{email,jdbctype=varchar})\n  </insert>\n  <update id="updatebyprimarykey" parametertype="io.github.dunwu.spring.orm.entity.user">\n    update user\n    set name = #{name,jdbctype=varchar},\n      age = #{age,jdbctype=integer},\n      address = #{address,jdbctype=varchar},\n      email = #{email,jdbctype=varchar}\n    where id = #{id,jdbctype=bigint}\n  </update>\n  <select id="selectbyprimarykey" parametertype="java.lang.long" resultmap="baseresultmap">\n    select id, name, age, address, email\n    from user\n    where id = #{id,jdbctype=bigint}\n  </select>\n  <select id="selectall" resultmap="baseresultmap">\n    select id, name, age, address, email\n    from user\n  </select>\n</mapper>\n\n\n# mapper.java\n\nmapper.java 文件是 mapper.xml 对应的 java 对象。\n\n【示例】usermapper.java 文件\n\npublic interface usermapper {\n\n    int deletebyprimarykey(long id);\n\n    int insert(user record);\n\n    user selectbyprimarykey(long id);\n\n    list<user> selectall();\n\n    int updatebyprimarykey(user record);\n\n}\n\n\n对比 usermapper.java 和 usermapper.xml 文件，不难发现：\n\nusermapper.java 中的方法和 usermapper.xml 的 crud 语句元素（ <insert>、<delete>、<update>、<select>）存在一一对应关系。\n\n在 mybatis 中，正是通过方法的全限定名，将二者绑定在一起。\n\n# 数据实体.java\n\n【示例】user.java 文件\n\npublic class user {\n    private long id;\n\n    private string name;\n\n    private integer age;\n\n    private string address;\n\n    private string email;\n\n}\n\n\n<insert>、<delete>、<update>、<select> 的 parametertype 属性以及 <resultmap> 的 type 属性都可能会绑定到数据实体。这样就可以把 jdbc 操作的输入输出和 javabean 结合起来，更加方便、易于理解。\n\n\n# 测试程序\n\n【示例】mybatisdemo.java 文件\n\npublic class mybatisdemo {\n\n    public static void main(string[] args) throws exception {\n        // 1. 加载 mybatis 配置文件，创建 sqlsessionfactory\n        // 注：在实际的应用中，sqlsessionfactory 应该是单例\n        inputstream inputstream = resources.getresourceasstream("mybatis/mybatis-config.xml");\n        sqlsessionfactorybuilder builder = new sqlsessionfactorybuilder();\n        sqlsessionfactory factory = builder.build(inputstream);\n\n        // 2. 创建一个 sqlsession 实例，进行数据库操作\n        sqlsession sqlsession = factory.opensession();\n\n        // 3. mapper 映射并执行\n        long params = 1l;\n        list<user> list = sqlsession.selectlist("io.github.dunwu.spring.orm.mapper.usermapper.selectbyprimarykey", params);\n        for (user user : list) {\n            system.out.println("user name: " + user.getname());\n        }\n        // 输出：user name: 张三\n    }\n\n}\n\n\n> 说明：\n> \n> sqlsession 接口是 mybatis api 核心中的核心，它代表了 mybatis 和数据库的一次完整会话。\n> \n>  * mybatis 会解析配置，并根据配置创建 sqlsession 。\n>  * 然后，mybatis 将 mapper 映射为 sqlsession，然后传递参数，执行 sql 语句并获取结果。\n\n\n# mybatis 生命周期\n\n\n\n\n# sqlsessionfactorybuilder\n\n# sqlsessionfactorybuilder 的职责\n\nsqlsessionfactorybuilder 负责创建 sqlsessionfactory 实例。sqlsessionfactorybuilder 可以从 xml 配置文件或一个预先定制的 configuration 的实例构建出 sqlsessionfactory 的实例。\n\nconfiguration 类包含了对一个 sqlsessionfactory 实例你可能关心的所有内容。\n\n\n\nsqlsessionfactorybuilder 应用了建造者设计模式，它有五个 build 方法，允许你通过不同的资源创建 sqlsessionfactory 实例。\n\nsqlsessionfactory build(inputstream inputstream)\nsqlsessionfactory build(inputstream inputstream, string environment)\nsqlsessionfactory build(inputstream inputstream, properties properties)\nsqlsessionfactory build(inputstream inputstream, string env, properties props)\nsqlsessionfactory build(configuration config)\n\n\n# sqlsessionfactorybuilder 的生命周期\n\nsqlsessionfactorybuilder 可以被实例化、使用和丢弃，一旦创建了 sqlsessionfactory，就不再需要它了。 因此 sqlsessionfactorybuilder 实例的最佳作用域是方法作用域（也就是局部方法变量）。你可以重用 sqlsessionfactorybuilder 来创建多个 sqlsessionfactory 实例，但最好还是不要一直保留着它，以保证所有的 xml 解析资源可以被释放给更重要的事情。\n\n\n# sqlsessionfactory\n\n# sqlsessionfactory 职责\n\nsqlsessionfactory 负责创建 sqlsession 实例。\n\n\n\nsqlsessionfactory 应用了工厂设计模式，它提供了一组方法，用于创建 sqlsession 实例。\n\nsqlsession opensession()\nsqlsession opensession(boolean autocommit)\nsqlsession opensession(connection connection)\nsqlsession opensession(transactionisolationlevel level)\nsqlsession opensession(executortype exectype, transactionisolationlevel level)\nsqlsession opensession(executortype exectype)\nsqlsession opensession(executortype exectype, boolean autocommit)\nsqlsession opensession(executortype exectype, connection connection)\nconfiguration getconfiguration();\n\n\n方法说明：\n\n * 默认的 opensession() 方法没有参数，它会创建具备如下特性的 sqlsession：\n   * 事务作用域将会开启（也就是不自动提交）。\n   * 将由当前环境配置的 datasource 实例中获取 connection 对象。\n   * 事务隔离级别将会使用驱动或数据源的默认设置。\n   * 预处理语句不会被复用，也不会批量处理更新。\n * transactionisolationlevel 表示事务隔离级别，它对应着 jdbc 的五个事务隔离级别。\n * executortype 枚举类型定义了三个值:\n   * executortype.simple：该类型的执行器没有特别的行为。它为每个语句的执行创建一个新的预处理语句。\n   * executortype.reuse：该类型的执行器会复用预处理语句。\n   * executortype.batch：该类型的执行器会批量执行所有更新语句，如果 select 在多个更新中间执行，将在必要时将多条更新语句分隔开来，以方便理解。\n\n# sqlsessionfactory 生命周期\n\nsqlsessionfactory 应该以单例形式在应用的运行期间一直存在。\n\n\n# sqlsession\n\n# sqlsession 职责\n\nmybatis 的主要 java 接口就是 sqlsession。它包含了所有执行语句，获取映射器和管理事务等方法。\n\n> 详细内容可以参考：“ mybatis 官方文档之 sqlsessions ” 。\n\nsqlsession 类的方法可以按照下图进行大致分类：\n\n\n\n# sqlsession 生命周期\n\nsqlsessions 是由 sqlsessionfactory 实例创建的；而 sqlsessionfactory 是由 sqlsessionfactorybuilder 创建的。\n\n> 🔔 注意：当 mybatis 与一些依赖注入框架（如 spring 或者 guice）同时使用时，sqlsessions 将被依赖注入框架所创建，所以你不需要使用 sqlsessionfactorybuilder 或者 sqlsessionfactory。\n\n每个线程都应该有它自己的 sqlsession 实例。\n\nsqlsession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。 绝对不能将 sqlsession 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。 也绝不能将 sqlsession 实例的引用放在任何类型的托管作用域中，比如 servlet 框架中的 httpsession。 正确在 web 中使用 sqlsession 的场景是：每次收到的 http 请求，就可以打开一个 sqlsession，返回一个响应，就关闭它。\n\n编程模式：\n\ntry (sqlsession session = sqlsessionfactory.opensession()) {\n  // 你的应用逻辑代码\n}\n\n\n\n# 映射器\n\n# 映射器职责\n\n映射器是一些由用户创建的、绑定 sql 语句的接口。\n\nsqlsession 中的 insert、update、delete 和 select 方法都很强大，但也有些繁琐。更通用的方式是使用映射器类来执行映射语句。一个映射器类就是一个仅需声明与 sqlsession 方法相匹配的方法的接口类。\n\nmybatis 将配置文件中的每一个 <mapper> 节点抽象为一个 mapper 接口，而这个接口中声明的方法和跟 <mapper> 节点中的 <select|update|delete|insert> 节点相对应，即 <select|update|delete|insert> 节点的 id 值为 mapper 接口中的方法名称，parametertype 值表示 mapper 对应方法的入参类型，而 resultmap 值则对应了 mapper 接口表示的返回值类型或者返回结果集的元素类型。\n\nmybatis 会根据相应的接口声明的方法信息，通过动态代理机制生成一个 mapper 实例；mybatis 会根据这个方法的方法名和参数类型，确定 statement id，然后和 sqlsession 进行映射，底层还是通过 sqlsession 完成和数据库的交互。\n\n下面的示例展示了一些方法签名以及它们是如何映射到 sqlsession 上的。\n\n\n\n> 注意\n> \n>  * 映射器接口不需要去实现任何接口或继承自任何类。只要方法可以被唯一标识对应的映射语句就可以了。\n>  * 映射器接口可以继承自其他接口。当使用 xml 来构建映射器接口时要保证语句被包含在合适的命名空间中。而且，唯一的限制就是你不能在两个继承关系的接口中拥有相同的方法签名（潜在的危险做法不可取）。\n\n# 映射器生命周期\n\n映射器接口的实例是从 sqlsession 中获得的。因此从技术层面讲，任何映射器实例的最大作用域是和请求它们的 sqlsession 相同的。尽管如此，映射器实例的最佳作用域是方法作用域。 也就是说，映射器实例应该在调用它们的方法中被请求，用过之后即可丢弃。\n\n编程模式：\n\ntry (sqlsession session = sqlsessionfactory.opensession()) {\n  blogmapper mapper = session.getmapper(blogmapper.class);\n  // 你的应用逻辑代码\n}\n\n\n * 映射器注解\n\nmybatis 是一个 xml 驱动的框架。配置信息是基于 xml 的，而且映射语句也是定义在 xml 中的。mybatis 3 以后，支持注解配置。注解配置基于配置 api；而配置 api 基于 xml 配置。\n\nmybatis 支持诸如 @insert、@update、@delete、@select、@result 等注解。\n\n> 详细内容请参考：mybatis 官方文档之 sqlsessions，其中列举了 mybatis 支持的注解清单，以及基本用法。\n\n\n# mybatis 的架构\n\n从 mybatis 代码实现的角度来看，mybatis 的主要组件有以下几个：\n\n * sqlsession - 作为 mybatis 工作的主要顶层 api，表示和数据库交互的会话，完成必要数据库增删改查功能。\n * executor - mybatis 执行器，是 mybatis 调度的核心，负责 sql 语句的生成和查询缓存的维护。\n * statementhandler - 封装了 jdbc statement 操作，负责对 jdbc statement 的操作，如设置参数、将 statement 结果集转换成 list 集合。\n * parameterhandler - 负责对用户传递的参数转换成 jdbc statement 所需要的参数。\n * resultsethandler - 负责将 jdbc 返回的 resultset 结果集对象转换成 list 类型的集合。\n * typehandler - 负责 java 数据类型和 jdbc 数据类型之间的映射和转换。\n * mappedstatement - mappedstatement 维护了一条 <select|update|delete|insert> 节点的封装。\n * sqlsource - 负责根据用户传递的 parameterobject，动态地生成 sql 语句，将信息封装到 boundsql 对象中，并返回。\n * boundsql - 表示动态生成的 sql 语句以及相应的参数信息。\n * configuration - mybatis 所有的配置信息都维持在 configuration 对象之中。\n\n这些组件的架构层次如下：\n\n\n\n\n# 配置层\n\n配置层决定了 mybatis 的工作方式。\n\nmybatis 提供了两种配置方式：\n\n * 基于 xml 配置文件的方式\n * 基于 java api 的方式\n\nsqlsessionfactorybuilder 会根据配置创建 sqlsessionfactory ；\n\nsqlsessionfactory 负责创建 sqlsessions 。\n\n\n# 接口层\n\n接口层负责和数据库交互的方式。\n\nmybatis 和数据库的交互有两种方式：\n\n * 使用 sqlsession：sqlsession 封装了所有执行语句，获取映射器和管理事务的方法。\n   * 用户只需要传入 statement id 和查询参数给 sqlsession 对象，就可以很方便的和数据库进行交互。\n   * 这种方式的缺点是不符合面向对象编程的范式。\n * 使用 mapper 接口：mybatis 会根据相应的接口声明的方法信息，通过动态代理机制生成一个 mapper 实例；mybatis 会根据这个方法的方法名和参数类型，确定 statement id，然后和 sqlsession 进行映射，底层还是通过 sqlsession 完成和数据库的交互。\n\n\n# 数据处理层\n\n数据处理层可以说是 mybatis 的核心，从大的方面上讲，它要完成两个功能：\n\n * 根据传参 statement 和参数构建动态 sql 语句\n   * 动态语句生成可以说是 mybatis 框架非常优雅的一个设计，mybatis 通过传入的参数值，使用 ognl 来动态地构造 sql 语句，使得 mybatis 有很强的灵活性和扩展性。\n   * 参数映射指的是对于 java 数据类型和 jdbc 数据类型之间的转换：这里有包括两个过程：查询阶段，我们要将 java 类型的数据，转换成 jdbc 类型的数据，通过 preparedstatement.setxxx() 来设值；另一个就是对 resultset 查询结果集的 jdbctype 数据转换成 java 数据类型。\n * 执行 sql 语句以及处理响应结果集 resultset\n   * 动态 sql 语句生成之后，mybatis 将执行 sql 语句，并将可能返回的结果集转换成 list<e> 列表。\n   * mybatis 在对结果集的处理中，支持结果集关系一对多和多对一的转换，并且有两种支持方式，一种为嵌套查询语句的查询，还有一种是嵌套结果集的查询。\n\n\n# 框架支撑层\n\n * 事务管理机制 - mybatis 将事务抽象成了 transaction 接口。mybatis 的事务管理分为两种形式：\n   \n   * 使用 jdbc 的事务管理机制：即利用 java.sql.connection 对象完成对事务的提交（commit）、回滚（rollback）、关闭（close）等。\n   * 使用 managed 的事务管理机制：mybatis 自身不会去实现事务管理，而是让程序的容器如（jboss，weblogic）来实现对事务的管理。\n\n * 连接池管理\n\n * sql 语句的配置 - 支持两种方式：\n   \n   * xml 配置\n   * 注解配置\n\n * 缓存机制 - mybatis 采用两级缓存结构\n   \n   * 一级缓存是 session 会话级别的缓存 - 一级缓存又被称之为本地缓存。一般而言，一个 sqlsession 对象会使用一个 executor 对象来完成会话操作，executor 对象会维护一个 cache 缓存，以提高查询性能。\n     * 一级缓存的生命周期是 session 会话级别的。\n   * 二级缓存是 application 应用级别的缓存 - 用户配置了 "cacheenabled=true"，才会开启二级缓存。\n     * 如果开启了二级缓存，sqlsession 会先使用 cachingexecutor 对象来处理查询请求。cachingexecutor 会在二级缓存中查看是否有匹配的数据，如果匹配，则直接返回缓存结果；如果缓存中没有，再交给真正的 executor 对象来完成查询，之后 cachingexecutor 会将真正 executor 返回的查询结果放置到缓存中，然后在返回给用户。\n     * 二级缓存的生命周期是应用级别的。\n\n\n\n\n# sqlsession 内部工作机制\n\n从前文，我们已经了解了，mybatis 封装了对数据库的访问，把对数据库的会话和事务控制放到了 sqlsession 对象中。那么具体是如何工作的呢？接下来，我们通过源码解读来进行分析。\n\n\n\nsqlsession 对于 insert、update、delete、select 的内部处理机制基本上大同小异。所以，接下来，我会以一次完整的 select 查询流程为例讲解 sqlsession 内部的工作机制。相信读者如果理解了 select 的处理流程，对于其他 crud 操作也能做到一通百通。\n\n\n# sqlsession 子组件\n\n前面的内容已经介绍了：sqlsession 是 mybatis 的顶层接口，它提供了所有执行语句，获取映射器和管理事务等方法。\n\n实际上，sqlsession 是通过聚合多个子组件，让每个子组件负责各自功能的方式，实现了任务的下发。\n\n在了解各个子组件工作机制前，先让我们简单认识一下 sqlsession 的核心子组件。\n\n# executor\n\nexecutor 即执行器，它负责生成动态 sql 以及管理缓存。\n\n\n\n * executor 即执行器接口。\n * baseexecutor 是 executor 的抽象类，它采用了模板方法设计模式，内置了一些共性方法，而将定制化方法留给子类去实现。\n * simpleexecutor 是最简单的执行器。它只会直接执行 sql，不会做额外的事。\n * batchexecutor 是批处理执行器。它的作用是通过批处理来优化性能。值得注意的是，批量更新操作，由于内部有缓存机制，使用完后需要调用 flushstatements 来清除缓存。\n * reuseexecutor 是可重用的执行器。重用的对象是 statement，也就是说，该执行器会缓存同一个 sql 的 statement，避免重复创建 statement。其内部的实现是通过一个 hashmap 来维护 statement 对象的。由于当前 map 只在该 session 中有效，所以使用完后需要调用 flushstatements 来清除 map。\n * cachingexecutor 是缓存执行器。它只在启用二级缓存时才会用到。\n\n# statementhandler\n\nstatementhandler 对象负责设置 statement 对象中的查询参数、处理 jdbc 返回的 resultset，将 resultset 加工为 list 集合返回。\n\nstatementhandler 的家族成员：\n\n\n\n * statementhandler 是接口；\n * basestatementhandler 是实现 statementhandler 的抽象类，内置一些共性方法；\n * simplestatementhandler 负责处理 statement；\n * preparedstatementhandler 负责处理 preparedstatement；\n * callablestatementhandler 负责处理 callablestatement。\n * routingstatementhandler 负责代理 statementhandler 具体子类，根据 statement 类型，选择实例化 simplestatementhandler、preparedstatementhandler、callablestatementhandler。\n\n# parameterhandler\n\nparameterhandler 负责将传入的 java 对象转换 jdbc 类型对象，并为 preparedstatement 的动态 sql 填充数值。\n\nparameterhandler 只有一个具体实现类，即 defaultparameterhandler。\n\n# resultsethandler\n\nresultsethandler 负责两件事：\n\n * 处理 statement 执行后产生的结果集，生成结果列表\n * 处理存储过程执行后的输出参数\n\nresultsethandler 只有一个具体实现类，即 defaultresultsethandler。\n\n# typehandler\n\ntypehandler 负责将 java 对象类型和 jdbc 类型进行相互转换。\n\n\n# sqlsession 和 mapper\n\n先来回忆一下 mybatis 完整示例章节的 测试程序部分的代码。\n\nmybatisdemo.java 文件中的代码片段：\n\n// 2. 创建一个 sqlsession 实例，进行数据库操作\nsqlsession sqlsession = factory.opensession();\n\n// 3. mapper 映射并执行\nlong params = 1l;\nlist<user> list = sqlsession.selectlist("io.github.dunwu.spring.orm.mapper.usermapper.selectbyprimarykey", params);\nfor (user user : list) {\n    system.out.println("user name: " + user.getname());\n}\n\n\n示例代码中，给 sqlsession 对象的传递一个配置的 sql 语句的 statement id 和参数，然后返回结果\n\nio.github.dunwu.spring.orm.mapper.usermapper.selectbyprimarykey 是配置在 usermapper.xml 的 statement id，params 是 sql 参数。\n\nusermapper.xml 文件中的代码片段：\n\n  <select id="selectbyprimarykey" parametertype="java.lang.long" resultmap="baseresultmap">\n    select id, name, age, address, email\n    from user\n    where id = #{id,jdbctype=bigint}\n  </select>\n\n\nmybatis 通过方法的全限定名，将 sqlsession 和 mapper 相互映射起来。\n\n\n# sqlsession 和 executor\n\norg.apache.ibatis.session.defaults.defaultsqlsession 中 selectlist 方法的源码：\n\n@override\npublic <e> list<e> selectlist(string statement) {\n  return this.selectlist(statement, null);\n}\n\n@override\npublic <e> list<e> selectlist(string statement, object parameter) {\n  return this.selectlist(statement, parameter, rowbounds.default);\n}\n\n@override\npublic <e> list<e> selectlist(string statement, object parameter, rowbounds rowbounds) {\n  try {\n    // 1. 根据 statement id，在配置对象 configuration 中查找和配置文件相对应的 mappedstatement\n    mappedstatement ms = configuration.getmappedstatement(statement);\n    // 2. 将 sql 语句交由执行器 executor 处理\n    return executor.query(ms, wrapcollection(parameter), rowbounds, executor.no_result_handler);\n  } catch (exception e) {\n    throw exceptionfactory.wrapexception("error querying database.  cause: " + e, e);\n  } finally {\n    errorcontext.instance().reset();\n  }\n}\n\n\n说明：\n\nmybatis 所有的配置信息都维持在 configuration 对象之中。中维护了一个 map<string, mappedstatement> 对象。其中，key 为 mapper 方法的全限定名（对于本例而言，key 就是 io.github.dunwu.spring.orm.mapper.usermapper.selectbyprimarykey ），value 为 mappedstatement 对象。所以，传入 statement id 就可以从 map 中找到对应的 mappedstatement。\n\nmappedstatement 维护了一个 mapper 方法的元数据信息，其数据组织可以参考下面的 debug 截图：\n\n\n\n> 小结：\n> \n> 通过 "sqlsession 和 mapper" 以及 "sqlsession 和 executor" 这两节，我们已经知道：\n> \n> sqlsession 的职能是：根据 statement id, 在 configuration 中获取到对应的 mappedstatement 对象，然后调用 executor 来执行具体的操作。\n\n\n# executor 工作流程\n\n继续上一节的流程，sqlsession 将 sql 语句交由执行器 executor 处理。executor 又做了哪些事儿呢？\n\n（1）执行器查询入口\n\npublic <e> list<e> query(mappedstatement ms, object parameter, rowbounds rowbounds, resulthandler resulthandler) throws sqlexception {\n\t// 1. 根据传参，动态生成需要执行的 sql 语句，用 boundsql 对象表示\n    boundsql boundsql = ms.getboundsql(parameter);\n    // 2. 根据传参，创建一个缓存key\n    cachekey key = createcachekey(ms, parameter, rowbounds, boundsql);\n    return query(ms, parameter, rowbounds, resulthandler, key, boundsql);\n }\n\n\n执行器查询入口主要做两件事：\n\n * 生成动态 sql：根据传参，动态生成需要执行的 sql 语句，用 boundsql 对象表示。\n * 管理缓存：根据传参，创建一个缓存 key。\n\n（2）执行器查询第二入口\n\n  @suppresswarnings("unchecked")\n  @override\n  public <e> list<e> query(mappedstatement ms, object parameter, rowbounds rowbounds, resulthandler resulthandler, cachekey key, boundsql boundsql) throws sqlexception {\n    // 略\n    list<e> list;\n    try {\n      querystack++;\n      list = resulthandler == null ? (list<e>) localcache.getobject(key) : null;\n      // 3. 缓存中有值，则直接从缓存中取数据；否则，查询数据库\n      if (list != null) {\n        handlelocallycachedoutputparameters(ms, key, parameter, boundsql);\n      } else {\n        list = queryfromdatabase(ms, parameter, rowbounds, resulthandler, key, boundsql);\n      }\n    } finally {\n      querystack--;\n    }\n    // 略\n    return list;\n  }\n\n\n实际查询方法主要的职能是判断缓存 key 是否能命中缓存：\n\n * 命中，则将缓存中数据返回；\n * 不命中，则查询数据库：\n\n（3）查询数据库\n\n  private <e> list<e> queryfromdatabase(mappedstatement ms, object parameter, rowbounds rowbounds, resulthandler resulthandler, cachekey key, boundsql boundsql) throws sqlexception {\n    list<e> list;\n    localcache.putobject(key, execution_placeholder);\n    try {\n      // 4. 执行查询，获取 list 结果，并将查询的结果更新本地缓存中\n      list = doquery(ms, parameter, rowbounds, resulthandler, boundsql);\n    } finally {\n      localcache.removeobject(key);\n    }\n    localcache.putobject(key, list);\n    if (ms.getstatementtype() == statementtype.callable) {\n      localoutputparametercache.putobject(key, parameter);\n    }\n    return list;\n  }\n\n\nqueryfromdatabase 方法的职责是调用 doquery，向数据库发起查询，并将返回的结果更新到本地缓存。\n\n（4）实际查询方法\n\nsimpleexecutor 类的 doquery()方法实现\n\n  @override\n  public <e> list<e> doquery(mappedstatement ms, object parameter, rowbounds rowbounds, resulthandler resulthandler, boundsql boundsql) throws sqlexception {\n    statement stmt = null;\n    try {\n      configuration configuration = ms.getconfiguration();\n      // 5. 根据既有的参数，创建statementhandler对象来执行查询操作\n      statementhandler handler = configuration.newstatementhandler(wrapper, ms, parameter, rowbounds, resulthandler, boundsql);\n      // 6. 创建java.sql.statement对象，传递给statementhandler对象\n      stmt = preparestatement(handler, ms.getstatementlog());\n      // 7. 调用statementhandler.query()方法，返回list结果\n      return handler.query(stmt, resulthandler);\n    } finally {\n      closestatement(stmt);\n    }\n  }\n\n\n上述的 executor.query()方法几经转折，最后会创建一个 statementhandler 对象，然后将必要的参数传递给 statementhandler，使用 statementhandler 来完成对数据库的查询，最终返回 list 结果集。 从上面的代码中我们可以看出，executor 的功能和作用是：\n\n 1. 根据传递的参数，完成 sql 语句的动态解析，生成 boundsql 对象，供 statementhandler 使用；\n\n 2. 为查询创建缓存，以提高性能\n\n 3. 创建 jdbc 的 statement 连接对象，传递给 statementhandler 对象，返回 list 查询结果。\n\npreparestatement() 方法的实现：\n\n  private statement preparestatement(statementhandler handler, log statementlog) throws sqlexception {\n    statement stmt;\n    connection connection = getconnection(statementlog);\n    stmt = handler.prepare(connection, transaction.gettimeout());\n    //对创建的statement对象设置参数，即设置sql 语句中 ? 设置为指定的参数\n    handler.parameterize(stmt);\n    return stmt;\n  }\n\n\n对于 jdbc 的 preparedstatement 类型的对象，创建的过程中，我们使用的是 sql 语句字符串会包含 若干个? 占位符，我们其后再对占位符进行设值。\n\n\n# statementhandler 工作流程\n\nstatementhandler 有一个子类 routingstatementhandler，它负责代理其他 statementhandler 子类的工作。\n\n它会根据配置的 statement 类型，选择实例化相应的 statementhandler，然后由其代理对象完成工作。\n\n【源码】routingstatementhandler\n\npublic routingstatementhandler(executor executor, mappedstatement ms, object parameter, rowbounds rowbounds, resulthandler resulthandler, boundsql boundsql) {\n\n  switch (ms.getstatementtype()) {\n    case statement:\n      delegate = new simplestatementhandler(executor, ms, parameter, rowbounds, resulthandler, boundsql);\n      break;\n    case prepared:\n      delegate = new preparedstatementhandler(executor, ms, parameter, rowbounds, resulthandler, boundsql);\n      break;\n    case callable:\n      delegate = new callablestatementhandler(executor, ms, parameter, rowbounds, resulthandler, boundsql);\n      break;\n    default:\n      throw new executorexception("unknown statement type: " + ms.getstatementtype());\n  }\n\n}\n\n\n【源码】routingstatementhandler 的 parameterize 方法源码\n\n【源码】preparedstatementhandler 的 parameterize 方法源码\n\nstatementhandler 使用 parameterhandler 对象来完成对 statement 的赋值。\n\n@override\npublic void parameterize(statement statement) throws sqlexception {\n  // 使用 parameterhandler 对象来完成对 statement 的设值\n  parameterhandler.setparameters((preparedstatement) statement);\n}\n\n\n【源码】statementhandler 的 query 方法源码\n\nstatementhandler 使用 resultsethandler 对象来完成对 resultset 的处理。\n\n@override\npublic <e> list<e> query(statement statement, resulthandler resulthandler) throws sqlexception {\n  preparedstatement ps = (preparedstatement) statement;\n  ps.execute();\n  // 使用resulthandler来处理resultset\n  return resultsethandler.handleresultsets(ps);\n}\n\n\n\n# parameterhandler 工作流程\n\n【源码】defaultparameterhandler 的 setparameters 方法\n\n  @override\n  public void setparameters(preparedstatement ps) {\n\t// parametermappings 是对占位符 #{} 对应参数的封装\n    list<parametermapping> parametermappings = boundsql.getparametermappings();\n    if (parametermappings != null) {\n      for (int i = 0; i < parametermappings.size(); i++) {\n        parametermapping parametermapping = parametermappings.get(i);\n        // 不处理存储过程中的参数\n        if (parametermapping.getmode() != parametermode.out) {\n          object value;\n          string propertyname = parametermapping.getproperty();\n          if (boundsql.hasadditionalparameter(propertyname)) { // issue #448 ask first for additional params\n            // 获取对应的实际数值\n            value = boundsql.getadditionalparameter(propertyname);\n          } else if (parameterobject == null) {\n            value = null;\n          } else if (typehandlerregistry.hastypehandler(parameterobject.getclass())) {\n            value = parameterobject;\n          } else {\n            // 获取对象中相应的属性或查找 map 对象中的值\n            metaobject metaobject = configuration.newmetaobject(parameterobject);\n            value = metaobject.getvalue(propertyname);\n          }\n\n          typehandler typehandler = parametermapping.gettypehandler();\n          jdbctype jdbctype = parametermapping.getjdbctype();\n          if (value == null && jdbctype == null) {\n            jdbctype = configuration.getjdbctypefornull();\n          }\n          try {\n            // 通过 typehandler 将 java 对象参数转为 jdbc 类型的参数\n            // 然后，将数值动态绑定到 preparedstaement 中\n            typehandler.setparameter(ps, i + 1, value, jdbctype);\n          } catch (typeexception | sqlexception e) {\n            throw new typeexception("could not set parameters for mapping: " + parametermapping + ". cause: " + e, e);\n          }\n        }\n      }\n    }\n  }\n\n\n\n# resultsethandler 工作流程\n\nresultsethandler 的实现可以概括为：将 statement 执行后的结果集，按照 mapper 文件中配置的 resulttype 或 resultmap 来转换成对应的 javabean 对象，最后将结果返回。\n\n【源码】defaultresultsethandler 的 handleresultsets 方法\n\nhandleresultsets 方法是 defaultresultsethandler 的最关键方法。其实现如下：\n\n@override\npublic list<object> handleresultsets(statement stmt) throws sqlexception {\n  errorcontext.instance().activity("handling results").object(mappedstatement.getid());\n\n  final list<object> multipleresults = new arraylist<>();\n\n  int resultsetcount = 0;\n  // 第一个结果集\n  resultsetwrapper rsw = getfirstresultset(stmt);\n  list<resultmap> resultmaps = mappedstatement.getresultmaps();\n  // 判断结果集的数量\n  int resultmapcount = resultmaps.size();\n  validateresultmapscount(rsw, resultmapcount);\n  // 遍历处理结果集\n  while (rsw != null && resultmapcount > resultsetcount) {\n    resultmap resultmap = resultmaps.get(resultsetcount);\n    handleresultset(rsw, resultmap, multipleresults, null);\n    rsw = getnextresultset(stmt);\n    cleanupafterhandlingresultset();\n    resultsetcount++;\n  }\n\n  string[] resultsets = mappedstatement.getresultsets();\n  if (resultsets != null) {\n    while (rsw != null && resultsetcount < resultsets.length) {\n      resultmapping parentmapping = nextresultmaps.get(resultsets[resultsetcount]);\n      if (parentmapping != null) {\n        string nestedresultmapid = parentmapping.getnestedresultmapid();\n        resultmap resultmap = configuration.getresultmap(nestedresultmapid);\n        handleresultset(rsw, resultmap, null, parentmapping);\n      }\n      rsw = getnextresultset(stmt);\n      cleanupafterhandlingresultset();\n      resultsetcount++;\n    }\n  }\n\n  return collapsesingleresultlist(multipleresults);\n}\n\n\n\n# 参考资料\n\n * 官方\n   * mybatis github\n   * mybatis 官网\n * 文章\n   * 深入理解 mybatis 原理\n   * mybatis 源码中文注释\n   * mybatis 中强大的 resultmap',charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Java ORM 框架",frontmatter:{title:"Java ORM 框架",date:"2022-02-17T22:34:30.000Z",categories:["Java","框架","ORM"],tags:["Java","框架","ORM"],permalink:"/pages/fe879a/",hidden:!0,index:!1},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/11.ORM/",relativePath:"01.Java/13.框架/11.ORM/README.md",key:"v-f8df10f8",path:"/pages/fe879a/",headers:[{level:2,title:"📖 内容",slug:"📖-内容",normalizedTitle:"📖 内容",charIndex:18},{level:3,title:"Mybatis 快速入门",slug:"mybatis-快速入门",normalizedTitle:"mybatis 快速入门",charIndex:155},{level:3,title:"Mybatis 原理",slug:"mybatis-原理",normalizedTitle:"mybatis 原理",charIndex:172},{level:2,title:"📚 资料",slug:"📚-资料",normalizedTitle:"📚 资料",charIndex:187},{level:2,title:"🚪 传送",slug:"🚪-传送",normalizedTitle:"🚪 传送",charIndex:608}],headersStr:"📖 内容 Mybatis 快速入门 Mybatis 原理 📚 资料 🚪 传送",content:"# Java ORM 框架\n\n\n# 📖 内容\n\n> Mybatis 的前身就是 iBatis ，是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。本文以一个 Mybatis 完整示例为切入点，结合 Mybatis 底层源码分析，图文并茂的讲解 Mybatis 的核心工作机制。\n\n\n\n\n# Mybatis 快速入门\n\n\n# Mybatis 原理\n\n\n# 📚 资料\n\n * 官方\n   * Mybatis Github\n   * Mybatis 官网\n   * MyBatis 官方代码生成（mybatis-generator）\n   * MyBatis 官方集成 Spring（mybatis-spring）\n   * Mybatis 官方集成 Spring Boot（mybatis-spring-boot）\n * 扩展插件\n   * MyBatis-Plus - CRUD 扩展插件、代码生成器、分页器等多功能\n   * Mapper - CRUD 扩展插件\n   * Mybatis-PageHelper - Mybatis 通用分页插件\n * 文章\n   * 深入理解 mybatis 原理\n   * mybatis 源码中文注释\n   * MyBatis Generator 详解\n   * Mybatis 常见面试题\n   * Mybatis 中强大的 resultMap\n\n\n# 🚪 传送\n\n◾ 💧 钝悟的 IT 知识图谱 ◾",normalizedContent:"# java orm 框架\n\n\n# 📖 内容\n\n> mybatis 的前身就是 ibatis ，是一款优秀的持久层框架，它支持自定义 sql、存储过程以及高级映射。本文以一个 mybatis 完整示例为切入点，结合 mybatis 底层源码分析，图文并茂的讲解 mybatis 的核心工作机制。\n\n\n\n\n# mybatis 快速入门\n\n\n# mybatis 原理\n\n\n# 📚 资料\n\n * 官方\n   * mybatis github\n   * mybatis 官网\n   * mybatis 官方代码生成（mybatis-generator）\n   * mybatis 官方集成 spring（mybatis-spring）\n   * mybatis 官方集成 spring boot（mybatis-spring-boot）\n * 扩展插件\n   * mybatis-plus - crud 扩展插件、代码生成器、分页器等多功能\n   * mapper - crud 扩展插件\n   * mybatis-pagehelper - mybatis 通用分页插件\n * 文章\n   * 深入理解 mybatis 原理\n   * mybatis 源码中文注释\n   * mybatis generator 详解\n   * mybatis 常见面试题\n   * mybatis 中强大的 resultmap\n\n\n# 🚪 传送\n\n◾ 💧 钝悟的 it 知识图谱 ◾",charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Shiro 快速入门",frontmatter:{title:"Shiro 快速入门",date:"2022-02-17T22:34:30.000Z",order:1,categories:["Java","框架","安全"],tags:["Java","框架","安全","Shiro"],permalink:"/pages/3295c4/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/12.%E5%AE%89%E5%85%A8/01.Shiro.html",relativePath:"01.Java/13.框架/12.安全/01.Shiro.md",key:"v-a97447de",path:"/pages/3295c4/",headers:[{level:2,title:"一、Shiro 简介",slug:"一、shiro-简介",normalizedTitle:"一、shiro 简介",charIndex:53},{level:3,title:"Shiro 特性",slug:"shiro-特性",normalizedTitle:"shiro 特性",charIndex:68},{level:3,title:"Shiro 架构概述",slug:"shiro-架构概述",normalizedTitle:"shiro 架构概述",charIndex:722},{level:3,title:"SecurityManager",slug:"securitymanager",normalizedTitle:"securitymanager",charIndex:1074},{level:2,title:"二、Shiro 认证",slug:"二、shiro-认证",normalizedTitle:"二、shiro 认证",charIndex:1836},{level:3,title:"认证 Subject",slug:"认证-subject",normalizedTitle:"认证 subject",charIndex:1851},{level:3,title:"Remembered 和 Authenticated",slug:"remembered-和-authenticated",normalizedTitle:"remembered 和 authenticated",charIndex:2612},{level:3,title:"登出",slug:"登出",normalizedTitle:"登出",charIndex:2920},{level:3,title:"认证流程",slug:"认证流程",normalizedTitle:"认证流程",charIndex:3009},{level:3,title:"认证策略",slug:"认证策略",normalizedTitle:"认证策略",charIndex:1568},{level:2,title:"三、Shiro 授权",slug:"三、shiro-授权",normalizedTitle:"三、shiro 授权",charIndex:4637},{level:3,title:"授权元素",slug:"授权元素",normalizedTitle:"授权元素",charIndex:4700},{level:4,title:"权限",slug:"权限",normalizedTitle:"权限",charIndex:164},{level:4,title:"角色",slug:"角色",normalizedTitle:"角色",charIndex:196},{level:4,title:"用户",slug:"用户",normalizedTitle:"用户",charIndex:112},{level:3,title:"基于角色的授权",slug:"基于角色的授权",normalizedTitle:"基于角色的授权",charIndex:5062},{level:3,title:"基于权限的授权",slug:"基于权限的授权",normalizedTitle:"基于权限的授权",charIndex:5499},{level:3,title:"基于注解的授权",slug:"基于注解的授权",normalizedTitle:"基于注解的授权",charIndex:6273},{level:4,title:"@RequiresAuthentication",slug:"requiresauthentication",normalizedTitle:"@requiresauthentication",charIndex:6316},{level:4,title:"@RequiresGuest",slug:"requiresguest",normalizedTitle:"@requiresguest",charIndex:6586},{level:3,title:"授权流程",slug:"授权流程",normalizedTitle:"授权流程",charIndex:6660},{level:2,title:"四、Shiro 会话管理",slug:"四、shiro-会话管理",normalizedTitle:"四、shiro 会话管理",charIndex:7342},{level:3,title:"会话超时",slug:"会话超时",normalizedTitle:"会话超时",charIndex:7644},{level:3,title:"会话监听",slug:"会话监听",normalizedTitle:"会话监听",charIndex:7749},{level:3,title:"会话存储",slug:"会话存储",normalizedTitle:"会话存储",charIndex:8382},{level:2,title:"五、Realm",slug:"五、realm",normalizedTitle:"五、realm",charIndex:8568},{level:3,title:"认证令牌",slug:"认证令牌",normalizedTitle:"认证令牌",charIndex:8688},{level:3,title:"加密",slug:"加密",normalizedTitle:"加密",charIndex:38},{level:2,title:"六、配置",slug:"六、配置",normalizedTitle:"六、配置",charIndex:10293},{level:3,title:"过滤链",slug:"过滤链",normalizedTitle:"过滤链",charIndex:10302},{level:3,title:"RememberMe",slug:"rememberme",normalizedTitle:"rememberme",charIndex:2115},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:11360}],headersStr:"一、Shiro 简介 Shiro 特性 Shiro 架构概述 SecurityManager 二、Shiro 认证 认证 Subject Remembered 和 Authenticated 登出 认证流程 认证策略 三、Shiro 授权 授权元素 权限 角色 用户 基于角色的授权 基于权限的授权 基于注解的授权 @RequiresAuthentication @RequiresGuest 授权流程 四、Shiro 会话管理 会话超时 会话监听 会话存储 五、Realm 认证令牌 加密 六、配置 过滤链 RememberMe 参考资料",content:'# Shiro 快速入门\n\n> Shiro 是一个安全框架，具有认证、授权、加密、会话管理功能。\n\n\n# 一、Shiro 简介\n\n\n# Shiro 特性\n\n\n\n核心功能：\n\n * Authentication - 认证。验证用户是不是拥有相应的身份。\n * Authorization - 授权。验证某个已认证的用户是否拥有某个权限；即判断用户是否能做事情，常见的如：验证某个用户是否拥有某个角色。或者细粒度的验证某个用户对某个资源是否具有某个权限。\n * Session Manager - 会话管理。即用户登录后就是一次会话，在没有退出之前，它的所有信息都在会话中。会话可以是普通 JavaSE 环境的，也可以是如 Web 环境的。\n * Cryptography - 加密。保护数据的安全性，如密码加密存储到数据库，而不是明文存储。\n\n辅助功能：\n\n * Web Support - Web 支持。可以非常容易的集成到 Web 环境；\n * Caching - 缓存。比如用户登录后，其用户信息、拥有的角色 / 权限不必每次去查，这样可以提高效率；\n * Concurrency - 并发。Shiro 支持多线程应用的并发验证，即如在一个线程中开启另一个线程，能把权限自动传播过去；\n * Testing - 测试。提供测试支持；\n * Run As - 运行方式。允许一个用户假装为另一个用户（如果他们允许）的身份进行访问；\n * Remember Me - 记住我。即一次登录后，下次再访问免登录。\n\n> 🔔 注意：Shiro 不会去维护用户、维护权限；这些需要我们自己去提供；然后通过相应的接口注入给 Shiro 即可。\n\n\n# Shiro 架构概述\n\n\n\n * Subject - 主题。它代表当前用户，Subject 可以是一个人，但也可以是第三方服务、守护进程帐户、时钟守护任务或者其它——当前和软件交互的任何事件。Subject 是 Shiro 的入口。\n   \n   * Principals 是 Subject 的“识别属性”。Principals 可以是任何可以识别 Subject 的东西，例如名字（姓氏），姓氏（姓氏或姓氏），用户名，社会保险号等。当然，Principals 在应用程序中最好是惟一的。\n   * Credentials 通常是仅由 Subject 知道的秘密值，用作他们实际上“拥有”所主张身份的佐证 凭据的一些常见示例是密码，生物特征数据（例如指纹和视网膜扫描）以及 X.509 证书。\n\n * SecurityManager - 安全管理。它是 Shiro 的核心，所有与安全有关的操作（认证、授权、及会话、缓存的管理）都与 SecurityManager 交互，且它管理着所有 Subject。\n\n * Realm - 域。用于访问安全相关数据，可以视为应用自身的数据源，需要开发者自己实现。Shiro 会通过 Realm 获取安全数据（如用户、角色、权限），就是说 SecurityManager 要验证用户身份，那么它需要从 Realm 获取相应的用户进行比较以确定用户身份是否合法；也需要从 Realm 得到用户相应的角色/权限进行验证用户是否能进行操作；可以把 Realm 看成 DataSource，即安全数据源。\n\n\n# SecurityManager\n\nSecurityManager 是 Shiro 框架核心中的核心，它相当于 Shiro 的总指挥，负责调度所有行为，包括：认证、授权、获取安全数据（调用 Realm）、会话管理等。\n\n\n\nSecurityManager 聚合了以下组件：\n\n * Authenticator - 认证器，负责认证。如果用户需要定制认证策略，可以实现此接口。\n * Authorizer - 授权器，负责权限控制。用来决定主体是否有权限进行相应的操作；即控制着用户能访问应用中的哪些功能；\n * SessionManager - 会话管理器。Shiro 抽象了一个自己的 Session 来管理主体与应用之间交互的数据。\n * SessionDAO - 会话 DAO 用于存储会话，需要用户自己实现。\n * CacheManager - 缓存控制器。用于管理如用户、角色、权限等信息的缓存。\n * Cryptography - 密码器。用于对数据加密、解密。\n\n\n# 二、Shiro 认证\n\n\n# 认证 Subject\n\n验证 Subject 的过程可以有效地分为三个不同的步骤：\n\n（1）收集 Subject 提交的 Principals 和 Credentials\n\n//Example using most common scenario of username/password pair:\nUsernamePasswordToken token = new UsernamePasswordToken(username, password);\n\n//"Remember Me" built-in:\ntoken.setRememberMe(true);\n\n\n（2）提交 Principals 和 Credentials 以进行身份验证。\n\nSubject currentUser = SecurityUtils.getSubject();\n\ncurrentUser.login(token);\n\n\n（3）如果提交成功，则允许访问，否则重试身份验证或阻止访问。\n\ntry {\n    currentUser.login(token);\n} catch ( UnknownAccountException uae ) { ...\n} catch ( IncorrectCredentialsException ice ) { ...\n} catch ( LockedAccountException lae ) { ...\n} catch ( ExcessiveAttemptsException eae ) { ...\n} ... catch your own ...\n} catch ( AuthenticationException ae ) {\n    //unexpected error?\n}\n\n\n\n# Remembered 和 Authenticated\n\n * Remembered - 记住我。被记住的 Subject 不是匿名的，并且具有已知的身份（即 subject.getPrincipals() 是非空的）。 但是，在先前的会话期间，通过先前的身份验证会记住此身份。 如果 subject.isRemembered() 返回 true，则认为该主题已被记住。\n * Authenticated - 已认证。已认证的 Subject 是在当前会话期间已成功认证的 Subject。 如果 subject.isAuthenticated() 返回 true，则认为该 Subject 已通过身份验证。\n\n\n# 登出\n\n当 Subject 与应用程序完成交互后，可以调用 subject.logout() 登出，即放弃所有标识信息。\n\ncurrentUser.logout();\n\n\n\n# 认证流程\n\n\n\n 1. 应用程序代码调用 Subject.login 方法，传入构造的 AuthenticationToken 实例，该实例代表最终用户的 Principals 和 Credentials。\n\n 2. Subject 实例（通常是 DelegatingSubject（或子类））通过调用 securityManager.login（token）委托应用程序的 SecurityManager，在此处开始实际的身份验证工作。\n\n 3. SecurityManager 接收令牌，并通过调用 authenticator.authenticate（token）来简单地委派给其内部 Authenticator 实例。这几乎总是一个 ModularRealmAuthenticator 实例，它支持在身份验证期间协调一个或多个 Realm 实例。\n\n 4. 如果为该应用程序配置了多个 Realm，则 ModularRealmAuthenticator 实例将利用其配置的 AuthenticationStrategy 发起多域验证尝试。在调用领域进行身份验证之前，期间和之后，将调用 AuthenticationStrategy 以使其对每个领域的结果做出反应。\n\n 5. 请咨询每个已配置的 Realm，以查看其是否支持提交的 AuthenticationToken。 如果是这样，将使用提交的令牌调用支持 Realm 的 getAuthenticationInfo 方法。 getAuthenticationInfo 方法有效地表示对该特定 Realm 的单个身份验证尝试。\n\n\n# 认证策略\n\n当为一个应用程序配置两个或多个领域时，ModularRealmAuthenticator 依赖于内部 AuthenticationStrategy 组件来确定认证尝试成功或失败的条件。\n\n例如，如果只有一个 Realm 成功地对 AuthenticationToken 进行身份验证，而所有其他 Realm 都失败了，那么该身份验证尝试是否被视为成功？还是必须所有领域都成功进行身份验证才能将整体尝试视为成功？或者，如果某个领域成功通过身份验证，是否有必要进一步咨询其他领域？ AuthenticationStrategy 根据应用程序的需求做出适当的决定。\n\nAuthenticationStrategy 是无状态组件，在尝试进行身份验证时会被查询 4 次（这 4 种交互所需的任何必要状态都将作为方法参数给出）：\n\n * 在任何领域被调用之前\n * 在调用单个 Realm 的 getAuthenticationInfo 方法之前\n * 在调用单个 Realm 的 getAuthenticationInfo 方法之后\n * 在所有领域都被调用之后\n\nAuthenticationStrategy 还负责汇总每个成功 Realm 的结果，并将它们“捆绑”成单个 AuthenticationInfo 表示形式。最终的聚合 AuthenticationInfo 实例是 Authenticator 实例返回的结果，也是 Shiro 用来表示主体的最终身份（也称为委托人）的东西。\n\nAUTHENTICATIONSTRATEGY         描述\nAtLeastOneSuccessfulStrategy   只要有一个 Realm 成功认证，则整个尝试都被视为成功。\nFirstSuccessfulStrategy        仅使用从第一个成功通过身份验证的 Realm 返回的信息，所有其他 Realm 将被忽略。\nAllSuccessfulStrategy          只有所有 Realm 成功认证，则整个尝试才被视为成功。\n\n> 🔗 更多认证细节可以参考：Apache Shiro Authentication\n\n\n# 三、Shiro 授权\n\n授权，也称为访问控制，是管理对资源的访问的过程。 换句话说，控制谁有权访问应用程序中的内容。\n\n\n# 授权元素\n\n授权有三个核心要素：权限、角色和用户。\n\n# 权限\n\n权限示例：\n\n * 打开一个文件\n * 查看 /user/list web 页面\n * 查询记录\n * 删除一条记录\n * ...\n\n大多数资源都支持一般的 CRUD 操作。除此以外，对于一些特定的资源，任何有意义的行为都是可以的。基本的设计思路是：权限控制，至少是基于资源和行为。\n\n# 角色\n\n角色是一个命名实体，通常代表一组行为或职责。这些行为会转化为：谁可以在应用程序中执行哪些行为？谁不可以在程序中执行哪些行为？\n\n角色通常是分配给用户帐户的，因此通过关联，用户可以获得自身角色所赋予的权限。\n\n# 用户\n\n用户本质上是应用程序的“用户”。\n\n用户（即 Shiro 的 Subject）通过与角色或直接权限的关联在应用程序中执行某些行为。\n\n\n# 基于角色的授权\n\n如果授权是基于角色赋予权限的数据模型，编程模式如下：\n\n【示例一】\n\nSubject currentUser = SecurityUtils.getSubject();\n\nif (currentUser.hasRole("administrator")) {\n    //show the admin button\n} else {\n    //don\'t show the button?  Grey it out?\n}\n\n\n【示例二】\n\nSubject currentUser = SecurityUtils.getSubject();\n\n// 检查当前 Subject 是否有某种权限\n// 如果有，直接跳过；如果没有，Shiro 会抛出 AuthorizationException\ncurrentUser.checkRole("bankTeller");\nopenBankAccount();\n\n\n> 提示：方式二相比方式一，代码更简洁\n\n\n# 基于权限的授权\n\n更好的授权策略通常是基于权限的授权。基于权限的授权，由于它和应用程序的原始功能（针对具体资源上的行为）紧密相关，所以基于权限的授权源代码会在功能更改时同步更改（而不是在安全策略发生更改时）。 这意味着与类似的基于角色的授权代码相比，修改代码的影响面要小得多。\n\n【示例】基于对象的权限检查\n\nPermission printPermission = new PrinterPermission("laserjet4400n", "print");\n\nSubject currentUser = SecurityUtils.getSubject();\n\nif (currentUser.isPermitted(printPermission)) {\n    //show the Print button\n} else {\n    //don\'t show the button?  Grey it out?\n}\n\n\n在对象中存储权限控制信息，但这种方式较为繁重\n\n【示例】字符串定义权限控制信息\n\nSubject currentUser = SecurityUtils.getSubject();\n\nif (currentUser.isPermitted("printer:print:laserjet4400n")) {\n    //show the Print button\n} else {\n    //don\'t show the button?  Grey it out?\n}\n\n\n使用 : 分隔，表示资源类型、行为、资源 ID，Shiro 提供了默认实现： org.apache.shiro.authz.permission.WildcardPermission。\n\n这种权限控制方式的好处在于：轻量、灵活。\n\n\n# 基于注解的授权\n\nShiro 提供了一些用于授权的注解，来进一步简化授权代码。\n\n# @RequiresAuthentication\n\n@RequiresAuthentication 注解要求当前 Subject 必须是已认证用户才可以访问被修饰的方法。\n\n【示例】\n\n@RequiresAuthentication\npublic void updateAccount(Account userAccount) {\n    //this method will only be invoked by a\n    //Subject that is guaranteed authenticated\n    ...\n}\n\n\n# @RequiresGuest\n\n@RequiresGuest 注解要求当前 Subject 的角色是 guest 才可以访问被修饰的方法。\n\n\n# 授权流程\n\n\n\n 1. 应用程序或框架代码调用任何 Subject 的 hasRole*，checkRole*，isPermitted* 或 checkPermission* 方法，并传入所需的权限或角色。\n\n 2. Subject 实例，通常是 DelegatingSubject（或子类），通过调用 securityManager 几乎相同的各自 hasRole*，checkRole*，isPermitted* 或 checkPermission* 方法来委托 SecurityManager （实现了 org.apache.shiro.authz.Authorizer 接口）处理授权。\n\n 3. SecurityManager 通过调用授权者各自的 hasRole*，checkRole*，isPermitted* 或 checkPermission* 方法来中继/委托其内部的 org.apache.shiro.authz.Authorizer 实例。默认情况下，authorizer 实例是 ModularRealmAuthorizer 实例，该实例支持在任何授权操作期间协调一个或多个 Realm 实例。\n\n 4. 检查每个已配置的 Realm，以查看其是否实现相同的 Authorizer 接口。如果是这样，则将调用 Realm 各自的 hasRole*，checkRole*，isPermitted* 或 checkPermission* 方法。\n\n> 🔗 更多授权细节可以参考：Apache Shiro Authorization\n\n\n# 四、Shiro 会话管理\n\nShiro 提供了一套独特的会话管理方案：其 Session 可以使用 Java SE 程序，也可以使用于 Java Web 程序。\n\n在 Shiro 中，SessionManager 负责管理应用所有 Subject 的会话，如：创建、删除、失效、验证等。\n\n【示例】会话使用示例\n\nSubject currentUser = SecurityUtils.getSubject();\n\nSession session = currentUser.getSession();\nsession.setAttribute( "someKey", someValue);\n\n\n\n# 会话超时\n\n默认情况下，Shiro 中的会话有效期为 30 分钟，超时后，该会话将被 Shiro 视为无效。\n\n可以通过 globalSessionTimeout 方法设置 Shiro 会话超时时间。\n\n\n# 会话监听\n\nShiro 提供了 SessionListener 接口（或 SessionListenerAdapter 接口），用于监听重要的会话事件，并允许使用者在事件触发时做定制化处理。\n\n【示例】\n\npublic class ShiroSessionListener implements SessionListener {\n\n    private final Logger log = LoggerFactory.getLogger(this.getClass());\n\n    private final AtomicInteger sessionCount = new AtomicInteger(0);\n\n    @Override\n    public void onStart(Session session) {\n        sessionCount.incrementAndGet();\n    }\n\n    @Override\n    public void onStop(Session session) {\n        sessionCount.decrementAndGet();\n    }\n\n    @Override\n    public void onExpiration(Session session) {\n        sessionCount.decrementAndGet();\n    }\n}\n\n\n\n# 会话存储\n\n大多数情况下，应用需要保存会话信息，以便在稍后可以使用它。\n\nShiro 提供了 SessionManager 接口，负责将针对会话的 CRUD 操作委派给内部组件 SessionDAO，该组件反映了数据访问对象（DAO）设计模式。\n\n> 🔔 注意：由于会话通常具有时效性，所以一般会话天然适合存储于缓存中。存储于 Redis 中是一个不错的选择。\n\n\n# 五、Realm\n\nRealm 是 Shiro 访问程序安全相关数据（如：用户、角色、权限）的接口。\n\nRealm 是有开发者自己实现的，开发者可以通过实现 Realm 接口，接入应用的数据源，如：JDBC、文件、Nosql 等等。\n\n\n# 认证令牌\n\nShiro 支持身份验证令牌。在咨询 Realm 进行认证尝试之前，将调用其支持方法。 如果返回值为 true，则仅会调用其 getAuthenticationInfo(token) 方法。通常，Realm 会检查所提交令牌的类型（接口或类），以查看其是否可以处理它。\n\n令牌认证处理流程如下：\n\n 1. 检查用于标识 principal 的令牌（帐户标识信息）。\n 2. 根据 principal，在数据源中查找相应的帐户数据。\n 3. 确保令牌提供的凭证与数据存储中存储的凭证匹配。\n 4. 如果 credentials 匹配，则返回 AuthenticationInfo 实例。\n 5. 如果 credentials 不匹配，则抛出 AuthenticationException 异常。\n\n\n# 加密\n\n通过前文，可以了解：Shiro 需要通过一对 principal 和 credentials 来确认身份是否匹配（即认证）。\n\n一般来说，成熟软件是不允许存储账户、密码这些敏感数据时，使用明文存储。所以，通常要将密码加密后存储。\n\nShiro 提供了一些加密器，其思想就是用 MD5、SHA 这种数字签名算法，加 Salt，然后转为 Base64 字符串。为了避免被暴力破解，Shiro 使用多次加密的方式获得最终的 credentials 字符串。\n\n【示例】Shiro 加密密码示例\n\nimport org.apache.shiro.crypto.hash.Sha256Hash;\nimport org.apache.shiro.crypto.RandomNumberGenerator;\nimport org.apache.shiro.crypto.SecureRandomNumberGenerator;\n...\n\n//We\'ll use a Random Number Generator to generate salts.  This\n//is much more secure than using a username as a salt or not\n//having a salt at all.  Shiro makes this easy.\n//\n//Note that a normal app would reference an attribute rather\n//than create a new RNG every time:\nRandomNumberGenerator rng = new SecureRandomNumberGenerator();\nObject salt = rng.nextBytes();\n\n//Now hash the plain-text password with the random salt and multiple\n//iterations and then Base64-encode the value (requires less space than Hex):\nString hashedPasswordBase64 = new Sha256Hash(plainTextPassword, salt, 1024).toBase64();\n\nUser user = new User(username, hashedPasswordBase64);\n//save the salt with the new account.  The HashedCredentialsMatcher\n//will need it later when handling login attempts:\nuser.setPasswordSalt(salt);\nuserDAO.create(user);\n\n\n\n# 六、配置\n\n\n# 过滤链\n\n运行 Web 应用程序时，Shiro 将创建一些有用的默认 Filter 实例。\n\nFILTER NAME         CLASS\nanon                org.apache.shiro.web.filter.authc.AnonymousFilter\nauthc               org.apache.shiro.web.filter.authc.FormAuthenticationFilter\nauthcBasic          org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter\nlogout              org.apache.shiro.web.filter.authc.LogoutFilter\nnoSessionCreation   org.apache.shiro.web.filter.session.NoSessionCreationFilter\nperms               org.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter\nport                org.apache.shiro.web.filter.authz.PortFilter\nrest                org.apache.shiro.web.filter.authz.HttpMethodPermissionFilter\nroles               org.apache.shiro.web.filter.authz.RolesAuthorizationFilter\nssl                 org.apache.shiro.web.filter.authz.SslFilter\nuser                org.apache.shiro.web.filter.authc.UserFilter\n\n\n# RememberMe\n\nUsernamePasswordToken token = new UsernamePasswordToken(username, password);\ntoken.setRememberMe(true);\nSecurityUtils.getSubject().login(token);\n\n\n\n# 参考资料\n\n * Shiro 官方文档\n * 跟我学 Shiro\n * The New RBAC: Resource-Based Access Control',normalizedContent:'# shiro 快速入门\n\n> shiro 是一个安全框架，具有认证、授权、加密、会话管理功能。\n\n\n# 一、shiro 简介\n\n\n# shiro 特性\n\n\n\n核心功能：\n\n * authentication - 认证。验证用户是不是拥有相应的身份。\n * authorization - 授权。验证某个已认证的用户是否拥有某个权限；即判断用户是否能做事情，常见的如：验证某个用户是否拥有某个角色。或者细粒度的验证某个用户对某个资源是否具有某个权限。\n * session manager - 会话管理。即用户登录后就是一次会话，在没有退出之前，它的所有信息都在会话中。会话可以是普通 javase 环境的，也可以是如 web 环境的。\n * cryptography - 加密。保护数据的安全性，如密码加密存储到数据库，而不是明文存储。\n\n辅助功能：\n\n * web support - web 支持。可以非常容易的集成到 web 环境；\n * caching - 缓存。比如用户登录后，其用户信息、拥有的角色 / 权限不必每次去查，这样可以提高效率；\n * concurrency - 并发。shiro 支持多线程应用的并发验证，即如在一个线程中开启另一个线程，能把权限自动传播过去；\n * testing - 测试。提供测试支持；\n * run as - 运行方式。允许一个用户假装为另一个用户（如果他们允许）的身份进行访问；\n * remember me - 记住我。即一次登录后，下次再访问免登录。\n\n> 🔔 注意：shiro 不会去维护用户、维护权限；这些需要我们自己去提供；然后通过相应的接口注入给 shiro 即可。\n\n\n# shiro 架构概述\n\n\n\n * subject - 主题。它代表当前用户，subject 可以是一个人，但也可以是第三方服务、守护进程帐户、时钟守护任务或者其它——当前和软件交互的任何事件。subject 是 shiro 的入口。\n   \n   * principals 是 subject 的“识别属性”。principals 可以是任何可以识别 subject 的东西，例如名字（姓氏），姓氏（姓氏或姓氏），用户名，社会保险号等。当然，principals 在应用程序中最好是惟一的。\n   * credentials 通常是仅由 subject 知道的秘密值，用作他们实际上“拥有”所主张身份的佐证 凭据的一些常见示例是密码，生物特征数据（例如指纹和视网膜扫描）以及 x.509 证书。\n\n * securitymanager - 安全管理。它是 shiro 的核心，所有与安全有关的操作（认证、授权、及会话、缓存的管理）都与 securitymanager 交互，且它管理着所有 subject。\n\n * realm - 域。用于访问安全相关数据，可以视为应用自身的数据源，需要开发者自己实现。shiro 会通过 realm 获取安全数据（如用户、角色、权限），就是说 securitymanager 要验证用户身份，那么它需要从 realm 获取相应的用户进行比较以确定用户身份是否合法；也需要从 realm 得到用户相应的角色/权限进行验证用户是否能进行操作；可以把 realm 看成 datasource，即安全数据源。\n\n\n# securitymanager\n\nsecuritymanager 是 shiro 框架核心中的核心，它相当于 shiro 的总指挥，负责调度所有行为，包括：认证、授权、获取安全数据（调用 realm）、会话管理等。\n\n\n\nsecuritymanager 聚合了以下组件：\n\n * authenticator - 认证器，负责认证。如果用户需要定制认证策略，可以实现此接口。\n * authorizer - 授权器，负责权限控制。用来决定主体是否有权限进行相应的操作；即控制着用户能访问应用中的哪些功能；\n * sessionmanager - 会话管理器。shiro 抽象了一个自己的 session 来管理主体与应用之间交互的数据。\n * sessiondao - 会话 dao 用于存储会话，需要用户自己实现。\n * cachemanager - 缓存控制器。用于管理如用户、角色、权限等信息的缓存。\n * cryptography - 密码器。用于对数据加密、解密。\n\n\n# 二、shiro 认证\n\n\n# 认证 subject\n\n验证 subject 的过程可以有效地分为三个不同的步骤：\n\n（1）收集 subject 提交的 principals 和 credentials\n\n//example using most common scenario of username/password pair:\nusernamepasswordtoken token = new usernamepasswordtoken(username, password);\n\n//"remember me" built-in:\ntoken.setrememberme(true);\n\n\n（2）提交 principals 和 credentials 以进行身份验证。\n\nsubject currentuser = securityutils.getsubject();\n\ncurrentuser.login(token);\n\n\n（3）如果提交成功，则允许访问，否则重试身份验证或阻止访问。\n\ntry {\n    currentuser.login(token);\n} catch ( unknownaccountexception uae ) { ...\n} catch ( incorrectcredentialsexception ice ) { ...\n} catch ( lockedaccountexception lae ) { ...\n} catch ( excessiveattemptsexception eae ) { ...\n} ... catch your own ...\n} catch ( authenticationexception ae ) {\n    //unexpected error?\n}\n\n\n\n# remembered 和 authenticated\n\n * remembered - 记住我。被记住的 subject 不是匿名的，并且具有已知的身份（即 subject.getprincipals() 是非空的）。 但是，在先前的会话期间，通过先前的身份验证会记住此身份。 如果 subject.isremembered() 返回 true，则认为该主题已被记住。\n * authenticated - 已认证。已认证的 subject 是在当前会话期间已成功认证的 subject。 如果 subject.isauthenticated() 返回 true，则认为该 subject 已通过身份验证。\n\n\n# 登出\n\n当 subject 与应用程序完成交互后，可以调用 subject.logout() 登出，即放弃所有标识信息。\n\ncurrentuser.logout();\n\n\n\n# 认证流程\n\n\n\n 1. 应用程序代码调用 subject.login 方法，传入构造的 authenticationtoken 实例，该实例代表最终用户的 principals 和 credentials。\n\n 2. subject 实例（通常是 delegatingsubject（或子类））通过调用 securitymanager.login（token）委托应用程序的 securitymanager，在此处开始实际的身份验证工作。\n\n 3. securitymanager 接收令牌，并通过调用 authenticator.authenticate（token）来简单地委派给其内部 authenticator 实例。这几乎总是一个 modularrealmauthenticator 实例，它支持在身份验证期间协调一个或多个 realm 实例。\n\n 4. 如果为该应用程序配置了多个 realm，则 modularrealmauthenticator 实例将利用其配置的 authenticationstrategy 发起多域验证尝试。在调用领域进行身份验证之前，期间和之后，将调用 authenticationstrategy 以使其对每个领域的结果做出反应。\n\n 5. 请咨询每个已配置的 realm，以查看其是否支持提交的 authenticationtoken。 如果是这样，将使用提交的令牌调用支持 realm 的 getauthenticationinfo 方法。 getauthenticationinfo 方法有效地表示对该特定 realm 的单个身份验证尝试。\n\n\n# 认证策略\n\n当为一个应用程序配置两个或多个领域时，modularrealmauthenticator 依赖于内部 authenticationstrategy 组件来确定认证尝试成功或失败的条件。\n\n例如，如果只有一个 realm 成功地对 authenticationtoken 进行身份验证，而所有其他 realm 都失败了，那么该身份验证尝试是否被视为成功？还是必须所有领域都成功进行身份验证才能将整体尝试视为成功？或者，如果某个领域成功通过身份验证，是否有必要进一步咨询其他领域？ authenticationstrategy 根据应用程序的需求做出适当的决定。\n\nauthenticationstrategy 是无状态组件，在尝试进行身份验证时会被查询 4 次（这 4 种交互所需的任何必要状态都将作为方法参数给出）：\n\n * 在任何领域被调用之前\n * 在调用单个 realm 的 getauthenticationinfo 方法之前\n * 在调用单个 realm 的 getauthenticationinfo 方法之后\n * 在所有领域都被调用之后\n\nauthenticationstrategy 还负责汇总每个成功 realm 的结果，并将它们“捆绑”成单个 authenticationinfo 表示形式。最终的聚合 authenticationinfo 实例是 authenticator 实例返回的结果，也是 shiro 用来表示主体的最终身份（也称为委托人）的东西。\n\nauthenticationstrategy         描述\natleastonesuccessfulstrategy   只要有一个 realm 成功认证，则整个尝试都被视为成功。\nfirstsuccessfulstrategy        仅使用从第一个成功通过身份验证的 realm 返回的信息，所有其他 realm 将被忽略。\nallsuccessfulstrategy          只有所有 realm 成功认证，则整个尝试才被视为成功。\n\n> 🔗 更多认证细节可以参考：apache shiro authentication\n\n\n# 三、shiro 授权\n\n授权，也称为访问控制，是管理对资源的访问的过程。 换句话说，控制谁有权访问应用程序中的内容。\n\n\n# 授权元素\n\n授权有三个核心要素：权限、角色和用户。\n\n# 权限\n\n权限示例：\n\n * 打开一个文件\n * 查看 /user/list web 页面\n * 查询记录\n * 删除一条记录\n * ...\n\n大多数资源都支持一般的 crud 操作。除此以外，对于一些特定的资源，任何有意义的行为都是可以的。基本的设计思路是：权限控制，至少是基于资源和行为。\n\n# 角色\n\n角色是一个命名实体，通常代表一组行为或职责。这些行为会转化为：谁可以在应用程序中执行哪些行为？谁不可以在程序中执行哪些行为？\n\n角色通常是分配给用户帐户的，因此通过关联，用户可以获得自身角色所赋予的权限。\n\n# 用户\n\n用户本质上是应用程序的“用户”。\n\n用户（即 shiro 的 subject）通过与角色或直接权限的关联在应用程序中执行某些行为。\n\n\n# 基于角色的授权\n\n如果授权是基于角色赋予权限的数据模型，编程模式如下：\n\n【示例一】\n\nsubject currentuser = securityutils.getsubject();\n\nif (currentuser.hasrole("administrator")) {\n    //show the admin button\n} else {\n    //don\'t show the button?  grey it out?\n}\n\n\n【示例二】\n\nsubject currentuser = securityutils.getsubject();\n\n// 检查当前 subject 是否有某种权限\n// 如果有，直接跳过；如果没有，shiro 会抛出 authorizationexception\ncurrentuser.checkrole("bankteller");\nopenbankaccount();\n\n\n> 提示：方式二相比方式一，代码更简洁\n\n\n# 基于权限的授权\n\n更好的授权策略通常是基于权限的授权。基于权限的授权，由于它和应用程序的原始功能（针对具体资源上的行为）紧密相关，所以基于权限的授权源代码会在功能更改时同步更改（而不是在安全策略发生更改时）。 这意味着与类似的基于角色的授权代码相比，修改代码的影响面要小得多。\n\n【示例】基于对象的权限检查\n\npermission printpermission = new printerpermission("laserjet4400n", "print");\n\nsubject currentuser = securityutils.getsubject();\n\nif (currentuser.ispermitted(printpermission)) {\n    //show the print button\n} else {\n    //don\'t show the button?  grey it out?\n}\n\n\n在对象中存储权限控制信息，但这种方式较为繁重\n\n【示例】字符串定义权限控制信息\n\nsubject currentuser = securityutils.getsubject();\n\nif (currentuser.ispermitted("printer:print:laserjet4400n")) {\n    //show the print button\n} else {\n    //don\'t show the button?  grey it out?\n}\n\n\n使用 : 分隔，表示资源类型、行为、资源 id，shiro 提供了默认实现： org.apache.shiro.authz.permission.wildcardpermission。\n\n这种权限控制方式的好处在于：轻量、灵活。\n\n\n# 基于注解的授权\n\nshiro 提供了一些用于授权的注解，来进一步简化授权代码。\n\n# @requiresauthentication\n\n@requiresauthentication 注解要求当前 subject 必须是已认证用户才可以访问被修饰的方法。\n\n【示例】\n\n@requiresauthentication\npublic void updateaccount(account useraccount) {\n    //this method will only be invoked by a\n    //subject that is guaranteed authenticated\n    ...\n}\n\n\n# @requiresguest\n\n@requiresguest 注解要求当前 subject 的角色是 guest 才可以访问被修饰的方法。\n\n\n# 授权流程\n\n\n\n 1. 应用程序或框架代码调用任何 subject 的 hasrole*，checkrole*，ispermitted* 或 checkpermission* 方法，并传入所需的权限或角色。\n\n 2. subject 实例，通常是 delegatingsubject（或子类），通过调用 securitymanager 几乎相同的各自 hasrole*，checkrole*，ispermitted* 或 checkpermission* 方法来委托 securitymanager （实现了 org.apache.shiro.authz.authorizer 接口）处理授权。\n\n 3. securitymanager 通过调用授权者各自的 hasrole*，checkrole*，ispermitted* 或 checkpermission* 方法来中继/委托其内部的 org.apache.shiro.authz.authorizer 实例。默认情况下，authorizer 实例是 modularrealmauthorizer 实例，该实例支持在任何授权操作期间协调一个或多个 realm 实例。\n\n 4. 检查每个已配置的 realm，以查看其是否实现相同的 authorizer 接口。如果是这样，则将调用 realm 各自的 hasrole*，checkrole*，ispermitted* 或 checkpermission* 方法。\n\n> 🔗 更多授权细节可以参考：apache shiro authorization\n\n\n# 四、shiro 会话管理\n\nshiro 提供了一套独特的会话管理方案：其 session 可以使用 java se 程序，也可以使用于 java web 程序。\n\n在 shiro 中，sessionmanager 负责管理应用所有 subject 的会话，如：创建、删除、失效、验证等。\n\n【示例】会话使用示例\n\nsubject currentuser = securityutils.getsubject();\n\nsession session = currentuser.getsession();\nsession.setattribute( "somekey", somevalue);\n\n\n\n# 会话超时\n\n默认情况下，shiro 中的会话有效期为 30 分钟，超时后，该会话将被 shiro 视为无效。\n\n可以通过 globalsessiontimeout 方法设置 shiro 会话超时时间。\n\n\n# 会话监听\n\nshiro 提供了 sessionlistener 接口（或 sessionlisteneradapter 接口），用于监听重要的会话事件，并允许使用者在事件触发时做定制化处理。\n\n【示例】\n\npublic class shirosessionlistener implements sessionlistener {\n\n    private final logger log = loggerfactory.getlogger(this.getclass());\n\n    private final atomicinteger sessioncount = new atomicinteger(0);\n\n    @override\n    public void onstart(session session) {\n        sessioncount.incrementandget();\n    }\n\n    @override\n    public void onstop(session session) {\n        sessioncount.decrementandget();\n    }\n\n    @override\n    public void onexpiration(session session) {\n        sessioncount.decrementandget();\n    }\n}\n\n\n\n# 会话存储\n\n大多数情况下，应用需要保存会话信息，以便在稍后可以使用它。\n\nshiro 提供了 sessionmanager 接口，负责将针对会话的 crud 操作委派给内部组件 sessiondao，该组件反映了数据访问对象（dao）设计模式。\n\n> 🔔 注意：由于会话通常具有时效性，所以一般会话天然适合存储于缓存中。存储于 redis 中是一个不错的选择。\n\n\n# 五、realm\n\nrealm 是 shiro 访问程序安全相关数据（如：用户、角色、权限）的接口。\n\nrealm 是有开发者自己实现的，开发者可以通过实现 realm 接口，接入应用的数据源，如：jdbc、文件、nosql 等等。\n\n\n# 认证令牌\n\nshiro 支持身份验证令牌。在咨询 realm 进行认证尝试之前，将调用其支持方法。 如果返回值为 true，则仅会调用其 getauthenticationinfo(token) 方法。通常，realm 会检查所提交令牌的类型（接口或类），以查看其是否可以处理它。\n\n令牌认证处理流程如下：\n\n 1. 检查用于标识 principal 的令牌（帐户标识信息）。\n 2. 根据 principal，在数据源中查找相应的帐户数据。\n 3. 确保令牌提供的凭证与数据存储中存储的凭证匹配。\n 4. 如果 credentials 匹配，则返回 authenticationinfo 实例。\n 5. 如果 credentials 不匹配，则抛出 authenticationexception 异常。\n\n\n# 加密\n\n通过前文，可以了解：shiro 需要通过一对 principal 和 credentials 来确认身份是否匹配（即认证）。\n\n一般来说，成熟软件是不允许存储账户、密码这些敏感数据时，使用明文存储。所以，通常要将密码加密后存储。\n\nshiro 提供了一些加密器，其思想就是用 md5、sha 这种数字签名算法，加 salt，然后转为 base64 字符串。为了避免被暴力破解，shiro 使用多次加密的方式获得最终的 credentials 字符串。\n\n【示例】shiro 加密密码示例\n\nimport org.apache.shiro.crypto.hash.sha256hash;\nimport org.apache.shiro.crypto.randomnumbergenerator;\nimport org.apache.shiro.crypto.securerandomnumbergenerator;\n...\n\n//we\'ll use a random number generator to generate salts.  this\n//is much more secure than using a username as a salt or not\n//having a salt at all.  shiro makes this easy.\n//\n//note that a normal app would reference an attribute rather\n//than create a new rng every time:\nrandomnumbergenerator rng = new securerandomnumbergenerator();\nobject salt = rng.nextbytes();\n\n//now hash the plain-text password with the random salt and multiple\n//iterations and then base64-encode the value (requires less space than hex):\nstring hashedpasswordbase64 = new sha256hash(plaintextpassword, salt, 1024).tobase64();\n\nuser user = new user(username, hashedpasswordbase64);\n//save the salt with the new account.  the hashedcredentialsmatcher\n//will need it later when handling login attempts:\nuser.setpasswordsalt(salt);\nuserdao.create(user);\n\n\n\n# 六、配置\n\n\n# 过滤链\n\n运行 web 应用程序时，shiro 将创建一些有用的默认 filter 实例。\n\nfilter name         class\nanon                org.apache.shiro.web.filter.authc.anonymousfilter\nauthc               org.apache.shiro.web.filter.authc.formauthenticationfilter\nauthcbasic          org.apache.shiro.web.filter.authc.basichttpauthenticationfilter\nlogout              org.apache.shiro.web.filter.authc.logoutfilter\nnosessioncreation   org.apache.shiro.web.filter.session.nosessioncreationfilter\nperms               org.apache.shiro.web.filter.authz.permissionsauthorizationfilter\nport                org.apache.shiro.web.filter.authz.portfilter\nrest                org.apache.shiro.web.filter.authz.httpmethodpermissionfilter\nroles               org.apache.shiro.web.filter.authz.rolesauthorizationfilter\nssl                 org.apache.shiro.web.filter.authz.sslfilter\nuser                org.apache.shiro.web.filter.authc.userfilter\n\n\n# rememberme\n\nusernamepasswordtoken token = new usernamepasswordtoken(username, password);\ntoken.setrememberme(true);\nsecurityutils.getsubject().login(token);\n\n\n\n# 参考资料\n\n * shiro 官方文档\n * 跟我学 shiro\n * the new rbac: resource-based access control',charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Netty 快速入门",frontmatter:{title:"Netty 快速入门",date:"2022-02-17T22:34:30.000Z",order:1,categories:["Java","框架","IO"],tags:["Java","IO","Netty"],permalink:"/pages/10bd70/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/13.IO/01.Netty.html",relativePath:"01.Java/13.框架/13.IO/01.Netty.md",key:"v-2ce67d1d",path:"/pages/10bd70/",headers:[{level:2,title:"Netty 简介",slug:"netty-简介",normalizedTitle:"netty 简介",charIndex:17},{level:3,title:"Netty 的特性",slug:"netty-的特性",normalizedTitle:"netty 的特性",charIndex:83},{level:2,title:"核心组件",slug:"核心组件",normalizedTitle:"核心组件",charIndex:290},{level:2,title:"高性能",slug:"高性能",normalizedTitle:"高性能",charIndex:921},{level:2,title:"零拷贝",slug:"零拷贝",normalizedTitle:"零拷贝",charIndex:213},{level:3,title:"传统意义的拷贝",slug:"传统意义的拷贝",normalizedTitle:"传统意义的拷贝",charIndex:1132},{level:3,title:"零拷贝的概念",slug:"零拷贝的概念",normalizedTitle:"零拷贝的概念",charIndex:1353},{level:3,title:"Netty 中的零拷贝",slug:"netty-中的零拷贝",normalizedTitle:"netty 中的零拷贝",charIndex:1572},{level:2,title:"Netty 流程",slug:"netty-流程",normalizedTitle:"netty 流程",charIndex:2117},{level:2,title:"应用",slug:"应用",normalizedTitle:"应用",charIndex:2130},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:3672}],headersStr:"Netty 简介 Netty 的特性 核心组件 高性能 零拷贝 传统意义的拷贝 零拷贝的概念 Netty 中的零拷贝 Netty 流程 应用 参考资料",content:'# Netty 快速入门\n\n\n# Netty 简介\n\n> Netty 是一款基于 NIO（Nonblocking I/O，非阻塞 IO）开发的网络通信框架。\n\n\n# Netty 的特性\n\n * 高并发：Netty 是一款基于 NIO（Nonblocking IO，非阻塞 IO）开发的网络通信框架，对比于 BIO（Blocking I/O，阻塞 IO），他的并发性能得到了很大提高。\n * 传输快：Netty 的传输依赖于内存零拷贝特性，尽量减少不必要的内存拷贝，实现了更高效率的传输。\n * 封装好：Netty 封装了 NIO 操作的很多细节，提供了易于使用调用接口。\n\n\n# 核心组件\n\n * Channel：Netty 网络操作抽象类，它除了包括基本的 I/O 操作，如 bind、connect、read、write 等。\n * EventLoop：主要是配合 Channel 处理 I/O 操作，用来处理连接的生命周期中所发生的事情。\n * ChannelFuture：Netty 框架中所有的 I/O 操作都为异步的，因此我们需要 ChannelFuture 的 addListener()注册一个 ChannelFutureListener 监听事件，当操作执行成功或者失败时，监听就会自动触发返回结果。\n * ChannelHandler：充当了所有处理入站和出站数据的逻辑容器。ChannelHandler 主要用来处理各种事件，这里的事件很广泛，比如可以是连接、数据接收、异常、数据转换等。\n * ChannelPipeline：为 ChannelHandler 链提供了容器，当 channel 创建时，就会被自动分配到它专属的 ChannelPipeline，这个关联是永久性的。\n\nNetty 有两种发送消息的方式：\n\n * 直接写入 Channel 中，消息从 ChannelPipeline 当中尾部开始移动；\n * 写入和 ChannelHandler 绑定的 ChannelHandlerContext 中，消息从 ChannelPipeline 中的下一个 ChannelHandler 中移动。\n\n\n# 高性能\n\nNetty 高性能表现在哪些方面：\n\n * NIO 线程模型：同步非阻塞，用最少的资源做更多的事。\n * 内存零拷贝：尽量减少不必要的内存拷贝，实现了更高效率的传输。\n * 内存池设计：申请的内存可以重用，主要指直接内存。内部实现是用一颗二叉查找树管理内存分配情况。\n * 串形化处理读写：避免使用锁带来的性能开销。\n * 高性能序列化协议：支持 protobuf 等高性能序列化协议。\n\n\n# 零拷贝\n\n\n# 传统意义的拷贝\n\n是在发送数据的时候，传统的实现方式是：\n\nFile.read(bytes)\n\nSocket.send(bytes)\n\n这种方式需要四次数据拷贝和四次上下文切换：\n\n 1. 数据从磁盘读取到内核的 read buffer\n\n 2. 数据从内核缓冲区拷贝到用户缓冲区\n\n 3. 数据从用户缓冲区拷贝到内核的 socket buffer\n\n 4. 数据从内核的 socket buffer 拷贝到网卡接口（硬件）的缓冲区\n\n\n# 零拷贝的概念\n\n明显上面的第二步和第三步是非必要的，通过 java 的 FileChannel.transferTo 方法，可以避免上面两次多余的拷贝（当然这需要底层操作系统支持）\n\n * 调用 transferTo，数据从文件由 DMA 引擎拷贝到内核 read buffer\n * 接着 DMA 从内核 read buffer 将数据拷贝到网卡接口 buffer\n\n上面的两次操作都不需要 CPU 参与，所以就达到了零拷贝。\n\n\n# Netty 中的零拷贝\n\n主要体现在三个方面：\n\nbytebuffer\n\nNetty 发送和接收消息主要使用 bytebuffer，bytebuffer 使用对外内存（DirectMemory）直接进行 Socket 读写。\n\n原因：如果使用传统的堆内存进行 Socket 读写，JVM 会将堆内存 buffer 拷贝一份到直接内存中然后再写入 socket，多了一次缓冲区的内存拷贝。DirectMemory 中可以直接通过 DMA 发送到网卡接口\n\nComposite Buffers\n\n传统的 ByteBuffer，如果需要将两个 ByteBuffer 中的数据组合到一起，我们需要首先创建一个 size=size1+size2 大小的新的数组，然后将两个数组中的数据拷贝到新的数组中。但是使用 Netty 提供的组合 ByteBuf，就可以避免这样的操作，因为 CompositeByteBuf 并没有真正将多个 Buffer 组合起来，而是保存了它们的引用，从而避免了数据的拷贝，实现了零拷贝。\n\n对于 FileChannel.transferTo 的使用\n\nNetty 中使用了 FileChannel 的 transferTo 方法，该方法依赖于操作系统实现零拷贝。\n\n\n# Netty 流程\n\n\n# 应用\n\n> Netty 是一个广泛使用的 Java 网络编程框架。很多著名软件都使用了它，如：Dubbo、Cassandra、Elasticsearch、Vert.x 等。\n\n有了 Netty，你可以实现自己的 HTTP 服务器，FTP 服务器，UDP 服务器，RPC 服务器，WebSocket 服务器，Redis 的 Proxy 服务器，MySQL 的 Proxy 服务器等等。\n\npublic class NettyOioServer {\n\n    public void server(int port) throws Exception {\n        final ByteBuf buf = Unpooled.unreleasableBuffer(\n                Unpooled.copiedBuffer("Hi!\\r\\n", Charset.forName("UTF-8")));\n        EventLoopGroup group = new OioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();        //1\n\n            b.group(group)                                    //2\n             .channel(OioServerSocketChannel.class)\n             .localAddress(new InetSocketAddress(port))\n             .childHandler(new ChannelInitializer<SocketChannel>() {//3\n                 @Override\n                 public void initChannel(SocketChannel ch)\n                     throws Exception {\n                     ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {            //4\n                         @Override\n                         public void channelActive(ChannelHandlerContext ctx) throws Exception {\n                             ctx.writeAndFlush(buf.duplicate()).addListener(ChannelFutureListener.CLOSE);//5\n                         }\n                     });\n                 }\n             });\n            ChannelFuture f = b.bind().sync();  //6\n            f.channel().closeFuture().sync();\n        } finally {\n            group.shutdownGracefully().sync();        //7\n        }\n    }\n}\n\n\n\n# 参考资料\n\n * 官方\n   * Netty 官网\n   * Netty Github\n * 文章\n   * Netty 入门教程——认识 Netty\n   * 彻底理解 Netty，这一篇文章就够了\n   * Java 200+ 面试题补充 ② Netty 模块',normalizedContent:'# netty 快速入门\n\n\n# netty 简介\n\n> netty 是一款基于 nio（nonblocking i/o，非阻塞 io）开发的网络通信框架。\n\n\n# netty 的特性\n\n * 高并发：netty 是一款基于 nio（nonblocking io，非阻塞 io）开发的网络通信框架，对比于 bio（blocking i/o，阻塞 io），他的并发性能得到了很大提高。\n * 传输快：netty 的传输依赖于内存零拷贝特性，尽量减少不必要的内存拷贝，实现了更高效率的传输。\n * 封装好：netty 封装了 nio 操作的很多细节，提供了易于使用调用接口。\n\n\n# 核心组件\n\n * channel：netty 网络操作抽象类，它除了包括基本的 i/o 操作，如 bind、connect、read、write 等。\n * eventloop：主要是配合 channel 处理 i/o 操作，用来处理连接的生命周期中所发生的事情。\n * channelfuture：netty 框架中所有的 i/o 操作都为异步的，因此我们需要 channelfuture 的 addlistener()注册一个 channelfuturelistener 监听事件，当操作执行成功或者失败时，监听就会自动触发返回结果。\n * channelhandler：充当了所有处理入站和出站数据的逻辑容器。channelhandler 主要用来处理各种事件，这里的事件很广泛，比如可以是连接、数据接收、异常、数据转换等。\n * channelpipeline：为 channelhandler 链提供了容器，当 channel 创建时，就会被自动分配到它专属的 channelpipeline，这个关联是永久性的。\n\nnetty 有两种发送消息的方式：\n\n * 直接写入 channel 中，消息从 channelpipeline 当中尾部开始移动；\n * 写入和 channelhandler 绑定的 channelhandlercontext 中，消息从 channelpipeline 中的下一个 channelhandler 中移动。\n\n\n# 高性能\n\nnetty 高性能表现在哪些方面：\n\n * nio 线程模型：同步非阻塞，用最少的资源做更多的事。\n * 内存零拷贝：尽量减少不必要的内存拷贝，实现了更高效率的传输。\n * 内存池设计：申请的内存可以重用，主要指直接内存。内部实现是用一颗二叉查找树管理内存分配情况。\n * 串形化处理读写：避免使用锁带来的性能开销。\n * 高性能序列化协议：支持 protobuf 等高性能序列化协议。\n\n\n# 零拷贝\n\n\n# 传统意义的拷贝\n\n是在发送数据的时候，传统的实现方式是：\n\nfile.read(bytes)\n\nsocket.send(bytes)\n\n这种方式需要四次数据拷贝和四次上下文切换：\n\n 1. 数据从磁盘读取到内核的 read buffer\n\n 2. 数据从内核缓冲区拷贝到用户缓冲区\n\n 3. 数据从用户缓冲区拷贝到内核的 socket buffer\n\n 4. 数据从内核的 socket buffer 拷贝到网卡接口（硬件）的缓冲区\n\n\n# 零拷贝的概念\n\n明显上面的第二步和第三步是非必要的，通过 java 的 filechannel.transferto 方法，可以避免上面两次多余的拷贝（当然这需要底层操作系统支持）\n\n * 调用 transferto，数据从文件由 dma 引擎拷贝到内核 read buffer\n * 接着 dma 从内核 read buffer 将数据拷贝到网卡接口 buffer\n\n上面的两次操作都不需要 cpu 参与，所以就达到了零拷贝。\n\n\n# netty 中的零拷贝\n\n主要体现在三个方面：\n\nbytebuffer\n\nnetty 发送和接收消息主要使用 bytebuffer，bytebuffer 使用对外内存（directmemory）直接进行 socket 读写。\n\n原因：如果使用传统的堆内存进行 socket 读写，jvm 会将堆内存 buffer 拷贝一份到直接内存中然后再写入 socket，多了一次缓冲区的内存拷贝。directmemory 中可以直接通过 dma 发送到网卡接口\n\ncomposite buffers\n\n传统的 bytebuffer，如果需要将两个 bytebuffer 中的数据组合到一起，我们需要首先创建一个 size=size1+size2 大小的新的数组，然后将两个数组中的数据拷贝到新的数组中。但是使用 netty 提供的组合 bytebuf，就可以避免这样的操作，因为 compositebytebuf 并没有真正将多个 buffer 组合起来，而是保存了它们的引用，从而避免了数据的拷贝，实现了零拷贝。\n\n对于 filechannel.transferto 的使用\n\nnetty 中使用了 filechannel 的 transferto 方法，该方法依赖于操作系统实现零拷贝。\n\n\n# netty 流程\n\n\n# 应用\n\n> netty 是一个广泛使用的 java 网络编程框架。很多著名软件都使用了它，如：dubbo、cassandra、elasticsearch、vert.x 等。\n\n有了 netty，你可以实现自己的 http 服务器，ftp 服务器，udp 服务器，rpc 服务器，websocket 服务器，redis 的 proxy 服务器，mysql 的 proxy 服务器等等。\n\npublic class nettyoioserver {\n\n    public void server(int port) throws exception {\n        final bytebuf buf = unpooled.unreleasablebuffer(\n                unpooled.copiedbuffer("hi!\\r\\n", charset.forname("utf-8")));\n        eventloopgroup group = new oioeventloopgroup();\n        try {\n            serverbootstrap b = new serverbootstrap();        //1\n\n            b.group(group)                                    //2\n             .channel(oioserversocketchannel.class)\n             .localaddress(new inetsocketaddress(port))\n             .childhandler(new channelinitializer<socketchannel>() {//3\n                 @override\n                 public void initchannel(socketchannel ch)\n                     throws exception {\n                     ch.pipeline().addlast(new channelinboundhandleradapter() {            //4\n                         @override\n                         public void channelactive(channelhandlercontext ctx) throws exception {\n                             ctx.writeandflush(buf.duplicate()).addlistener(channelfuturelistener.close);//5\n                         }\n                     });\n                 }\n             });\n            channelfuture f = b.bind().sync();  //6\n            f.channel().closefuture().sync();\n        } finally {\n            group.shutdowngracefully().sync();        //7\n        }\n    }\n}\n\n\n\n# 参考资料\n\n * 官方\n   * netty 官网\n   * netty github\n * 文章\n   * netty 入门教程——认识 netty\n   * 彻底理解 netty，这一篇文章就够了\n   * java 200+ 面试题补充 ② netty 模块',charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Spring Security 快速入门",frontmatter:{title:"Spring Security 快速入门",date:"2022-02-17T22:34:30.000Z",order:2,categories:["Java","框架","安全"],tags:["Java","框架","安全","SpringSecurity"],permalink:"/pages/050cdd/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/12.%E5%AE%89%E5%85%A8/02.SpringSecurity.html",relativePath:"01.Java/13.框架/12.安全/02.SpringSecurity.md",key:"v-de6109ae",path:"/pages/050cdd/",headers:[{level:2,title:"快速开始",slug:"快速开始",normalizedTitle:"快速开始",charIndex:27},{level:2,title:"核心 API",slug:"核心-api",normalizedTitle:"核心 api",charIndex:67},{level:2,title:"设计原理",slug:"设计原理",normalizedTitle:"设计原理",charIndex:78},{level:2,title:"认证",slug:"认证",normalizedTitle:"认证",charIndex:1374},{level:3,title:"数据模型",slug:"数据模型",normalizedTitle:"数据模型",charIndex:1381},{level:3,title:"认证基本流程",slug:"认证基本流程",normalizedTitle:"认证基本流程",charIndex:1968},{level:3,title:"用户名/密码认证",slug:"用户名-密码认证",normalizedTitle:"用户名/密码认证",charIndex:2894},{level:4,title:"表单认证",slug:"表单认证",normalizedTitle:"表单认证",charIndex:2994},{level:4,title:"基本认证",slug:"基本认证",normalizedTitle:"基本认证",charIndex:2927},{level:4,title:"内存认证",slug:"内存认证",normalizedTitle:"内存认证",charIndex:3231},{level:4,title:"JDBC 认证",slug:"jdbc-认证",normalizedTitle:"jdbc 认证",charIndex:3823},{level:4,title:"UserDetailsService",slug:"userdetailsservice",normalizedTitle:"userdetailsservice",charIndex:2964},{level:4,title:"PasswordEncoder",slug:"passwordencoder",normalizedTitle:"passwordencoder",charIndex:3480},{level:3,title:"Remember-Me",slug:"remember-me",normalizedTitle:"remember-me",charIndex:5442},{level:2,title:"Spring Boot 集成",slug:"spring-boot-集成",normalizedTitle:"spring boot 集成",charIndex:5458},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:5759}],headersStr:"快速开始 核心 API 设计原理 认证 数据模型 认证基本流程 用户名/密码认证 表单认证 基本认证 内存认证 JDBC 认证 UserDetailsService PasswordEncoder Remember-Me Spring Boot 集成 参考资料",content:'# Spring Security 快速入门\n\n\n# 快速开始\n\n参考：Securing a Web Application\n\n\n# 核心 API\n\n\n# 设计原理\n\nSpring Security 对于 Servlet 的支持基于过滤链（FilterChain）实现。\n\nSpring 提供了一个名为 DelegatingFilterProxy 的 Filter 实现，该实现允许在 Servlet 容器的生命周期和 Spring 的 ApplicationContext 之间进行桥接。 Servlet 容器允许使用其自己的标准注册 Filters，但它不了解 Spring 定义的 Bean。 DelegatingFilterProxy 可以通过标准的 Servlet 容器机制进行注册，但是可以将所有工作委托给实现 Filter 的 Spring Bean。\n\npublic void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) {\n    // Lazily get Filter that was registered as a Spring Bean\n    // For the example in DelegatingFilterProxy delegate is an instance of Bean Filter0\n    Filter delegate = getFilterBean(someBeanName);\n    // delegate work to the Spring Bean\n    delegate.doFilter(request, response);\n}\n\n\nFilterChainProxy 使用 SecurityFilterChain 确定应对此请求调用哪些 Spring Security 过滤器。\n\nSecurityFilterChain 中的安全过滤器通常是 Bean，但它们是使用 FilterChainProxy 而不是 DelegatingFilterProxy 注册的。\n\n实际上，FilterChainProxy 可用于确定应使用哪个 SecurityFilterChain。如果您的应用程序可以为不同的模块提供完全独立的配置。\n\n\n\nExceptionTranslationFilter 可以将 AccessDeniedException 和 AuthenticationException 转换为 HTTP 响应。\n\n\n\n核心源码：\n\ntry {\n    filterChain.doFilter(request, response);\n} catch (AccessDeniedException | AuthenticationException e) {\n    if (!authenticated || e instanceof AuthenticationException) {\n        startAuthentication();\n    } else {\n        accessDenied();\n    }\n}\n\n\n\n# 认证\n\n\n# 数据模型\n\nSpring Security 框架中的认证数据模型如下：\n\n\n\n * Authentication - 认证信息实体。\n   * principal - 用户标识。如：用户名、账户名等。通常是 UserDetails 的实例（后面详细讲解）。\n   * credentials - 认证凭证。如：密码等。\n   * authorities - 授权信息。如：用户的角色、权限等信息。\n * SecurityContext - 安全上下文。包含一个 Authentication 对象。\n * SecurityContextHolder - 安全上下文持有者。用于存储认证信息。\n\n【示例】注册认证信息\n\nSecurityContext context = SecurityContextHolder.createEmptyContext();\nAuthentication authentication =\n    new TestingAuthenticationToken("username", "password", "ROLE_USER");\ncontext.setAuthentication(authentication);\nSecurityContextHolder.setContext(context);\n\n\n【示例】访问认证信息\n\n\n# 认证基本流程\n\nAbstractAuthenticationProcessingFilter 用作验证用户凭据的基本过滤器。 在对凭证进行身份验证之前，Spring Security 通常使用 AuthenticationEntryPoint 请求凭证。\n\n\n\n * （1）当用户提交其凭据时，AbstractAuthenticationProcessingFilter 从要验证的 HttpServletRequest 创建一个 Authentication。创建的身份验证类型取决于 AbstractAuthenticationProcessingFilter 的子类。例如，UsernamePasswordAuthenticationFilter 根据在 HttpServletRequest 中提交的用户名和密码来创建 UsernamePasswordAuthenticationToken。\n * （2）接下来，将身份验证传递到 AuthenticationManager 进行身份验证。\n * （3）如果身份验证失败，则认证失败\n   * 清除 SecurityContextHolder。\n   * 调用 RememberMeServices.loginFail。如果没有配置 remember me，则为空。\n   * 调用 AuthenticationFailureHandler。\n * （4）如果身份验证成功，则认证成功。\n   * 如果是新的登录，则通知 SessionAuthenticationStrategy。\n   * 身份验证是在 SecurityContextHolder 上设置的。之后，SecurityContextPersistenceFilter 将 SecurityContext 保存到 HttpSession 中。\n   * 调用 RememberMeServices.loginSuccess。如果没有配置 remember me，则为空。\n   * ApplicationEventPublisher 发布一个 InteractiveAuthenticationSuccessEvent。\n\n\n# 用户名/密码认证\n\n读取用户名和密码的方式：\n\n * 表单\n * 基本认证\n * 数字认证\n\n存储机制\n\n * 内存\n * JDBC\n * UserDetailsService\n * LDAP\n\n# 表单认证\n\nspring security 支持通过从 html 表单获取登录时提交的用户名、密码。\n\n\n\n一旦，登录信息被提交，UsernamePasswordAuthenticationFilter 就会验证用户名和密码。\n\n\n\n# 基本认证\n\nprotected void configure(HttpSecurity http) {\n    http\n        // ...\n        .httpBasic(withDefaults());\n}\n\n\n# 内存认证\n\nInMemoryUserDetailsManager 实现了 UserDetailsService ，提供了基本的用户名、密码认证，其认证数据存储在内存中。\n\n@Bean\npublic UserDetailsService users() {\n    // The builder will ensure the passwords are encoded before saving in memory\n    UserBuilder users = User.withDefaultPasswordEncoder();\n    UserDetails user = users\n        .username("user")\n        .password("password")\n        .roles("USER")\n        .build();\n    UserDetails user = users\n        .username("admin")\n        .password("password")\n        .roles("USER", "ADMIN")\n        .build();\n    return new InMemoryUserDetailsManager(user, admin);\n}\n\n\n# JDBC 认证\n\nJdbcUserDetailsManager 实现了 UserDetailsService ，提供了基本的用户名、密码认证，其认证数据存储在关系型数据库中，通过 JDBC 方式访问。\n\n@Bean\nUserDetailsManager users(DataSource dataSource) {\n    UserDetails user = User.builder()\n        .username("user")\n        .password("{bcrypt}$2a$10$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW")\n        .roles("USER")\n        .build();\n    UserDetails admin = User.builder()\n        .username("admin")\n        .password("{bcrypt}$2a$10$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW")\n        .roles("USER", "ADMIN")\n        .build();\n    JdbcUserDetailsManager users = new JdbcUserDetailsManager(dataSource);\n    users.createUser()\n}\n\n\n基本的 scheam：\n\ncreate table users(\n    username varchar_ignorecase(50) not null primary key,\n    password varchar_ignorecase(50) not null,\n    enabled boolean not null\n);\n\ncreate table authorities (\n    username varchar_ignorecase(50) not null,\n    authority varchar_ignorecase(50) not null,\n    constraint fk_authorities_users foreign key(username) references users(username)\n);\ncreate unique index ix_auth_username on authorities (username,authority);\n\n\n# UserDetailsService\n\nUserDetails 由 UserDetailsService 返回。 DaoAuthenticationProvider 验证 UserDetails，然后返回身份验证，该身份验证的主体是已配置的 UserDetailsService 返回的 UserDetails。\n\nDaoAuthenticationProvider 使用 UserDetailsService 检索用户名，密码和其他用于使用用户名和密码进行身份验证的属性。 Spring Security 提供 UserDetailsService 的内存中和 JDBC 实现。\n\n您可以通过将自定义 UserDetailsService 公开为 bean 来定义自定义身份验证。\n\n# PasswordEncoder\n\nSpring Security 的 servlet 支持通过与 PasswordEncoder 集成来安全地存储密码。 可以通过公开一个 PasswordEncoder Bean 来定制 Spring Security 使用的 PasswordEncoder 实现。\n\n\n\n\n# Remember-Me\n\n\n# Spring Boot 集成\n\n@EnableWebSecurity 和 @Configuration 注解一起使用, 注解 WebSecurityConfigurer 类型的类。\n\n或者利用@EnableWebSecurity注解继承 WebSecurityConfigurerAdapter 的类，这样就构成了 Spring Security 的配置。\n\n * configure(WebSecurity)：通过重载该方法，可配置 Spring Security 的 Filter 链。\n * configure(HttpSecurity)：通过重载该方法，可配置如何通过拦截器保护请求。\n\n\n# 参考资料\n\n * Spring Security Architecture\n * Securing a Web Application',normalizedContent:'# spring security 快速入门\n\n\n# 快速开始\n\n参考：securing a web application\n\n\n# 核心 api\n\n\n# 设计原理\n\nspring security 对于 servlet 的支持基于过滤链（filterchain）实现。\n\nspring 提供了一个名为 delegatingfilterproxy 的 filter 实现，该实现允许在 servlet 容器的生命周期和 spring 的 applicationcontext 之间进行桥接。 servlet 容器允许使用其自己的标准注册 filters，但它不了解 spring 定义的 bean。 delegatingfilterproxy 可以通过标准的 servlet 容器机制进行注册，但是可以将所有工作委托给实现 filter 的 spring bean。\n\npublic void dofilter(servletrequest request, servletresponse response, filterchain chain) {\n    // lazily get filter that was registered as a spring bean\n    // for the example in delegatingfilterproxy delegate is an instance of bean filter0\n    filter delegate = getfilterbean(somebeanname);\n    // delegate work to the spring bean\n    delegate.dofilter(request, response);\n}\n\n\nfilterchainproxy 使用 securityfilterchain 确定应对此请求调用哪些 spring security 过滤器。\n\nsecurityfilterchain 中的安全过滤器通常是 bean，但它们是使用 filterchainproxy 而不是 delegatingfilterproxy 注册的。\n\n实际上，filterchainproxy 可用于确定应使用哪个 securityfilterchain。如果您的应用程序可以为不同的模块提供完全独立的配置。\n\n\n\nexceptiontranslationfilter 可以将 accessdeniedexception 和 authenticationexception 转换为 http 响应。\n\n\n\n核心源码：\n\ntry {\n    filterchain.dofilter(request, response);\n} catch (accessdeniedexception | authenticationexception e) {\n    if (!authenticated || e instanceof authenticationexception) {\n        startauthentication();\n    } else {\n        accessdenied();\n    }\n}\n\n\n\n# 认证\n\n\n# 数据模型\n\nspring security 框架中的认证数据模型如下：\n\n\n\n * authentication - 认证信息实体。\n   * principal - 用户标识。如：用户名、账户名等。通常是 userdetails 的实例（后面详细讲解）。\n   * credentials - 认证凭证。如：密码等。\n   * authorities - 授权信息。如：用户的角色、权限等信息。\n * securitycontext - 安全上下文。包含一个 authentication 对象。\n * securitycontextholder - 安全上下文持有者。用于存储认证信息。\n\n【示例】注册认证信息\n\nsecuritycontext context = securitycontextholder.createemptycontext();\nauthentication authentication =\n    new testingauthenticationtoken("username", "password", "role_user");\ncontext.setauthentication(authentication);\nsecuritycontextholder.setcontext(context);\n\n\n【示例】访问认证信息\n\n\n# 认证基本流程\n\nabstractauthenticationprocessingfilter 用作验证用户凭据的基本过滤器。 在对凭证进行身份验证之前，spring security 通常使用 authenticationentrypoint 请求凭证。\n\n\n\n * （1）当用户提交其凭据时，abstractauthenticationprocessingfilter 从要验证的 httpservletrequest 创建一个 authentication。创建的身份验证类型取决于 abstractauthenticationprocessingfilter 的子类。例如，usernamepasswordauthenticationfilter 根据在 httpservletrequest 中提交的用户名和密码来创建 usernamepasswordauthenticationtoken。\n * （2）接下来，将身份验证传递到 authenticationmanager 进行身份验证。\n * （3）如果身份验证失败，则认证失败\n   * 清除 securitycontextholder。\n   * 调用 remembermeservices.loginfail。如果没有配置 remember me，则为空。\n   * 调用 authenticationfailurehandler。\n * （4）如果身份验证成功，则认证成功。\n   * 如果是新的登录，则通知 sessionauthenticationstrategy。\n   * 身份验证是在 securitycontextholder 上设置的。之后，securitycontextpersistencefilter 将 securitycontext 保存到 httpsession 中。\n   * 调用 remembermeservices.loginsuccess。如果没有配置 remember me，则为空。\n   * applicationeventpublisher 发布一个 interactiveauthenticationsuccessevent。\n\n\n# 用户名/密码认证\n\n读取用户名和密码的方式：\n\n * 表单\n * 基本认证\n * 数字认证\n\n存储机制\n\n * 内存\n * jdbc\n * userdetailsservice\n * ldap\n\n# 表单认证\n\nspring security 支持通过从 html 表单获取登录时提交的用户名、密码。\n\n\n\n一旦，登录信息被提交，usernamepasswordauthenticationfilter 就会验证用户名和密码。\n\n\n\n# 基本认证\n\nprotected void configure(httpsecurity http) {\n    http\n        // ...\n        .httpbasic(withdefaults());\n}\n\n\n# 内存认证\n\ninmemoryuserdetailsmanager 实现了 userdetailsservice ，提供了基本的用户名、密码认证，其认证数据存储在内存中。\n\n@bean\npublic userdetailsservice users() {\n    // the builder will ensure the passwords are encoded before saving in memory\n    userbuilder users = user.withdefaultpasswordencoder();\n    userdetails user = users\n        .username("user")\n        .password("password")\n        .roles("user")\n        .build();\n    userdetails user = users\n        .username("admin")\n        .password("password")\n        .roles("user", "admin")\n        .build();\n    return new inmemoryuserdetailsmanager(user, admin);\n}\n\n\n# jdbc 认证\n\njdbcuserdetailsmanager 实现了 userdetailsservice ，提供了基本的用户名、密码认证，其认证数据存储在关系型数据库中，通过 jdbc 方式访问。\n\n@bean\nuserdetailsmanager users(datasource datasource) {\n    userdetails user = user.builder()\n        .username("user")\n        .password("{bcrypt}$2a$10$grldnijsqmuvl/au9ofl.edwmoohzzs7.rmnsjz.0fxo/btk76klw")\n        .roles("user")\n        .build();\n    userdetails admin = user.builder()\n        .username("admin")\n        .password("{bcrypt}$2a$10$grldnijsqmuvl/au9ofl.edwmoohzzs7.rmnsjz.0fxo/btk76klw")\n        .roles("user", "admin")\n        .build();\n    jdbcuserdetailsmanager users = new jdbcuserdetailsmanager(datasource);\n    users.createuser()\n}\n\n\n基本的 scheam：\n\ncreate table users(\n    username varchar_ignorecase(50) not null primary key,\n    password varchar_ignorecase(50) not null,\n    enabled boolean not null\n);\n\ncreate table authorities (\n    username varchar_ignorecase(50) not null,\n    authority varchar_ignorecase(50) not null,\n    constraint fk_authorities_users foreign key(username) references users(username)\n);\ncreate unique index ix_auth_username on authorities (username,authority);\n\n\n# userdetailsservice\n\nuserdetails 由 userdetailsservice 返回。 daoauthenticationprovider 验证 userdetails，然后返回身份验证，该身份验证的主体是已配置的 userdetailsservice 返回的 userdetails。\n\ndaoauthenticationprovider 使用 userdetailsservice 检索用户名，密码和其他用于使用用户名和密码进行身份验证的属性。 spring security 提供 userdetailsservice 的内存中和 jdbc 实现。\n\n您可以通过将自定义 userdetailsservice 公开为 bean 来定义自定义身份验证。\n\n# passwordencoder\n\nspring security 的 servlet 支持通过与 passwordencoder 集成来安全地存储密码。 可以通过公开一个 passwordencoder bean 来定制 spring security 使用的 passwordencoder 实现。\n\n\n\n\n# remember-me\n\n\n# spring boot 集成\n\n@enablewebsecurity 和 @configuration 注解一起使用, 注解 websecurityconfigurer 类型的类。\n\n或者利用@enablewebsecurity注解继承 websecurityconfigureradapter 的类，这样就构成了 spring security 的配置。\n\n * configure(websecurity)：通过重载该方法，可配置 spring security 的 filter 链。\n * configure(httpsecurity)：通过重载该方法，可配置如何通过拦截器保护请求。\n\n\n# 参考资料\n\n * spring security architecture\n * securing a web application',charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Java 框架",frontmatter:{title:"Java 框架",date:"2022-02-18T08:53:11.000Z",categories:["Java","框架"],tags:["Java","框架"],permalink:"/pages/e373d7/",hidden:!0,index:!1},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/",relativePath:"01.Java/13.框架/README.md",key:"v-7d955174",path:"/pages/e373d7/",headers:[{level:2,title:"📖 内容",slug:"📖-内容",normalizedTitle:"📖 内容",charIndex:14},{level:3,title:"Spring",slug:"spring",normalizedTitle:"spring",charIndex:24},{level:4,title:"综合",slug:"综合",normalizedTitle:"综合",charIndex:34},{level:4,title:"核心",slug:"核心",normalizedTitle:"核心",charIndex:105},{level:4,title:"数据",slug:"数据",normalizedTitle:"数据",charIndex:239},{level:4,title:"Web",slug:"web",normalizedTitle:"web",charIndex:637},{level:4,title:"IO",slug:"io",normalizedTitle:"io",charIndex:687},{level:4,title:"集成",slug:"集成",normalizedTitle:"集成",charIndex:556},{level:4,title:"其他",slug:"其他",normalizedTitle:"其他",charIndex:817},{level:3,title:"ORM",slug:"orm",normalizedTitle:"orm",charIndex:887},{level:3,title:"安全",slug:"安全",normalizedTitle:"安全",charIndex:926},{level:3,title:"IO",slug:"io-2",normalizedTitle:"io",charIndex:687},{level:2,title:"📚 资料",slug:"📚-资料",normalizedTitle:"📚 资料",charIndex:1179},{level:2,title:"🚪 传送",slug:"🚪-传送",normalizedTitle:"🚪 传送",charIndex:1477}],headersStr:"📖 内容 Spring 综合 核心 数据 Web IO 集成 其他 ORM 安全 IO 📚 资料 🚪 传送",content:"# Java 框架\n\n\n# 📖 内容\n\n\n# Spring\n\n# 综合\n\n * Spring 概述\n * SpringBoot 知识图谱\n * SpringBoot 基本原理\n * Spring 面试\n\n# 核心\n\n * Spring Bean\n * Spring IoC\n * Spring 依赖查找\n * Spring 依赖注入\n * Spring IoC 依赖来源\n * Spring Bean 作用域\n * Spring Bean 生命周期\n * Spring 配置元数据\n * Spring AOP\n * Spring 资源管理\n * Spring 校验\n * Spring 数据绑定\n * Spring 类型转换\n * Spring EL 表达式\n * Spring 事件\n * Spring 国际化\n * Spring 泛型处理\n * Spring 注解\n * Spring Environment 抽象\n * SpringBoot 教程之快速入门\n * SpringBoot 之属性加载\n * SpringBoot 之 Profile\n\n# 数据\n\n * Spring 之数据源\n * Spring 之 JDBC\n * Spring 之事务\n * Spring 之 JPA\n * Spring 集成 Mybatis\n * Spring 访问 Redis\n * Spring 访问 MongoDB\n * Spring 访问 Elasticsearch\n\n# Web\n\n * Spring WebMvc\n * SpringBoot 之应用 EasyUI\n\n# IO\n\n * SpringBoot 之异步请求\n * SpringBoot 之 Json\n * SpringBoot 之邮件\n\n# 集成\n\n * Spring 集成缓存中间件\n * Spring 集成定时任务中间件\n * Spring 集成 Dubbo\n\n# 其他\n\n * Spring4 升级\n * SpringBoot 之 banner\n * SpringBoot 之 Actuator\n\n\n# ORM\n\n * Mybatis 快速入门\n * Mybatis 原理\n\n\n# 安全\n\n> Java 领域比较流行的安全框架就是 shiro 和 spring-security。\n> \n> shiro 更为简单、轻便，容易理解，能满足大多数基本安全场景下的需要。\n> \n> spring-security 功能更丰富，也比 shiro 更复杂。值得一提的是由于 spring-security 是 spring 团队开发，所以集成 spring 和 spring-boot 框架更容易。\n\n * Shiro\n * SpringSecurity\n\n\n# IO\n\n * Netty\n\n\n# 📚 资料\n\n * Mybatis\n   * Mybatis Github\n   * Mybatis 官网\n   * MyBatis 官方代码生成（mybatis-generator）\n   * MyBatis 官方集成 Spring（mybatis-spring）\n   * Mybatis 官方集成 Spring Boot（mybatis-spring-boot）\n   * MyBatis-Plus - CRUD 扩展插件、代码生成器、分页器等多功能\n   * Mapper - CRUD 扩展插件\n   * Mybatis-PageHelper - Mybatis 通用分页插件\n\n\n# 🚪 传送\n\n◾ 💧 钝悟的 IT 知识图谱 ◾",normalizedContent:"# java 框架\n\n\n# 📖 内容\n\n\n# spring\n\n# 综合\n\n * spring 概述\n * springboot 知识图谱\n * springboot 基本原理\n * spring 面试\n\n# 核心\n\n * spring bean\n * spring ioc\n * spring 依赖查找\n * spring 依赖注入\n * spring ioc 依赖来源\n * spring bean 作用域\n * spring bean 生命周期\n * spring 配置元数据\n * spring aop\n * spring 资源管理\n * spring 校验\n * spring 数据绑定\n * spring 类型转换\n * spring el 表达式\n * spring 事件\n * spring 国际化\n * spring 泛型处理\n * spring 注解\n * spring environment 抽象\n * springboot 教程之快速入门\n * springboot 之属性加载\n * springboot 之 profile\n\n# 数据\n\n * spring 之数据源\n * spring 之 jdbc\n * spring 之事务\n * spring 之 jpa\n * spring 集成 mybatis\n * spring 访问 redis\n * spring 访问 mongodb\n * spring 访问 elasticsearch\n\n# web\n\n * spring webmvc\n * springboot 之应用 easyui\n\n# io\n\n * springboot 之异步请求\n * springboot 之 json\n * springboot 之邮件\n\n# 集成\n\n * spring 集成缓存中间件\n * spring 集成定时任务中间件\n * spring 集成 dubbo\n\n# 其他\n\n * spring4 升级\n * springboot 之 banner\n * springboot 之 actuator\n\n\n# orm\n\n * mybatis 快速入门\n * mybatis 原理\n\n\n# 安全\n\n> java 领域比较流行的安全框架就是 shiro 和 spring-security。\n> \n> shiro 更为简单、轻便，容易理解，能满足大多数基本安全场景下的需要。\n> \n> spring-security 功能更丰富，也比 shiro 更复杂。值得一提的是由于 spring-security 是 spring 团队开发，所以集成 spring 和 spring-boot 框架更容易。\n\n * shiro\n * springsecurity\n\n\n# io\n\n * netty\n\n\n# 📚 资料\n\n * mybatis\n   * mybatis github\n   * mybatis 官网\n   * mybatis 官方代码生成（mybatis-generator）\n   * mybatis 官方集成 spring（mybatis-spring）\n   * mybatis 官方集成 spring boot（mybatis-spring-boot）\n   * mybatis-plus - crud 扩展插件、代码生成器、分页器等多功能\n   * mapper - crud 扩展插件\n   * mybatis-pagehelper - mybatis 通用分页插件\n\n\n# 🚪 传送\n\n◾ 💧 钝悟的 it 知识图谱 ◾",charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Java 缓存中间件",frontmatter:{title:"Java 缓存中间件",date:"2022-02-17T22:34:30.000Z",order:2,categories:["Java","中间件","缓存"],tags:["Java","中间件","缓存"],permalink:"/pages/85460d/"},regularPath:"/01.Java/14.%E4%B8%AD%E9%97%B4%E4%BB%B6/02.%E7%BC%93%E5%AD%98/02.Java%E7%BC%93%E5%AD%98%E4%B8%AD%E9%97%B4%E4%BB%B6.html",relativePath:"01.Java/14.中间件/02.缓存/02.Java缓存中间件.md",key:"v-60970149",path:"/pages/85460d/",headers:[{level:2,title:"一 、JSR 107",slug:"一-、jsr-107",normalizedTitle:"一 、jsr 107",charIndex:54},{level:2,title:"二、Spring Cache",slug:"二、spring-cache",normalizedTitle:"二、spring cache",charIndex:608},{level:3,title:"开启缓存注解",slug:"开启缓存注解",normalizedTitle:"开启缓存注解",charIndex:936},{level:3,title:"spring 缓存注解 API",slug:"spring-缓存注解-api",normalizedTitle:"spring 缓存注解 api",charIndex:1180},{level:4,title:"@Cacheable",slug:"cacheable",normalizedTitle:"@cacheable",charIndex:1293},{level:4,title:"@CachePut",slug:"cacheput",normalizedTitle:"@cacheput",charIndex:1482},{level:4,title:"@CacheEvict",slug:"cacheevict",normalizedTitle:"@cacheevict",charIndex:1587},{level:4,title:"@Caching",slug:"caching",normalizedTitle:"@caching",charIndex:2483},{level:4,title:"@CacheConfig",slug:"cacheconfig",normalizedTitle:"@cacheconfig",charIndex:2737},{level:2,title:"三、Spring Boot Cache",slug:"三、spring-boot-cache",normalizedTitle:"三、spring boot cache",charIndex:2987},{level:3,title:"Spring Boot Cache 快速入门",slug:"spring-boot-cache-快速入门",normalizedTitle:"spring boot cache 快速入门",charIndex:3096},{level:2,title:"四、JetCache",slug:"四、jetcache",normalizedTitle:"四、jetcache",charIndex:3926},{level:3,title:"jetcache 快速入门",slug:"jetcache-快速入门",normalizedTitle:"jetcache 快速入门",charIndex:4221},{level:2,title:"五、j2cache",slug:"五、j2cache",normalizedTitle:"五、j2cache",charIndex:6371},{level:2,title:"六、总结",slug:"六、总结",normalizedTitle:"六、总结",charIndex:6385},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:6542}],headersStr:"一 、JSR 107 二、Spring Cache 开启缓存注解 spring 缓存注解 API @Cacheable @CachePut @CacheEvict @Caching @CacheConfig 三、Spring Boot Cache Spring Boot Cache 快速入门 四、JetCache jetcache 快速入门 五、j2cache 六、总结 参考资料",content:'# Java 缓存中间件\n\n> 关键词：Spring Cache、J2Cache、JetCache\n\n\n# 一 、JSR 107\n\nJSR107 中制订了 Java 缓存的规范。\n\n因此，在很多缓存框架、缓存库中，其 API 都参考了 JSR 107 规范。\n\n\n\nJava Caching 定义了 5 个核心接口\n\n * CachingProvider - 定义了创建、配置、获取、管理和控制多个 CacheManager。一个应用可以在运行期访问多个 CachingProvider。\n * CacheManager - 定义了创建、配置、获取、管理和控制多个唯一命名的 Cache，这些 Cache 存在于 CacheManager 的上下文中。一个 CacheManager 仅被一个 CachingProvider 所拥有。\n * Cache - 是一个类似 Map 的数据结构并临时存储以 Key 为索引的值。一个 Cache 仅被一个 CacheManager 所拥有。\n * Entry - 是一个存储在 Cache 中的 key-value 对。\n * Expiry - 每一个存储在 Cache 中的条目有一个定义的有效期，即 Expiry Duration。一旦超过这个时间，条目为过期的状态。一旦过期，条目将不可访问、更新和删除。缓存有效期可以通过 ExpiryPolicy 设置。\n\n\n# 二、Spring Cache\n\n> 详见：Spring Cache 官方文档\n\nSpring 作为 Java 开发最著名的框架，也提供了缓存功能的框架—— Spring Cache。\n\nSpring 支持基于注释（annotation）的缓存（cache）技术，它本质上不是一个具体的缓存实现方案（例如：EHCache 或 OSCache），而是一个对缓存使用的抽象，通过在既有代码中添加少量它定义的各种 annotation，即能够达到缓存方法的返回对象的效果。\n\nSpring Cache 的特点：\n\n * 通过缓存注解即可支持缓存功能\n * 支持 Spring EL 表达式\n * 支持 AspectJ\n * 支持自定义 key 和缓存管理\n\n\n# 开启缓存注解\n\nSpring 为缓存功能提供了注解功能，但是你必须启动注解。\n\n有两种方式：\n\n（一）使用标记注解 @EnableCaching\n\n这种方式对于 Spring 或 Spring Boot 项目都适用。\n\n@Configuration\n@EnableCaching\npublic class AppConfig {\n}\n\n\n（二）在 xml 中声明\n\n<cache:annotation-driven cache-manager="cacheManager"/>\n\n\n\n# spring 缓存注解 API\n\nSpring 对缓存的支持类似于对事务的支持。\n\n首先使用注解标记方法，相当于定义了切点，然后使用 Aop 技术在这个方法的调用前、调用后获取方法的入参和返回值，进而实现了缓存的逻辑。\n\n# @Cacheable\n\n@Cacheable 用于触发缓存。\n\n表明所修饰的方法是可以缓存的：当第一次调用这个方法时，它的结果会被缓存下来，在缓存的有效时间内，以后访问这个方法都直接返回缓存结果，不再执行方法中的代码段。\n\n这个注解可以用condition属性来设置条件，如果不满足条件，就不使用缓存能力，直接执行方法。\n\n可以使用key属性来指定 key 的生成规则。\n\n# @CachePut\n\n@CachePut 用于更新缓存。\n\n与@Cacheable不同，@CachePut不仅会缓存方法的结果，还会执行方法的代码段。\n\n它支持的属性和用法都与@Cacheable一致。\n\n# @CacheEvict\n\n@CacheEvict 用于清除缓存。\n\n与@Cacheable功能相反，@CacheEvict表明所修饰的方法是用来删除失效或无用的缓存数据。\n\n下面是@Cacheable、@CacheEvict和@CachePut基本使用方法的一个集中展示：\n\n@Service\npublic class UserService {\n    // @Cacheable可以设置多个缓存，形式如：@Cacheable({"books", "isbns"})\n    @Cacheable(value={"users"}, key="#user.id")\n    public User findUser(User user) {\n        return findUserInDB(user.getId());\n    }\n\n    @Cacheable(value = "users", condition = "#user.getId() <= 2")\n    public User findUserInLimit(User user) {\n        return findUserInDB(user.getId());\n    }\n\n    @CachePut(value = "users", key = "#user.getId()")\n    public void updateUser(User user) {\n        updateUserInDB(user);\n    }\n\n    @CacheEvict(value = "users")\n    public void removeUser(User user) {\n        removeUserInDB(user.getId());\n    }\n\n    @CacheEvict(value = "users", allEntries = true)\n    public void clear() {\n        removeAllInDB();\n    }\n}\n\n\n# @Caching\n\n@Caching 用于组合定义多种缓存功能。\n\n如果需要使用同一个缓存注解（@Cacheable、@CacheEvict或@CachePut）多次修饰一个方法，就需要用到@Caching。\n\n@Caching(evict = { @CacheEvict("primary"), @CacheEvict(cacheNames="secondary", key="#p0") })\npublic Book importBooks(String deposit, Date date)\n\n\n# @CacheConfig\n\n@CacheConfig 用于定义公共缓存配置。\n\n与前面的缓存注解不同，这是一个类级别的注解。\n\n如果类的所有操作都是缓存操作，你可以使用@CacheConfig来指定类，省去一些配置。\n\n@CacheConfig("books")\npublic class BookRepositoryImpl implements BookRepository {\n @Cacheable\n public Book findBook(ISBN isbn) {...}\n}\n\n\n\n# 三、Spring Boot Cache\n\n> 详见：Spring Boot Cache 特性官方文档\n\nSpring Boot Cache 是在 Spring Cache 的基础上做了封装，使得使用更为便捷。\n\n\n# Spring Boot Cache 快速入门\n\n（1）引入依赖\n\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-cache</artifactId>\n</dependency>\n\n\x3c!-- 按序引入需要的缓存库 --\x3e\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-data-redis</artifactId>\n</dependency>\n\n\n（2）缓存配置\n\n例如，选用缓存为 redis，则需要配置 redis 相关的配置项（如：数据源、连接池等配置信息）\n\n# 缓存类型，支持类型：GENERIC、JCACHE、EHCACHE、HAZELCAST、INFINISPAN、COUCHBASE、REDIS、CAFFEINE、SIMPLE\nspring.cache.type = redis\n# 全局缓存时间\nspring.cache.redis.time-to-live = 60s\n\n# Redis 配置\nspring.redis.database = 0\nspring.redis.host = localhost\nspring.redis.port = 6379\nspring.redis.password =\n\n\n（3）使用 @EnableCaching 开启缓存\n\n@EnableCaching\n@SpringBootApplication\npublic class Application {\n    // ...\n}\n\n\n（4）缓存注解（@Cacheable、@CachePut、@CacheEvit 等）使用方式与 Spring Cache 完全一样\n\n\n# 四、JetCache\n\n> JetCache 是一个基于 Java 的缓存系统封装，提供统一的 API 和注解来简化缓存的使用。 JetCache 提供了比 SpringCache 更加强大的注解，可以原生的支持 TTL、两级缓存、分布式自动刷新，还提供了Cache接口用于手工缓存操作。 当前有四个实现，RedisCache、TairCache（此部分未在 github 开源）、CaffeineCache(in memory)和一个简易的LinkedHashMapCache(in memory)，要添加新的实现也是非常简单的。\n> \n> 详见：jetcache Github\n\n\n# jetcache 快速入门\n\n如果使用 Spring Boot，可以按如下的方式配置（这里使用了 jedis 客户端连接 redis，如果需要集群、读写分离、异步等特性支持请使用lettuce客户端）。\n\n（1）引入 POM\n\n<dependency>\n    <groupId>com.alicp.jetcache</groupId>\n    <artifactId>jetcache-starter-redis</artifactId>\n    <version>2.5.14</version>\n</dependency>\n\n\n（2）配置\n\n配置一个 spring boot 风格的 application.yml 文件，把他放到资源目录中\n\njetcache:\n  statIntervalMinutes: 15\n  areaInCacheName: false\n  local:\n    default:\n      type: linkedhashmap\n      keyConvertor: fastjson\n  remote:\n    default:\n      type: redis\n      keyConvertor: fastjson\n      valueEncoder: java\n      valueDecoder: java\n      poolConfig:\n        minIdle: 5\n        maxIdle: 20\n        maxTotal: 50\n      host: 127.0.0.1\n      port: 6379\n\n\n（3）开启缓存\n\n然后创建一个 App 类放在业务包的根下，EnableMethodCache，EnableCreateCacheAnnotation 这两个注解分别激活 Cached 和 CreateCache 注解，其他和标准的 Spring Boot 程序是一样的。这个类可以直接 main 方法运行。\n\npackage com.company.mypackage;\n\nimport com.alicp.jetcache.anno.config.EnableCreateCacheAnnotation;\nimport com.alicp.jetcache.anno.config.EnableMethodCache;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\n@EnableMethodCache(basePackages = "com.company.mypackage")\n@EnableCreateCacheAnnotation\npublic class MySpringBootApp {\n    public static void main(String[] args) {\n        SpringApplication.run(MySpringBootApp.class);\n    }\n}\n\n\n（4）API 基本使用\n\n创建缓存实例\n\n通过 @CreateCache 注解创建一个缓存实例，默认超时时间是 100 秒\n\n@CreateCache(expire = 100)\nprivate Cache<Long, UserDO> userCache;\n\n\n用起来就像 map 一样\n\nUserDO user = userCache.get(123L);\nuserCache.put(123L, user);\nuserCache.remove(123L);\n\n\n创建一个两级（内存+远程）的缓存，内存中的元素个数限制在 50 个。\n\n@CreateCache(name = "UserService.userCache", expire = 100, cacheType = CacheType.BOTH, localLimit = 50)\nprivate Cache<Long, UserDO> userCache;\n\n\nname 属性不是必须的，但是起个名字是个好习惯，展示统计数据的使用，会使用这个名字。如果同一个 area 两个 @CreateCache 的 name 配置一样，它们生成的 Cache 将指向同一个实例。\n\n创建方法缓存\n\n使用 @Cached 方法可以为一个方法添加上缓存。JetCache 通过 Spring AOP 生成代理，来支持缓存功能。注解可以加在接口方法上也可以加在类方法上，但需要保证是个 Spring bean。\n\npublic interface UserService {\n    @Cached(name="UserService.getUserById", expire = 3600)\n    User getUserById(long userId);\n}\n\n\n\n# 五、j2cache\n\n\n# 六、总结\n\n使用缓存框架，使得开发缓存功能非常便捷。\n\n如果你的系统只需要使用一种缓存，那么推荐使用 Spring Boot Cache。Spring Boot Cache 在 Spring Cache 基础上做了封装，使用更简单、方便。\n\n如果你的系统需要使用多级缓存，那么推荐使用 jetcache。\n\n\n# 参考资料\n\n * JSR107\n * Spring Cache 官方文档\n * Spring Boot Cache 特性官方文档\n * J2Cache Gitee\n * jetcache Github\n * jetcache wiki',normalizedContent:'# java 缓存中间件\n\n> 关键词：spring cache、j2cache、jetcache\n\n\n# 一 、jsr 107\n\njsr107 中制订了 java 缓存的规范。\n\n因此，在很多缓存框架、缓存库中，其 api 都参考了 jsr 107 规范。\n\n\n\njava caching 定义了 5 个核心接口\n\n * cachingprovider - 定义了创建、配置、获取、管理和控制多个 cachemanager。一个应用可以在运行期访问多个 cachingprovider。\n * cachemanager - 定义了创建、配置、获取、管理和控制多个唯一命名的 cache，这些 cache 存在于 cachemanager 的上下文中。一个 cachemanager 仅被一个 cachingprovider 所拥有。\n * cache - 是一个类似 map 的数据结构并临时存储以 key 为索引的值。一个 cache 仅被一个 cachemanager 所拥有。\n * entry - 是一个存储在 cache 中的 key-value 对。\n * expiry - 每一个存储在 cache 中的条目有一个定义的有效期，即 expiry duration。一旦超过这个时间，条目为过期的状态。一旦过期，条目将不可访问、更新和删除。缓存有效期可以通过 expirypolicy 设置。\n\n\n# 二、spring cache\n\n> 详见：spring cache 官方文档\n\nspring 作为 java 开发最著名的框架，也提供了缓存功能的框架—— spring cache。\n\nspring 支持基于注释（annotation）的缓存（cache）技术，它本质上不是一个具体的缓存实现方案（例如：ehcache 或 oscache），而是一个对缓存使用的抽象，通过在既有代码中添加少量它定义的各种 annotation，即能够达到缓存方法的返回对象的效果。\n\nspring cache 的特点：\n\n * 通过缓存注解即可支持缓存功能\n * 支持 spring el 表达式\n * 支持 aspectj\n * 支持自定义 key 和缓存管理\n\n\n# 开启缓存注解\n\nspring 为缓存功能提供了注解功能，但是你必须启动注解。\n\n有两种方式：\n\n（一）使用标记注解 @enablecaching\n\n这种方式对于 spring 或 spring boot 项目都适用。\n\n@configuration\n@enablecaching\npublic class appconfig {\n}\n\n\n（二）在 xml 中声明\n\n<cache:annotation-driven cache-manager="cachemanager"/>\n\n\n\n# spring 缓存注解 api\n\nspring 对缓存的支持类似于对事务的支持。\n\n首先使用注解标记方法，相当于定义了切点，然后使用 aop 技术在这个方法的调用前、调用后获取方法的入参和返回值，进而实现了缓存的逻辑。\n\n# @cacheable\n\n@cacheable 用于触发缓存。\n\n表明所修饰的方法是可以缓存的：当第一次调用这个方法时，它的结果会被缓存下来，在缓存的有效时间内，以后访问这个方法都直接返回缓存结果，不再执行方法中的代码段。\n\n这个注解可以用condition属性来设置条件，如果不满足条件，就不使用缓存能力，直接执行方法。\n\n可以使用key属性来指定 key 的生成规则。\n\n# @cacheput\n\n@cacheput 用于更新缓存。\n\n与@cacheable不同，@cacheput不仅会缓存方法的结果，还会执行方法的代码段。\n\n它支持的属性和用法都与@cacheable一致。\n\n# @cacheevict\n\n@cacheevict 用于清除缓存。\n\n与@cacheable功能相反，@cacheevict表明所修饰的方法是用来删除失效或无用的缓存数据。\n\n下面是@cacheable、@cacheevict和@cacheput基本使用方法的一个集中展示：\n\n@service\npublic class userservice {\n    // @cacheable可以设置多个缓存，形式如：@cacheable({"books", "isbns"})\n    @cacheable(value={"users"}, key="#user.id")\n    public user finduser(user user) {\n        return finduserindb(user.getid());\n    }\n\n    @cacheable(value = "users", condition = "#user.getid() <= 2")\n    public user finduserinlimit(user user) {\n        return finduserindb(user.getid());\n    }\n\n    @cacheput(value = "users", key = "#user.getid()")\n    public void updateuser(user user) {\n        updateuserindb(user);\n    }\n\n    @cacheevict(value = "users")\n    public void removeuser(user user) {\n        removeuserindb(user.getid());\n    }\n\n    @cacheevict(value = "users", allentries = true)\n    public void clear() {\n        removeallindb();\n    }\n}\n\n\n# @caching\n\n@caching 用于组合定义多种缓存功能。\n\n如果需要使用同一个缓存注解（@cacheable、@cacheevict或@cacheput）多次修饰一个方法，就需要用到@caching。\n\n@caching(evict = { @cacheevict("primary"), @cacheevict(cachenames="secondary", key="#p0") })\npublic book importbooks(string deposit, date date)\n\n\n# @cacheconfig\n\n@cacheconfig 用于定义公共缓存配置。\n\n与前面的缓存注解不同，这是一个类级别的注解。\n\n如果类的所有操作都是缓存操作，你可以使用@cacheconfig来指定类，省去一些配置。\n\n@cacheconfig("books")\npublic class bookrepositoryimpl implements bookrepository {\n @cacheable\n public book findbook(isbn isbn) {...}\n}\n\n\n\n# 三、spring boot cache\n\n> 详见：spring boot cache 特性官方文档\n\nspring boot cache 是在 spring cache 的基础上做了封装，使得使用更为便捷。\n\n\n# spring boot cache 快速入门\n\n（1）引入依赖\n\n<dependency>\n  <groupid>org.springframework.boot</groupid>\n  <artifactid>spring-boot-starter-cache</artifactid>\n</dependency>\n\n\x3c!-- 按序引入需要的缓存库 --\x3e\n<dependency>\n  <groupid>org.springframework.boot</groupid>\n  <artifactid>spring-boot-starter-data-redis</artifactid>\n</dependency>\n\n\n（2）缓存配置\n\n例如，选用缓存为 redis，则需要配置 redis 相关的配置项（如：数据源、连接池等配置信息）\n\n# 缓存类型，支持类型：generic、jcache、ehcache、hazelcast、infinispan、couchbase、redis、caffeine、simple\nspring.cache.type = redis\n# 全局缓存时间\nspring.cache.redis.time-to-live = 60s\n\n# redis 配置\nspring.redis.database = 0\nspring.redis.host = localhost\nspring.redis.port = 6379\nspring.redis.password =\n\n\n（3）使用 @enablecaching 开启缓存\n\n@enablecaching\n@springbootapplication\npublic class application {\n    // ...\n}\n\n\n（4）缓存注解（@cacheable、@cacheput、@cacheevit 等）使用方式与 spring cache 完全一样\n\n\n# 四、jetcache\n\n> jetcache 是一个基于 java 的缓存系统封装，提供统一的 api 和注解来简化缓存的使用。 jetcache 提供了比 springcache 更加强大的注解，可以原生的支持 ttl、两级缓存、分布式自动刷新，还提供了cache接口用于手工缓存操作。 当前有四个实现，rediscache、taircache（此部分未在 github 开源）、caffeinecache(in memory)和一个简易的linkedhashmapcache(in memory)，要添加新的实现也是非常简单的。\n> \n> 详见：jetcache github\n\n\n# jetcache 快速入门\n\n如果使用 spring boot，可以按如下的方式配置（这里使用了 jedis 客户端连接 redis，如果需要集群、读写分离、异步等特性支持请使用lettuce客户端）。\n\n（1）引入 pom\n\n<dependency>\n    <groupid>com.alicp.jetcache</groupid>\n    <artifactid>jetcache-starter-redis</artifactid>\n    <version>2.5.14</version>\n</dependency>\n\n\n（2）配置\n\n配置一个 spring boot 风格的 application.yml 文件，把他放到资源目录中\n\njetcache:\n  statintervalminutes: 15\n  areaincachename: false\n  local:\n    default:\n      type: linkedhashmap\n      keyconvertor: fastjson\n  remote:\n    default:\n      type: redis\n      keyconvertor: fastjson\n      valueencoder: java\n      valuedecoder: java\n      poolconfig:\n        minidle: 5\n        maxidle: 20\n        maxtotal: 50\n      host: 127.0.0.1\n      port: 6379\n\n\n（3）开启缓存\n\n然后创建一个 app 类放在业务包的根下，enablemethodcache，enablecreatecacheannotation 这两个注解分别激活 cached 和 createcache 注解，其他和标准的 spring boot 程序是一样的。这个类可以直接 main 方法运行。\n\npackage com.company.mypackage;\n\nimport com.alicp.jetcache.anno.config.enablecreatecacheannotation;\nimport com.alicp.jetcache.anno.config.enablemethodcache;\nimport org.springframework.boot.springapplication;\nimport org.springframework.boot.autoconfigure.springbootapplication;\n\n@springbootapplication\n@enablemethodcache(basepackages = "com.company.mypackage")\n@enablecreatecacheannotation\npublic class myspringbootapp {\n    public static void main(string[] args) {\n        springapplication.run(myspringbootapp.class);\n    }\n}\n\n\n（4）api 基本使用\n\n创建缓存实例\n\n通过 @createcache 注解创建一个缓存实例，默认超时时间是 100 秒\n\n@createcache(expire = 100)\nprivate cache<long, userdo> usercache;\n\n\n用起来就像 map 一样\n\nuserdo user = usercache.get(123l);\nusercache.put(123l, user);\nusercache.remove(123l);\n\n\n创建一个两级（内存+远程）的缓存，内存中的元素个数限制在 50 个。\n\n@createcache(name = "userservice.usercache", expire = 100, cachetype = cachetype.both, locallimit = 50)\nprivate cache<long, userdo> usercache;\n\n\nname 属性不是必须的，但是起个名字是个好习惯，展示统计数据的使用，会使用这个名字。如果同一个 area 两个 @createcache 的 name 配置一样，它们生成的 cache 将指向同一个实例。\n\n创建方法缓存\n\n使用 @cached 方法可以为一个方法添加上缓存。jetcache 通过 spring aop 生成代理，来支持缓存功能。注解可以加在接口方法上也可以加在类方法上，但需要保证是个 spring bean。\n\npublic interface userservice {\n    @cached(name="userservice.getuserbyid", expire = 3600)\n    user getuserbyid(long userid);\n}\n\n\n\n# 五、j2cache\n\n\n# 六、总结\n\n使用缓存框架，使得开发缓存功能非常便捷。\n\n如果你的系统只需要使用一种缓存，那么推荐使用 spring boot cache。spring boot cache 在 spring cache 基础上做了封装，使用更简单、方便。\n\n如果你的系统需要使用多级缓存，那么推荐使用 jetcache。\n\n\n# 参考资料\n\n * jsr107\n * spring cache 官方文档\n * spring boot cache 特性官方文档\n * j2cache gitee\n * jetcache github\n * jetcache wiki',charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Java 进程内缓存",frontmatter:{title:"Java 进程内缓存",date:"2022-02-17T22:34:30.000Z",order:5,categories:["Java","中间件","缓存"],tags:["Java","中间件","缓存"],permalink:"/pages/59f078/"},regularPath:"/01.Java/14.%E4%B8%AD%E9%97%B4%E4%BB%B6/02.%E7%BC%93%E5%AD%98/05.Java%E8%BF%9B%E7%A8%8B%E5%86%85%E7%BC%93%E5%AD%98.html",relativePath:"01.Java/14.中间件/02.缓存/05.Java进程内缓存.md",key:"v-79787bec",path:"/pages/59f078/",headers:[{level:2,title:"一、ConcurrentHashMap",slug:"一、concurrenthashmap",normalizedTitle:"一、concurrenthashmap",charIndex:82},{level:2,title:"二、LRUHashMap",slug:"二、lruhashmap",normalizedTitle:"二、lruhashmap",charIndex:203},{level:2,title:"三、Guava Cache",slug:"三、guava-cache",normalizedTitle:"三、guava cache",charIndex:1310},{level:3,title:"Guava Cache 缓存回收",slug:"guava-cache-缓存回收",normalizedTitle:"guava cache 缓存回收",charIndex:1735},{level:3,title:"基于容量回收",slug:"基于容量回收",normalizedTitle:"基于容量回收",charIndex:1785},{level:3,title:"基于定时回收",slug:"基于定时回收",normalizedTitle:"基于定时回收",charIndex:1836},{level:3,title:"基于引用回收",slug:"基于引用回收",normalizedTitle:"基于引用回收",charIndex:1415},{level:3,title:"Guava Cache 核心 API",slug:"guava-cache-核心-api",normalizedTitle:"guava cache 核心 api",charIndex:2274},{level:4,title:"CacheBuilder",slug:"cachebuilder",normalizedTitle:"cachebuilder",charIndex:1455},{level:4,title:"LocalManualCache",slug:"localmanualcache",normalizedTitle:"localmanualcache",charIndex:2475},{level:4,title:"LocalLoadingCache",slug:"localloadingcache",normalizedTitle:"localloadingcache",charIndex:2581},{level:4,title:"LocalCache",slug:"localcache",normalizedTitle:"localcache",charIndex:1497},{level:2,title:"四、Caffeine",slug:"四、caffeine",normalizedTitle:"四、caffeine",charIndex:2876},{level:2,title:"五、Ehcache",slug:"五、ehcache",normalizedTitle:"五、ehcache",charIndex:3030},{level:2,title:"六、进程内缓存对比",slug:"六、进程内缓存对比",normalizedTitle:"六、进程内缓存对比",charIndex:3058},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:4513}],headersStr:"一、ConcurrentHashMap 二、LRUHashMap 三、Guava Cache Guava Cache 缓存回收 基于容量回收 基于定时回收 基于引用回收 Guava Cache 核心 API CacheBuilder LocalManualCache LocalLoadingCache LocalCache 四、Caffeine 五、Ehcache 六、进程内缓存对比 参考资料",content:"# Java 进程内缓存\n\n> 关键词：ConcurrentHashMap、LRUHashMap、Guava Cache、Caffeine、Ehcache\n\n\n# 一、ConcurrentHashMap\n\n最简单的进程内缓存可以通过 JDK 自带的 HashMap 或 ConcurrentHashMap 实现。\n\n适用场景：不需要淘汰的缓存数据。\n\n缺点：无法进行缓存淘汰，内存会无限制的增长。\n\n\n# 二、LRUHashMap\n\n可以通过继承 LinkedHashMap 来实现一个简单的 LRUHashMap，即可完成一个简单的 **LRU （最近最少使用）**算法。\n\n缺点：\n\n * 锁竞争严重，性能比较低。\n * 不支持过期时间\n * 不支持自动刷新\n\n【示例】LRUHashMap 的简单实现\n\nclass LRUCache extends LinkedHashMap {\n\n    private final int max;\n    private Object lock;\n\n    public LRUCache(int max) {\n        //无需扩容\n        super((int) (max * 1.4f), 0.75f, true);\n        this.max = max;\n        this.lock = new Object();\n    }\n\n    /**\n     * 重写LinkedHashMap的removeEldestEntry方法即可 在Put的时候判断，如果为true，就会删除最老的\n     *\n     * @param eldest\n     * @return\n     */\n    @Override\n    protected boolean removeEldestEntry(Map.Entry eldest) {\n        return size() > max;\n    }\n\n    public Object getValue(Object key) {\n        synchronized (lock) {\n            return get(key);\n        }\n    }\n\n    public void putValue(Object key, Object value) {\n        synchronized (lock) {\n            put(key, value);\n        }\n    }\n\n    public boolean removeValue(Object key) {\n        synchronized (lock) {\n            return remove(key) != null;\n        }\n    }\n\n    public boolean removeAll() {\n        clear();\n        return true;\n    }\n\n}\n\n\n\n# 三、Guava Cache\n\nGuava Cache 解决了 LRUHashMap 中的几个缺点。\n\nGuava Cache 提供了基于容量，时间和引用的缓存回收方式。基于容量的方式内部实现采用 LRU 算法，基于引用回收很好的利用了 Java 虚拟机的垃圾回收机制。\n\n其中的缓存构造器 CacheBuilder 采用构建者模式提供了设置好各种参数的缓存对象。缓存核心类 LocalCache 里面的内部类 Segment 与 jdk1.7 及以前的 ConcurrentHashMap 非常相似，分段加锁，减少锁竞争，并且都继承于 ReetrantLock，还有六个队列，以实现丰富的本地缓存方案。Guava Cache 对于过期的 Entry 并没有马上过期(也就是并没有后台线程一直在扫)，而是通过进行读写操作的时候进行过期处理，这样做的好处是避免后台线程扫描的时候进行全局加锁。\n\n直接通过查询，判断其是否满足刷新条件，进行刷新。\n\n\n# Guava Cache 缓存回收\n\nGuava Cache 提供了三种基本的缓存回收方式。\n\n\n# 基于容量回收\n\nmaximumSize(long)：当缓存中的元素数量超过指定值时触发回收。\n\n\n# 基于定时回收\n\n * expireAfterAccess(long, TimeUnit)：缓存项在给定时间内没有被读/写访问，则回收。请注意这种缓存的回收顺序和基于大小回收一样。\n * expireAfterWrite(long, TimeUnit)：缓存项在给定时间内没有被写访问（创建或覆盖），则回收。如果认为缓存数据总是在固定时候后变得陈旧不可用，这种回收方式是可取的。\n\n如下文所讨论，定时回收周期性地在写操作中执行，偶尔在读操作中执行。\n\n\n# 基于引用回收\n\n * CacheBuilder.weakKeys()：使用弱引用存储键。当键没有其它（强或软）引用时，缓存项可以被垃圾回收。\n * CacheBuilder.weakValues()：使用弱引用存储值。当值没有其它（强或软）引用时，缓存项可以被垃圾回收。\n * CacheBuilder.softValues()：使用软引用存储值。软引用只有在响应内存需要时，才按照全局最近最少使用的顺序回收。\n\n\n# Guava Cache 核心 API\n\n# CacheBuilder\n\n缓存构建器。构建缓存的入口，指定缓存配置参数并初始化本地缓存。 主要采用 builder 的模式，CacheBuilder 的每一个方法都返回这个 CacheBuilder 知道 build 方法的调用。 注意 build 方法有重载，带有参数的为构建一个具有数据加载功能的缓存，不带参数的构建一个没有数据加载功能的缓存。\n\n# LocalManualCache\n\n作为 LocalCache 的一个内部类，在构造方法里面会把 LocalCache 类型的变量传入，并且调用方法时都直接或者间接调用 LocalCache 里面的方法。\n\n# LocalLoadingCache\n\n可以看到该类继承了 LocalManualCache 并实现接口 LoadingCache。 覆盖了 get，getUnchecked 等方法。\n\n# LocalCache\n\nGuava Cache 中的核心类，重点了解。\n\nLocalCache 的数据结构与 ConcurrentHashMap 很相似，都由多个 segment 组成，且各 segment 相对独立，互不影响，所以能支持并行操作。每个 segment 由一个 table 和若干队列组成。缓存数据存储在 table 中，其类型为 AtomicReferenceArray。\n\n\n# 四、Caffeine\n\n> caffeine 是一个使用 JDK8 改进 Guava 缓存的高性能缓存库。\n\nCaffeine 实现了 W-TinyLFU(LFU + LRU 算法的变种)，其命中率和读写吞吐量大大优于 Guava Cache。\n\n其实现原理较复杂，可以参考你应该知道的缓存进化史。\n\n\n# 五、Ehcache\n\n> 参考：Ehcache\n\n\n# 六、进程内缓存对比\n\n常用进程内缓存技术对比：\n\n比较项      CONCURRENTHASHMAP   LRUMAP                EHCACHE                 GUAVA CACHE             CAFFEINE\n读写性能     很好，分段锁              一般，全局加锁               好                       好，需要做淘汰操作               很好\n淘汰算法     无                   LRU，一般                支持多种淘汰算法,LRU,LFU,FIFO   LRU，一般                  W-TinyLFU, 很好\n功能丰富程度   功能比较简单              功能比较单一                功能很丰富                   功能很丰富，支持刷新和虚引用等         功能和 Guava Cache 类似\n工具大小     jdk 自带类，很小          基于 LinkedHashMap，较小   很大，最新版本 1.4MB           是 Guava 工具类中的一个小部分，较小   一般，最新版本 644KB\n是否持久化    否                   否                     是                       否                       否\n是否支持集群   否                   否                     是                       否                       否\n\n * ConcurrentHashMap - 比较适合缓存比较固定不变的元素，且缓存的数量较小的。虽然从上面表格中比起来有点逊色，但是其由于是 JDK 自带的类，在各种框架中依然有大量的使用，比如我们可以用来缓存我们反射的 Method，Field 等等；也可以缓存一些链接，防止其重复建立。在 Caffeine 中也是使用的 ConcurrentHashMap 来存储元素。\n * LRUMap - 如果不想引入第三方包，又想使用淘汰算法淘汰数据，可以使用这个。\n * Ehcache - 由于其 jar 包很大，较重量级。对于需要持久化和集群的一些功能的，可以选择 Ehcache。需要注意的是，虽然 Ehcache 也支持分布式缓存，但是由于其节点间通信方式为 rmi，表现不如 Redis，所以一般不建议用它来作为分布式缓存。\n * Guava Cache - Guava 这个 jar 包在很多 Java 应用程序中都有大量的引入，所以很多时候其实是直接用就好了，并且其本身是轻量级的而且功能较为丰富，在不了解 Caffeine 的情况下可以选择 Guava Cache。\n * Caffeine - 其在命中率，读写性能上都比 Guava Cache 好很多，并且其 API 和 Guava cache 基本一致，甚至会多一点。在真实环境中使用 Caffeine，取得过不错的效果。\n\n总结一下：如果不需要淘汰算法则选择 ConcurrentHashMap，如果需要淘汰算法和一些丰富的 API，推荐选择 Caffeine。\n\n\n# 参考资料\n\n * caffeine github\n * 深入解密来自未来的缓存-Caffeine\n * Caffeine 缓存\n * Google Guava 官方教程（中文版）\n * Google Guava Cache 全解析\n * 注释驱动的 Spring cache 缓存介绍",normalizedContent:"# java 进程内缓存\n\n> 关键词：concurrenthashmap、lruhashmap、guava cache、caffeine、ehcache\n\n\n# 一、concurrenthashmap\n\n最简单的进程内缓存可以通过 jdk 自带的 hashmap 或 concurrenthashmap 实现。\n\n适用场景：不需要淘汰的缓存数据。\n\n缺点：无法进行缓存淘汰，内存会无限制的增长。\n\n\n# 二、lruhashmap\n\n可以通过继承 linkedhashmap 来实现一个简单的 lruhashmap，即可完成一个简单的 **lru （最近最少使用）**算法。\n\n缺点：\n\n * 锁竞争严重，性能比较低。\n * 不支持过期时间\n * 不支持自动刷新\n\n【示例】lruhashmap 的简单实现\n\nclass lrucache extends linkedhashmap {\n\n    private final int max;\n    private object lock;\n\n    public lrucache(int max) {\n        //无需扩容\n        super((int) (max * 1.4f), 0.75f, true);\n        this.max = max;\n        this.lock = new object();\n    }\n\n    /**\n     * 重写linkedhashmap的removeeldestentry方法即可 在put的时候判断，如果为true，就会删除最老的\n     *\n     * @param eldest\n     * @return\n     */\n    @override\n    protected boolean removeeldestentry(map.entry eldest) {\n        return size() > max;\n    }\n\n    public object getvalue(object key) {\n        synchronized (lock) {\n            return get(key);\n        }\n    }\n\n    public void putvalue(object key, object value) {\n        synchronized (lock) {\n            put(key, value);\n        }\n    }\n\n    public boolean removevalue(object key) {\n        synchronized (lock) {\n            return remove(key) != null;\n        }\n    }\n\n    public boolean removeall() {\n        clear();\n        return true;\n    }\n\n}\n\n\n\n# 三、guava cache\n\nguava cache 解决了 lruhashmap 中的几个缺点。\n\nguava cache 提供了基于容量，时间和引用的缓存回收方式。基于容量的方式内部实现采用 lru 算法，基于引用回收很好的利用了 java 虚拟机的垃圾回收机制。\n\n其中的缓存构造器 cachebuilder 采用构建者模式提供了设置好各种参数的缓存对象。缓存核心类 localcache 里面的内部类 segment 与 jdk1.7 及以前的 concurrenthashmap 非常相似，分段加锁，减少锁竞争，并且都继承于 reetrantlock，还有六个队列，以实现丰富的本地缓存方案。guava cache 对于过期的 entry 并没有马上过期(也就是并没有后台线程一直在扫)，而是通过进行读写操作的时候进行过期处理，这样做的好处是避免后台线程扫描的时候进行全局加锁。\n\n直接通过查询，判断其是否满足刷新条件，进行刷新。\n\n\n# guava cache 缓存回收\n\nguava cache 提供了三种基本的缓存回收方式。\n\n\n# 基于容量回收\n\nmaximumsize(long)：当缓存中的元素数量超过指定值时触发回收。\n\n\n# 基于定时回收\n\n * expireafteraccess(long, timeunit)：缓存项在给定时间内没有被读/写访问，则回收。请注意这种缓存的回收顺序和基于大小回收一样。\n * expireafterwrite(long, timeunit)：缓存项在给定时间内没有被写访问（创建或覆盖），则回收。如果认为缓存数据总是在固定时候后变得陈旧不可用，这种回收方式是可取的。\n\n如下文所讨论，定时回收周期性地在写操作中执行，偶尔在读操作中执行。\n\n\n# 基于引用回收\n\n * cachebuilder.weakkeys()：使用弱引用存储键。当键没有其它（强或软）引用时，缓存项可以被垃圾回收。\n * cachebuilder.weakvalues()：使用弱引用存储值。当值没有其它（强或软）引用时，缓存项可以被垃圾回收。\n * cachebuilder.softvalues()：使用软引用存储值。软引用只有在响应内存需要时，才按照全局最近最少使用的顺序回收。\n\n\n# guava cache 核心 api\n\n# cachebuilder\n\n缓存构建器。构建缓存的入口，指定缓存配置参数并初始化本地缓存。 主要采用 builder 的模式，cachebuilder 的每一个方法都返回这个 cachebuilder 知道 build 方法的调用。 注意 build 方法有重载，带有参数的为构建一个具有数据加载功能的缓存，不带参数的构建一个没有数据加载功能的缓存。\n\n# localmanualcache\n\n作为 localcache 的一个内部类，在构造方法里面会把 localcache 类型的变量传入，并且调用方法时都直接或者间接调用 localcache 里面的方法。\n\n# localloadingcache\n\n可以看到该类继承了 localmanualcache 并实现接口 loadingcache。 覆盖了 get，getunchecked 等方法。\n\n# localcache\n\nguava cache 中的核心类，重点了解。\n\nlocalcache 的数据结构与 concurrenthashmap 很相似，都由多个 segment 组成，且各 segment 相对独立，互不影响，所以能支持并行操作。每个 segment 由一个 table 和若干队列组成。缓存数据存储在 table 中，其类型为 atomicreferencearray。\n\n\n# 四、caffeine\n\n> caffeine 是一个使用 jdk8 改进 guava 缓存的高性能缓存库。\n\ncaffeine 实现了 w-tinylfu(lfu + lru 算法的变种)，其命中率和读写吞吐量大大优于 guava cache。\n\n其实现原理较复杂，可以参考你应该知道的缓存进化史。\n\n\n# 五、ehcache\n\n> 参考：ehcache\n\n\n# 六、进程内缓存对比\n\n常用进程内缓存技术对比：\n\n比较项      concurrenthashmap   lrumap                ehcache                 guava cache             caffeine\n读写性能     很好，分段锁              一般，全局加锁               好                       好，需要做淘汰操作               很好\n淘汰算法     无                   lru，一般                支持多种淘汰算法,lru,lfu,fifo   lru，一般                  w-tinylfu, 很好\n功能丰富程度   功能比较简单              功能比较单一                功能很丰富                   功能很丰富，支持刷新和虚引用等         功能和 guava cache 类似\n工具大小     jdk 自带类，很小          基于 linkedhashmap，较小   很大，最新版本 1.4mb           是 guava 工具类中的一个小部分，较小   一般，最新版本 644kb\n是否持久化    否                   否                     是                       否                       否\n是否支持集群   否                   否                     是                       否                       否\n\n * concurrenthashmap - 比较适合缓存比较固定不变的元素，且缓存的数量较小的。虽然从上面表格中比起来有点逊色，但是其由于是 jdk 自带的类，在各种框架中依然有大量的使用，比如我们可以用来缓存我们反射的 method，field 等等；也可以缓存一些链接，防止其重复建立。在 caffeine 中也是使用的 concurrenthashmap 来存储元素。\n * lrumap - 如果不想引入第三方包，又想使用淘汰算法淘汰数据，可以使用这个。\n * ehcache - 由于其 jar 包很大，较重量级。对于需要持久化和集群的一些功能的，可以选择 ehcache。需要注意的是，虽然 ehcache 也支持分布式缓存，但是由于其节点间通信方式为 rmi，表现不如 redis，所以一般不建议用它来作为分布式缓存。\n * guava cache - guava 这个 jar 包在很多 java 应用程序中都有大量的引入，所以很多时候其实是直接用就好了，并且其本身是轻量级的而且功能较为丰富，在不了解 caffeine 的情况下可以选择 guava cache。\n * caffeine - 其在命中率，读写性能上都比 guava cache 好很多，并且其 api 和 guava cache 基本一致，甚至会多一点。在真实环境中使用 caffeine，取得过不错的效果。\n\n总结一下：如果不需要淘汰算法则选择 concurrenthashmap，如果需要淘汰算法和一些丰富的 api，推荐选择 caffeine。\n\n\n# 参考资料\n\n * caffeine github\n * 深入解密来自未来的缓存-caffeine\n * caffeine 缓存\n * google guava 官方教程（中文版）\n * google guava cache 全解析\n * 注释驱动的 spring cache 缓存介绍",charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Ehcache 快速入门",frontmatter:{title:"Ehcache 快速入门",date:"2022-02-17T22:34:30.000Z",order:4,categories:["Java","中间件","缓存"],tags:["Java","中间件","缓存","Ehcache"],permalink:"/pages/5f7893/"},regularPath:"/01.Java/14.%E4%B8%AD%E9%97%B4%E4%BB%B6/02.%E7%BC%93%E5%AD%98/04.Ehcache.html",relativePath:"01.Java/14.中间件/02.缓存/04.Ehcache.md",key:"v-0cc297da",path:"/pages/5f7893/",headers:[{level:2,title:"一、简介",slug:"一、简介",normalizedTitle:"一、简介",charIndex:94},{level:3,title:"Ehcache 特性",slug:"ehcache-特性",normalizedTitle:"ehcache 特性",charIndex:157},{level:3,title:"Ehcache 集群",slug:"ehcache-集群",normalizedTitle:"ehcache 集群",charIndex:450},{level:4,title:"RMI",slug:"rmi",normalizedTitle:"rmi",charIndex:271},{level:4,title:"JMS",slug:"jms",normalizedTitle:"jms",charIndex:493},{level:4,title:"Cache Server",slug:"cache-server",normalizedTitle:"cache server",charIndex:676},{level:2,title:"二、快速入门",slug:"二、快速入门",normalizedTitle:"二、快速入门",charIndex:695},{level:3,title:"引入 Ehcache",slug:"引入-ehcache",normalizedTitle:"引入 ehcache",charIndex:706},{level:3,title:"添加配置文件",slug:"添加配置文件",normalizedTitle:"添加配置文件",charIndex:1254},{level:3,title:"Ehcache 工作示例",slug:"ehcache-工作示例",normalizedTitle:"ehcache 工作示例",charIndex:2120},{level:2,title:"三、Ehcache API",slug:"三、ehcache-api",normalizedTitle:"三、ehcache api",charIndex:3136},{level:3,title:"创建 CacheManager",slug:"创建-cachemanager",normalizedTitle:"创建 cachemanager",charIndex:3405},{level:3,title:"添加缓存",slug:"添加缓存",normalizedTitle:"添加缓存",charIndex:4557},{level:3,title:"删除缓存",slug:"删除缓存",normalizedTitle:"删除缓存",charIndex:5716},{level:3,title:"基本缓存操作",slug:"基本缓存操作",normalizedTitle:"基本缓存操作",charIndex:5868},{level:2,title:"四、Ehcache 配置",slug:"四、ehcache-配置",normalizedTitle:"四、ehcache 配置",charIndex:7607},{level:3,title:"xml 配置方式",slug:"xml-配置方式",normalizedTitle:"xml 配置方式",charIndex:7692},{level:3,title:"API 配置方式",slug:"api-配置方式",normalizedTitle:"api 配置方式",charIndex:8641},{level:2,title:"五、Spring 集成 Ehcache",slug:"五、spring-集成-ehcache",normalizedTitle:"五、spring 集成 ehcache",charIndex:9106},{level:3,title:"绑定 Ehcache",slug:"绑定-ehcache",normalizedTitle:"绑定 ehcache",charIndex:9304},{level:3,title:"使用 Spring 的缓存注解",slug:"使用-spring-的缓存注解",normalizedTitle:"使用 spring 的缓存注解",charIndex:10476},{level:4,title:"开启注解",slug:"开启注解",normalizedTitle:"开启注解",charIndex:10495},{level:3,title:"注解基本使用方法",slug:"注解基本使用方法",normalizedTitle:"注解基本使用方法",charIndex:10785},{level:4,title:"@Cacheable",slug:"cacheable",normalizedTitle:"@cacheable",charIndex:10904},{level:4,title:"@CachePut",slug:"cacheput",normalizedTitle:"@cacheput",charIndex:11071},{level:4,title:"@CacheEvict",slug:"cacheevict",normalizedTitle:"@cacheevict",charIndex:11156},{level:4,title:"@Caching",slug:"caching",normalizedTitle:"@caching",charIndex:12030},{level:4,title:"@CacheConfig",slug:"cacheconfig",normalizedTitle:"@cacheconfig",charIndex:12260},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:12483}],headersStr:"一、简介 Ehcache 特性 Ehcache 集群 RMI JMS Cache Server 二、快速入门 引入 Ehcache 添加配置文件 Ehcache 工作示例 三、Ehcache API 创建 CacheManager 添加缓存 删除缓存 基本缓存操作 四、Ehcache 配置 xml 配置方式 API 配置方式 五、Spring 集成 Ehcache 绑定 Ehcache 使用 Spring 的缓存注解 开启注解 注解基本使用方法 @Cacheable @CachePut @CacheEvict @Caching @CacheConfig 参考资料",content:'# Ehcache 快速入门\n\n> EhCache 是一个纯 Java 的进程内缓存框架，具有快速、精干等特点，是 Hibernate 中默认的 CacheProvider。\n\n\n\n\n# 一、简介\n\n> Ehcache 虽然也支持分布式模式，但是分布式方案不是很好好，建议只将其作为单机的进程内缓存使用。\n\n\n# Ehcache 特性\n\n优点\n\n * 快速、简单\n * 支持多种缓存策略：LRU、LFU、FIFO 淘汰算法\n * 缓存数据有两级：内存和磁盘，因此无需担心容量问题\n * 缓存数据会在虚拟机重启的过程中写入磁盘\n * 可以通过 RMI、可插入 API 等方式进行分布式缓存\n * 具有缓存和缓存管理器的侦听接口\n * 支持多缓存管理器实例，以及一个实例的多个缓存区域\n * 提供 Hibernate 的缓存实现\n\n缺点\n\n * 使用磁盘 Cache 的时候非常占用磁盘空间\n * 不保证数据的安全\n * 虽然支持分布式缓存，但效率不高（通过组播方式，在不同节点之间同步数据）。\n\n\n# Ehcache 集群\n\nEhcache 目前支持五种集群方式：\n\n * RMI\n * JMS\n * JGroup\n * Terracotta\n * Ehcache Server\n\n# RMI\n\n使用组播方式通知所有节点同步数据。\n\n如果网络有问题，或某台服务宕机，则存在数据无法同步的可能，导致数据不一致。\n\n\n\n# JMS\n\nJMS 类似 MQ，所有节点订阅消息，当某节点缓存发生变化，就向 JMS 发消息，其他节点感知变化后，同步数据。\n\n\n\n# Cache Server\n\n\n\n\n# 二、快速入门\n\n\n# 引入 Ehcache\n\n如果你的项目使用 maven 管理，添加以下依赖到你的 pom.xml 中。\n\n<dependency>\n  <groupId>net.sf.ehcache</groupId>\n  <artifactId>ehcache</artifactId>\n  <version>2.10.2</version>\n  <type>pom</type>\n</dependency>\n\n\n如果你的项目不使用 maven 管理，请在 Ehcache 官网下载地址 下载 jar 包。\n\nSpring 提供了对于 Ehcache 接口的封装，可以更简便的使用其功能。接入方式如下：\n\n如果你的项目使用 maven 管理，添加以下依赖到你的pom.xml中。\n\nspring-context-support这个 jar 包中含有 Spring 对于缓存功能的抽象封装接口。\n\n<dependency>\n  <groupId>org.springframework</groupId>\n  <artifactId>spring-context-support</artifactId>\n  <version>4.1.4.RELEASE</version>\n</dependency>\n\n\n\n# 添加配置文件\n\n（1）在 classpath 下添加 ehcache.xml 添加一个名为 helloworld 的缓存。\n\n<?xml version="1.0" encoding="UTF-8"?>\n<ehcache xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n         xsi:noNamespaceSchemaLocation="http://ehcache.org/ehcache.xsd">\n\n  \x3c!-- 磁盘缓存位置 --\x3e\n  <diskStore path="java.io.tmpdir/ehcache"/>\n\n  \x3c!-- 默认缓存 --\x3e\n  <defaultCache\n          maxEntriesLocalHeap="10000"\n          eternal="false"\n          timeToIdleSeconds="120"\n          timeToLiveSeconds="120"\n          maxEntriesLocalDisk="10000000"\n          diskExpiryThreadIntervalSeconds="120"\n          memoryStoreEvictionPolicy="LRU"/>\n\n  \x3c!-- helloworld缓存 --\x3e\n  <cache name="helloworld"\n         maxElementsInMemory="1000"\n         eternal="false"\n         timeToIdleSeconds="5"\n         timeToLiveSeconds="5"\n         overflowToDisk="false"\n         memoryStoreEvictionPolicy="LRU"/>\n</ehcache>\n\n\n\n# Ehcache 工作示例\n\nEhcache 会自动加载 classpath 根目录下名为 ehcache.xml 文件。\n\nEhcacheDemo 的工作步骤如下：\n\n 1. 在 EhcacheDemo 中，我们引用 ehcache.xml 声明的名为 helloworld 的缓存来创建Cache对象；\n 2. 然后我们用一个键值对来实例化Element对象；\n 3. 将Element对象添加到Cache；\n 4. 然后用Cache的 get 方法获取Element对象。\n\npublic class EhcacheDemo {\n    public static void main(String[] args) throws Exception {\n        // Create a cache manager\n        final CacheManager cacheManager = new CacheManager();\n\n        // create the cache called "helloworld"\n        final Cache cache = cacheManager.getCache("helloworld");\n\n        // create a key to map the data to\n        final String key = "greeting";\n\n        // Create a data element\n        final Element putGreeting = new Element(key, "Hello, World!");\n\n        // Put the element into the data store\n        cache.put(putGreeting);\n\n        // Retrieve the data element\n        final Element getGreeting = cache.get(key);\n\n        // Print the value\n        System.out.println(getGreeting.getObjectValue());\n    }\n}\n\n\n输出\n\nHello, World!\n\n\n\n# 三、Ehcache API\n\nElement、Cache、CacheManager是 Ehcache 最重要的 API。\n\n * Element - 缓存的元素，它维护着一个键值对。\n * Cache - 它是 Ehcache 的核心类，它有多个Element，并被CacheManager管理。它实现了对缓存的逻辑行为。\n * CacheManager - Cache的容器对象，并管理着Cache的生命周期。CacheManager 支持两种创建模式：单例（Singleton mode）和实例（InstanceMode）。\n\n\n# 创建 CacheManager\n\n下面的代码列举了创建 CacheManager 的五种方式。\n\n使用静态方法create()会以默认配置来创建单例的CacheManager实例。\n\nnewInstance()方法是一个工厂方法，以默认配置创建一个新的CacheManager实例。\n\n此外，newInstance()还有几个重载函数，分别可以通过传入String、URL、InputStream参数来加载配置文件，然后创建CacheManager实例。\n\n// 使用Ehcache默认配置获取单例的CacheManager实例\nCacheManager.create();\nString[] cacheNames = CacheManager.getInstance().getCacheNames();\n\n// 使用Ehcache默认配置新建一个CacheManager实例\nCacheManager.newInstance();\nString[] cacheNames = manager.getCacheNames();\n\n// 使用不同的配置文件分别创建一个CacheManager实例\nCacheManager manager1 = CacheManager.newInstance("src/config/ehcache1.xml");\nCacheManager manager2 = CacheManager.newInstance("src/config/ehcache2.xml");\nString[] cacheNamesForManager1 = manager1.getCacheNames();\nString[] cacheNamesForManager2 = manager2.getCacheNames();\n\n// 基于classpath下的配置文件创建CacheManager实例\nURL url = getClass().getResource("/anotherconfigurationname.xml");\nCacheManager manager = CacheManager.newInstance(url);\n\n// 基于文件流得到配置文件，并创建CacheManager实例\nInputStream fis = new FileInputStream(new File\n("src/config/ehcache.xml").getAbsolutePath());\ntry {\n CacheManager manager = CacheManager.newInstance(fis);\n} finally {\n fis.close();\n}\n\n\n\n# 添加缓存\n\n需要强调一点，Cache对象在用addCache方法添加到CacheManager之前，是无效的。\n\n使用 CacheManager 的 addCache 方法可以根据缓存名将 ehcache.xml 中声明的 cache 添加到容器中；它也可以直接将 Cache 对象添加到缓存容器中。\n\nCache有多个构造函数，提供了不同方式去加载缓存的配置参数。\n\n有时候，你可能需要使用 API 来动态的添加缓存，下面的例子就提供了这样的范例。\n\n// 除了可以使用xml文件中配置的缓存，你也可以使用API动态增删缓存\n// 添加缓存\nmanager.addCache(cacheName);\n\n// 使用默认配置添加缓存\nCacheManager singletonManager = CacheManager.create();\nsingletonManager.addCache("testCache");\nCache test = singletonManager.getCache("testCache");\n\n// 使用自定义配置添加缓存，注意缓存未添加进CacheManager之前并不可用\nCacheManager singletonManager = CacheManager.create();\nCache memoryOnlyCache = new Cache("testCache", 5000, false, false, 5, 2);\nsingletonManager.addCache(memoryOnlyCache);\nCache test = singletonManager.getCache("testCache");\n\n// 使用特定的配置添加缓存\nCacheManager manager = CacheManager.create();\nCache testCache = new Cache(\n new CacheConfiguration("testCache", maxEntriesLocalHeap)\n .memoryStoreEvictionPolicy(MemoryStoreEvictionPolicy.LFU)\n .eternal(false)\n .timeToLiveSeconds(60)\n .timeToIdleSeconds(30)\n .diskExpiryThreadIntervalSeconds(0)\n .persistence(new PersistenceConfiguration().strategy(Strategy.LOCALTEMPSWAP)));\n manager.addCache(testCache);\n\n\n\n# 删除缓存\n\n删除缓存比较简单，你只需要将指定的缓存名传入removeCache方法即可。\n\nCacheManager singletonManager = CacheManager.create();\nsingletonManager.removeCache("sampleCache1");\n\n\n\n# 基本缓存操作\n\nCache 最重要的两个方法就是 put 和 get，分别用来添加 Element 和获取 Element。\n\nCache 还提供了一系列的 get、set 方法来设置或获取缓存参数，这里不一一列举，更多 API 操作可参考官方 API 开发手册。\n\n/**\n * 测试：使用默认配置或使用指定配置来创建CacheManager\n *\n * @author Zhang Peng\n */\npublic class CacheOperationTest {\n    private final Logger log = LoggerFactory.getLogger(CacheOperationTest.class);\n\n    /**\n     * 使用Ehcache默认配置(classpath下的ehcache.xml)获取单例的CacheManager实例\n     */\n    @Test\n    public void operation() {\n        CacheManager manager = CacheManager.newInstance("src/test/resources/ehcache/ehcache.xml");\n\n        // 获得Cache的引用\n        Cache cache = manager.getCache("userCache");\n\n        // 将一个Element添加到Cache\n        cache.put(new Element("key1", "value1"));\n\n        // 获取Element，Element类支持序列化，所以下面两种方法都可以用\n        Element element1 = cache.get("key1");\n        // 获取非序列化的值\n        log.debug("key:{}, value:{}", element1.getObjectKey(), element1.getObjectValue());\n        // 获取序列化的值\n        log.debug("key:{}, value:{}", element1.getKey(), element1.getValue());\n\n        // 更新Cache中的Element\n        cache.put(new Element("key1", "value2"));\n        Element element2 = cache.get("key1");\n        log.debug("key:{}, value:{}", element2.getObjectKey(), element2.getObjectValue());\n\n        // 获取Cache的元素数\n        log.debug("cache size:{}", cache.getSize());\n\n        // 获取MemoryStore的元素数\n        log.debug("MemoryStoreSize:{}", cache.getMemoryStoreSize());\n\n        // 获取DiskStore的元素数\n        log.debug("DiskStoreSize:{}", cache.getDiskStoreSize());\n\n        // 移除Element\n        cache.remove("key1");\n        log.debug("cache size:{}", cache.getSize());\n\n        // 关闭当前CacheManager对象\n        manager.shutdown();\n\n        // 关闭CacheManager单例实例\n        CacheManager.getInstance().shutdown();\n    }\n}\n\n\n\n# 四、Ehcache 配置\n\n> Ehcache 支持通过 xml 文件和 API 两种方式进行配置。\n> \n> 详情参考：Ehcache 官方 XML 配置手册\n\n\n# xml 配置方式\n\nEhcache 的CacheManager构造函数或工厂方法被调用时，会默认加载 classpath 下名为ehcache.xml的配置文件。如果加载失败，会加载 Ehcache jar 包中的ehcache-failsafe.xml文件，这个文件中含有简单的默认配置。 ehcache.xml 配置参数说明：\n\n * name：缓存名称。\n * maxElementsInMemory：缓存最大个数。\n * eternal：缓存中对象是否为永久的，如果是，超时设置将被忽略，对象从不过期。\n * timeToIdleSeconds：置对象在失效前的允许闲置时间（单位：秒）。仅当 eternal=false 对象不是永久有效时使用，可选属性，默认值是 0，也就是可闲置时间无穷大。\n * timeToLiveSeconds：缓存数据的生存时间（TTL），也就是一个元素从构建到消亡的最大时间间隔值，这只能在元素不是永久驻留时有效，如果该值是 0 就意味着元素可以停顿无穷长的时间。\n * maxEntriesLocalDisk：当内存中对象数量达到 maxElementsInMemory 时，Ehcache 将会对象写到磁盘中。\n * overflowToDisk：内存不足时，是否启用磁盘缓存。\n * diskSpoolBufferSizeMB：这个参数设置 DiskStore（磁盘缓存）的缓存区大小。默认是 30MB。每个 Cache 都应该有自己的一个缓冲区。\n * maxElementsOnDisk：硬盘最大缓存个数。\n * diskPersistent：是否在 VM 重启时存储硬盘的缓存数据。默认值是 false。\n * diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是 120 秒。\n * memoryStoreEvictionPolicy：当达到 maxElementsInMemory 限制时，Ehcache 将会根据指定的策略去清理内存。默认策略是 LRU（最近最少使用）。你可以设置为 FIFO（先进先出）或是 LFU（较少使用）。\n * clearOnFlush：内存数量最大时是否清除。\n\n\n# API 配置方式\n\nxml 配置的参数也可以直接通过编程方式来动态的进行配置（dynamicConfig 没有设为 false）。\n\nCache cache = manager.getCache("sampleCache");\nCacheConfiguration config = cache.getCacheConfiguration();\nconfig.setTimeToIdleSeconds(60);\nconfig.setTimeToLiveSeconds(120);\nconfig.setmaxEntriesLocalHeap(10000);\nconfig.setmaxEntriesLocalDisk(1000000);\n\n\n也可以通过disableDynamicFeatures()方式关闭动态配置开关。配置以后你将无法再以编程方式配置参数。\n\nCache cache = manager.getCache("sampleCache");\ncache.disableDynamicFeatures();\n\n\n\n# 五、Spring 集成 Ehcache\n\nSpring3.1 开始添加了对缓存的支持。和事务功能的支持方式类似，缓存抽象允许底层使用不同的缓存解决方案来进行整合。\n\nSpring4.1 开始支持 JSR-107 注解。\n\n> 注：我本人使用的 Spring 版本为 4.1.4.RELEASE，目前 Spring 版本仅支持 Ehcache2.5 以上版本，但不支持 Ehcache3。\n\n\n# 绑定 Ehcache\n\norg.springframework.cache.ehcache.EhCacheManagerFactoryBean这个类的作用是加载 Ehcache 配置文件。 org.springframework.cache.ehcache.EhCacheCacheManager这个类的作用是支持 net.sf.ehcache.CacheManager。\n\nspring-ehcache.xml的配置\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xmlns:cache="http://www.springframework.org/schema/cache"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\n        http://www.springframework.org/schema/cache\n        http://www.springframework.org/schema/cache/spring-cache-3.2.xsd">\n\n  <description>ehcache缓存配置管理文件</description>\n\n  <bean id="ehcache" class="org.springframework.cache.ehcache.EhCacheManagerFactoryBean">\n    <property name="configLocation" value="classpath:ehcache/ehcache.xml"/>\n  </bean>\n\n  <bean id="cacheManager" class="org.springframework.cache.ehcache.EhCacheCacheManager">\n    <property name="cacheManager" ref="ehcache"/>\n  </bean>\n\n  \x3c!-- 启用缓存注解开关 --\x3e\n  <cache:annotation-driven cache-manager="cacheManager"/>\n</beans>\n\n\n\n# 使用 Spring 的缓存注解\n\n# 开启注解\n\nSpring 为缓存功能提供了注解功能，但是你必须启动注解。 你有两个选择： (1) 在 xml 中声明 像上一节 spring-ehcache.xml 中的做法一样，使用<cache:annotation-driven/>\n\n<cache:annotation-driven cache-manager="cacheManager"/>\n\n\n(2) 使用标记注解 你也可以通过对一个类进行注解修饰的方式在这个类中使用缓存注解。 范例如下：\n\n@Configuration\n@EnableCaching\npublic class AppConfig {\n}\n\n\n\n# 注解基本使用方法\n\nSpring 对缓存的支持类似于对事务的支持。 首先使用注解标记方法，相当于定义了切点，然后使用 Aop 技术在这个方法的调用前、调用后获取方法的入参和返回值，进而实现了缓存的逻辑。 下面三个注解都是方法级别：\n\n# @Cacheable\n\n表明所修饰的方法是可以缓存的：当第一次调用这个方法时，它的结果会被缓存下来，在缓存的有效时间内，以后访问这个方法都直接返回缓存结果，不再执行方法中的代码段。 这个注解可以用condition属性来设置条件，如果不满足条件，就不使用缓存能力，直接执行方法。 可以使用key属性来指定 key 的生成规则。\n\n# @CachePut\n\n与@Cacheable不同，@CachePut不仅会缓存方法的结果，还会执行方法的代码段。 它支持的属性和用法都与@Cacheable一致。\n\n# @CacheEvict\n\n与@Cacheable功能相反，@CacheEvict表明所修饰的方法是用来删除失效或无用的缓存数据。 下面是@Cacheable、@CacheEvict和@CachePut基本使用方法的一个集中展示：\n\n@Service\npublic class UserService {\n    // @Cacheable可以设置多个缓存，形式如：@Cacheable({"books", "isbns"})\n    @Cacheable(value={"users"}, key="#user.id")\n    public User findUser(User user) {\n        return findUserInDB(user.getId());\n    }\n\n    @Cacheable(value = "users", condition = "#user.getId() <= 2")\n    public User findUserInLimit(User user) {\n        return findUserInDB(user.getId());\n    }\n\n    @CachePut(value = "users", key = "#user.getId()")\n    public void updateUser(User user) {\n        updateUserInDB(user);\n    }\n\n    @CacheEvict(value = "users")\n    public void removeUser(User user) {\n        removeUserInDB(user.getId());\n    }\n\n    @CacheEvict(value = "users", allEntries = true)\n    public void clear() {\n        removeAllInDB();\n    }\n}\n\n\n# @Caching\n\n如果需要使用同一个缓存注解（@Cacheable、@CacheEvict或@CachePut）多次修饰一个方法，就需要用到@Caching。\n\n@Caching(evict = { @CacheEvict("primary"), @CacheEvict(cacheNames="secondary", key="#p0") })\npublic Book importBooks(String deposit, Date date)\n\n\n# @CacheConfig\n\n与前面的缓存注解不同，这是一个类级别的注解。 如果类的所有操作都是缓存操作，你可以使用@CacheConfig来指定类，省去一些配置。\n\n@CacheConfig("books")\npublic class BookRepositoryImpl implements BookRepository {\n @Cacheable\n public Book findBook(ISBN isbn) {...}\n}\n\n\n\n# 参考资料\n\n * 官方\n   * Ehcache 官网\n   * Ehcache Github\n * 文章\n   * Ehcache 优缺点以及分布式详解\n   * Ehcache 详细解读\n   * 注释驱动的 Spring cache 缓存介绍\n   * Spring 官方文档第 36 章缓存抽象',normalizedContent:'# ehcache 快速入门\n\n> ehcache 是一个纯 java 的进程内缓存框架，具有快速、精干等特点，是 hibernate 中默认的 cacheprovider。\n\n\n\n\n# 一、简介\n\n> ehcache 虽然也支持分布式模式，但是分布式方案不是很好好，建议只将其作为单机的进程内缓存使用。\n\n\n# ehcache 特性\n\n优点\n\n * 快速、简单\n * 支持多种缓存策略：lru、lfu、fifo 淘汰算法\n * 缓存数据有两级：内存和磁盘，因此无需担心容量问题\n * 缓存数据会在虚拟机重启的过程中写入磁盘\n * 可以通过 rmi、可插入 api 等方式进行分布式缓存\n * 具有缓存和缓存管理器的侦听接口\n * 支持多缓存管理器实例，以及一个实例的多个缓存区域\n * 提供 hibernate 的缓存实现\n\n缺点\n\n * 使用磁盘 cache 的时候非常占用磁盘空间\n * 不保证数据的安全\n * 虽然支持分布式缓存，但效率不高（通过组播方式，在不同节点之间同步数据）。\n\n\n# ehcache 集群\n\nehcache 目前支持五种集群方式：\n\n * rmi\n * jms\n * jgroup\n * terracotta\n * ehcache server\n\n# rmi\n\n使用组播方式通知所有节点同步数据。\n\n如果网络有问题，或某台服务宕机，则存在数据无法同步的可能，导致数据不一致。\n\n\n\n# jms\n\njms 类似 mq，所有节点订阅消息，当某节点缓存发生变化，就向 jms 发消息，其他节点感知变化后，同步数据。\n\n\n\n# cache server\n\n\n\n\n# 二、快速入门\n\n\n# 引入 ehcache\n\n如果你的项目使用 maven 管理，添加以下依赖到你的 pom.xml 中。\n\n<dependency>\n  <groupid>net.sf.ehcache</groupid>\n  <artifactid>ehcache</artifactid>\n  <version>2.10.2</version>\n  <type>pom</type>\n</dependency>\n\n\n如果你的项目不使用 maven 管理，请在 ehcache 官网下载地址 下载 jar 包。\n\nspring 提供了对于 ehcache 接口的封装，可以更简便的使用其功能。接入方式如下：\n\n如果你的项目使用 maven 管理，添加以下依赖到你的pom.xml中。\n\nspring-context-support这个 jar 包中含有 spring 对于缓存功能的抽象封装接口。\n\n<dependency>\n  <groupid>org.springframework</groupid>\n  <artifactid>spring-context-support</artifactid>\n  <version>4.1.4.release</version>\n</dependency>\n\n\n\n# 添加配置文件\n\n（1）在 classpath 下添加 ehcache.xml 添加一个名为 helloworld 的缓存。\n\n<?xml version="1.0" encoding="utf-8"?>\n<ehcache xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n         xsi:nonamespaceschemalocation="http://ehcache.org/ehcache.xsd">\n\n  \x3c!-- 磁盘缓存位置 --\x3e\n  <diskstore path="java.io.tmpdir/ehcache"/>\n\n  \x3c!-- 默认缓存 --\x3e\n  <defaultcache\n          maxentrieslocalheap="10000"\n          eternal="false"\n          timetoidleseconds="120"\n          timetoliveseconds="120"\n          maxentrieslocaldisk="10000000"\n          diskexpirythreadintervalseconds="120"\n          memorystoreevictionpolicy="lru"/>\n\n  \x3c!-- helloworld缓存 --\x3e\n  <cache name="helloworld"\n         maxelementsinmemory="1000"\n         eternal="false"\n         timetoidleseconds="5"\n         timetoliveseconds="5"\n         overflowtodisk="false"\n         memorystoreevictionpolicy="lru"/>\n</ehcache>\n\n\n\n# ehcache 工作示例\n\nehcache 会自动加载 classpath 根目录下名为 ehcache.xml 文件。\n\nehcachedemo 的工作步骤如下：\n\n 1. 在 ehcachedemo 中，我们引用 ehcache.xml 声明的名为 helloworld 的缓存来创建cache对象；\n 2. 然后我们用一个键值对来实例化element对象；\n 3. 将element对象添加到cache；\n 4. 然后用cache的 get 方法获取element对象。\n\npublic class ehcachedemo {\n    public static void main(string[] args) throws exception {\n        // create a cache manager\n        final cachemanager cachemanager = new cachemanager();\n\n        // create the cache called "helloworld"\n        final cache cache = cachemanager.getcache("helloworld");\n\n        // create a key to map the data to\n        final string key = "greeting";\n\n        // create a data element\n        final element putgreeting = new element(key, "hello, world!");\n\n        // put the element into the data store\n        cache.put(putgreeting);\n\n        // retrieve the data element\n        final element getgreeting = cache.get(key);\n\n        // print the value\n        system.out.println(getgreeting.getobjectvalue());\n    }\n}\n\n\n输出\n\nhello, world!\n\n\n\n# 三、ehcache api\n\nelement、cache、cachemanager是 ehcache 最重要的 api。\n\n * element - 缓存的元素，它维护着一个键值对。\n * cache - 它是 ehcache 的核心类，它有多个element，并被cachemanager管理。它实现了对缓存的逻辑行为。\n * cachemanager - cache的容器对象，并管理着cache的生命周期。cachemanager 支持两种创建模式：单例（singleton mode）和实例（instancemode）。\n\n\n# 创建 cachemanager\n\n下面的代码列举了创建 cachemanager 的五种方式。\n\n使用静态方法create()会以默认配置来创建单例的cachemanager实例。\n\nnewinstance()方法是一个工厂方法，以默认配置创建一个新的cachemanager实例。\n\n此外，newinstance()还有几个重载函数，分别可以通过传入string、url、inputstream参数来加载配置文件，然后创建cachemanager实例。\n\n// 使用ehcache默认配置获取单例的cachemanager实例\ncachemanager.create();\nstring[] cachenames = cachemanager.getinstance().getcachenames();\n\n// 使用ehcache默认配置新建一个cachemanager实例\ncachemanager.newinstance();\nstring[] cachenames = manager.getcachenames();\n\n// 使用不同的配置文件分别创建一个cachemanager实例\ncachemanager manager1 = cachemanager.newinstance("src/config/ehcache1.xml");\ncachemanager manager2 = cachemanager.newinstance("src/config/ehcache2.xml");\nstring[] cachenamesformanager1 = manager1.getcachenames();\nstring[] cachenamesformanager2 = manager2.getcachenames();\n\n// 基于classpath下的配置文件创建cachemanager实例\nurl url = getclass().getresource("/anotherconfigurationname.xml");\ncachemanager manager = cachemanager.newinstance(url);\n\n// 基于文件流得到配置文件，并创建cachemanager实例\ninputstream fis = new fileinputstream(new file\n("src/config/ehcache.xml").getabsolutepath());\ntry {\n cachemanager manager = cachemanager.newinstance(fis);\n} finally {\n fis.close();\n}\n\n\n\n# 添加缓存\n\n需要强调一点，cache对象在用addcache方法添加到cachemanager之前，是无效的。\n\n使用 cachemanager 的 addcache 方法可以根据缓存名将 ehcache.xml 中声明的 cache 添加到容器中；它也可以直接将 cache 对象添加到缓存容器中。\n\ncache有多个构造函数，提供了不同方式去加载缓存的配置参数。\n\n有时候，你可能需要使用 api 来动态的添加缓存，下面的例子就提供了这样的范例。\n\n// 除了可以使用xml文件中配置的缓存，你也可以使用api动态增删缓存\n// 添加缓存\nmanager.addcache(cachename);\n\n// 使用默认配置添加缓存\ncachemanager singletonmanager = cachemanager.create();\nsingletonmanager.addcache("testcache");\ncache test = singletonmanager.getcache("testcache");\n\n// 使用自定义配置添加缓存，注意缓存未添加进cachemanager之前并不可用\ncachemanager singletonmanager = cachemanager.create();\ncache memoryonlycache = new cache("testcache", 5000, false, false, 5, 2);\nsingletonmanager.addcache(memoryonlycache);\ncache test = singletonmanager.getcache("testcache");\n\n// 使用特定的配置添加缓存\ncachemanager manager = cachemanager.create();\ncache testcache = new cache(\n new cacheconfiguration("testcache", maxentrieslocalheap)\n .memorystoreevictionpolicy(memorystoreevictionpolicy.lfu)\n .eternal(false)\n .timetoliveseconds(60)\n .timetoidleseconds(30)\n .diskexpirythreadintervalseconds(0)\n .persistence(new persistenceconfiguration().strategy(strategy.localtempswap)));\n manager.addcache(testcache);\n\n\n\n# 删除缓存\n\n删除缓存比较简单，你只需要将指定的缓存名传入removecache方法即可。\n\ncachemanager singletonmanager = cachemanager.create();\nsingletonmanager.removecache("samplecache1");\n\n\n\n# 基本缓存操作\n\ncache 最重要的两个方法就是 put 和 get，分别用来添加 element 和获取 element。\n\ncache 还提供了一系列的 get、set 方法来设置或获取缓存参数，这里不一一列举，更多 api 操作可参考官方 api 开发手册。\n\n/**\n * 测试：使用默认配置或使用指定配置来创建cachemanager\n *\n * @author zhang peng\n */\npublic class cacheoperationtest {\n    private final logger log = loggerfactory.getlogger(cacheoperationtest.class);\n\n    /**\n     * 使用ehcache默认配置(classpath下的ehcache.xml)获取单例的cachemanager实例\n     */\n    @test\n    public void operation() {\n        cachemanager manager = cachemanager.newinstance("src/test/resources/ehcache/ehcache.xml");\n\n        // 获得cache的引用\n        cache cache = manager.getcache("usercache");\n\n        // 将一个element添加到cache\n        cache.put(new element("key1", "value1"));\n\n        // 获取element，element类支持序列化，所以下面两种方法都可以用\n        element element1 = cache.get("key1");\n        // 获取非序列化的值\n        log.debug("key:{}, value:{}", element1.getobjectkey(), element1.getobjectvalue());\n        // 获取序列化的值\n        log.debug("key:{}, value:{}", element1.getkey(), element1.getvalue());\n\n        // 更新cache中的element\n        cache.put(new element("key1", "value2"));\n        element element2 = cache.get("key1");\n        log.debug("key:{}, value:{}", element2.getobjectkey(), element2.getobjectvalue());\n\n        // 获取cache的元素数\n        log.debug("cache size:{}", cache.getsize());\n\n        // 获取memorystore的元素数\n        log.debug("memorystoresize:{}", cache.getmemorystoresize());\n\n        // 获取diskstore的元素数\n        log.debug("diskstoresize:{}", cache.getdiskstoresize());\n\n        // 移除element\n        cache.remove("key1");\n        log.debug("cache size:{}", cache.getsize());\n\n        // 关闭当前cachemanager对象\n        manager.shutdown();\n\n        // 关闭cachemanager单例实例\n        cachemanager.getinstance().shutdown();\n    }\n}\n\n\n\n# 四、ehcache 配置\n\n> ehcache 支持通过 xml 文件和 api 两种方式进行配置。\n> \n> 详情参考：ehcache 官方 xml 配置手册\n\n\n# xml 配置方式\n\nehcache 的cachemanager构造函数或工厂方法被调用时，会默认加载 classpath 下名为ehcache.xml的配置文件。如果加载失败，会加载 ehcache jar 包中的ehcache-failsafe.xml文件，这个文件中含有简单的默认配置。 ehcache.xml 配置参数说明：\n\n * name：缓存名称。\n * maxelementsinmemory：缓存最大个数。\n * eternal：缓存中对象是否为永久的，如果是，超时设置将被忽略，对象从不过期。\n * timetoidleseconds：置对象在失效前的允许闲置时间（单位：秒）。仅当 eternal=false 对象不是永久有效时使用，可选属性，默认值是 0，也就是可闲置时间无穷大。\n * timetoliveseconds：缓存数据的生存时间（ttl），也就是一个元素从构建到消亡的最大时间间隔值，这只能在元素不是永久驻留时有效，如果该值是 0 就意味着元素可以停顿无穷长的时间。\n * maxentrieslocaldisk：当内存中对象数量达到 maxelementsinmemory 时，ehcache 将会对象写到磁盘中。\n * overflowtodisk：内存不足时，是否启用磁盘缓存。\n * diskspoolbuffersizemb：这个参数设置 diskstore（磁盘缓存）的缓存区大小。默认是 30mb。每个 cache 都应该有自己的一个缓冲区。\n * maxelementsondisk：硬盘最大缓存个数。\n * diskpersistent：是否在 vm 重启时存储硬盘的缓存数据。默认值是 false。\n * diskexpirythreadintervalseconds：磁盘失效线程运行时间间隔，默认是 120 秒。\n * memorystoreevictionpolicy：当达到 maxelementsinmemory 限制时，ehcache 将会根据指定的策略去清理内存。默认策略是 lru（最近最少使用）。你可以设置为 fifo（先进先出）或是 lfu（较少使用）。\n * clearonflush：内存数量最大时是否清除。\n\n\n# api 配置方式\n\nxml 配置的参数也可以直接通过编程方式来动态的进行配置（dynamicconfig 没有设为 false）。\n\ncache cache = manager.getcache("samplecache");\ncacheconfiguration config = cache.getcacheconfiguration();\nconfig.settimetoidleseconds(60);\nconfig.settimetoliveseconds(120);\nconfig.setmaxentrieslocalheap(10000);\nconfig.setmaxentrieslocaldisk(1000000);\n\n\n也可以通过disabledynamicfeatures()方式关闭动态配置开关。配置以后你将无法再以编程方式配置参数。\n\ncache cache = manager.getcache("samplecache");\ncache.disabledynamicfeatures();\n\n\n\n# 五、spring 集成 ehcache\n\nspring3.1 开始添加了对缓存的支持。和事务功能的支持方式类似，缓存抽象允许底层使用不同的缓存解决方案来进行整合。\n\nspring4.1 开始支持 jsr-107 注解。\n\n> 注：我本人使用的 spring 版本为 4.1.4.release，目前 spring 版本仅支持 ehcache2.5 以上版本，但不支持 ehcache3。\n\n\n# 绑定 ehcache\n\norg.springframework.cache.ehcache.ehcachemanagerfactorybean这个类的作用是加载 ehcache 配置文件。 org.springframework.cache.ehcache.ehcachecachemanager这个类的作用是支持 net.sf.ehcache.cachemanager。\n\nspring-ehcache.xml的配置\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n       xmlns:cache="http://www.springframework.org/schema/cache"\n       xsi:schemalocation="http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\n        http://www.springframework.org/schema/cache\n        http://www.springframework.org/schema/cache/spring-cache-3.2.xsd">\n\n  <description>ehcache缓存配置管理文件</description>\n\n  <bean id="ehcache" class="org.springframework.cache.ehcache.ehcachemanagerfactorybean">\n    <property name="configlocation" value="classpath:ehcache/ehcache.xml"/>\n  </bean>\n\n  <bean id="cachemanager" class="org.springframework.cache.ehcache.ehcachecachemanager">\n    <property name="cachemanager" ref="ehcache"/>\n  </bean>\n\n  \x3c!-- 启用缓存注解开关 --\x3e\n  <cache:annotation-driven cache-manager="cachemanager"/>\n</beans>\n\n\n\n# 使用 spring 的缓存注解\n\n# 开启注解\n\nspring 为缓存功能提供了注解功能，但是你必须启动注解。 你有两个选择： (1) 在 xml 中声明 像上一节 spring-ehcache.xml 中的做法一样，使用<cache:annotation-driven/>\n\n<cache:annotation-driven cache-manager="cachemanager"/>\n\n\n(2) 使用标记注解 你也可以通过对一个类进行注解修饰的方式在这个类中使用缓存注解。 范例如下：\n\n@configuration\n@enablecaching\npublic class appconfig {\n}\n\n\n\n# 注解基本使用方法\n\nspring 对缓存的支持类似于对事务的支持。 首先使用注解标记方法，相当于定义了切点，然后使用 aop 技术在这个方法的调用前、调用后获取方法的入参和返回值，进而实现了缓存的逻辑。 下面三个注解都是方法级别：\n\n# @cacheable\n\n表明所修饰的方法是可以缓存的：当第一次调用这个方法时，它的结果会被缓存下来，在缓存的有效时间内，以后访问这个方法都直接返回缓存结果，不再执行方法中的代码段。 这个注解可以用condition属性来设置条件，如果不满足条件，就不使用缓存能力，直接执行方法。 可以使用key属性来指定 key 的生成规则。\n\n# @cacheput\n\n与@cacheable不同，@cacheput不仅会缓存方法的结果，还会执行方法的代码段。 它支持的属性和用法都与@cacheable一致。\n\n# @cacheevict\n\n与@cacheable功能相反，@cacheevict表明所修饰的方法是用来删除失效或无用的缓存数据。 下面是@cacheable、@cacheevict和@cacheput基本使用方法的一个集中展示：\n\n@service\npublic class userservice {\n    // @cacheable可以设置多个缓存，形式如：@cacheable({"books", "isbns"})\n    @cacheable(value={"users"}, key="#user.id")\n    public user finduser(user user) {\n        return finduserindb(user.getid());\n    }\n\n    @cacheable(value = "users", condition = "#user.getid() <= 2")\n    public user finduserinlimit(user user) {\n        return finduserindb(user.getid());\n    }\n\n    @cacheput(value = "users", key = "#user.getid()")\n    public void updateuser(user user) {\n        updateuserindb(user);\n    }\n\n    @cacheevict(value = "users")\n    public void removeuser(user user) {\n        removeuserindb(user.getid());\n    }\n\n    @cacheevict(value = "users", allentries = true)\n    public void clear() {\n        removeallindb();\n    }\n}\n\n\n# @caching\n\n如果需要使用同一个缓存注解（@cacheable、@cacheevict或@cacheput）多次修饰一个方法，就需要用到@caching。\n\n@caching(evict = { @cacheevict("primary"), @cacheevict(cachenames="secondary", key="#p0") })\npublic book importbooks(string deposit, date date)\n\n\n# @cacheconfig\n\n与前面的缓存注解不同，这是一个类级别的注解。 如果类的所有操作都是缓存操作，你可以使用@cacheconfig来指定类，省去一些配置。\n\n@cacheconfig("books")\npublic class bookrepositoryimpl implements bookrepository {\n @cacheable\n public book findbook(isbn isbn) {...}\n}\n\n\n\n# 参考资料\n\n * 官方\n   * ehcache 官网\n   * ehcache github\n * 文章\n   * ehcache 优缺点以及分布式详解\n   * ehcache 详细解读\n   * 注释驱动的 spring cache 缓存介绍\n   * spring 官方文档第 36 章缓存抽象',charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Http 缓存",frontmatter:{title:"Http 缓存",date:"2022-02-17T22:34:30.000Z",order:6,categories:["Java","中间件","缓存"],tags:["缓存","Http"],permalink:"/pages/30abaa/"},regularPath:"/01.Java/14.%E4%B8%AD%E9%97%B4%E4%BB%B6/02.%E7%BC%93%E5%AD%98/06.Http%E7%BC%93%E5%AD%98.html",relativePath:"01.Java/14.中间件/02.缓存/06.Http缓存.md",key:"v-18696fc0",path:"/pages/30abaa/",headers:[{level:2,title:"Http 强缓存",slug:"http-强缓存",normalizedTitle:"http 强缓存",charIndex:85},{level:3,title:"Expires",slug:"expires",normalizedTitle:"expires",charIndex:240},{level:3,title:"Cache-Control",slug:"cache-control",normalizedTitle:"cache-control",charIndex:248},{level:3,title:"Pragma",slug:"pragma",normalizedTitle:"pragma",charIndex:264},{level:2,title:"协商缓存",slug:"协商缓存",normalizedTitle:"协商缓存",charIndex:36},{level:3,title:"ETag/If-None-Match",slug:"etag-if-none-match",normalizedTitle:"etag/if-none-match",charIndex:1066},{level:3,title:"Last-Modified/If-Modified-Since",slug:"last-modified-if-modified-since",normalizedTitle:"last-modified/if-modified-since",charIndex:1411},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:2076}],headersStr:"Http 强缓存 Expires Cache-Control Pragma 协商缓存 ETag/If-None-Match Last-Modified/If-Modified-Since 参考资料",content:"# Http 缓存\n\nHTTP 缓存分为 2 种，一种是强缓存，另一种是协商缓存。主要作用是可以加快资源获取速度，提升用户体验，减少网络传输，缓解服务端的压力。\n\n\n# Http 强缓存\n\n不需要发送请求到服务端，直接读取浏览器本地缓存，在 Chrome 的 Network 中显示的 HTTP 状态码是 200 ，在 Chrome 中，强缓存又分为 Disk Cache (存放在硬盘中)和 Memory Cache (存放在内存中)，存放的位置是由浏览器控制的。是否强缓存由 Expires、Cache-Control 和 Pragma 3 个 Header 属性共同来控制。\n\n\n# Expires\n\nExpires 的值是一个 HTTP 日期，在浏览器发起请求时，会根据系统时间和 Expires 的值进行比较，如果系统时间超过了 Expires 的值，缓存失效。由于和系统时间进行比较，所以当系统时间和服务器时间不一致的时候，会有缓存有效期不准的问题。Expires 的优先级在三个 Header 属性中是最低的。\n\n\n# Cache-Control\n\nCache-Control 是 HTTP/1.1 中新增的属性，在请求头和响应头中都可以使用，常用的属性值如有：\n\n * max-age：单位是秒，缓存时间计算的方式是距离发起的时间的秒数，超过间隔的秒数缓存失效\n * no-cache：不使用强缓存，需要与服务器验证缓存是否新鲜\n * no-store：禁止使用缓存（包括协商缓存），每次都向服务器请求最新的资源\n * private：专用于个人的缓存，中间代理、CDN 等不能缓存此响应\n * public：响应可以被中间代理、CDN 等缓存\n * must-revalidate：在缓存过期前可以使用，过期后必须向服务器验证\n\n\n# Pragma\n\nPragma 只有一个属性值，就是 no-cache ，效果和 Cache-Control 中的 no-cache 一致，不使用强缓存，需要与服务器验证缓存是否新鲜，在 3 个头部属性中的优先级最高。\n\n\n# 协商缓存\n\n当浏览器的强缓存失效的时候或者请求头中设置了不走强缓存，并且在请求头中设置了 If-Modified-Since 或者 If-None-Match 的时候，会将这两个属性值到服务端去验证是否命中协商缓存，如果命中了协商缓存，会返回 304 状态，加载浏览器缓存，并且响应头会设置 Last-Modified 或者 ETag 属性。\n\n\n# ETag/If-None-Match\n\nEtag： 服务器响应请求时，通过此字段告诉浏览器当前资源在服务器生成的唯一标识（生成规则由服务器决定）\n\nIf-None-Match： 再次请求服务器时，浏览器的请求报文头部会包含此字段，后面的值为在缓存中获取的标识。服务器接收到次报文后发现 If-None-Match 则与被请求资源的唯一标识进行对比。\n\n 1. 不同，说明资源被改动过，则响应整个资源内容，返回状态码 200。\n 2. 相同，说明资源无心修改，则响应 header，浏览器直接从缓存中获取数据信息。返回状态码 304.\n\n但是实际应用中由于 Etag 的计算是使用算法来得出的，而算法会占用服务端计算的资源，所有服务端的资源都是宝贵的，所以就很少使用 Etag 了。\n\n\n# Last-Modified/If-Modified-Since\n\nLast-Modified： 服务器在响应请求时，会告诉浏览器资源的最后修改时间。\n\nif-Modified-Since: 浏览器再次请求服务器的时候，请求头会包含此字段，后面跟着在缓存中获得的最后修改时间。服务端收到此请求头发现有 if-Modified-Since，则与被请求资源的最后修改时间进行对比，如果一致则返回 304 和响应报文头，浏览器只需要从缓存中获取信息即可。 从字面上看，就是说：从某个时间节点算起，是否文件被修改了\n\n 1. 如果真的被修改：那么开始传输响应一个整体，服务器返回：200 OK\n 2. 如果没有被修改：那么只需传输响应 header，服务器返回：304 Not Modified\n\nif-Unmodified-Since: 从字面上看, 就是说: 从某个时间点算起, 是否文件没有被修改\n\n 1. 如果没有被修改:则开始`继续'传送文件: 服务器返回: 200 OK\n 2. 如果文件被修改:则不传输,服务器返回: 412 Precondition failed (预处理错误)\n\n这两个的区别是一个是修改了才下载一个是没修改才下载。 Last-Modified 说好却也不是特别好，因为如果在服务器上，一个资源被修改了，但其实际内容根本没发生改变，会因为 Last-Modified 时间匹配不上而返回了整个实体给客户端（即使客户端缓存里有个一模一样的资源）。为了解决这个问题，HTTP1.1 推出了 Etag。\n\n\n# 参考资料\n\n * 图解 HTTP 缓存\n * HTTP----HTTP 缓存机制\n * 缓存详解",normalizedContent:"# http 缓存\n\nhttp 缓存分为 2 种，一种是强缓存，另一种是协商缓存。主要作用是可以加快资源获取速度，提升用户体验，减少网络传输，缓解服务端的压力。\n\n\n# http 强缓存\n\n不需要发送请求到服务端，直接读取浏览器本地缓存，在 chrome 的 network 中显示的 http 状态码是 200 ，在 chrome 中，强缓存又分为 disk cache (存放在硬盘中)和 memory cache (存放在内存中)，存放的位置是由浏览器控制的。是否强缓存由 expires、cache-control 和 pragma 3 个 header 属性共同来控制。\n\n\n# expires\n\nexpires 的值是一个 http 日期，在浏览器发起请求时，会根据系统时间和 expires 的值进行比较，如果系统时间超过了 expires 的值，缓存失效。由于和系统时间进行比较，所以当系统时间和服务器时间不一致的时候，会有缓存有效期不准的问题。expires 的优先级在三个 header 属性中是最低的。\n\n\n# cache-control\n\ncache-control 是 http/1.1 中新增的属性，在请求头和响应头中都可以使用，常用的属性值如有：\n\n * max-age：单位是秒，缓存时间计算的方式是距离发起的时间的秒数，超过间隔的秒数缓存失效\n * no-cache：不使用强缓存，需要与服务器验证缓存是否新鲜\n * no-store：禁止使用缓存（包括协商缓存），每次都向服务器请求最新的资源\n * private：专用于个人的缓存，中间代理、cdn 等不能缓存此响应\n * public：响应可以被中间代理、cdn 等缓存\n * must-revalidate：在缓存过期前可以使用，过期后必须向服务器验证\n\n\n# pragma\n\npragma 只有一个属性值，就是 no-cache ，效果和 cache-control 中的 no-cache 一致，不使用强缓存，需要与服务器验证缓存是否新鲜，在 3 个头部属性中的优先级最高。\n\n\n# 协商缓存\n\n当浏览器的强缓存失效的时候或者请求头中设置了不走强缓存，并且在请求头中设置了 if-modified-since 或者 if-none-match 的时候，会将这两个属性值到服务端去验证是否命中协商缓存，如果命中了协商缓存，会返回 304 状态，加载浏览器缓存，并且响应头会设置 last-modified 或者 etag 属性。\n\n\n# etag/if-none-match\n\netag： 服务器响应请求时，通过此字段告诉浏览器当前资源在服务器生成的唯一标识（生成规则由服务器决定）\n\nif-none-match： 再次请求服务器时，浏览器的请求报文头部会包含此字段，后面的值为在缓存中获取的标识。服务器接收到次报文后发现 if-none-match 则与被请求资源的唯一标识进行对比。\n\n 1. 不同，说明资源被改动过，则响应整个资源内容，返回状态码 200。\n 2. 相同，说明资源无心修改，则响应 header，浏览器直接从缓存中获取数据信息。返回状态码 304.\n\n但是实际应用中由于 etag 的计算是使用算法来得出的，而算法会占用服务端计算的资源，所有服务端的资源都是宝贵的，所以就很少使用 etag 了。\n\n\n# last-modified/if-modified-since\n\nlast-modified： 服务器在响应请求时，会告诉浏览器资源的最后修改时间。\n\nif-modified-since: 浏览器再次请求服务器的时候，请求头会包含此字段，后面跟着在缓存中获得的最后修改时间。服务端收到此请求头发现有 if-modified-since，则与被请求资源的最后修改时间进行对比，如果一致则返回 304 和响应报文头，浏览器只需要从缓存中获取信息即可。 从字面上看，就是说：从某个时间节点算起，是否文件被修改了\n\n 1. 如果真的被修改：那么开始传输响应一个整体，服务器返回：200 ok\n 2. 如果没有被修改：那么只需传输响应 header，服务器返回：304 not modified\n\nif-unmodified-since: 从字面上看, 就是说: 从某个时间点算起, 是否文件没有被修改\n\n 1. 如果没有被修改:则开始`继续'传送文件: 服务器返回: 200 ok\n 2. 如果文件被修改:则不传输,服务器返回: 412 precondition failed (预处理错误)\n\n这两个的区别是一个是修改了才下载一个是没修改才下载。 last-modified 说好却也不是特别好，因为如果在服务器上，一个资源被修改了，但其实际内容根本没发生改变，会因为 last-modified 时间匹配不上而返回了整个实体给客户端（即使客户端缓存里有个一模一样的资源）。为了解决这个问题，http1.1 推出了 etag。\n\n\n# 参考资料\n\n * 图解 http 缓存\n * http----http 缓存机制\n * 缓存详解",charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Java 缓存",frontmatter:{title:"Java 缓存",date:"2022-02-17T22:34:30.000Z",categories:["Java","中间件","缓存"],tags:["Java","中间件","缓存"],permalink:"/pages/c4efe9/",hidden:!0,index:!1},regularPath:"/01.Java/14.%E4%B8%AD%E9%97%B4%E4%BB%B6/02.%E7%BC%93%E5%AD%98/",relativePath:"01.Java/14.中间件/02.缓存/README.md",key:"v-50444ed1",path:"/pages/c4efe9/",headers:[{level:2,title:"📖 内容",slug:"📖-内容",normalizedTitle:"📖 内容",charIndex:113},{level:2,title:"📚 资料",slug:"📚-资料",normalizedTitle:"📚 资料",charIndex:176},{level:2,title:"🚪 传送",slug:"🚪-传送",normalizedTitle:"🚪 传送",charIndex:380}],headersStr:"📖 内容 📚 资料 🚪 传送",content:"# Java 缓存\n\n> 缓存可以说是优化系统性能的第一手段，在各种技术中都会有缓存的应用。\n> \n> 如果想深入学习缓存，建议先了解一下 缓存基本原理，有助于理解缓存的特性、原理，使用缓存常见的问题及解决方案。\n\n\n\n\n# 📖 内容\n\n * Java 缓存框架\n * Ehcache 快速入门\n * Java 缓存库\n * Http 缓存\n\n\n# 📚 资料\n\n * JSR107\n * Spring Cache 官方文档\n * Spring Boot Cache 特性官方文档\n * J2Cache Gitee\n * JetCache Github\n * JetCache wiki\n * Memcached 官网\n * Memcached Github\n * Redis 官网\n * Redis github\n * Redis 官方文档中文版\n\n\n# 🚪 传送\n\n◾ 💧 钝悟的 IT 知识图谱 ◾",normalizedContent:"# java 缓存\n\n> 缓存可以说是优化系统性能的第一手段，在各种技术中都会有缓存的应用。\n> \n> 如果想深入学习缓存，建议先了解一下 缓存基本原理，有助于理解缓存的特性、原理，使用缓存常见的问题及解决方案。\n\n\n\n\n# 📖 内容\n\n * java 缓存框架\n * ehcache 快速入门\n * java 缓存库\n * http 缓存\n\n\n# 📚 资料\n\n * jsr107\n * spring cache 官方文档\n * spring boot cache 特性官方文档\n * j2cache gitee\n * jetcache github\n * jetcache wiki\n * memcached 官网\n * memcached github\n * redis 官网\n * redis github\n * redis 官方文档中文版\n\n\n# 🚪 传送\n\n◾ 💧 钝悟的 it 知识图谱 ◾",charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Hystrix 快速入门",frontmatter:{title:"Hystrix 快速入门",date:"2022-02-17T22:34:30.000Z",order:1,categories:["Java","中间件","流量控制"],tags:["Java","中间件","流量控制","Hystrix"],permalink:"/pages/364124/"},regularPath:"/01.Java/14.%E4%B8%AD%E9%97%B4%E4%BB%B6/03.%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/01.Hystrix.html",relativePath:"01.Java/14.中间件/03.流量控制/01.Hystrix.md",key:"v-e3279b12",path:"/pages/364124/",headers:[{level:2,title:"Hystrix 简介",slug:"hystrix-简介",normalizedTitle:"hystrix 简介",charIndex:19},{level:3,title:"Hystrix 是什么",slug:"hystrix-是什么",normalizedTitle:"hystrix 是什么",charIndex:34},{level:3,title:"为什么需要 Hystrix",slug:"为什么需要-hystrix",normalizedTitle:"为什么需要 hystrix",charIndex:391},{level:3,title:"Hystrix 的功能",slug:"hystrix-的功能",normalizedTitle:"hystrix 的功能",charIndex:949},{level:2,title:"Hystrix 原理",slug:"hystrix-原理",normalizedTitle:"hystrix 原理",charIndex:1421},{level:3,title:"（一）构建一个 HystrixCommand 或 HystrixObservableCommand 对象",slug:"一-构建一个-hystrixcommand-或-hystrixobservablecommand-对象",normalizedTitle:"（一）构建一个 hystrixcommand 或 hystrixobservablecommand 对象",charIndex:1472},{level:3,title:"（二）执行命令",slug:"二-执行命令",normalizedTitle:"（二）执行命令",charIndex:1911},{level:3,title:"（三）是否缓存",slug:"三-是否缓存",normalizedTitle:"（三）是否缓存",charIndex:3049},{level:3,title:"（四）是否开启断路器",slug:"四-是否开启断路器",normalizedTitle:"（四）是否开启断路器",charIndex:3121},{level:3,title:"（五）信号量、线程池是否拒绝",slug:"五-信号量、线程池是否拒绝",normalizedTitle:"（五）信号量、线程池是否拒绝",charIndex:3278},{level:3,title:"（六）construct() 或 run()",slug:"六-construct-或-run",normalizedTitle:"（六）construct() 或 run()",charIndex:3552},{level:3,title:"（七）健康检查",slug:"七-健康检查",normalizedTitle:"（七）健康检查",charIndex:4566},{level:3,title:"（八）获取 Fallback",slug:"八-获取-fallback",normalizedTitle:"（八）获取 fallback",charIndex:4769},{level:3,title:"（九）返回结果",slug:"九-返回结果",normalizedTitle:"（九）返回结果",charIndex:4921},{level:2,title:"断路器工作原理",slug:"断路器工作原理",normalizedTitle:"断路器工作原理",charIndex:5329},{level:3,title:"系统指标",slug:"系统指标",normalizedTitle:"系统指标",charIndex:7511},{level:2,title:"资源隔离技术",slug:"资源隔离技术",normalizedTitle:"资源隔离技术",charIndex:1575},{level:3,title:"线程池隔离",slug:"线程池隔离",normalizedTitle:"线程池隔离",charIndex:7822},{level:3,title:"信号量隔离",slug:"信号量隔离",normalizedTitle:"信号量隔离",charIndex:10871},{level:2,title:"Hystrix 应用",slug:"hystrix-应用",normalizedTitle:"hystrix 应用",charIndex:11238},{level:2,title:"Hystrix 配置",slug:"hystrix-配置",normalizedTitle:"hystrix 配置",charIndex:11253},{level:3,title:"执行配置",slug:"执行配置",normalizedTitle:"执行配置",charIndex:12370},{level:3,title:"断路配置",slug:"断路配置",normalizedTitle:"断路配置",charIndex:12784},{level:3,title:"指标配置",slug:"指标配置",normalizedTitle:"指标配置",charIndex:13299},{level:3,title:"线程池配置",slug:"线程池配置",normalizedTitle:"线程池配置",charIndex:14170},{level:2,title:"其他限流技术",slug:"其他限流技术",normalizedTitle:"其他限流技术",charIndex:15008},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:15751}],headersStr:"Hystrix 简介 Hystrix 是什么 为什么需要 Hystrix Hystrix 的功能 Hystrix 原理 （一）构建一个 HystrixCommand 或 HystrixObservableCommand 对象 （二）执行命令 （三）是否缓存 （四）是否开启断路器 （五）信号量、线程池是否拒绝 （六）construct() 或 run() （七）健康检查 （八）获取 Fallback （九）返回结果 断路器工作原理 系统指标 资源隔离技术 线程池隔离 信号量隔离 Hystrix 应用 Hystrix 配置 执行配置 断路配置 指标配置 线程池配置 其他限流技术 参考资料",content:'# Hystrix 快速入门\n\n\n# Hystrix 简介\n\n\n# Hystrix 是什么\n\nHystrix 是由 Netflix 开源，用于处理分布式系统的延迟和容错的一个开源组件。在分布式系统里，许多依赖不可避免的会调用失败，比如超时、异常等。Hystrix 采用断路器模式来实现服务间的彼此隔离，从而避免级联故障，以提高分布式系统整体的弹性。\n\n“断路器”本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控（类似熔断保险丝），向调用方返回一个符合预期的、可处理的备选响应（FallBack），而不是长时间的等待或者抛出调用方无法处理的异常，这样就保证了服务调用方的线程不会被长时间、不必要地占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩。\n\nHystrix 官方已宣布不再发布新版本。但是，Hystrix 的断路器设计理念，有非常高的学习价值。\n\n\n# 为什么需要 Hystrix\n\n复杂的分布式系统架构中的应用程序往往具有数十个依赖项，每个依赖项都会不可避免地在某个时刻失败。 如果主机应用程序未与这些外部故障隔离开来，则可能会被波及。\n\n例如，对于依赖于 30 个服务的应用程序，假设每个服务的正常运行时间为 99.99％，则可以期望：\n\n> 99.9930 = 99.7％ 的正常运行时间\n> \n> 10 亿个请求中的 0.3％= 3,000,000 个失败\n> \n> 即使所有依赖项都具有出色的正常运行时间，每月也会有 2 个小时以上的停机时间。\n> \n> 然而，现实情况一般比这种估量情况更糟糕。\n\n----------------------------------------\n\n当一切正常时，整体系统如下所示：\n\n\n\n在高并发场景，这些依赖的稳定性与否对系统的影响非常大，但是依赖有很多不可控问题：如网络连接、资源繁忙、服务宕机等。例如：下图中有一个 QPS 为 50 的依赖 I 出现不可用，但是其他依赖服务是可用的。\n\n\n\n但是，在高并发场景下，当依赖 I 阻塞时，大多数服务器的线程池就出现阻塞(BLOCK)。当这种级联故障愈演愈烈，就可能造成整个线上服务不可用的雪崩效应，如下图：\n\n\n\nHystrix 就是为了解决这类问题而应运而生。\n\n\n# Hystrix 的功能\n\nHystrix 具有以下功能：\n\n * 避免资源耗尽：阻止任何一个依赖服务耗尽所有的资源，比如 tomcat 中的所有线程资源。\n * 避免请求排队和积压：采用限流和 fail fast 来控制故障。\n * 支持降级：提供 fallback 降级机制来应对故障。\n * 资源隔离：比如 bulkhead（舱壁隔离技术）、swimlane（泳道技术）、circuit breaker（断路技术）来限制任何一个依赖服务的故障的影响。\n * 统计/监控/报警：通过近实时的统计/监控/报警功能，来提高故障发现的速度。\n * 通过近实时的属性和配置热修改功能，来提高故障处理和恢复的速度。\n * 保护依赖服务调用的所有故障情况，而不仅仅只是网络故障情况。\n\n如果使用 Hystrix 对每个基础依赖服务进行过载保护，则整个系统架构将会类似下图所示，每个依赖项彼此隔离，受到延迟时发生饱和的资源的被限制访问，并包含 fallback 逻辑（用于降级处理），该逻辑决定了在依赖项中发生任何类型的故障时做出对应的处理。\n\n\n\n\n# Hystrix 原理\n\n如下图所示，Hystrix 的工作流程大致可以分为 9 个步骤。\n\n\n\n\n# （一）构建一个 HystrixCommand 或 HystrixObservableCommand 对象\n\nHystrix 进行资源隔离，其实是提供了一个抽象，叫做命令模式。这也是 Hystrix 最基本的资源隔离技术。\n\n在使用 Hystrix 的过程中，会对依赖服务的调用请求封装成命令对象，Hystrix 对 命令对象抽象了两个抽象类：HystrixCommand 和 HystrixObservableCommand 。\n\n * HystrixCommand 表示的命令对象会返回一个唯一返回值。\n * HystrixObservableCommand 表示的命令对象 会返回多个返回值。\n\nHystrixCommand command = new HystrixCommand(arg1, arg2);\nHystrixObservableCommand command = new HystrixObservableCommand(arg1, arg2);\n\n\n\n# （二）执行命令\n\nHystrix 中共有 4 种方式执行命令，如下所示：\n\n执行方式             说明                                               可用对象\nexecute()        阻塞式同步执行，返回依赖服务的单一返回结果(或者抛出异常)                    HystrixCommand\nqueue()          异步执行，通过 Future 返回依赖服务的单一返回结果(或者抛出异常)             HystrixCommand\nobserve()        基于 Rxjava 的 Observable 方式，返回通过 Observable        HystrixObservableCommand\n                 表示的依赖服务返回结果。代调用代码先执行(Hot Obserable)\ntoObservable()   基于 Rxjava 的 Observable 方式，返回通过 Observable        HystrixObservableCommand\n                 表示的依赖服务返回结果。执行代码等到真正订阅的时候才会执行(cold observable)\n\n这四种命令中，exeucte()、queue()、observe() 的表示其实是通过 toObservable() 实现的，其转换关系如下图所示：\n\n\n\nHystrixCommand 执行方式\n\nK value   = command.execute();\n// 等价语句：\nK value = command.execute().queue().get();\n\n\nFuture<K> fValue  = command.queue();\n//等价语句：\nFuture<K> fValue = command.toObservable().toBlocking().toFuture();\n\n\nObservable<K> ohValue = command.observe(); //hot observable，立刻订阅，命令立刻执行\n//等价语句：\nObservable<K> ohValue = command.toObservable().subscribe(subject);\n\n// 上述执行最终实现还是基于 toObservable()\nObservable<K> ocValue = command.toObservable(); //cold observable，延后订阅，订阅发生后，执行才真正执行\n\n\n\n# （三）是否缓存\n\n如果当前命令对象启用了请求缓存，并且请求的响应存在于缓存中，则缓存的响应会立刻以 Observable 的形式返回。\n\n\n# （四）是否开启断路器\n\n如果第三步没有缓存没有命中，则判断一下当前断路器的断路状态是否打开。如果断路器状态为打开状态，则 Hystrix 将不会执行此 Command 命令，直接执行步骤 8 调用 Fallback；\n\n如果断路器状态是关闭，则执行步骤 5 检查是否有足够的资源运行 Command 命令\n\n\n# （五）信号量、线程池是否拒绝\n\n当您执行该命令时，Hystrix 会检查断路器以查看电路是否打开。\n\n如果电路开路（或“跳闸”），则 Hystrix 将不会执行该命令，而是将流程路由到 (8) 获取回退。\n\n如果电路闭合，则流程前进至 (5) 以检查是否有可用容量来运行命令。\n\n如果当前要执行的 Command 命令 先关连的线程池 和队列(或者信号量)资源已经满了，Hystrix 将不会运行 Command 命令，直接执行 步骤 8的 Fallback 降级处理；如果未满，表示有剩余的资源执行 Command 命令，则执行步骤 6\n\n\n# （六）construct() 或 run()\n\n当经过步骤 5 判断，有足够的资源执行 Command 命令时，本步骤将调用 Command 命令运行方法，基于不同类型的 Command，有如下两种两种运行方式：\n\n运行方式                                   说明\nHystrixCommand.run()                   返回一个处理结果或者抛出一个异常\nHystrixObservableCommand.construct()   返回一个 Observable 表示的结果(可能多个)，或者 基于onError的错误通知\n\n如果run() 或者construct()方法 的真实执行时间超过了 Command 设置的超时时间阈值, 则当前则执行线程（或者是独立的定时器线程）将会抛出TimeoutException。抛出超时异常 TimeoutException，后，将执行步骤 8的 Fallback 降级处理。即使run()或者construct()执行没有被取消或中断，最终能够处理返回结果，但在降级处理逻辑中，将会抛弃run()或construct()方法的返回结果，而返回 Fallback 降级处理结果。\n\n> 注意事项 需要注意的是，Hystrix 无法强制 将正在运行的线程停止掉--Hystrix 能够做的最好的方式就是在 JVM 中抛出一个InterruptedException。如果 Hystrix 包装的工作不抛出中断异常InterruptedException, 则在 Hystrix 线程池中的线程将会继续执行，尽管调用的客户端已经接收到了TimeoutException。这种方式会使 Hystrix 的线程池处于饱和状态。大部分的 Java Http Client 开源库并不会解析 InterruptedException。所以确认 HTTP client 相关的连接和读/写相关的超时时间设置。 如果 Command 命令没有抛出任何异常，并且有返回结果，则 Hystrix 将会在做完日志记录和统计之后会将结果返回。 如果是通过run()方式运行，则返回一个Obserable对象，包含一个唯一值，并且发送一个onCompleted通知；如果是通过consturct()方式运行 ，则返回一个Observable对象。\n\n\n# （七）健康检查\n\nHystrix 会统计 Command 命令执行执行过程中的成功数、失败数、拒绝数和超时数,将这些信息记录到断路器(Circuit Breaker)中。断路器将上述统计按照时间窗的形式记录到一个定长数组中。断路器根据时间窗内的统计数据去判定请求什么时候可以被熔断，熔断后，在接下来一段恢复周期内，相同的请求过来后会直接被熔断。当再次校验，如果健康监测通过后，熔断开关将会被关闭。\n\n\n# （八）获取 Fallback\n\n当以下场景出现后，Hystrix 将会尝试触发 Fallback:\n\n>  * 步骤 6 Command 执行时抛出了任何异常；\n>  * 步骤 4 断路器已经被打开\n>  * 步骤 5 执行命令的线程池、队列或者信号量资源已满\n>  * 命令执行的时间超过阈值\n\n\n# （九）返回结果\n\n如果 Hystrix 命令对象执行成功，将会返回结果，或者以Observable形式包装的结果。根据步骤 2的 command 调用方式，返回的Observable 会按照如下图说是的转换关系进行返回：\n\n\n\n * execute() — 用和 .queue() 相同的方式获取 Future，然后调用 Future 的 get() 以获取 Observable 的单个值。\n * queue() —将 Observable 转换为 BlockingObservable，以便可以将其转换为 Future 并返回。\n * watch() —订阅 Observable 并开始执行命令的流程； 返回一个 Observable，当订阅该 Observable 时，它会重新通知。\n * toObservable() —返回不变的 Observable； 必须订阅它才能真正开始执行命令的流程。\n\n\n# 断路器工作原理\n\n\n\n 1. 断路器时间窗内的请求数 是否超过了请求数断路器生效阈值circuitBreaker.requestVolumeThreshold,如果超过了阈值，则将会触发断路，断路状态为开启 例如，如果当前阈值设置的是20,则当时间窗内统计的请求数共计 19 个，即使 19 个全部失败了，都不会触发断路器。\n 2. 并且请求错误率超过了请求错误率阈值errorThresholdPercentage\n 3. 如果两个都满足，则将断路器由关闭迁移到开启\n 4. 如果断路器开启，则后续的所有相同请求将会被断路掉；\n 5. 直到过了沉睡时间窗sleepWindowInMilliseconds后，再发起请求时，允许其通过（此时的状态为半开起状态）。如果请求失败了，则保持断路器状态为开启状态，并更新沉睡时间窗。如果请求成功了，则将断路器状态改为关闭状态；\n\n核心的逻辑如下：\n\n @Override\n                        public void onNext(HealthCounts hc) {\n                            // check if we are past the statisticalWindowVolumeThreshold\n                            if (hc.getTotalRequests() < properties.circuitBreakerRequestVolumeThreshold().get()) {\n                                // we are not past the minimum volume threshold for the stat window,\n                                // so no change to circuit status.\n                                // if it was CLOSED, it stays CLOSED\n                                // if it was half-open, we need to wait for a successful command execution\n                                // if it was open, we need to wait for sleep window to elapse\n                            } else {\n                                if (hc.getErrorPercentage() < properties.circuitBreakerErrorThresholdPercentage().get()) {\n                                    //we are not past the minimum error threshold for the stat window,\n                                    // so no change to circuit status.\n                                    // if it was CLOSED, it stays CLOSED\n                                    // if it was half-open, we need to wait for a successful command execution\n                                    // if it was open, we need to wait for sleep window to elapse\n                                } else {\n                                    // our failure rate is too high, we need to set the state to OPEN\n                                    if (status.compareAndSet(Status.CLOSED, Status.OPEN)) {\n                                        circuitOpened.set(System.currentTimeMillis());\n                                    }\n                                }\n                            }\n                        }\n\n\n\n# 系统指标\n\nHystrix 对系统指标的统计是基于时间窗模式的：\n\n> 时间窗：最近的一个时间区间内，比如前一小时到现在，那么时间窗的长度就是1小时； 桶：桶是在特定的时间窗内，等分的指标收集的统计集合；比如时间窗的长度为1小时，而桶的数量为10,那么每个桶在时间轴上依次排开，时间由远及近，每个桶统计的时间分片为 1h / 10 = 6 min 6 分钟。一个桶中，包含了成功数、失败数、超时数、拒绝数 四个指标。\n\n在系统内，时间窗会随着系统的运行逐渐向前移动，而时间窗的长度和桶的数量是固定不变的，那么随着时间的移动，会出现较久的过期的桶被移除出去，新的桶被添加进来，如下图所示：\n\n\n\n\n# 资源隔离技术\n\n\n# 线程池隔离\n\n如下图所示，由于计算机系统的基本执行单位就是线程，线程具备独立的执行能力，所以，为了做到资源保护，需要对系统的线程池进行划分，对于外部调用方\n\nUser Request\n\n\n的请求，调用各个线程池的服务，各个线程池独立完成调用，然后将结果返回\n\n调用方\n\n\n。在调用服务的过程中，如果\n\n服务提供方\n\n\n执行时间过长，则\n\n调用方\n\n\n可以直接以超时的方式直接返回，快速失败。\n\n\n\n线程池隔离的几点好处\n\n>  1. 使用超时返回的机制，避免同步调用服务时，调用时间过长，无法释放，导致资源耗尽的情况\n>  2. 服务方可以控制请求数量，请求过多，可以直接拒绝,达到快速失败的目的；\n>  3. 请求排队，线程池可以维护执行队列，将请求压到队列中处理\n\n举个例子，如下代码段，模拟了同步调用服务的过程：\n\n        //服务提供方，执行服务的时候模拟2分钟的耗时\n        Callable<String> callableService  = ()->{\n            long start = System.currentTimeMillis();\n            while(System.currentTimeMillis()-start> 1000 * 60 *2){\n               //模拟服务执行时间过长的情况\n            }\n            return "OK";\n        };\n\n        //模拟10个客户端调用服务\n        ExecutorService clients = Executors.newFixedThreadPool(10);\n        //模拟给10个客户端提交处理请求\n        for (int i = 0; i < 20; i++) {\n            clients.execute(()->{\n                //同步调用\n                try {\n                    String result = callableService.call();\n                    System.out.println("当前客户端："+Thread.currentThread().getName()+"调用服务完成，得到结果："+result);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            });\n        }\n\n\n在此环节中，客户端 clients必须等待服务方返回结果之后，才能接收新的请求。如果用吞吐量来衡量系统的话，会发现系统的处理能力比较低。为了提高相应时间，可以借助线程池的方式，设置超时时间，这样的话，客户端就不需要必须等待服务方返回，如果时间过长，可以提前返回,改造后的代码如下所示：\n\n //服务提供方，执行服务的时候模拟2分钟的耗时\n        Callable<String> callableService  = ()->{\n            long start = System.currentTimeMillis();\n            while(System.currentTimeMillis()-start> 1000 * 60 *2){\n               //模拟服务执行时间过长的情况\n            }\n            return "OK";\n        };\n\n        //创建线程池作为服务方\n        ExecutorService executorService = Executors.newFixedThreadPool(30);\n\n\n        //模拟10个客户端调用服务\n        ExecutorService clients = Executors.newFixedThreadPool(10);\n        for (int i = 0; i < 10; i++) {\n            clients.execute(()->{\n                //同步调用\n                    //将请求提交给线程池执行，Callable 和 Runnable在某种意义上，也是Command对象\n                    Future<String> future = executorService.submit(callableService::call);\n                    //在指定的时间内获取结果，如果超时，调用方可以直接返回\n                    try {\n                        String result = future.get(1000, TimeUnit.SECONDS);\n                        //客户端等待时间之后，快速返回\n                        System.out.println("当前客户端："+Thread.currentThread().getName()+"调用服务完成，得到结果："+result);\n                    }catch (TimeoutException timeoutException){\n                        System.out.println("服务调用超时，返回处理");\n                    } catch (InterruptedException e) {\n\n                    } catch (ExecutionException e) {\n                    }\n            });\n        }\n\n\n如果我们将服务方的线程池设置为：\n\nThreadPoolExecutor executorService = new ThreadPoolExecutor(10,1000,TimeUnit.SECONDS,\nnew ArrayBlockingQueue<>(100),\nnew ThreadPoolExecutor.DiscardPolicy() // 提交请求过多时，可以丢弃请求，避免死等阻塞的情况。\n)\n\n\n线程池隔离模式的弊端\n\n> 线程池隔离模式，会根据服务划分出独立的线程池，系统资源的线程并发数是有限的，当线程数过多，系统话费大量的 CPU 时间来做线程上下文切换的无用操作，反而降低系统性能；如果线程池隔离的过多，会导致真正用于接收用户请求的线程就相应地减少，系统吞吐量反而下降； 在实践上，应当对像远程方法调用，网络资源请求这种服务时间不太可控的场景下使用线程池隔离模式处理 如下图所示，是线程池隔离模式的三种场景：\n\n\n\n\n# 信号量隔离\n\n由于基于线程池隔离的模式占用系统线程池资源，Hystrix 还提供了另外一个隔离技术：基于信号量的隔离。\n\n基于信号量的隔离方式非常地简单，其核心就是使用共用变量\n\nsemaphore\n\n\n进行原子操作，控制线程的并发量，当并发量达到一定量级时，服务禁止调用。如下图所示：信号量本身不会消耗多余的线程资源，所以就非常轻量。\n\n\n\n基于信号量隔离的利弊\n\n> 利：基于信号量的隔离，利用 JVM 的原子性 CAS 操作，避免了资源锁的竞争，省去了线程池开销，效率非常高； 弊：本质上基于信号量的隔离是同步行为，所以无法做到超时熔断，所以服务方自身要控制住执行时间，避免超时。 应用场景：业务服务上，有并发上限限制时，可以考虑此方式 > Alibaba Sentinel开源框架，就是基于信号量的熔断和断路器框架。\n\n\n# Hystrix 应用\n\n * Hystrix 配置无法动态调节生效。Hystrix 框架本身是使用的Archaius框架完成的配置加载和刷新，但是集成自 Spring Cloud 下，无法有效地根据实时监控结果，动态调整熔断和系统参数\n * 线程池和 Command 之间的配置比较复杂,在 Spring Cloud 在做 feigin-hystrix 集成的时候，还有些 BUG，对 command 的默认配置没有处理好，导致所有 command 占用公共的 command 线程池，没有细粒度控制，还需要做框架适配调整\n\npublic interface SetterFactory {\n\n  /**\n   * Returns a hystrix setter appropriate for the given target and method\n   */\n  HystrixCommand.Setter create(Target<?> target, Method method);\n\n  /**\n   * Default behavior is to derive the group key from {@link Target#name()} and the command key from\n   * {@link Feign#configKey(Class, Method)}.\n   */\n  final class Default implements SetterFactory {\n\n    @Override\n    public HystrixCommand.Setter create(Target<?> target, Method method) {\n      String groupKey = target.name();\n      String commandKey = Feign.configKey(target.type(), method);\n      return HystrixCommand.Setter\n          .withGroupKey(HystrixCommandGroupKey.Factory.asKey(groupKey))\n          .andCommandKey(HystrixCommandKey.Factory.asKey(commandKey));\n          //没有处理好default配置项的加载\n    }\n  }\n}\n\n\n\n# Hystrix 配置\n\n> 详细配置可以参考 Hystrix 官方配置手册，这里仅介绍比较核心的配置\n\n\n# 执行配置\n\n以下配置用于控制 HystrixCommand.run() 如何执行。\n\n配置项                                                   说明                              默认值\nexecution.isolation.strategy                          线程隔离（THREAD）或信号量隔离（SEMAPHORE）   THREAD\nexecution.isolation.thread.timeoutInMilliseconds      方法执行超时时间                        1000(ms)\nexecution.isolation.semaphore.maxConcurrentRequests   信号量隔离最大并发数                      10\n\n\n# 断路配置\n\n以下配置用于控制 HystrixCircuitBreaker 的断路处理。\n\n配置项                                        说明                默认值\ncircuitBreaker.enabled                     是否开启断路器           true\ncircuitBreaker.requestVolumeThreshold      断路器启用请求数阈值        20\ncircuitBreaker.sleepWindowInMilliseconds   断路器启用后的休眠时间       5000(ms)\ncircuitBreaker.errorThresholdPercentage    断路器启用失败率阈值        50(%)\ncircuitBreaker.forceOpen                   是否强制将断路器设置成开启状态   false\ncircuitBreaker.forceClosed                 是否强制将断路器设置成关闭状态   false\n\n\n# 指标配置\n\n以下配置用于从 HystrixCommand 和 HystrixObservableCommand 执行中捕获相关指标。\n\n配置项                                             说明                                            默认值\nmetrics.rollingStats.timeInMilliseconds         时间窗的长度                                        10000(ms)\nmetrics.rollingStats.numBuckets                 桶的数量，需要保证timeInMilliseconds % numBuckets =0   10\nmetrics.rollingPercentile.enabled               是否统计运行延迟的占比                                   true\nmetrics.rollingPercentile.timeInMilliseconds    运行延迟占比统计的时间窗                                  60000(ms)\nmetrics.rollingPercentile.numBuckets            运行延迟占比统计的桶数                                   6\nmetrics.rollingPercentile.bucketSize            百分比统计桶的容量，桶内最多保存的运行时间统计                       100\nmetrics.healthSnapshot.intervalInMilliseconds   统计快照刷新间隔                                      500 (ms)\n\n\n# 线程池配置\n\n以下配置用于控制 Hystrix Command 执行所使用的线程池。\n\n配置项                                     说明                                                           默认值\ncoreSize                                线程池核心线程数                                                     10\nmaximumSize                             线程池最大线程数                                                     10\nmaxQueueSize                            最大 LinkedBlockingQueue 的大小，-1 表示用 SynchronousQueue           -1\nqueueSizeRejectionThreshold             队列大小阈值，超过则拒绝                                                 5\nallowMaximumSizeToDivergeFromCoreSize   此属性允许 maximumSize 的配置生效。该值可以等于或大于 coreSize。设置 coreSize       false\n                                        <maximumSize 使得线程池可以维持 maximumSize 并发性，但是会在相对空闲时将线程回收。（取决于\n                                        keepAliveTimeInMinutes）\n\n\n# 其他限流技术\n\n * resilience4j Hystrix 虽然官方宣布不再维护，其推荐另外一个框架：resilience4j, 这个框架是是为 Java 8 和 函数式编程设计的一个轻量级的容错框架，该框架充分利用函数式编程的概念，为函数式接口、lamda表达式、方法引用高阶函数进行包装，(本质上是装饰者模式的概念)，通过包装实现断路、限流、重试、舱壁功能。 这个框架整体而言比较轻量，没有控制台，不太好做系统级监控；\n\n * Alibaba Sentinel\n   \n   Sentinel\n   \n   \n   是 阿里巴巴开源的轻量级的流量控制、熔断降级 Java 库，该库的核心是使用的是信号量隔离的方式做流量控制和熔断，其优点是其集成性和易用性，几乎能和当前主流的 Spring Cloud, dubbo ,grpc ,nacos, zookeeper 做集成，如下图所示：\n   \n   \n   \n   sentinel-features-overview-en.png\n   \n   Sentinel\n   \n   \n   的目标生态圈：\n   \n   \n   \n   sentinel\n   \n   \n   一个强大的功能，就是它有一个流控管理控制台，你可以实时地监控每个服务的流控情况，并且可以实时编辑各种流控、熔断规则，有效地保证了服务保护的及时性。下图是内部试用的 sentinel 控制台：\n   \n   另外，\n   \n   sentinel\n   \n   \n   还可以和\n   \n   ctrip apollo\n   \n   \n   分布式配置系统进行集成，将流控规降级等各种规则先配置在 apollo 中，然后服务启动自动加载流控规则。\n\n\n# 参考资料\n\n * Hystrix Github\n * Spring Cloud Hystrix 设计原理\n * Hystrix 都停更了，我为什么还要学？',normalizedContent:'# hystrix 快速入门\n\n\n# hystrix 简介\n\n\n# hystrix 是什么\n\nhystrix 是由 netflix 开源，用于处理分布式系统的延迟和容错的一个开源组件。在分布式系统里，许多依赖不可避免的会调用失败，比如超时、异常等。hystrix 采用断路器模式来实现服务间的彼此隔离，从而避免级联故障，以提高分布式系统整体的弹性。\n\n“断路器”本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控（类似熔断保险丝），向调用方返回一个符合预期的、可处理的备选响应（fallback），而不是长时间的等待或者抛出调用方无法处理的异常，这样就保证了服务调用方的线程不会被长时间、不必要地占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩。\n\nhystrix 官方已宣布不再发布新版本。但是，hystrix 的断路器设计理念，有非常高的学习价值。\n\n\n# 为什么需要 hystrix\n\n复杂的分布式系统架构中的应用程序往往具有数十个依赖项，每个依赖项都会不可避免地在某个时刻失败。 如果主机应用程序未与这些外部故障隔离开来，则可能会被波及。\n\n例如，对于依赖于 30 个服务的应用程序，假设每个服务的正常运行时间为 99.99％，则可以期望：\n\n> 99.9930 = 99.7％ 的正常运行时间\n> \n> 10 亿个请求中的 0.3％= 3,000,000 个失败\n> \n> 即使所有依赖项都具有出色的正常运行时间，每月也会有 2 个小时以上的停机时间。\n> \n> 然而，现实情况一般比这种估量情况更糟糕。\n\n----------------------------------------\n\n当一切正常时，整体系统如下所示：\n\n\n\n在高并发场景，这些依赖的稳定性与否对系统的影响非常大，但是依赖有很多不可控问题：如网络连接、资源繁忙、服务宕机等。例如：下图中有一个 qps 为 50 的依赖 i 出现不可用，但是其他依赖服务是可用的。\n\n\n\n但是，在高并发场景下，当依赖 i 阻塞时，大多数服务器的线程池就出现阻塞(block)。当这种级联故障愈演愈烈，就可能造成整个线上服务不可用的雪崩效应，如下图：\n\n\n\nhystrix 就是为了解决这类问题而应运而生。\n\n\n# hystrix 的功能\n\nhystrix 具有以下功能：\n\n * 避免资源耗尽：阻止任何一个依赖服务耗尽所有的资源，比如 tomcat 中的所有线程资源。\n * 避免请求排队和积压：采用限流和 fail fast 来控制故障。\n * 支持降级：提供 fallback 降级机制来应对故障。\n * 资源隔离：比如 bulkhead（舱壁隔离技术）、swimlane（泳道技术）、circuit breaker（断路技术）来限制任何一个依赖服务的故障的影响。\n * 统计/监控/报警：通过近实时的统计/监控/报警功能，来提高故障发现的速度。\n * 通过近实时的属性和配置热修改功能，来提高故障处理和恢复的速度。\n * 保护依赖服务调用的所有故障情况，而不仅仅只是网络故障情况。\n\n如果使用 hystrix 对每个基础依赖服务进行过载保护，则整个系统架构将会类似下图所示，每个依赖项彼此隔离，受到延迟时发生饱和的资源的被限制访问，并包含 fallback 逻辑（用于降级处理），该逻辑决定了在依赖项中发生任何类型的故障时做出对应的处理。\n\n\n\n\n# hystrix 原理\n\n如下图所示，hystrix 的工作流程大致可以分为 9 个步骤。\n\n\n\n\n# （一）构建一个 hystrixcommand 或 hystrixobservablecommand 对象\n\nhystrix 进行资源隔离，其实是提供了一个抽象，叫做命令模式。这也是 hystrix 最基本的资源隔离技术。\n\n在使用 hystrix 的过程中，会对依赖服务的调用请求封装成命令对象，hystrix 对 命令对象抽象了两个抽象类：hystrixcommand 和 hystrixobservablecommand 。\n\n * hystrixcommand 表示的命令对象会返回一个唯一返回值。\n * hystrixobservablecommand 表示的命令对象 会返回多个返回值。\n\nhystrixcommand command = new hystrixcommand(arg1, arg2);\nhystrixobservablecommand command = new hystrixobservablecommand(arg1, arg2);\n\n\n\n# （二）执行命令\n\nhystrix 中共有 4 种方式执行命令，如下所示：\n\n执行方式             说明                                               可用对象\nexecute()        阻塞式同步执行，返回依赖服务的单一返回结果(或者抛出异常)                    hystrixcommand\nqueue()          异步执行，通过 future 返回依赖服务的单一返回结果(或者抛出异常)             hystrixcommand\nobserve()        基于 rxjava 的 observable 方式，返回通过 observable        hystrixobservablecommand\n                 表示的依赖服务返回结果。代调用代码先执行(hot obserable)\ntoobservable()   基于 rxjava 的 observable 方式，返回通过 observable        hystrixobservablecommand\n                 表示的依赖服务返回结果。执行代码等到真正订阅的时候才会执行(cold observable)\n\n这四种命令中，exeucte()、queue()、observe() 的表示其实是通过 toobservable() 实现的，其转换关系如下图所示：\n\n\n\nhystrixcommand 执行方式\n\nk value   = command.execute();\n// 等价语句：\nk value = command.execute().queue().get();\n\n\nfuture<k> fvalue  = command.queue();\n//等价语句：\nfuture<k> fvalue = command.toobservable().toblocking().tofuture();\n\n\nobservable<k> ohvalue = command.observe(); //hot observable，立刻订阅，命令立刻执行\n//等价语句：\nobservable<k> ohvalue = command.toobservable().subscribe(subject);\n\n// 上述执行最终实现还是基于 toobservable()\nobservable<k> ocvalue = command.toobservable(); //cold observable，延后订阅，订阅发生后，执行才真正执行\n\n\n\n# （三）是否缓存\n\n如果当前命令对象启用了请求缓存，并且请求的响应存在于缓存中，则缓存的响应会立刻以 observable 的形式返回。\n\n\n# （四）是否开启断路器\n\n如果第三步没有缓存没有命中，则判断一下当前断路器的断路状态是否打开。如果断路器状态为打开状态，则 hystrix 将不会执行此 command 命令，直接执行步骤 8 调用 fallback；\n\n如果断路器状态是关闭，则执行步骤 5 检查是否有足够的资源运行 command 命令\n\n\n# （五）信号量、线程池是否拒绝\n\n当您执行该命令时，hystrix 会检查断路器以查看电路是否打开。\n\n如果电路开路（或“跳闸”），则 hystrix 将不会执行该命令，而是将流程路由到 (8) 获取回退。\n\n如果电路闭合，则流程前进至 (5) 以检查是否有可用容量来运行命令。\n\n如果当前要执行的 command 命令 先关连的线程池 和队列(或者信号量)资源已经满了，hystrix 将不会运行 command 命令，直接执行 步骤 8的 fallback 降级处理；如果未满，表示有剩余的资源执行 command 命令，则执行步骤 6\n\n\n# （六）construct() 或 run()\n\n当经过步骤 5 判断，有足够的资源执行 command 命令时，本步骤将调用 command 命令运行方法，基于不同类型的 command，有如下两种两种运行方式：\n\n运行方式                                   说明\nhystrixcommand.run()                   返回一个处理结果或者抛出一个异常\nhystrixobservablecommand.construct()   返回一个 observable 表示的结果(可能多个)，或者 基于onerror的错误通知\n\n如果run() 或者construct()方法 的真实执行时间超过了 command 设置的超时时间阈值, 则当前则执行线程（或者是独立的定时器线程）将会抛出timeoutexception。抛出超时异常 timeoutexception，后，将执行步骤 8的 fallback 降级处理。即使run()或者construct()执行没有被取消或中断，最终能够处理返回结果，但在降级处理逻辑中，将会抛弃run()或construct()方法的返回结果，而返回 fallback 降级处理结果。\n\n> 注意事项 需要注意的是，hystrix 无法强制 将正在运行的线程停止掉--hystrix 能够做的最好的方式就是在 jvm 中抛出一个interruptedexception。如果 hystrix 包装的工作不抛出中断异常interruptedexception, 则在 hystrix 线程池中的线程将会继续执行，尽管调用的客户端已经接收到了timeoutexception。这种方式会使 hystrix 的线程池处于饱和状态。大部分的 java http client 开源库并不会解析 interruptedexception。所以确认 http client 相关的连接和读/写相关的超时时间设置。 如果 command 命令没有抛出任何异常，并且有返回结果，则 hystrix 将会在做完日志记录和统计之后会将结果返回。 如果是通过run()方式运行，则返回一个obserable对象，包含一个唯一值，并且发送一个oncompleted通知；如果是通过consturct()方式运行 ，则返回一个observable对象。\n\n\n# （七）健康检查\n\nhystrix 会统计 command 命令执行执行过程中的成功数、失败数、拒绝数和超时数,将这些信息记录到断路器(circuit breaker)中。断路器将上述统计按照时间窗的形式记录到一个定长数组中。断路器根据时间窗内的统计数据去判定请求什么时候可以被熔断，熔断后，在接下来一段恢复周期内，相同的请求过来后会直接被熔断。当再次校验，如果健康监测通过后，熔断开关将会被关闭。\n\n\n# （八）获取 fallback\n\n当以下场景出现后，hystrix 将会尝试触发 fallback:\n\n>  * 步骤 6 command 执行时抛出了任何异常；\n>  * 步骤 4 断路器已经被打开\n>  * 步骤 5 执行命令的线程池、队列或者信号量资源已满\n>  * 命令执行的时间超过阈值\n\n\n# （九）返回结果\n\n如果 hystrix 命令对象执行成功，将会返回结果，或者以observable形式包装的结果。根据步骤 2的 command 调用方式，返回的observable 会按照如下图说是的转换关系进行返回：\n\n\n\n * execute() — 用和 .queue() 相同的方式获取 future，然后调用 future 的 get() 以获取 observable 的单个值。\n * queue() —将 observable 转换为 blockingobservable，以便可以将其转换为 future 并返回。\n * watch() —订阅 observable 并开始执行命令的流程； 返回一个 observable，当订阅该 observable 时，它会重新通知。\n * toobservable() —返回不变的 observable； 必须订阅它才能真正开始执行命令的流程。\n\n\n# 断路器工作原理\n\n\n\n 1. 断路器时间窗内的请求数 是否超过了请求数断路器生效阈值circuitbreaker.requestvolumethreshold,如果超过了阈值，则将会触发断路，断路状态为开启 例如，如果当前阈值设置的是20,则当时间窗内统计的请求数共计 19 个，即使 19 个全部失败了，都不会触发断路器。\n 2. 并且请求错误率超过了请求错误率阈值errorthresholdpercentage\n 3. 如果两个都满足，则将断路器由关闭迁移到开启\n 4. 如果断路器开启，则后续的所有相同请求将会被断路掉；\n 5. 直到过了沉睡时间窗sleepwindowinmilliseconds后，再发起请求时，允许其通过（此时的状态为半开起状态）。如果请求失败了，则保持断路器状态为开启状态，并更新沉睡时间窗。如果请求成功了，则将断路器状态改为关闭状态；\n\n核心的逻辑如下：\n\n @override\n                        public void onnext(healthcounts hc) {\n                            // check if we are past the statisticalwindowvolumethreshold\n                            if (hc.gettotalrequests() < properties.circuitbreakerrequestvolumethreshold().get()) {\n                                // we are not past the minimum volume threshold for the stat window,\n                                // so no change to circuit status.\n                                // if it was closed, it stays closed\n                                // if it was half-open, we need to wait for a successful command execution\n                                // if it was open, we need to wait for sleep window to elapse\n                            } else {\n                                if (hc.geterrorpercentage() < properties.circuitbreakererrorthresholdpercentage().get()) {\n                                    //we are not past the minimum error threshold for the stat window,\n                                    // so no change to circuit status.\n                                    // if it was closed, it stays closed\n                                    // if it was half-open, we need to wait for a successful command execution\n                                    // if it was open, we need to wait for sleep window to elapse\n                                } else {\n                                    // our failure rate is too high, we need to set the state to open\n                                    if (status.compareandset(status.closed, status.open)) {\n                                        circuitopened.set(system.currenttimemillis());\n                                    }\n                                }\n                            }\n                        }\n\n\n\n# 系统指标\n\nhystrix 对系统指标的统计是基于时间窗模式的：\n\n> 时间窗：最近的一个时间区间内，比如前一小时到现在，那么时间窗的长度就是1小时； 桶：桶是在特定的时间窗内，等分的指标收集的统计集合；比如时间窗的长度为1小时，而桶的数量为10,那么每个桶在时间轴上依次排开，时间由远及近，每个桶统计的时间分片为 1h / 10 = 6 min 6 分钟。一个桶中，包含了成功数、失败数、超时数、拒绝数 四个指标。\n\n在系统内，时间窗会随着系统的运行逐渐向前移动，而时间窗的长度和桶的数量是固定不变的，那么随着时间的移动，会出现较久的过期的桶被移除出去，新的桶被添加进来，如下图所示：\n\n\n\n\n# 资源隔离技术\n\n\n# 线程池隔离\n\n如下图所示，由于计算机系统的基本执行单位就是线程，线程具备独立的执行能力，所以，为了做到资源保护，需要对系统的线程池进行划分，对于外部调用方\n\nuser request\n\n\n的请求，调用各个线程池的服务，各个线程池独立完成调用，然后将结果返回\n\n调用方\n\n\n。在调用服务的过程中，如果\n\n服务提供方\n\n\n执行时间过长，则\n\n调用方\n\n\n可以直接以超时的方式直接返回，快速失败。\n\n\n\n线程池隔离的几点好处\n\n>  1. 使用超时返回的机制，避免同步调用服务时，调用时间过长，无法释放，导致资源耗尽的情况\n>  2. 服务方可以控制请求数量，请求过多，可以直接拒绝,达到快速失败的目的；\n>  3. 请求排队，线程池可以维护执行队列，将请求压到队列中处理\n\n举个例子，如下代码段，模拟了同步调用服务的过程：\n\n        //服务提供方，执行服务的时候模拟2分钟的耗时\n        callable<string> callableservice  = ()->{\n            long start = system.currenttimemillis();\n            while(system.currenttimemillis()-start> 1000 * 60 *2){\n               //模拟服务执行时间过长的情况\n            }\n            return "ok";\n        };\n\n        //模拟10个客户端调用服务\n        executorservice clients = executors.newfixedthreadpool(10);\n        //模拟给10个客户端提交处理请求\n        for (int i = 0; i < 20; i++) {\n            clients.execute(()->{\n                //同步调用\n                try {\n                    string result = callableservice.call();\n                    system.out.println("当前客户端："+thread.currentthread().getname()+"调用服务完成，得到结果："+result);\n                } catch (exception e) {\n                    e.printstacktrace();\n                }\n            });\n        }\n\n\n在此环节中，客户端 clients必须等待服务方返回结果之后，才能接收新的请求。如果用吞吐量来衡量系统的话，会发现系统的处理能力比较低。为了提高相应时间，可以借助线程池的方式，设置超时时间，这样的话，客户端就不需要必须等待服务方返回，如果时间过长，可以提前返回,改造后的代码如下所示：\n\n //服务提供方，执行服务的时候模拟2分钟的耗时\n        callable<string> callableservice  = ()->{\n            long start = system.currenttimemillis();\n            while(system.currenttimemillis()-start> 1000 * 60 *2){\n               //模拟服务执行时间过长的情况\n            }\n            return "ok";\n        };\n\n        //创建线程池作为服务方\n        executorservice executorservice = executors.newfixedthreadpool(30);\n\n\n        //模拟10个客户端调用服务\n        executorservice clients = executors.newfixedthreadpool(10);\n        for (int i = 0; i < 10; i++) {\n            clients.execute(()->{\n                //同步调用\n                    //将请求提交给线程池执行，callable 和 runnable在某种意义上，也是command对象\n                    future<string> future = executorservice.submit(callableservice::call);\n                    //在指定的时间内获取结果，如果超时，调用方可以直接返回\n                    try {\n                        string result = future.get(1000, timeunit.seconds);\n                        //客户端等待时间之后，快速返回\n                        system.out.println("当前客户端："+thread.currentthread().getname()+"调用服务完成，得到结果："+result);\n                    }catch (timeoutexception timeoutexception){\n                        system.out.println("服务调用超时，返回处理");\n                    } catch (interruptedexception e) {\n\n                    } catch (executionexception e) {\n                    }\n            });\n        }\n\n\n如果我们将服务方的线程池设置为：\n\nthreadpoolexecutor executorservice = new threadpoolexecutor(10,1000,timeunit.seconds,\nnew arrayblockingqueue<>(100),\nnew threadpoolexecutor.discardpolicy() // 提交请求过多时，可以丢弃请求，避免死等阻塞的情况。\n)\n\n\n线程池隔离模式的弊端\n\n> 线程池隔离模式，会根据服务划分出独立的线程池，系统资源的线程并发数是有限的，当线程数过多，系统话费大量的 cpu 时间来做线程上下文切换的无用操作，反而降低系统性能；如果线程池隔离的过多，会导致真正用于接收用户请求的线程就相应地减少，系统吞吐量反而下降； 在实践上，应当对像远程方法调用，网络资源请求这种服务时间不太可控的场景下使用线程池隔离模式处理 如下图所示，是线程池隔离模式的三种场景：\n\n\n\n\n# 信号量隔离\n\n由于基于线程池隔离的模式占用系统线程池资源，hystrix 还提供了另外一个隔离技术：基于信号量的隔离。\n\n基于信号量的隔离方式非常地简单，其核心就是使用共用变量\n\nsemaphore\n\n\n进行原子操作，控制线程的并发量，当并发量达到一定量级时，服务禁止调用。如下图所示：信号量本身不会消耗多余的线程资源，所以就非常轻量。\n\n\n\n基于信号量隔离的利弊\n\n> 利：基于信号量的隔离，利用 jvm 的原子性 cas 操作，避免了资源锁的竞争，省去了线程池开销，效率非常高； 弊：本质上基于信号量的隔离是同步行为，所以无法做到超时熔断，所以服务方自身要控制住执行时间，避免超时。 应用场景：业务服务上，有并发上限限制时，可以考虑此方式 > alibaba sentinel开源框架，就是基于信号量的熔断和断路器框架。\n\n\n# hystrix 应用\n\n * hystrix 配置无法动态调节生效。hystrix 框架本身是使用的archaius框架完成的配置加载和刷新，但是集成自 spring cloud 下，无法有效地根据实时监控结果，动态调整熔断和系统参数\n * 线程池和 command 之间的配置比较复杂,在 spring cloud 在做 feigin-hystrix 集成的时候，还有些 bug，对 command 的默认配置没有处理好，导致所有 command 占用公共的 command 线程池，没有细粒度控制，还需要做框架适配调整\n\npublic interface setterfactory {\n\n  /**\n   * returns a hystrix setter appropriate for the given target and method\n   */\n  hystrixcommand.setter create(target<?> target, method method);\n\n  /**\n   * default behavior is to derive the group key from {@link target#name()} and the command key from\n   * {@link feign#configkey(class, method)}.\n   */\n  final class default implements setterfactory {\n\n    @override\n    public hystrixcommand.setter create(target<?> target, method method) {\n      string groupkey = target.name();\n      string commandkey = feign.configkey(target.type(), method);\n      return hystrixcommand.setter\n          .withgroupkey(hystrixcommandgroupkey.factory.askey(groupkey))\n          .andcommandkey(hystrixcommandkey.factory.askey(commandkey));\n          //没有处理好default配置项的加载\n    }\n  }\n}\n\n\n\n# hystrix 配置\n\n> 详细配置可以参考 hystrix 官方配置手册，这里仅介绍比较核心的配置\n\n\n# 执行配置\n\n以下配置用于控制 hystrixcommand.run() 如何执行。\n\n配置项                                                   说明                              默认值\nexecution.isolation.strategy                          线程隔离（thread）或信号量隔离（semaphore）   thread\nexecution.isolation.thread.timeoutinmilliseconds      方法执行超时时间                        1000(ms)\nexecution.isolation.semaphore.maxconcurrentrequests   信号量隔离最大并发数                      10\n\n\n# 断路配置\n\n以下配置用于控制 hystrixcircuitbreaker 的断路处理。\n\n配置项                                        说明                默认值\ncircuitbreaker.enabled                     是否开启断路器           true\ncircuitbreaker.requestvolumethreshold      断路器启用请求数阈值        20\ncircuitbreaker.sleepwindowinmilliseconds   断路器启用后的休眠时间       5000(ms)\ncircuitbreaker.errorthresholdpercentage    断路器启用失败率阈值        50(%)\ncircuitbreaker.forceopen                   是否强制将断路器设置成开启状态   false\ncircuitbreaker.forceclosed                 是否强制将断路器设置成关闭状态   false\n\n\n# 指标配置\n\n以下配置用于从 hystrixcommand 和 hystrixobservablecommand 执行中捕获相关指标。\n\n配置项                                             说明                                            默认值\nmetrics.rollingstats.timeinmilliseconds         时间窗的长度                                        10000(ms)\nmetrics.rollingstats.numbuckets                 桶的数量，需要保证timeinmilliseconds % numbuckets =0   10\nmetrics.rollingpercentile.enabled               是否统计运行延迟的占比                                   true\nmetrics.rollingpercentile.timeinmilliseconds    运行延迟占比统计的时间窗                                  60000(ms)\nmetrics.rollingpercentile.numbuckets            运行延迟占比统计的桶数                                   6\nmetrics.rollingpercentile.bucketsize            百分比统计桶的容量，桶内最多保存的运行时间统计                       100\nmetrics.healthsnapshot.intervalinmilliseconds   统计快照刷新间隔                                      500 (ms)\n\n\n# 线程池配置\n\n以下配置用于控制 hystrix command 执行所使用的线程池。\n\n配置项                                     说明                                                           默认值\ncoresize                                线程池核心线程数                                                     10\nmaximumsize                             线程池最大线程数                                                     10\nmaxqueuesize                            最大 linkedblockingqueue 的大小，-1 表示用 synchronousqueue           -1\nqueuesizerejectionthreshold             队列大小阈值，超过则拒绝                                                 5\nallowmaximumsizetodivergefromcoresize   此属性允许 maximumsize 的配置生效。该值可以等于或大于 coresize。设置 coresize       false\n                                        <maximumsize 使得线程池可以维持 maximumsize 并发性，但是会在相对空闲时将线程回收。（取决于\n                                        keepalivetimeinminutes）\n\n\n# 其他限流技术\n\n * resilience4j hystrix 虽然官方宣布不再维护，其推荐另外一个框架：resilience4j, 这个框架是是为 java 8 和 函数式编程设计的一个轻量级的容错框架，该框架充分利用函数式编程的概念，为函数式接口、lamda表达式、方法引用高阶函数进行包装，(本质上是装饰者模式的概念)，通过包装实现断路、限流、重试、舱壁功能。 这个框架整体而言比较轻量，没有控制台，不太好做系统级监控；\n\n * alibaba sentinel\n   \n   sentinel\n   \n   \n   是 阿里巴巴开源的轻量级的流量控制、熔断降级 java 库，该库的核心是使用的是信号量隔离的方式做流量控制和熔断，其优点是其集成性和易用性，几乎能和当前主流的 spring cloud, dubbo ,grpc ,nacos, zookeeper 做集成，如下图所示：\n   \n   \n   \n   sentinel-features-overview-en.png\n   \n   sentinel\n   \n   \n   的目标生态圈：\n   \n   \n   \n   sentinel\n   \n   \n   一个强大的功能，就是它有一个流控管理控制台，你可以实时地监控每个服务的流控情况，并且可以实时编辑各种流控、熔断规则，有效地保证了服务保护的及时性。下图是内部试用的 sentinel 控制台：\n   \n   另外，\n   \n   sentinel\n   \n   \n   还可以和\n   \n   ctrip apollo\n   \n   \n   分布式配置系统进行集成，将流控规降级等各种规则先配置在 apollo 中，然后服务启动自动加载流控规则。\n\n\n# 参考资料\n\n * hystrix github\n * spring cloud hystrix 设计原理\n * hystrix 都停更了，我为什么还要学？',charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"数据库连接池",frontmatter:{title:"数据库连接池",date:"2022-09-21T23:58:06.000Z",order:1,categories:["Java","中间件","其他"],tags:["Java","中间件","数据库连接池"],permalink:"/pages/be5227/"},regularPath:"/01.Java/14.%E4%B8%AD%E9%97%B4%E4%BB%B6/99.%E5%85%B6%E4%BB%96/01.%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0.html",relativePath:"01.Java/14.中间件/99.其他/01.数据库连接池.md",key:"v-60f62e76",path:"/pages/be5227/",headers:[{level:2,title:"什么是数据库连接池",slug:"什么是数据库连接池",normalizedTitle:"什么是数据库连接池",charIndex:145},{level:2,title:"为什么需要数据库连接池",slug:"为什么需要数据库连接池",normalizedTitle:"为什么需要数据库连接池",charIndex:534},{level:3,title:"不使用数据库连接池",slug:"不使用数据库连接池",normalizedTitle:"不使用数据库连接池",charIndex:550},{level:3,title:"使用数据库连接池",slug:"使用数据库连接池",normalizedTitle:"使用数据库连接池",charIndex:551},{level:2,title:"数据库连接池如何工作",slug:"数据库连接池如何工作",normalizedTitle:"数据库连接池如何工作",charIndex:977},{level:2,title:"数据库连接池的核心参数",slug:"数据库连接池的核心参数",normalizedTitle:"数据库连接池的核心参数",charIndex:1536},{level:2,title:"数据库连接池的问题",slug:"数据库连接池的问题",normalizedTitle:"数据库连接池的问题",charIndex:1772},{level:2,title:"数据库连接池技术选型",slug:"数据库连接池技术选型",normalizedTitle:"数据库连接池技术选型",charIndex:2686},{level:2,title:"HikariCP",slug:"hikaricp",normalizedTitle:"hikaricp",charIndex:2713},{level:2,title:"Druid",slug:"druid",normalizedTitle:"druid",charIndex:2771},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:8010}],headersStr:"什么是数据库连接池 为什么需要数据库连接池 不使用数据库连接池 使用数据库连接池 数据库连接池如何工作 数据库连接池的核心参数 数据库连接池的问题 数据库连接池技术选型 HikariCP Druid 参考资料",content:"# 数据库连接池\n\n> 数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。这项技术能明显提高对数据库操作的性能。——摘自百度百科\n\n\n# 什么是数据库连接池\n\n数据库连接是一种关键的有限的昂贵的资源，这一点在多用户的网页应用程序中体现得尤为突出。 一个数据库连接对象均对应一个物理数据库连接，每次操作都打开一个物理连接，使用完都关闭连接，这样造成系统的 性能低下。 数据库连接池的解决方案是在应用程序启动时建立足够的数据库连接，并讲这些连接组成一个连接池(简单说：在一个“池”里放了好多半成品的数据库联接对象)，由应用程序动态地对池中的连接进行申请、使用和释放。对于多于连接池中连接数的并发请求，应该在请求队列中排队等待。并且应用程序可以根据池中连接的使用率，动态增加或减少池中的连接数。 连接池技术尽可能多地重用了消耗内存地资源，大大节省了内存，提高了服务器地服务效率，能够支持更多的客户服务。通过使用连接池，将大大提高程序运行效率，同时，我们可以通过其自身的管理机制来监视数据库连接的数量、使用情况等。\n\n\n# 为什么需要数据库连接池\n\n\n# 不使用数据库连接池\n\n\n\n不使用数据库连接池的步骤：\n\n 1. TCP 建立连接的三次握手\n 2. MySQL 认证的三次握手\n 3. 真正的 SQL 执行\n 4. MySQL 的关闭\n 5. TCP 的四次握手关闭\n\n不使用数据库连接池的特性：\n\n * 优点：实现简单\n * 缺点：\n   * 网络 IO 较多\n   * 数据库的负载较高\n   * 响应时间较长及 QPS 较低\n   * 应用频繁的创建连接和关闭连接，导致临时对象较多，GC 频繁\n   * 在关闭连接后，会出现大量 TIME_WAIT 的 TCP 状态（在 2 个 MSL 之后关闭）\n\n\n# 使用数据库连接池\n\n\n\n使用数据库连接池的步骤：只有第一次访问的时候，需要建立连接。 但是之后的访问，均会复用之前创建的连接，直接执行 SQL 语句。\n\n使用数据库连接池的优点：\n\n * 减少了网络开销\n * 系统的性能会有一个实质的提升\n * 没有了 TIME_WAIT 状态\n\n\n# 数据库连接池如何工作\n\n数据库连接池工作的核心在于以下几点：\n\n 1. 创建连接池：与线程池等池化对象类似，数据库连接池会在进程启动之初，根据配置初始化，并在池中创建了几个连接对象，以便使用时能从连接池中获取。连接池中的连接不能随意创建和关闭，以避免创建、关闭所带来的系统开销。\n\n 2. 使用、管理连接池中：连接池管理策略是连接池机制的核心，连接池内连接的分配和释放对系统的性能有很大的影响。合理的策略可以保证数据库连接的有效复用，避免频繁的建立、释放连接所带来的系统资源开销。通常，数据库连接池的管理策略如下：\n    \n    1. 当请求数据库连接时，首先查看连接池中是否有空闲连接。\n    2. 如果存在空闲连接，则将连接分配给客户使用。\n    3. 如果没有空闲连接，则查看当前所开的连接数是否已经达到最大连接数。若未达到，就重新创建一个连接，并分配给请求的客户；如果达到，就按设定的最大等待时间进行等待，若超出最大等待时间，则抛出异常给客户。\n    4. 当客户释放数据库连接时，先判断该连接的引用次数是否超过了规定值。如果超过，就从连接池中删除该连接；否则保留为其他客户服务。\n\n 3. 关闭连接池：当应用程序退出时，关闭连接池中所有的连接，释放连接池相关的资源，该过程正好与创建相反。\n\n\n# 数据库连接池的核心参数\n\n使用数据库连接池，需要为其配置一些参数，以控制其工作。\n\n通常，数据库连接池都会包含以下核心参数：\n\n * 最小连接数：是连接池一直保持的数据库连接,所以如果应用程序对数据库连接的使用量不大,将会有大量的数据库连接资源被浪费.\n * 最大连接数：是连接池能申请的最大连接数,如果数据库连接请求超过次数,后面的数据库连接请求将被加入到等待队列中,这会影响以后的数据库操作\n * 最大空闲时间\n * 获取连接超时时间\n * 超时重试连接次数\n\n\n# 数据库连接池的问题\n\n并发问题：为了保证连接管理服务具有最大的通用性，必须考虑多线程环境，即并发问题。\n\n事务处理：我们知道，事务具有原子性，此时要求对数据库的操作符合“ALL-OR-NOTHING”原则,即对于一组 SQL 语句要么全做，要么全不做。我们知道当 2 个线程共用一个连接 Connection 对象，而且各自都有自己的事务要处理时候，对于连接池是一个很头疼的问题，因为即使 Connection 类提供了相应的事务支持，可是我们仍然不能确定那个数据库操作是对应那个事务的，这是由于我们有２个线程都在进行事务操作而引起的。为此我们可以使用每一个事务独占一个连接来实现，虽然这种方法有点浪费连接池资源但是可以大大降低事务管理的复杂性。\n\n连接池的分配与释放：连接池的分配与释放，对系统的性能有很大的影响。合理的分配与释放，可以提高连接的复用度，从而降低建立新连接的开销，同时还可以加快用户的访问速度。 对于连接的管理可使用一个 List。即把已经创建的连接都放入 List 中去统一管理。每当用户请求一个连接时，系统检查这个 List 中有没有可以分配的连接。如果有就把那个最合适的连接分配给他；如果没有就抛出一个异常给用户。\n\n连接池的配置与维护：连接池中到底应该放置多少连接，才能使系统的性能最佳？系统可采取设置最小连接数（minConnection）和最大连接数（maxConnection）等参数来控制连接池中的连接。比方说，最小连接数是系统启动时连接池所创建的连接数。如果创建过多，则系统启动就慢，但创建后系统的响应速度会很快；如果创建过少，则系统启动的很快，响应起来却慢。这样，可以在开发时，设置较小的最小连接数，开发起来会快，而在系统实际使用时设置较大的，因为这样对访问客户来说速度会快些。最大连接数是连接池中允许连接的最大数目，具体设置多少，要看系统的访问量，可通过软件需求上得到。 如何确保连接池中的最小连接数呢？有动态和静态两种策略。动态即每隔一定时间就对连接池进行检测，如果发现连接数量小于最小连接数，则补充相应数量的新连接,以保证连接池的正常运转。静态是发现空闲连接不够时再去检查。\n\n\n# 数据库连接池技术选型\n\n常见的数据库连接池：\n\n * HikariCP：HiKariCP 号称是跑的最快的连接池，并且是 SpringBoot 框架的默认连接池。\n * Druid：Druid 是阿里巴巴开源的数据库连接池。Druid 内置强大的监控功能，监控特性不影响性能。功能强大，能防 SQL 注入，内置 Loging 能诊断 Hack 应用行为。\n * DBCP： 由 Apache 开发的一个 Java 数据库连接池。commons-dbcp2 基于 commons-pool2 来实现底层的对象池机制。单线程，性能较差，适用于小型系统。官方自 2021 年后没有再更新。\n * C3P0：开源的 JDBC 连接池，实现了数据源和 JNDI 绑定，支持 JDBC3 规范和 JDBC2 的标准扩展。单线程，性能较差，适用于小型系统。官方自 2019 年后再没有更新。\n * Tomcat-jdbc：Tomcat 在 7.0 以前使用 DBCP 做为连接池组件，从 7.0 后新增了 Tomcat jdbc pool 模块，基于 Tomcat JULI，使用 Tomcat 日志框架，完全兼容 dbcp，通过异步方式获取连接，支持高并发应用环境，超级简单核心文件只有 8 个，支持 JMX，支持 XA Connection。\n\n来自 Druid 的竞品对比（https://github.com/alibaba/druid/wiki/Druid%E8%BF%9E%E6%8E%A5%E6%B1%A0%E4%BB%8B%E7%BB%8D）：\n\n功能类别              功能                DRUID          HIKARICP      DBCP   TOMCAT-JDBC       C3P0\n性能                PSCache           是              否             是      是                 是\nLRU               是                 否              是             是      是                 \nSLB 负载均衡支持        是                 否              否             否      否                 \n稳定性               ExceptionSorter   是              否             否      否                 否\n扩展                扩展                Filter                              JdbcIntercepter   \n监控                监控方式              jmx/log/http   jmx/metrics   jmx    jmx               jmx\n支持 SQL 级监控        是                 否              否             否      否                 \nSpring/Web 关联监控   是                 否              否             否      否                 \n                  诊断支持              LogFilter      否             否      否                 否\n连接泄露诊断            logAbandoned      否              否             否      否                 \n安全                SQL 防注入           是              无             无      无                 无\n支持配置加密            是                 否              否             否      否                 \n\n从数据库连接池最重要的性能角度来看：HikariCP 应该性能最好；Druid 也不错，并且有更多、更久的生产实践，更为可靠；而其他常见的数据库连接池性能远远不如。\n\n从功能角度来看：Druid 功能最全面，除基本的数据库连接池能力以外，还支持 sql 级监控、扩展、SQL 防注入以及监控等功能。\n\n综合来看：HikariCP 是 Spring Boot 首选数据库连接池，对于 Spring Boot 项目来说，无疑适配性最好。而非 Spring Boot 项目，可以优先考虑 Druid，在国内有大规模应用，中文社区支持良好。\n\n\n# HikariCP\n\nHiKariCP 号称是跑的最快的连接池，并且是 SpringBoot 框架的默认连接池。\n\nHiKariCP 为了提升性能，做了很多细节上的优化，例如：\n\n * 使用 FastList 替代 ArrayList，通过初始化的默认值，减少了越界检查的操作\n * 优化并精简了字节码，通过使用 Javassist，减少了动态代理的性能损耗，比如使用 invokestatic 指令代替 invokevirtual 指令\n * 实现了无锁的 ConcurrentBag，减少了并发场景下的锁竞争\n\nHikariCP 关键配置：\n\n * maximum-pool-size：池中最大连接数（包括空闲和正在使用的连接）。默认值是 10，这个一般预估应用的最大连接数，后期根据监测得到一个最大值的一个平均值。要知道，最大连接并不是越多越好，一个 connection 会占用系统的带宽和存储。但是 当连接池没有空闲连接并且已经到达最大值，新来的连接池请求（HikariPool#getConnection）会被阻塞直到connectionTimeout（毫秒），超时后便抛出 SQLException。\n * minimum-idle：池中最小空闲连接数量。默认值 10，小于池中最大连接数，一般根据系统大部分情况下的数据库连接情况取一个平均值。Hikari 会尽可能、尽快地将空闲连接数维持在这个数量上。如果为了获得最佳性能和对峰值需求的响应能力，我们也不妨让他和最大连接数保持一致，使得 HikariCP 成为一个固定大小的数据库连接池。\n * connection-timeout：连接超时时间。默认值为 30s，可以接收的最小超时时间为 250ms。但是连接池请求也可以自定义超时时间（com.zaxxer.hikari.pool.HikariPool#getConnection(long)）。\n * idle-timeout：空闲连接存活最大时间，默认 600000（十分钟）\n * max-lifetime：连接池中连接的最大生命周期。当连接一致处于闲置状态时，超过 8 小时数据库会主动断开连接。为了防止大量的同一时间处于空闲连接因为数据库方的闲置超时策略断开连接（可以理解为连接雪崩），一般将这个值设置的比数据库的“闲置超时时间”小几秒，以便这些连接断开后，HikariCP 能迅速的创建新一轮的连接。\n * pool-name：连接池的名字。一般会出现在日志和 JMX 控制台中。默认值：auto-genenrated。建议取一个合适的名字，便于监控。\n * auto-commit：是否自动提交池中返回的连接。默认值为 true。一般是有必要自动提交上一个连接中的事物的。如果为 false，那么就需要应用层手动提交事物。\n\n参考配置：\n\n# 连接池名称\nspring.datasource.hikari.pool-name = SpringTutorialHikariPool\n# 最大连接数，小于等于 0 会被重置为默认值 10；大于零小于 1 会被重置为 minimum-idle 的值\nspring.datasource.hikari.maximum-pool-size = 10\n# 最小空闲连接，默认值10，小于 0 或大于 maximum-pool-size，都会重置为 maximum-pool-size\nspring.datasource.hikari.minimum-idle = 10\n# 连接超时时间（单位：毫秒），小于 250 毫秒，会被重置为默认值 30 秒\nspring.datasource.hikari.connection-timeout = 60000\n# 空闲连接超时时间，默认值 600000（10分钟），大于等于 max-lifetime 且 max-lifetime>0，会被重置为0；不等于 0 且小于 10 秒，会被重置为 10 秒\n# 只有空闲连接数大于最大连接数且空闲时间超过该值，才会被释放\nspring.datasource.hikari.idle-timeout = 600000\n# 连接最大存活时间，不等于 0 且小于 30 秒，会被重置为默认值 30 分钟。该值应该比数据库所设置的超时时间短\nspring.datasource.hikari.max-lifetime = 1800000\n\n\n\n# Druid\n\nDruid 是阿里巴巴开源的数据库连接池。Druid 连接池为监控而生，内置强大的监控功能，监控特性不影响性能。功能强大，能防 SQL 注入，内置 Loging 能诊断 Hack 应用行为。\n\nDruid 关键配置：\n\n# 数据库访问配置\n# 主数据源，默认的\nspring.datasource.type=com.alibaba.druid.pool.DruidDataSource\nspring.datasource.driver-class-name=com.mysql.jdbc.Driver\nspring.datasource.url=jdbc:mysql://localhost:3306/druid\nspring.datasource.username=root\nspring.datasource.password=root\n\n# 下面为连接池的补充设置，应用到上面所有数据源中\n# 初始化大小，最小，最大\nspring.datasource.initialSize=5\nspring.datasource.minIdle=5\nspring.datasource.maxActive=20\n# 配置获取连接等待超时的时间\nspring.datasource.maxWait=60000\n# 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒\nspring.datasource.timeBetweenEvictionRunsMillis=60000\n# 配置一个连接在池中最小生存的时间，单位是毫秒\nspring.datasource.minEvictableIdleTimeMillis=300000\nspring.datasource.validationQuery=SELECT 1 FROM DUAL\nspring.datasource.testWhileIdle=true\nspring.datasource.testOnBorrow=false\nspring.datasource.testOnReturn=false\n# 打开PSCache，并且指定每个连接上PSCache的大小\nspring.datasource.poolPreparedStatements=true\nspring.datasource.maxPoolPreparedStatementPerConnectionSize=20\n# 配置监控统计拦截的filters，去掉后监控界面sql无法统计，'wall'用于防火墙\nspring.datasource.filters=stat,wall,log4j\n# 通过connectProperties属性来打开mergeSql功能；慢SQL记录\nspring.datasource.connectionProperties=druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000\n# 合并多个DruidDataSource的监控数据\n#spring.datasource.useGlobalDataSourceStat=true\n\n\n\n# 参考资料\n\n * 数据库连接池学习笔记（一）：原理介绍+常用连接池介绍\n * 高性能数据库连接池的内幕\n * HikariCP\n * druid",normalizedContent:"# 数据库连接池\n\n> 数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。这项技术能明显提高对数据库操作的性能。——摘自百度百科\n\n\n# 什么是数据库连接池\n\n数据库连接是一种关键的有限的昂贵的资源，这一点在多用户的网页应用程序中体现得尤为突出。 一个数据库连接对象均对应一个物理数据库连接，每次操作都打开一个物理连接，使用完都关闭连接，这样造成系统的 性能低下。 数据库连接池的解决方案是在应用程序启动时建立足够的数据库连接，并讲这些连接组成一个连接池(简单说：在一个“池”里放了好多半成品的数据库联接对象)，由应用程序动态地对池中的连接进行申请、使用和释放。对于多于连接池中连接数的并发请求，应该在请求队列中排队等待。并且应用程序可以根据池中连接的使用率，动态增加或减少池中的连接数。 连接池技术尽可能多地重用了消耗内存地资源，大大节省了内存，提高了服务器地服务效率，能够支持更多的客户服务。通过使用连接池，将大大提高程序运行效率，同时，我们可以通过其自身的管理机制来监视数据库连接的数量、使用情况等。\n\n\n# 为什么需要数据库连接池\n\n\n# 不使用数据库连接池\n\n\n\n不使用数据库连接池的步骤：\n\n 1. tcp 建立连接的三次握手\n 2. mysql 认证的三次握手\n 3. 真正的 sql 执行\n 4. mysql 的关闭\n 5. tcp 的四次握手关闭\n\n不使用数据库连接池的特性：\n\n * 优点：实现简单\n * 缺点：\n   * 网络 io 较多\n   * 数据库的负载较高\n   * 响应时间较长及 qps 较低\n   * 应用频繁的创建连接和关闭连接，导致临时对象较多，gc 频繁\n   * 在关闭连接后，会出现大量 time_wait 的 tcp 状态（在 2 个 msl 之后关闭）\n\n\n# 使用数据库连接池\n\n\n\n使用数据库连接池的步骤：只有第一次访问的时候，需要建立连接。 但是之后的访问，均会复用之前创建的连接，直接执行 sql 语句。\n\n使用数据库连接池的优点：\n\n * 减少了网络开销\n * 系统的性能会有一个实质的提升\n * 没有了 time_wait 状态\n\n\n# 数据库连接池如何工作\n\n数据库连接池工作的核心在于以下几点：\n\n 1. 创建连接池：与线程池等池化对象类似，数据库连接池会在进程启动之初，根据配置初始化，并在池中创建了几个连接对象，以便使用时能从连接池中获取。连接池中的连接不能随意创建和关闭，以避免创建、关闭所带来的系统开销。\n\n 2. 使用、管理连接池中：连接池管理策略是连接池机制的核心，连接池内连接的分配和释放对系统的性能有很大的影响。合理的策略可以保证数据库连接的有效复用，避免频繁的建立、释放连接所带来的系统资源开销。通常，数据库连接池的管理策略如下：\n    \n    1. 当请求数据库连接时，首先查看连接池中是否有空闲连接。\n    2. 如果存在空闲连接，则将连接分配给客户使用。\n    3. 如果没有空闲连接，则查看当前所开的连接数是否已经达到最大连接数。若未达到，就重新创建一个连接，并分配给请求的客户；如果达到，就按设定的最大等待时间进行等待，若超出最大等待时间，则抛出异常给客户。\n    4. 当客户释放数据库连接时，先判断该连接的引用次数是否超过了规定值。如果超过，就从连接池中删除该连接；否则保留为其他客户服务。\n\n 3. 关闭连接池：当应用程序退出时，关闭连接池中所有的连接，释放连接池相关的资源，该过程正好与创建相反。\n\n\n# 数据库连接池的核心参数\n\n使用数据库连接池，需要为其配置一些参数，以控制其工作。\n\n通常，数据库连接池都会包含以下核心参数：\n\n * 最小连接数：是连接池一直保持的数据库连接,所以如果应用程序对数据库连接的使用量不大,将会有大量的数据库连接资源被浪费.\n * 最大连接数：是连接池能申请的最大连接数,如果数据库连接请求超过次数,后面的数据库连接请求将被加入到等待队列中,这会影响以后的数据库操作\n * 最大空闲时间\n * 获取连接超时时间\n * 超时重试连接次数\n\n\n# 数据库连接池的问题\n\n并发问题：为了保证连接管理服务具有最大的通用性，必须考虑多线程环境，即并发问题。\n\n事务处理：我们知道，事务具有原子性，此时要求对数据库的操作符合“all-or-nothing”原则,即对于一组 sql 语句要么全做，要么全不做。我们知道当 2 个线程共用一个连接 connection 对象，而且各自都有自己的事务要处理时候，对于连接池是一个很头疼的问题，因为即使 connection 类提供了相应的事务支持，可是我们仍然不能确定那个数据库操作是对应那个事务的，这是由于我们有２个线程都在进行事务操作而引起的。为此我们可以使用每一个事务独占一个连接来实现，虽然这种方法有点浪费连接池资源但是可以大大降低事务管理的复杂性。\n\n连接池的分配与释放：连接池的分配与释放，对系统的性能有很大的影响。合理的分配与释放，可以提高连接的复用度，从而降低建立新连接的开销，同时还可以加快用户的访问速度。 对于连接的管理可使用一个 list。即把已经创建的连接都放入 list 中去统一管理。每当用户请求一个连接时，系统检查这个 list 中有没有可以分配的连接。如果有就把那个最合适的连接分配给他；如果没有就抛出一个异常给用户。\n\n连接池的配置与维护：连接池中到底应该放置多少连接，才能使系统的性能最佳？系统可采取设置最小连接数（minconnection）和最大连接数（maxconnection）等参数来控制连接池中的连接。比方说，最小连接数是系统启动时连接池所创建的连接数。如果创建过多，则系统启动就慢，但创建后系统的响应速度会很快；如果创建过少，则系统启动的很快，响应起来却慢。这样，可以在开发时，设置较小的最小连接数，开发起来会快，而在系统实际使用时设置较大的，因为这样对访问客户来说速度会快些。最大连接数是连接池中允许连接的最大数目，具体设置多少，要看系统的访问量，可通过软件需求上得到。 如何确保连接池中的最小连接数呢？有动态和静态两种策略。动态即每隔一定时间就对连接池进行检测，如果发现连接数量小于最小连接数，则补充相应数量的新连接,以保证连接池的正常运转。静态是发现空闲连接不够时再去检查。\n\n\n# 数据库连接池技术选型\n\n常见的数据库连接池：\n\n * hikaricp：hikaricp 号称是跑的最快的连接池，并且是 springboot 框架的默认连接池。\n * druid：druid 是阿里巴巴开源的数据库连接池。druid 内置强大的监控功能，监控特性不影响性能。功能强大，能防 sql 注入，内置 loging 能诊断 hack 应用行为。\n * dbcp： 由 apache 开发的一个 java 数据库连接池。commons-dbcp2 基于 commons-pool2 来实现底层的对象池机制。单线程，性能较差，适用于小型系统。官方自 2021 年后没有再更新。\n * c3p0：开源的 jdbc 连接池，实现了数据源和 jndi 绑定，支持 jdbc3 规范和 jdbc2 的标准扩展。单线程，性能较差，适用于小型系统。官方自 2019 年后再没有更新。\n * tomcat-jdbc：tomcat 在 7.0 以前使用 dbcp 做为连接池组件，从 7.0 后新增了 tomcat jdbc pool 模块，基于 tomcat juli，使用 tomcat 日志框架，完全兼容 dbcp，通过异步方式获取连接，支持高并发应用环境，超级简单核心文件只有 8 个，支持 jmx，支持 xa connection。\n\n来自 druid 的竞品对比（https://github.com/alibaba/druid/wiki/druid%e8%bf%9e%e6%8e%a5%e6%b1%a0%e4%bb%8b%e7%bb%8d）：\n\n功能类别              功能                druid          hikaricp      dbcp   tomcat-jdbc       c3p0\n性能                pscache           是              否             是      是                 是\nlru               是                 否              是             是      是                 \nslb 负载均衡支持        是                 否              否             否      否                 \n稳定性               exceptionsorter   是              否             否      否                 否\n扩展                扩展                filter                              jdbcintercepter   \n监控                监控方式              jmx/log/http   jmx/metrics   jmx    jmx               jmx\n支持 sql 级监控        是                 否              否             否      否                 \nspring/web 关联监控   是                 否              否             否      否                 \n                  诊断支持              logfilter      否             否      否                 否\n连接泄露诊断            logabandoned      否              否             否      否                 \n安全                sql 防注入           是              无             无      无                 无\n支持配置加密            是                 否              否             否      否                 \n\n从数据库连接池最重要的性能角度来看：hikaricp 应该性能最好；druid 也不错，并且有更多、更久的生产实践，更为可靠；而其他常见的数据库连接池性能远远不如。\n\n从功能角度来看：druid 功能最全面，除基本的数据库连接池能力以外，还支持 sql 级监控、扩展、sql 防注入以及监控等功能。\n\n综合来看：hikaricp 是 spring boot 首选数据库连接池，对于 spring boot 项目来说，无疑适配性最好。而非 spring boot 项目，可以优先考虑 druid，在国内有大规模应用，中文社区支持良好。\n\n\n# hikaricp\n\nhikaricp 号称是跑的最快的连接池，并且是 springboot 框架的默认连接池。\n\nhikaricp 为了提升性能，做了很多细节上的优化，例如：\n\n * 使用 fastlist 替代 arraylist，通过初始化的默认值，减少了越界检查的操作\n * 优化并精简了字节码，通过使用 javassist，减少了动态代理的性能损耗，比如使用 invokestatic 指令代替 invokevirtual 指令\n * 实现了无锁的 concurrentbag，减少了并发场景下的锁竞争\n\nhikaricp 关键配置：\n\n * maximum-pool-size：池中最大连接数（包括空闲和正在使用的连接）。默认值是 10，这个一般预估应用的最大连接数，后期根据监测得到一个最大值的一个平均值。要知道，最大连接并不是越多越好，一个 connection 会占用系统的带宽和存储。但是 当连接池没有空闲连接并且已经到达最大值，新来的连接池请求（hikaripool#getconnection）会被阻塞直到connectiontimeout（毫秒），超时后便抛出 sqlexception。\n * minimum-idle：池中最小空闲连接数量。默认值 10，小于池中最大连接数，一般根据系统大部分情况下的数据库连接情况取一个平均值。hikari 会尽可能、尽快地将空闲连接数维持在这个数量上。如果为了获得最佳性能和对峰值需求的响应能力，我们也不妨让他和最大连接数保持一致，使得 hikaricp 成为一个固定大小的数据库连接池。\n * connection-timeout：连接超时时间。默认值为 30s，可以接收的最小超时时间为 250ms。但是连接池请求也可以自定义超时时间（com.zaxxer.hikari.pool.hikaripool#getconnection(long)）。\n * idle-timeout：空闲连接存活最大时间，默认 600000（十分钟）\n * max-lifetime：连接池中连接的最大生命周期。当连接一致处于闲置状态时，超过 8 小时数据库会主动断开连接。为了防止大量的同一时间处于空闲连接因为数据库方的闲置超时策略断开连接（可以理解为连接雪崩），一般将这个值设置的比数据库的“闲置超时时间”小几秒，以便这些连接断开后，hikaricp 能迅速的创建新一轮的连接。\n * pool-name：连接池的名字。一般会出现在日志和 jmx 控制台中。默认值：auto-genenrated。建议取一个合适的名字，便于监控。\n * auto-commit：是否自动提交池中返回的连接。默认值为 true。一般是有必要自动提交上一个连接中的事物的。如果为 false，那么就需要应用层手动提交事物。\n\n参考配置：\n\n# 连接池名称\nspring.datasource.hikari.pool-name = springtutorialhikaripool\n# 最大连接数，小于等于 0 会被重置为默认值 10；大于零小于 1 会被重置为 minimum-idle 的值\nspring.datasource.hikari.maximum-pool-size = 10\n# 最小空闲连接，默认值10，小于 0 或大于 maximum-pool-size，都会重置为 maximum-pool-size\nspring.datasource.hikari.minimum-idle = 10\n# 连接超时时间（单位：毫秒），小于 250 毫秒，会被重置为默认值 30 秒\nspring.datasource.hikari.connection-timeout = 60000\n# 空闲连接超时时间，默认值 600000（10分钟），大于等于 max-lifetime 且 max-lifetime>0，会被重置为0；不等于 0 且小于 10 秒，会被重置为 10 秒\n# 只有空闲连接数大于最大连接数且空闲时间超过该值，才会被释放\nspring.datasource.hikari.idle-timeout = 600000\n# 连接最大存活时间，不等于 0 且小于 30 秒，会被重置为默认值 30 分钟。该值应该比数据库所设置的超时时间短\nspring.datasource.hikari.max-lifetime = 1800000\n\n\n\n# druid\n\ndruid 是阿里巴巴开源的数据库连接池。druid 连接池为监控而生，内置强大的监控功能，监控特性不影响性能。功能强大，能防 sql 注入，内置 loging 能诊断 hack 应用行为。\n\ndruid 关键配置：\n\n# 数据库访问配置\n# 主数据源，默认的\nspring.datasource.type=com.alibaba.druid.pool.druiddatasource\nspring.datasource.driver-class-name=com.mysql.jdbc.driver\nspring.datasource.url=jdbc:mysql://localhost:3306/druid\nspring.datasource.username=root\nspring.datasource.password=root\n\n# 下面为连接池的补充设置，应用到上面所有数据源中\n# 初始化大小，最小，最大\nspring.datasource.initialsize=5\nspring.datasource.minidle=5\nspring.datasource.maxactive=20\n# 配置获取连接等待超时的时间\nspring.datasource.maxwait=60000\n# 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒\nspring.datasource.timebetweenevictionrunsmillis=60000\n# 配置一个连接在池中最小生存的时间，单位是毫秒\nspring.datasource.minevictableidletimemillis=300000\nspring.datasource.validationquery=select 1 from dual\nspring.datasource.testwhileidle=true\nspring.datasource.testonborrow=false\nspring.datasource.testonreturn=false\n# 打开pscache，并且指定每个连接上pscache的大小\nspring.datasource.poolpreparedstatements=true\nspring.datasource.maxpoolpreparedstatementperconnectionsize=20\n# 配置监控统计拦截的filters，去掉后监控界面sql无法统计，'wall'用于防火墙\nspring.datasource.filters=stat,wall,log4j\n# 通过connectproperties属性来打开mergesql功能；慢sql记录\nspring.datasource.connectionproperties=druid.stat.mergesql=true;druid.stat.slowsqlmillis=5000\n# 合并多个druiddatasource的监控数据\n#spring.datasource.useglobaldatasourcestat=true\n\n\n\n# 参考资料\n\n * 数据库连接池学习笔记（一）：原理介绍+常用连接池介绍\n * 高性能数据库连接池的内幕\n * hikaricp\n * druid",charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Java 中间件",frontmatter:{title:"Java 中间件",date:"2022-04-09T15:11:37.000Z",categories:["Java","中间件"],tags:["编程","Java","中间件"],permalink:"/pages/fe6d83/",hidden:!0,index:!1},regularPath:"/01.Java/14.%E4%B8%AD%E9%97%B4%E4%BB%B6/",relativePath:"01.Java/14.中间件/README.md",key:"v-12857866",path:"/pages/fe6d83/",headers:[{level:2,title:"📖 内容",slug:"📖-内容",normalizedTitle:"📖 内容",charIndex:15},{level:4,title:"缓存",slug:"缓存",normalizedTitle:"缓存",charIndex:24},{level:4,title:"流量控制",slug:"流量控制",normalizedTitle:"流量控制",charIndex:182},{level:2,title:"📚 资料",slug:"📚-资料",normalizedTitle:"📚 资料",charIndex:203},{level:2,title:"🚪 传送",slug:"🚪-传送",normalizedTitle:"🚪 传送",charIndex:501}],headersStr:"📖 内容 缓存 流量控制 📚 资料 🚪 传送",content:"# Java 中间件\n\n\n# 📖 内容\n\n# 缓存\n\n> 缓存可以说是优化系统性能的第一手段，在各种技术中都会有缓存的应用。\n> \n> 如果想深入学习缓存，建议先了解一下 缓存基本原理，有助于理解缓存的特性、原理，使用缓存常见的问题及解决方案。\n\n * Java 缓存框架\n * Ehcache 快速入门\n * Java 进程内缓存\n * Http 缓存\n\n# 流量控制\n\n * Hystrix\n\n\n# 📚 资料\n\n * Mybatis\n   * Mybatis Github\n   * Mybatis 官网\n   * MyBatis 官方代码生成（mybatis-generator）\n   * MyBatis 官方集成 Spring（mybatis-spring）\n   * Mybatis 官方集成 Spring Boot（mybatis-spring-boot）\n   * MyBatis-Plus - CRUD 扩展插件、代码生成器、分页器等多功能\n   * Mapper - CRUD 扩展插件\n   * Mybatis-PageHelper - Mybatis 通用分页插件\n\n\n# 🚪 传送\n\n◾ 💧 钝悟的 IT 知识图谱 ◾",normalizedContent:"# java 中间件\n\n\n# 📖 内容\n\n# 缓存\n\n> 缓存可以说是优化系统性能的第一手段，在各种技术中都会有缓存的应用。\n> \n> 如果想深入学习缓存，建议先了解一下 缓存基本原理，有助于理解缓存的特性、原理，使用缓存常见的问题及解决方案。\n\n * java 缓存框架\n * ehcache 快速入门\n * java 进程内缓存\n * http 缓存\n\n# 流量控制\n\n * hystrix\n\n\n# 📚 资料\n\n * mybatis\n   * mybatis github\n   * mybatis 官网\n   * mybatis 官方代码生成（mybatis-generator）\n   * mybatis 官方集成 spring（mybatis-spring）\n   * mybatis 官方集成 spring boot（mybatis-spring-boot）\n   * mybatis-plus - crud 扩展插件、代码生成器、分页器等多功能\n   * mapper - crud 扩展插件\n   * mybatis-pagehelper - mybatis 通用分页插件\n\n\n# 🚪 传送\n\n◾ 💧 钝悟的 it 知识图谱 ◾",charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Java 教程",frontmatter:{title:"Java 教程",date:"2022-04-27T18:23:47.000Z",categories:["Java"],tags:["Java"],permalink:"/pages/0d2474/",hidden:!0,index:!1},regularPath:"/01.Java/",relativePath:"01.Java/README.md",key:"v-3feddaec",path:"/pages/0d2474/",headers:[{level:2,title:"📖 内容",slug:"📖-内容",normalizedTitle:"📖 内容",charIndex:235},{level:3,title:"JavaEE",slug:"javaee",normalizedTitle:"javaee",charIndex:245},{level:4,title:"JavaWeb",slug:"javaweb",normalizedTitle:"javaweb",charIndex:255},{level:4,title:"Java 服务器",slug:"java-服务器",normalizedTitle:"java 服务器",charIndex:386},{level:3,title:"Java 软件",slug:"java-软件",normalizedTitle:"java 软件",charIndex:557},{level:4,title:"Java 构建",slug:"java-构建",normalizedTitle:"java 构建",charIndex:568},{level:4,title:"Java IDE",slug:"java-ide",normalizedTitle:"java ide",charIndex:978},{level:4,title:"Java 监控诊断",slug:"java-监控诊断",normalizedTitle:"java 监控诊断",charIndex:1263},{level:3,title:"Java 工具",slug:"java-工具",normalizedTitle:"java 工具",charIndex:1402},{level:4,title:"Java IO",slug:"java-io",normalizedTitle:"java io",charIndex:1413},{level:4,title:"JavaBean 工具",slug:"javabean-工具",normalizedTitle:"javabean 工具",charIndex:1506},{level:4,title:"Java 模板引擎",slug:"java-模板引擎",normalizedTitle:"java 模板引擎",charIndex:1541},{level:4,title:"Java 测试工具",slug:"java-测试工具",normalizedTitle:"java 测试工具",charIndex:1592},{level:4,title:"其他",slug:"其他",normalizedTitle:"其他",charIndex:1643},{level:3,title:"Java 框架",slug:"java-框架",normalizedTitle:"java 框架",charIndex:1736},{level:4,title:"Spring",slug:"spring",normalizedTitle:"spring",charIndex:1747},{level:5,title:"综合",slug:"综合",normalizedTitle:"综合",charIndex:1757},{level:5,title:"核心",slug:"核心",normalizedTitle:"核心",charIndex:1828},{level:5,title:"数据",slug:"数据",normalizedTitle:"数据",charIndex:1319},{level:5,title:"Web",slug:"web",normalizedTitle:"web",charIndex:259},{level:5,title:"IO",slug:"io",normalizedTitle:"io",charIndex:1418},{level:5,title:"集成",slug:"集成",normalizedTitle:"集成",charIndex:2279},{level:5,title:"其他",slug:"其他-2",normalizedTitle:"其他",charIndex:1643},{level:4,title:"ORM",slug:"orm",normalizedTitle:"orm",charIndex:2609},{level:4,title:"安全",slug:"安全",normalizedTitle:"安全",charIndex:2647},{level:4,title:"IO",slug:"io-2",normalizedTitle:"io",charIndex:1418},{level:3,title:"Java 中间件",slug:"java-中间件",normalizedTitle:"java 中间件",charIndex:2899},{level:4,title:"缓存",slug:"缓存",normalizedTitle:"缓存",charIndex:2492},{level:4,title:"流量控制",slug:"流量控制",normalizedTitle:"流量控制",charIndex:3070},{level:3,title:"大数据",slug:"大数据",normalizedTitle:"大数据",charIndex:3091},{level:2,title:"📚 资料",slug:"📚-资料",normalizedTitle:"📚 资料",charIndex:3241},{level:2,title:"🚪 传送",slug:"🚪-传送",normalizedTitle:"🚪 传送",charIndex:4163}],headersStr:"📖 内容 JavaEE JavaWeb Java 服务器 Java 软件 Java 构建 Java IDE Java 监控诊断 Java 工具 Java IO JavaBean 工具 Java 模板引擎 Java 测试工具 其他 Java 框架 Spring 综合 核心 数据 Web IO 集成 其他 ORM 安全 IO Java 中间件 缓存 流量控制 大数据 📚 资料 🚪 传送",content:"JavaTutorial\n\n> ☕ java-tutorial 是一个 Java 教程，汇集一个老司机在 Java 领域的十年积累。\n> \n>  * 🔁 项目同步维护：Github | Gitee\n>  * 📖 电子书阅读：Github Pages | Gitee Pages\n> \n> 说明：\n> \n>  * 下面的内容清单中，凡是有 📚 标记的技术，都已整理成详细的教程。\n>  * 部分技术因为可以应用于不同领域，所以可能会同时出现在不同的类别下。\n\n\n# 📖 内容\n\n\n# JavaEE\n\n# JavaWeb\n\n * JavaWeb 面经\n * JavaWeb 之 Servlet 指南\n * JavaWeb 之 Jsp 指南\n * JavaWeb 之 Filter 和 Listener\n * JavaWeb 之 Cookie 和 Session\n\n# Java 服务器\n\n> Tomcat 和 Jetty 都是 Java 比较流行的轻量级服务器。\n> \n> Nginx 是目前最流行的反向代理服务器，也常用于负载均衡。\n\n * Tomcat 快速入门\n * Tomcat 连接器\n * Tomcat 容器\n * Tomcat 优化\n * Tomcat 和 Jetty\n * Jetty\n\n\n# Java 软件\n\n# Java 构建\n\n> Java 项目需要通过 构建工具 来管理项目依赖，完成编译、打包、发布、生成 JavaDoc 等任务。\n> \n>  * 目前最主流的构建工具是 Maven，它的功能非常强大。\n>  * Gradle 号称是要替代 Maven 等构件工具，它的版本管理确实简洁，但是需要学习 Groovy，学习成本比 Maven 高。\n>  * Ant 功能比 Maven 和 Gradle 要弱，现代 Java 项目基本不用了，但也有一些传统的 Java 项目还在使用。\n\n * Maven 📚\n   * Maven 快速入门\n   * Maven 教程之 pom.xml 详解\n   * Maven 教程之 settings.xml 详解\n   * Maven 实战问题和最佳实践\n   * Maven 教程之发布 jar 到私服或中央仓库\n   * Maven 插件之代码检查\n * Ant 简易教程\n\n# Java IDE\n\n> 自从有了 IDE，写代码从此就告别了刀耕火种的蛮荒时代。\n> \n>  * Eclipse 是久负盛名的开源 Java IDE，我的学生时代一直使用它写 Java。\n>  * 曾经抗拒从转 Intellij Idea ，但后来发现真香，不得不说，确实是目前最优秀的 Java IDE。\n>  * 你可以在 vscode 中写各种语言，只要安装相应插件即可。如果你的项目中使用了很多种编程语言，又懒得在多个 IDE 之间切换，那么就用 vscode 来一网打尽吧。\n\n * Intellij Idea\n * Eclipse\n * vscode\n\n# Java 监控诊断\n\n> 监控/诊断 工具主要用于 Java 应用的运维。通过采集、分析、存储、可视化应用的有效数据，帮助开发者、使用者快速定位问题，找到性能瓶颈。\n\n * 监控工具对比\n * CAT\n * Zipkin\n * SkyWalking\n * Arthas\n\n\n# Java 工具\n\n# Java IO\n\n * JSON 序列化 - fastjson、Jackson、Gson\n * 二进制序列化 - Protobuf、Thrift、Hessian、Kryo、FST\n\n# JavaBean 工具\n\n * Lombok\n * Dozer\n\n# Java 模板引擎\n\n * Freemark\n * Velocity\n * Thymeleaf\n\n# Java 测试工具\n\n * Junit\n * Mockito\n * Jmeter\n * JMH\n\n# 其他\n\n * Java 日志\n * Java 工具包\n * Reflections\n * JavaMail\n * Jsoup\n * Thumbnailator\n * Zxing\n\n\n# Java 框架\n\n# Spring\n\n# 综合\n\n * Spring 概述\n * SpringBoot 知识图谱\n * SpringBoot 基本原理\n * Spring 面试\n\n# 核心\n\n * Spring Bean\n * Spring IoC\n * Spring 依赖查找\n * Spring 依赖注入\n * Spring IoC 依赖来源\n * Spring Bean 作用域\n * Spring Bean 生命周期\n * Spring 配置元数据\n * Spring AOP\n * Spring 资源管理\n * Spring 校验\n * Spring 数据绑定\n * Spring 类型转换\n * Spring EL 表达式\n * Spring 事件\n * Spring 国际化\n * Spring 泛型处理\n * Spring 注解\n * Spring Environment 抽象\n * SpringBoot 教程之快速入门\n * SpringBoot 之属性加载\n * SpringBoot 之 Profile\n\n# 数据\n\n * Spring 之数据源\n * Spring 之 JDBC\n * Spring 之事务\n * Spring 之 JPA\n * Spring 集成 Mybatis\n * Spring 访问 Redis\n * Spring 访问 MongoDB\n * Spring 访问 Elasticsearch\n\n# Web\n\n * Spring WebMvc\n * SpringBoot 之应用 EasyUI\n\n# IO\n\n * SpringBoot 之异步请求\n * SpringBoot 之 Json\n * SpringBoot 之邮件\n\n# 集成\n\n * Spring 集成缓存中间件\n * Spring 集成定时任务中间件\n * Spring 集成 Dubbo\n\n# 其他\n\n * Spring4 升级\n * SpringBoot 之 banner\n * SpringBoot 之 Actuator\n\n# ORM\n\n * Mybatis 快速入门\n * Mybatis 原理\n\n# 安全\n\n> Java 领域比较流行的安全框架就是 shiro 和 spring-security。\n> \n> shiro 更为简单、轻便，容易理解，能满足大多数基本安全场景下的需要。\n> \n> spring-security 功能更丰富，也比 shiro 更复杂。值得一提的是由于 spring-security 是 spring 团队开发，所以集成 spring 和 spring-boot 框架更容易。\n\n * Shiro\n * SpringSecurity\n\n# IO\n\n * Shiro\n\n\n# Java 中间件\n\n# 缓存\n\n> 缓存可以说是优化系统性能的第一手段，在各种技术中都会有缓存的应用。\n> \n> 如果想深入学习缓存，建议先了解一下 缓存基本原理，有助于理解缓存的特性、原理，使用缓存常见的问题及解决方案。\n\n * Java 缓存中间件\n * Ehcache 快速入门\n * Java 进程内缓存\n * Http 缓存\n\n# 流量控制\n\n * Hystrix\n\n\n# 大数据\n\n> 大数据技术点以归档在：bigdata-tutorial\n\n * Hdfs 📚\n * Hbase 📚\n * Hive 📚\n * MapReduce\n * Yarn\n * ZooKeeper 📚\n * Kafka 📚\n * Spark\n * Storm\n * Flink\n\n\n# 📚 资料\n\n * Java 经典书籍\n   * 《Effective Java 中文版》 - 本书介绍了在 Java 编程中 78 条极具实用价值的经验规则，这些经验规则涵盖了大多数开发人员每天所面临的问题的解决方案。同推荐《重构 : 改善既有代码的设计》、《代码整洁之道》、《代码大全》，有一定的内容重叠。\n   * 《Java 并发编程实战》 - 本书深入浅出地介绍了 Java 线程和并发，是一本完美的 Java 并发参考手册。\n   * 《深入理解 Java 虚拟机》 - 不去了解 JVM 的工程师，和咸鱼有什么区\n   * 《Maven 实战》 - 国内最权威的 Maven 专家的力作，唯一一本哦！\n * 其他领域书籍\n   * 《Redis 设计与实现》 - 系统而全面地描述了 Redis 内部运行机制。图示丰富，描述清晰，并给出大量参考信息，是 NoSQL 数据库开发人员案头必备。\n   * 《鸟哥的 Linux 私房菜 （基础学习篇）》 - 本书是最具知名度的 Linux 入门书《鸟哥的 Linux 私房菜基础学习篇》的最新版，全面而详细地介绍了 Linux 操作系统。内容非常全面，建议挑选和自己实际工作相关度较高的，其他部分有需要再阅读。\n   * 《Head First 设计模式》 - 《Head First 设计模式》(中文版)共有 14 章，每章都介绍了几个设计模式，完整地涵盖了四人组版本全部 23 个设计模式。\n   * 《HTTP 权威指南》 - 本书尝试着将 HTTP 中一些互相关联且常被误解的规则梳理清楚，并编写了一系列基于各种主题的章节，对 HTTP 各方面的特性进行了介绍。纵观全书，对 HTTP“为什么”这样做进行了详细的解释，而不仅仅停留在它是“怎么做”的。\n   * 《TCP/IP 详解 系列》 - 完整而详细的 TCP/IP 协议指南。针对任何希望理解 TCP/IP 协议是如何实现的读者设计。\n   * 《剑指 Offer：名企面试官精讲典型编程题》 - 剖析了 80 个典型的编程面试题，系统整理基础知识、代码质量、解题思路、优化效率和综合能力这 5 个面试要点。\n\n\n# 🚪 传送\n\n◾ 💧 钝悟的 IT 知识图谱 ◾",normalizedContent:"javatutorial\n\n> ☕ java-tutorial 是一个 java 教程，汇集一个老司机在 java 领域的十年积累。\n> \n>  * 🔁 项目同步维护：github | gitee\n>  * 📖 电子书阅读：github pages | gitee pages\n> \n> 说明：\n> \n>  * 下面的内容清单中，凡是有 📚 标记的技术，都已整理成详细的教程。\n>  * 部分技术因为可以应用于不同领域，所以可能会同时出现在不同的类别下。\n\n\n# 📖 内容\n\n\n# javaee\n\n# javaweb\n\n * javaweb 面经\n * javaweb 之 servlet 指南\n * javaweb 之 jsp 指南\n * javaweb 之 filter 和 listener\n * javaweb 之 cookie 和 session\n\n# java 服务器\n\n> tomcat 和 jetty 都是 java 比较流行的轻量级服务器。\n> \n> nginx 是目前最流行的反向代理服务器，也常用于负载均衡。\n\n * tomcat 快速入门\n * tomcat 连接器\n * tomcat 容器\n * tomcat 优化\n * tomcat 和 jetty\n * jetty\n\n\n# java 软件\n\n# java 构建\n\n> java 项目需要通过 构建工具 来管理项目依赖，完成编译、打包、发布、生成 javadoc 等任务。\n> \n>  * 目前最主流的构建工具是 maven，它的功能非常强大。\n>  * gradle 号称是要替代 maven 等构件工具，它的版本管理确实简洁，但是需要学习 groovy，学习成本比 maven 高。\n>  * ant 功能比 maven 和 gradle 要弱，现代 java 项目基本不用了，但也有一些传统的 java 项目还在使用。\n\n * maven 📚\n   * maven 快速入门\n   * maven 教程之 pom.xml 详解\n   * maven 教程之 settings.xml 详解\n   * maven 实战问题和最佳实践\n   * maven 教程之发布 jar 到私服或中央仓库\n   * maven 插件之代码检查\n * ant 简易教程\n\n# java ide\n\n> 自从有了 ide，写代码从此就告别了刀耕火种的蛮荒时代。\n> \n>  * eclipse 是久负盛名的开源 java ide，我的学生时代一直使用它写 java。\n>  * 曾经抗拒从转 intellij idea ，但后来发现真香，不得不说，确实是目前最优秀的 java ide。\n>  * 你可以在 vscode 中写各种语言，只要安装相应插件即可。如果你的项目中使用了很多种编程语言，又懒得在多个 ide 之间切换，那么就用 vscode 来一网打尽吧。\n\n * intellij idea\n * eclipse\n * vscode\n\n# java 监控诊断\n\n> 监控/诊断 工具主要用于 java 应用的运维。通过采集、分析、存储、可视化应用的有效数据，帮助开发者、使用者快速定位问题，找到性能瓶颈。\n\n * 监控工具对比\n * cat\n * zipkin\n * skywalking\n * arthas\n\n\n# java 工具\n\n# java io\n\n * json 序列化 - fastjson、jackson、gson\n * 二进制序列化 - protobuf、thrift、hessian、kryo、fst\n\n# javabean 工具\n\n * lombok\n * dozer\n\n# java 模板引擎\n\n * freemark\n * velocity\n * thymeleaf\n\n# java 测试工具\n\n * junit\n * mockito\n * jmeter\n * jmh\n\n# 其他\n\n * java 日志\n * java 工具包\n * reflections\n * javamail\n * jsoup\n * thumbnailator\n * zxing\n\n\n# java 框架\n\n# spring\n\n# 综合\n\n * spring 概述\n * springboot 知识图谱\n * springboot 基本原理\n * spring 面试\n\n# 核心\n\n * spring bean\n * spring ioc\n * spring 依赖查找\n * spring 依赖注入\n * spring ioc 依赖来源\n * spring bean 作用域\n * spring bean 生命周期\n * spring 配置元数据\n * spring aop\n * spring 资源管理\n * spring 校验\n * spring 数据绑定\n * spring 类型转换\n * spring el 表达式\n * spring 事件\n * spring 国际化\n * spring 泛型处理\n * spring 注解\n * spring environment 抽象\n * springboot 教程之快速入门\n * springboot 之属性加载\n * springboot 之 profile\n\n# 数据\n\n * spring 之数据源\n * spring 之 jdbc\n * spring 之事务\n * spring 之 jpa\n * spring 集成 mybatis\n * spring 访问 redis\n * spring 访问 mongodb\n * spring 访问 elasticsearch\n\n# web\n\n * spring webmvc\n * springboot 之应用 easyui\n\n# io\n\n * springboot 之异步请求\n * springboot 之 json\n * springboot 之邮件\n\n# 集成\n\n * spring 集成缓存中间件\n * spring 集成定时任务中间件\n * spring 集成 dubbo\n\n# 其他\n\n * spring4 升级\n * springboot 之 banner\n * springboot 之 actuator\n\n# orm\n\n * mybatis 快速入门\n * mybatis 原理\n\n# 安全\n\n> java 领域比较流行的安全框架就是 shiro 和 spring-security。\n> \n> shiro 更为简单、轻便，容易理解，能满足大多数基本安全场景下的需要。\n> \n> spring-security 功能更丰富，也比 shiro 更复杂。值得一提的是由于 spring-security 是 spring 团队开发，所以集成 spring 和 spring-boot 框架更容易。\n\n * shiro\n * springsecurity\n\n# io\n\n * shiro\n\n\n# java 中间件\n\n# 缓存\n\n> 缓存可以说是优化系统性能的第一手段，在各种技术中都会有缓存的应用。\n> \n> 如果想深入学习缓存，建议先了解一下 缓存基本原理，有助于理解缓存的特性、原理，使用缓存常见的问题及解决方案。\n\n * java 缓存中间件\n * ehcache 快速入门\n * java 进程内缓存\n * http 缓存\n\n# 流量控制\n\n * hystrix\n\n\n# 大数据\n\n> 大数据技术点以归档在：bigdata-tutorial\n\n * hdfs 📚\n * hbase 📚\n * hive 📚\n * mapreduce\n * yarn\n * zookeeper 📚\n * kafka 📚\n * spark\n * storm\n * flink\n\n\n# 📚 资料\n\n * java 经典书籍\n   * 《effective java 中文版》 - 本书介绍了在 java 编程中 78 条极具实用价值的经验规则，这些经验规则涵盖了大多数开发人员每天所面临的问题的解决方案。同推荐《重构 : 改善既有代码的设计》、《代码整洁之道》、《代码大全》，有一定的内容重叠。\n   * 《java 并发编程实战》 - 本书深入浅出地介绍了 java 线程和并发，是一本完美的 java 并发参考手册。\n   * 《深入理解 java 虚拟机》 - 不去了解 jvm 的工程师，和咸鱼有什么区\n   * 《maven 实战》 - 国内最权威的 maven 专家的力作，唯一一本哦！\n * 其他领域书籍\n   * 《redis 设计与实现》 - 系统而全面地描述了 redis 内部运行机制。图示丰富，描述清晰，并给出大量参考信息，是 nosql 数据库开发人员案头必备。\n   * 《鸟哥的 linux 私房菜 （基础学习篇）》 - 本书是最具知名度的 linux 入门书《鸟哥的 linux 私房菜基础学习篇》的最新版，全面而详细地介绍了 linux 操作系统。内容非常全面，建议挑选和自己实际工作相关度较高的，其他部分有需要再阅读。\n   * 《head first 设计模式》 - 《head first 设计模式》(中文版)共有 14 章，每章都介绍了几个设计模式，完整地涵盖了四人组版本全部 23 个设计模式。\n   * 《http 权威指南》 - 本书尝试着将 http 中一些互相关联且常被误解的规则梳理清楚，并编写了一系列基于各种主题的章节，对 http 各方面的特性进行了介绍。纵观全书，对 http“为什么”这样做进行了详细的解释，而不仅仅停留在它是“怎么做”的。\n   * 《tcp/ip 详解 系列》 - 完整而详细的 tcp/ip 协议指南。针对任何希望理解 tcp/ip 协议是如何实现的读者设计。\n   * 《剑指 offer：名企面试官精讲典型编程题》 - 剖析了 80 个典型的编程面试题，系统整理基础知识、代码质量、解题思路、优化效率和综合能力这 5 个面试要点。\n\n\n# 🚪 传送\n\n◾ 💧 钝悟的 it 知识图谱 ◾",charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"归档",frontmatter:{archivesPage:!0,title:"归档",permalink:"/archives/",article:!1},regularPath:"/@pages/archivesPage.html",relativePath:"@pages/archivesPage.md",key:"v-04cda89e",path:"/archives/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"标签",frontmatter:{tagsPage:!0,title:"标签",permalink:"/tags/",article:!1},regularPath:"/@pages/tagsPage.html",relativePath:"@pages/tagsPage.md",key:"v-26877d31",path:"/tags/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"Home",frontmatter:{home:!0,heroImage:"img/bg.gif",heroText:"JAVA-TUTORIAL",tagline:"☕ java-tutorial 是一个 Java 教程，汇集一个老司机在 Java 领域的十年积累。",bannerBg:"none",postList:"none",footer:"CC-BY-SA-4.0 Licensed | Copyright © 2018-Now Dunwu"},regularPath:"/",relativePath:"README.md",key:"v-10d1fe8a",path:"/",headers:[{level:2,title:"📖 内容",slug:"📖-内容",normalizedTitle:"📖 内容",charIndex:221},{level:3,title:"JavaSE",slug:"javase",normalizedTitle:"javase",charIndex:231},{level:3,title:"JavaEE",slug:"javaee",normalizedTitle:"javaee",charIndex:321},{level:4,title:"JavaWeb",slug:"javaweb",normalizedTitle:"javaweb",charIndex:331},{level:4,title:"Java 服务器",slug:"java-服务器",normalizedTitle:"java 服务器",charIndex:462},{level:3,title:"Java 软件",slug:"java-软件",normalizedTitle:"java 软件",charIndex:633},{level:4,title:"Java 构建",slug:"java-构建",normalizedTitle:"java 构建",charIndex:644},{level:4,title:"Java IDE",slug:"java-ide",normalizedTitle:"java ide",charIndex:1054},{level:4,title:"Java 监控诊断",slug:"java-监控诊断",normalizedTitle:"java 监控诊断",charIndex:1339},{level:3,title:"Java 工具",slug:"java-工具",normalizedTitle:"java 工具",charIndex:1478},{level:4,title:"Java IO",slug:"java-io",normalizedTitle:"java io",charIndex:306},{level:4,title:"JavaBean 工具",slug:"javabean-工具",normalizedTitle:"javabean 工具",charIndex:1582},{level:4,title:"Java 模板引擎",slug:"java-模板引擎",normalizedTitle:"java 模板引擎",charIndex:1617},{level:4,title:"Java 测试工具",slug:"java-测试工具",normalizedTitle:"java 测试工具",charIndex:1668},{level:4,title:"其他",slug:"其他",normalizedTitle:"其他",charIndex:1719},{level:3,title:"Java 框架",slug:"java-框架",normalizedTitle:"java 框架",charIndex:1812},{level:4,title:"ORM",slug:"orm",normalizedTitle:"orm",charIndex:1823},{level:4,title:"Spring",slug:"spring",normalizedTitle:"spring",charIndex:1861},{level:4,title:"Spring Boot",slug:"spring-boot",normalizedTitle:"spring boot",charIndex:1908},{level:4,title:"安全",slug:"安全",normalizedTitle:"安全",charIndex:1964},{level:4,title:"IO",slug:"io",normalizedTitle:"io",charIndex:311},{level:3,title:"Java 中间件",slug:"java-中间件",normalizedTitle:"java 中间件",charIndex:2216},{level:4,title:"缓存",slug:"缓存",normalizedTitle:"缓存",charIndex:2228},{level:4,title:"流量控制",slug:"流量控制",normalizedTitle:"流量控制",charIndex:2387},{level:3,title:"大数据",slug:"大数据",normalizedTitle:"大数据",charIndex:2408},{level:2,title:"📚 资料",slug:"📚-资料",normalizedTitle:"📚 资料",charIndex:2558},{level:2,title:"🚪 传送",slug:"🚪-传送",normalizedTitle:"🚪 传送",charIndex:3480}],headersStr:"📖 内容 JavaSE JavaEE JavaWeb Java 服务器 Java 软件 Java 构建 Java IDE Java 监控诊断 Java 工具 Java IO JavaBean 工具 Java 模板引擎 Java 测试工具 其他 Java 框架 ORM Spring Spring Boot 安全 IO Java 中间件 缓存 流量控制 大数据 📚 资料 🚪 传送",content:"> ☕ java-tutorial 是一个 Java 教程，汇集一个老司机在 Java 领域的十年积累。\n> \n>  * 🔁 项目同步维护：Github | Gitee\n>  * 📖 电子书阅读：Github Pages | Gitee Pages\n> \n> 说明：\n> \n>  * 下面的内容清单中，凡是有 📚 标记的技术，都已整理成详细的教程。\n>  * 部分技术因为可以应用于不同领域，所以可能会同时出现在不同的类别下。\n\n\n# 📖 内容\n\n\n# JavaSE\n\n> 📚 javacore 是一个 Java 核心技术教程。内容包含：Java 基础特性、Java 高级特性、Java 并发、JVM、Java IO 等。\n\n\n# JavaEE\n\n# JavaWeb\n\n * JavaWeb 面经\n * JavaWeb 之 Servlet 指南\n * JavaWeb 之 Jsp 指南\n * JavaWeb 之 Filter 和 Listener\n * JavaWeb 之 Cookie 和 Session\n\n# Java 服务器\n\n> Tomcat 和 Jetty 都是 Java 比较流行的轻量级服务器。\n> \n> Nginx 是目前最流行的反向代理服务器，也常用于负载均衡。\n\n * Tomcat 快速入门\n * Tomcat 连接器\n * Tomcat 容器\n * Tomcat 优化\n * Tomcat 和 Jetty\n * Jetty\n\n\n# Java 软件\n\n# Java 构建\n\n> Java 项目需要通过 构建工具 来管理项目依赖，完成编译、打包、发布、生成 JavaDoc 等任务。\n> \n>  * 目前最主流的构建工具是 Maven，它的功能非常强大。\n>  * Gradle 号称是要替代 Maven 等构件工具，它的版本管理确实简洁，但是需要学习 Groovy，学习成本比 Maven 高。\n>  * Ant 功能比 Maven 和 Gradle 要弱，现代 Java 项目基本不用了，但也有一些传统的 Java 项目还在使用。\n\n * Maven 📚\n   * Maven 快速入门\n   * Maven 教程之 pom.xml 详解\n   * Maven 教程之 settings.xml 详解\n   * Maven 实战问题和最佳实践\n   * Maven 教程之发布 jar 到私服或中央仓库\n   * Maven 插件之代码检查\n * Ant 简易教程\n\n# Java IDE\n\n> 自从有了 IDE，写代码从此就告别了刀耕火种的蛮荒时代。\n> \n>  * Eclipse 是久负盛名的开源 Java IDE，我的学生时代一直使用它写 Java。\n>  * 曾经抗拒从转 Intellij Idea ，但后来发现真香，不得不说，确实是目前最优秀的 Java IDE。\n>  * 你可以在 vscode 中写各种语言，只要安装相应插件即可。如果你的项目中使用了很多种编程语言，又懒得在多个 IDE 之间切换，那么就用 vscode 来一网打尽吧。\n\n * Intellij Idea\n * Eclipse\n * vscode\n\n# Java 监控诊断\n\n> 监控/诊断 工具主要用于 Java 应用的运维。通过采集、分析、存储、可视化应用的有效数据，帮助开发者、使用者快速定位问题，找到性能瓶颈。\n\n * 监控工具对比\n * CAT\n * Zipkin\n * SkyWalking\n * Arthas\n\n\n# Java 工具\n\n# Java IO\n\n * JSON 序列化 - fastjson、Jackson、Gson\n * 二进制序列化 - Protobuf、Thrift、Hessian、Kryo、FST\n\n# JavaBean 工具\n\n * Lombok\n * Dozer\n\n# Java 模板引擎\n\n * Freemark\n * Velocity\n * Thymeleaf\n\n# Java 测试工具\n\n * Junit\n * Mockito\n * Jmeter\n * JMH\n\n# 其他\n\n * Java 日志\n * Java 工具包\n * Reflections\n * JavaMail\n * Jsoup\n * Thumbnailator\n * Zxing\n\n\n# Java 框架\n\n# ORM\n\n * Mybatis 快速入门\n * Mybatis 原理\n\n# Spring\n\n📚 spring-tutorial 是一个 Spring 实战教程。\n\n# Spring Boot\n\n📚 Spring Boot 教程 是一个 Spring Boot 实战教程。\n\n# 安全\n\n> Java 领域比较流行的安全框架就是 shiro 和 spring-security。\n> \n> shiro 更为简单、轻便，容易理解，能满足大多数基本安全场景下的需要。\n> \n> spring-security 功能更丰富，也比 shiro 更复杂。值得一提的是由于 spring-security 是 spring 团队开发，所以集成 spring 和 spring-boot 框架更容易。\n\n * Shiro\n * SpringSecurity\n\n# IO\n\n * Shiro\n\n\n# Java 中间件\n\n# 缓存\n\n> 缓存可以说是优化系统性能的第一手段，在各种技术中都会有缓存的应用。\n> \n> 如果想深入学习缓存，建议先了解一下 缓存基本原理，有助于理解缓存的特性、原理，使用缓存常见的问题及解决方案。\n\n * Java 缓存中间件\n * Ehcache 快速入门\n * Java 进程内缓存\n * Http 缓存\n\n# 流量控制\n\n * Hystrix\n\n\n# 大数据\n\n> 大数据技术点以归档在：bigdata-tutorial\n\n * Hdfs 📚\n * Hbase 📚\n * Hive 📚\n * MapReduce\n * Yarn\n * ZooKeeper 📚\n * Kafka 📚\n * Spark\n * Storm\n * Flink\n\n\n# 📚 资料\n\n * Java 经典书籍\n   * 《Effective Java 中文版》 - 本书介绍了在 Java 编程中 78 条极具实用价值的经验规则，这些经验规则涵盖了大多数开发人员每天所面临的问题的解决方案。同推荐《重构 : 改善既有代码的设计》、《代码整洁之道》、《代码大全》，有一定的内容重叠。\n   * 《Java 并发编程实战》 - 本书深入浅出地介绍了 Java 线程和并发，是一本完美的 Java 并发参考手册。\n   * 《深入理解 Java 虚拟机》 - 不去了解 JVM 的工程师，和咸鱼有什么区\n   * 《Maven 实战》 - 国内最权威的 Maven 专家的力作，唯一一本哦！\n * 其他领域书籍\n   * 《Redis 设计与实现》 - 系统而全面地描述了 Redis 内部运行机制。图示丰富，描述清晰，并给出大量参考信息，是 NoSQL 数据库开发人员案头必备。\n   * 《鸟哥的 Linux 私房菜 （基础学习篇）》 - 本书是最具知名度的 Linux 入门书《鸟哥的 Linux 私房菜基础学习篇》的最新版，全面而详细地介绍了 Linux 操作系统。内容非常全面，建议挑选和自己实际工作相关度较高的，其他部分有需要再阅读。\n   * 《Head First 设计模式》 - 《Head First 设计模式》(中文版)共有 14 章，每章都介绍了几个设计模式，完整地涵盖了四人组版本全部 23 个设计模式。\n   * 《HTTP 权威指南》 - 本书尝试着将 HTTP 中一些互相关联且常被误解的规则梳理清楚，并编写了一系列基于各种主题的章节，对 HTTP 各方面的特性进行了介绍。纵观全书，对 HTTP“为什么”这样做进行了详细的解释，而不仅仅停留在它是“怎么做”的。\n   * 《TCP/IP 详解 系列》 - 完整而详细的 TCP/IP 协议指南。针对任何希望理解 TCP/IP 协议是如何实现的读者设计。\n   * 《剑指 Offer：名企面试官精讲典型编程题》 - 剖析了 80 个典型的编程面试题，系统整理基础知识、代码质量、解题思路、优化效率和综合能力这 5 个面试要点。\n\n\n# 🚪 传送\n\n◾ 🏠 JAVA-TUTORIAL 首页 ◾ 🎯 我的博客 ◾\n\n> 你可能会感兴趣：\n\n * Java 教程 📚\n * JavaCore 教程 📚\n * Spring 教程 📚\n * Spring Boot 教程 📚\n * 数据库教程 📚\n * 数据结构和算法教程 📚\n * Linux 教程 📚\n * Nginx 教程 📚",normalizedContent:"> ☕ java-tutorial 是一个 java 教程，汇集一个老司机在 java 领域的十年积累。\n> \n>  * 🔁 项目同步维护：github | gitee\n>  * 📖 电子书阅读：github pages | gitee pages\n> \n> 说明：\n> \n>  * 下面的内容清单中，凡是有 📚 标记的技术，都已整理成详细的教程。\n>  * 部分技术因为可以应用于不同领域，所以可能会同时出现在不同的类别下。\n\n\n# 📖 内容\n\n\n# javase\n\n> 📚 javacore 是一个 java 核心技术教程。内容包含：java 基础特性、java 高级特性、java 并发、jvm、java io 等。\n\n\n# javaee\n\n# javaweb\n\n * javaweb 面经\n * javaweb 之 servlet 指南\n * javaweb 之 jsp 指南\n * javaweb 之 filter 和 listener\n * javaweb 之 cookie 和 session\n\n# java 服务器\n\n> tomcat 和 jetty 都是 java 比较流行的轻量级服务器。\n> \n> nginx 是目前最流行的反向代理服务器，也常用于负载均衡。\n\n * tomcat 快速入门\n * tomcat 连接器\n * tomcat 容器\n * tomcat 优化\n * tomcat 和 jetty\n * jetty\n\n\n# java 软件\n\n# java 构建\n\n> java 项目需要通过 构建工具 来管理项目依赖，完成编译、打包、发布、生成 javadoc 等任务。\n> \n>  * 目前最主流的构建工具是 maven，它的功能非常强大。\n>  * gradle 号称是要替代 maven 等构件工具，它的版本管理确实简洁，但是需要学习 groovy，学习成本比 maven 高。\n>  * ant 功能比 maven 和 gradle 要弱，现代 java 项目基本不用了，但也有一些传统的 java 项目还在使用。\n\n * maven 📚\n   * maven 快速入门\n   * maven 教程之 pom.xml 详解\n   * maven 教程之 settings.xml 详解\n   * maven 实战问题和最佳实践\n   * maven 教程之发布 jar 到私服或中央仓库\n   * maven 插件之代码检查\n * ant 简易教程\n\n# java ide\n\n> 自从有了 ide，写代码从此就告别了刀耕火种的蛮荒时代。\n> \n>  * eclipse 是久负盛名的开源 java ide，我的学生时代一直使用它写 java。\n>  * 曾经抗拒从转 intellij idea ，但后来发现真香，不得不说，确实是目前最优秀的 java ide。\n>  * 你可以在 vscode 中写各种语言，只要安装相应插件即可。如果你的项目中使用了很多种编程语言，又懒得在多个 ide 之间切换，那么就用 vscode 来一网打尽吧。\n\n * intellij idea\n * eclipse\n * vscode\n\n# java 监控诊断\n\n> 监控/诊断 工具主要用于 java 应用的运维。通过采集、分析、存储、可视化应用的有效数据，帮助开发者、使用者快速定位问题，找到性能瓶颈。\n\n * 监控工具对比\n * cat\n * zipkin\n * skywalking\n * arthas\n\n\n# java 工具\n\n# java io\n\n * json 序列化 - fastjson、jackson、gson\n * 二进制序列化 - protobuf、thrift、hessian、kryo、fst\n\n# javabean 工具\n\n * lombok\n * dozer\n\n# java 模板引擎\n\n * freemark\n * velocity\n * thymeleaf\n\n# java 测试工具\n\n * junit\n * mockito\n * jmeter\n * jmh\n\n# 其他\n\n * java 日志\n * java 工具包\n * reflections\n * javamail\n * jsoup\n * thumbnailator\n * zxing\n\n\n# java 框架\n\n# orm\n\n * mybatis 快速入门\n * mybatis 原理\n\n# spring\n\n📚 spring-tutorial 是一个 spring 实战教程。\n\n# spring boot\n\n📚 spring boot 教程 是一个 spring boot 实战教程。\n\n# 安全\n\n> java 领域比较流行的安全框架就是 shiro 和 spring-security。\n> \n> shiro 更为简单、轻便，容易理解，能满足大多数基本安全场景下的需要。\n> \n> spring-security 功能更丰富，也比 shiro 更复杂。值得一提的是由于 spring-security 是 spring 团队开发，所以集成 spring 和 spring-boot 框架更容易。\n\n * shiro\n * springsecurity\n\n# io\n\n * shiro\n\n\n# java 中间件\n\n# 缓存\n\n> 缓存可以说是优化系统性能的第一手段，在各种技术中都会有缓存的应用。\n> \n> 如果想深入学习缓存，建议先了解一下 缓存基本原理，有助于理解缓存的特性、原理，使用缓存常见的问题及解决方案。\n\n * java 缓存中间件\n * ehcache 快速入门\n * java 进程内缓存\n * http 缓存\n\n# 流量控制\n\n * hystrix\n\n\n# 大数据\n\n> 大数据技术点以归档在：bigdata-tutorial\n\n * hdfs 📚\n * hbase 📚\n * hive 📚\n * mapreduce\n * yarn\n * zookeeper 📚\n * kafka 📚\n * spark\n * storm\n * flink\n\n\n# 📚 资料\n\n * java 经典书籍\n   * 《effective java 中文版》 - 本书介绍了在 java 编程中 78 条极具实用价值的经验规则，这些经验规则涵盖了大多数开发人员每天所面临的问题的解决方案。同推荐《重构 : 改善既有代码的设计》、《代码整洁之道》、《代码大全》，有一定的内容重叠。\n   * 《java 并发编程实战》 - 本书深入浅出地介绍了 java 线程和并发，是一本完美的 java 并发参考手册。\n   * 《深入理解 java 虚拟机》 - 不去了解 jvm 的工程师，和咸鱼有什么区\n   * 《maven 实战》 - 国内最权威的 maven 专家的力作，唯一一本哦！\n * 其他领域书籍\n   * 《redis 设计与实现》 - 系统而全面地描述了 redis 内部运行机制。图示丰富，描述清晰，并给出大量参考信息，是 nosql 数据库开发人员案头必备。\n   * 《鸟哥的 linux 私房菜 （基础学习篇）》 - 本书是最具知名度的 linux 入门书《鸟哥的 linux 私房菜基础学习篇》的最新版，全面而详细地介绍了 linux 操作系统。内容非常全面，建议挑选和自己实际工作相关度较高的，其他部分有需要再阅读。\n   * 《head first 设计模式》 - 《head first 设计模式》(中文版)共有 14 章，每章都介绍了几个设计模式，完整地涵盖了四人组版本全部 23 个设计模式。\n   * 《http 权威指南》 - 本书尝试着将 http 中一些互相关联且常被误解的规则梳理清楚，并编写了一系列基于各种主题的章节，对 http 各方面的特性进行了介绍。纵观全书，对 http“为什么”这样做进行了详细的解释，而不仅仅停留在它是“怎么做”的。\n   * 《tcp/ip 详解 系列》 - 完整而详细的 tcp/ip 协议指南。针对任何希望理解 tcp/ip 协议是如何实现的读者设计。\n   * 《剑指 offer：名企面试官精讲典型编程题》 - 剖析了 80 个典型的编程面试题，系统整理基础知识、代码质量、解题思路、优化效率和综合能力这 5 个面试要点。\n\n\n# 🚪 传送\n\n◾ 🏠 java-tutorial 首页 ◾ 🎯 我的博客 ◾\n\n> 你可能会感兴趣：\n\n * java 教程 📚\n * javacore 教程 📚\n * spring 教程 📚\n * spring boot 教程 📚\n * 数据库教程 📚\n * 数据结构和算法教程 📚\n * linux 教程 📚\n * nginx 教程 📚",charsets:{cjk:!0},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3},{title:"分类",frontmatter:{categoriesPage:!0,title:"分类",permalink:"/categories/",article:!1},regularPath:"/@pages/categoriesPage.html",relativePath:"@pages/categoriesPage.md",key:"v-5d493111",path:"/categories/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2024/12/31, 08:02:35",lastUpdatedTimestamp:1735603355e3}],themeConfig:{nav:[{text:"首页",link:"/"},{text:"JavaEE",link:"/01.Java/02.JavaEE/"},{text:"Java软件",link:"/01.Java/11.软件/",items:[{text:"Java 构建",link:"/01.Java/11.软件/01.构建/"},{text:"Java IDE",link:"/01.Java/11.软件/02.IDE/"},{text:"Java 监控诊断",link:"/01.Java/11.软件/03.监控诊断/"}]},{text:"Java工具",link:"/01.Java/12.工具/",items:[{text:"Java IO 工具",link:"/01.Java/12.工具/01.IO/"},{text:"JavaBean 工具",link:"/01.Java/12.工具/02.JavaBean/"},{text:"Java 模板引擎",link:"/01.Java/12.工具/03.模板引擎/"},{text:"Java 测试工具",link:"/01.Java/12.工具/04.测试/"}]},{text:"Java框架",link:"/01.Java/13.框架/"},{text:"Java中间件",link:"/01.Java/14.中间件/"},{text:"✨ Java系列",ariaLabel:"Java",items:[{text:"Java 教程 📚",link:"https://dunwu.github.io/java-tutorial/",target:"_blank"},{text:"JavaCore 教程 📚",link:"https://dunwu.github.io/javacore/",target:"_blank"}]}],sidebarDepth:2,logo:"https://raw.githubusercontent.com/dunwu/images/master/common/dunwu-logo.png",repo:"dunwu/java-tutorial",searchMaxSuggestions:10,lastUpdated:"上次更新",docsDir:"docs",editLinks:!0,editLinkText:"📝 帮助改善此页面！",sidebar:{"/01.Java/":[{title:"JavaEE",collapsable:!0,children:[{title:"JavaWeb",collapsable:!0,children:[["02.JavaEE/01.JavaWeb/01.JavaWeb之Servlet指南.md","JavaWeb 之 Servlet 指南","/pages/e98894/"],["02.JavaEE/01.JavaWeb/02.JavaWeb之Jsp指南.md","JavaWeb 之 Jsp 指南","/pages/8cc787/"],["02.JavaEE/01.JavaWeb/03.JavaWeb之Filter和Listener.md","JavaWeb 之 Filter 和 Listener","/pages/82df5f/"],["02.JavaEE/01.JavaWeb/04.JavaWeb之Cookie和Session.md","JavaWeb 之 Cookie 和 Session","/pages/c46bff/"],["02.JavaEE/01.JavaWeb/99.JavaWeb面经.md","JavaWeb 面经","/pages/e175ce/"]]},{title:"服务器",collapsable:!0,children:[{title:"Tomcat",collapsable:!0,children:[["02.JavaEE/02.服务器/01.Tomcat/01.Tomcat快速入门.md","Tomcat 快速入门","/pages/4a4c02/"],["02.JavaEE/02.服务器/01.Tomcat/02.Tomcat连接器.md","Tomcat连接器","/pages/13f070/"],["02.JavaEE/02.服务器/01.Tomcat/03.Tomcat容器.md","Tomcat容器","/pages/d5076a/"],["02.JavaEE/02.服务器/01.Tomcat/04.Tomcat优化.md","Tomcat优化","/pages/f9e1e6/"],["02.JavaEE/02.服务器/01.Tomcat/05.Tomcat和Jetty.md","Tomcat 和 Jetty","/pages/f37326/"]]},["02.JavaEE/02.服务器/02.Jetty.md","Jetty 快速入门","/pages/ec364e/"]]}]},{title:"软件",collapsable:!0,children:[{title:"构建",collapsable:!0,children:[{title:"Maven",collapsable:!0,children:[["11.软件/01.构建/01.Maven/01.Maven快速入门.md","Maven 快速入门","/pages/e5b79f/"],["11.软件/01.构建/01.Maven/02.Maven教程之pom.xml详解.md","Maven 教程之 pom.xml 详解","/pages/d893c2/"],["11.软件/01.构建/01.Maven/03.Maven教程之settings.xml详解.md","Maven 教程之 settings.xml 详解","/pages/1d58f1/"],["11.软件/01.构建/01.Maven/04.Maven实战问题和最佳实践.md","Maven 实战问题和最佳实践","/pages/198618/"],["11.软件/01.构建/01.Maven/05.Maven教程之发布jar到私服或中央仓库.md","Maven 教程之发布 jar 到私服或中央仓库","/pages/7bdaf9/"],["11.软件/01.构建/01.Maven/06.Maven插件之代码检查.md","Maven 插件之代码检查","/pages/370f1d/"]]},["11.软件/01.构建/02.Ant.md","Ant 简易教程","/pages/0bafae/"]]},{title:"IDE",collapsable:!0,children:[["11.软件/02.IDE/01.Intellij.md","Intellij IDEA 快速入门","/pages/ac5c6a/"],["11.软件/02.IDE/02.Eclipse.md","Eclipse 快速入门","/pages/2257c7/"],["11.软件/02.IDE/03.VsCode.md","Vscode 快速入门","/pages/0f7153/"]]},{title:"监控诊断",collapsable:!0,children:[["11.软件/03.监控诊断/01.监控工具对比.md","监控工具对比","/pages/16563a/"],["11.软件/03.监控诊断/02.CAT.md","CAT 快速入门","/pages/821ca3/"],["11.软件/03.监控诊断/03.Zipkin.md","Zipkin 快速入门","/pages/0a8826/"],["11.软件/03.监控诊断/04.Skywalking.md","SkyWalking 快速入门","/pages/df7dec/"],["11.软件/03.监控诊断/05.Arthas.md","Arthas 快速入门","/pages/c689d1/"]]}]},{title:"工具",collapsable:!0,children:[{title:"IO",collapsable:!0,children:[["12.工具/01.IO/01.JSON序列化.md","Java 和 JSON 序列化","/pages/4622a6/"],["12.工具/01.IO/02.二进制序列化.md","Java 二进制序列化","/pages/08d872/"]]},{title:"JavaBean",collapsable:!0,children:[["12.工具/02.JavaBean/01.Lombok.md","Lombok 快速入门","/pages/eb1d46/"],["12.工具/02.JavaBean/02.Dozer.md","Dozer 快速入门","/pages/45e21b/"]]},{title:"模板引擎",collapsable:!0,children:[["12.工具/03.模板引擎/01.Freemark.md","Freemark 快速入门","/pages/a60ccf/"],["12.工具/03.模板引擎/02.Thymeleaf.md","Thymeleaf 快速入门","/pages/e7d2ad/"],["12.工具/03.模板引擎/03.Velocity.md","Velocity 快速入门","/pages/3ba0ff/"]]},{title:"测试",collapsable:!0,children:[["12.工具/04.测试/01.Junit.md","JUnit5 快速入门","/pages/b39f47/"],["12.工具/04.测试/02.Mockito.md","Mockito 快速入门","/pages/f2c6f5/"],["12.工具/04.测试/03.Jmeter.md","JMeter 快速入门","/pages/0e5ab1/"],["12.工具/04.测试/04.JMH.md","JMH 快速入门","/pages/9c6402/"]]},{title:"其他",collapsable:!0,children:[["12.工具/99.其他/01.Java日志.md","javalib-log","/pages/fcc1c4/"],["12.工具/99.其他/02.Java工具包.md","javalib-util","/pages/27ad42/"],["12.工具/99.其他/03.Reflections.md","Reflections 快速入门","/pages/ce6195/"],["12.工具/99.其他/04.JavaMail.md","JavaMail 快速入门","/pages/cd38ec/"],["12.工具/99.其他/05.Jsoup.md","Jsoup 快速入门","/pages/5dd78d/"],["12.工具/99.其他/06.Thumbnailator.md","Thumbnailator 快速入门","/pages/adacc5/"],["12.工具/99.其他/07.Zxing.md","ZXing 快速入门","/pages/b563af/"]]}]},{title:"框架",collapsable:!0,children:[{title:"Spring",collapsable:!0,children:[{title:"Spring综合",collapsable:!0,children:[["13.框架/01.Spring/00.Spring综合/01.Spring概述.md","Spring Framework 综述","/pages/9d3091/"],["13.框架/01.Spring/00.Spring综合/21.SpringBoot知识图谱.md","SpringBoot 知识图谱","/pages/430f53/"],["13.框架/01.Spring/00.Spring综合/22.SpringBoot基本原理.md","SpringBoot 基本原理","/pages/dbf521/"],["13.框架/01.Spring/00.Spring综合/99.Spring面试.md","Spring 面试","/pages/db33b0/"]]},{title:"Spring核心",collapsable:!0,children:[["13.框架/01.Spring/01.Spring核心/01.SpringBean.md","Spring Bean","/pages/68097d/"],["13.框架/01.Spring/01.Spring核心/02.SpringIoC.md","Spring IoC","/pages/915530/"],["13.框架/01.Spring/01.Spring核心/03.Spring依赖查找.md","Spring 依赖查找","/pages/9a6f6b/"],["13.框架/01.Spring/01.Spring核心/04.Spring依赖注入.md","Spring 依赖注入","/pages/f61a1c/"],["13.框架/01.Spring/01.Spring核心/05.SpringIoC依赖来源.md","Spring IoC 依赖来源","/pages/a5f257/"],["13.框架/01.Spring/01.Spring核心/06.SpringBean作用域.md","Spring Bean 作用域","/pages/8289f5/"],["13.框架/01.Spring/01.Spring核心/07.SpringBean生命周期.md","Spring Bean 生命周期","/pages/4ab176/"],["13.框架/01.Spring/01.Spring核心/08.Spring配置元数据.md","Spring 配置元数据","/pages/55f315/"],["13.框架/01.Spring/01.Spring核心/09.Spring应用上下文生命周期.md","Spring 应用上下文生命周期","/pages/ad472e/"],["13.框架/01.Spring/01.Spring核心/10.SpringAop.md","Spring AOP","/pages/53aedb/"],["13.框架/01.Spring/01.Spring核心/20.Spring资源管理.md","Spring 资源管理","/pages/a1549f/"],["13.框架/01.Spring/01.Spring核心/21.Spring校验.md","Spring 校验","/pages/fe6aad/"],["13.框架/01.Spring/01.Spring核心/22.Spring数据绑定.md","Spring 数据绑定","/pages/267b4c/"],["13.框架/01.Spring/01.Spring核心/23.Spring类型转换.md","Spring 类型转换","/pages/6662dc/"],["13.框架/01.Spring/01.Spring核心/24.SpringEL.md","Spring EL 表达式","/pages/1f743f/"],["13.框架/01.Spring/01.Spring核心/25.Spring事件.md","Spring 事件","/pages/cca414/"],["13.框架/01.Spring/01.Spring核心/26.Spring国际化.md","Spring 国际化","/pages/b5b8ad/"],["13.框架/01.Spring/01.Spring核心/27.Spring泛型处理.md","Spring 泛型处理","/pages/175cbd/"],["13.框架/01.Spring/01.Spring核心/28.Spring注解.md","Spring 注解","/pages/b6556f/"],["13.框架/01.Spring/01.Spring核心/29.SpringEnvironment抽象.md","Spring Environment 抽象","/pages/03d838/"],["13.框架/01.Spring/01.Spring核心/31.SpringBoot之快速入门.md","SpringBoot 之快速入门","/pages/950e4d/"],["13.框架/01.Spring/01.Spring核心/32.SpringBoot之属性加载.md","SpringBoot 之属性加载详解","/pages/0fb992/"],["13.框架/01.Spring/01.Spring核心/33.SpringBoot之Profile.md","SpringBoot 之 Profile","/pages/cb598e/"]]},{title:"Spring数据",collapsable:!0,children:[["13.框架/01.Spring/02.Spring数据/01.Spring之数据源.md","Spring 之数据源","/pages/1b774c/"],["13.框架/01.Spring/02.Spring数据/02.Spring之JDBC.md","Spring 之 JDBC","/pages/cf19fd/"],["13.框架/01.Spring/02.Spring数据/03.Spring之事务.md","Spring 之事务","/pages/128c54/"],["13.框架/01.Spring/02.Spring数据/04.Spring之JPA.md","Spring 之 JPA","/pages/a03d7b/"],["13.框架/01.Spring/02.Spring数据/10.Spring集成Mybatis.md","Spring 集成 Mybatis","/pages/88219e/"],["13.框架/01.Spring/02.Spring数据/20.SpringData综合.md","Spring Data 综合","/pages/191cdb/"],["13.框架/01.Spring/02.Spring数据/21.Spring访问Redis.md","Spring 访问 Redis","/pages/65e4a2/"],["13.框架/01.Spring/02.Spring数据/22.Spring访问MongoDB.md","Spring 访问 MongoDB","/pages/db2a41/"],["13.框架/01.Spring/02.Spring数据/23.Spring访问Elasticsearch.md","Spring 访问 Elasticsearch","/pages/fac14c/"]]},{title:"SpringWeb",collapsable:!0,children:[["13.框架/01.Spring/03.SpringWeb/01.SpringWebMvc.md","spring-mvc","/pages/65351b/"],["13.框架/01.Spring/03.SpringWeb/21.SpringBoot之应用EasyUI.md","SpringBoot 之应用 EasyUI","/pages/ad0516/"]]},{title:"SpringIO",collapsable:!0,children:[["13.框架/01.Spring/04.SpringIO/01.SpringBoot之异步请求.md","spring-boot-async","/pages/92add2/"],["13.框架/01.Spring/04.SpringIO/02.SpringBoot之Json.md","SpringBoot 之集成 Json","/pages/676725/"],["13.框架/01.Spring/04.SpringIO/03.SpringBoot之邮件.md","SpringBoot 之发送邮件","/pages/2586f1/"]]},{title:"Spring集成",collapsable:!0,children:[["13.框架/01.Spring/05.Spring集成/01.Spring集成缓存.md","Spring集成缓存","/pages/a311cb/"],["13.框架/01.Spring/05.Spring集成/02.Spring集成调度器.md","Spring 集成调度器","/pages/a187f0/"],["13.框架/01.Spring/05.Spring集成/03.Spring集成Dubbo.md","Spring集成Dubbo","/pages/274fd7/"]]},{title:"Spring安全",collapsable:!0,children:[["13.框架/01.Spring/10.Spring安全/01.SpringBoot之安全快速入门.md","SpringBoot 之安全快速入门","/pages/568352/"]]},{title:"Spring其他",collapsable:!0,children:[["13.框架/01.Spring/99.Spring其他/01.Spring4升级.md","Spring 4 升级踩雷指南","/pages/752c6a/"],["13.框架/01.Spring/99.Spring其他/21.SpringBoot之banner.md","SpringBoot 之 banner 定制","/pages/bac2ce/"],["13.框架/01.Spring/99.Spring其他/22.SpringBoot之Actuator.md","SpringBoot Actuator 快速入门","/pages/c013cc/"]]}]},{title:"ORM",collapsable:!0,children:[["13.框架/11.ORM/01.Mybatis快速入门.md","Mybatis快速入门","/pages/d4e6ee/"],["13.框架/11.ORM/02.Mybatis原理.md","Mybatis原理","/pages/d55184/"]]},{title:"安全",collapsable:!0,children:[["13.框架/12.安全/01.Shiro.md","Shiro 快速入门","/pages/3295c4/"],["13.框架/12.安全/02.SpringSecurity.md","Spring Security 快速入门","/pages/050cdd/"]]},{title:"IO",collapsable:!0,children:[["13.框架/13.IO/01.Netty.md","Netty 快速入门","/pages/10bd70/"]]}]},{title:"中间件",collapsable:!0,children:[{title:"缓存",collapsable:!0,children:[["14.中间件/02.缓存/02.Java缓存中间件.md","Java 缓存中间件","/pages/85460d/"],["14.中间件/02.缓存/04.Ehcache.md","Ehcache 快速入门","/pages/5f7893/"],["14.中间件/02.缓存/05.Java进程内缓存.md","Java 进程内缓存","/pages/59f078/"],["14.中间件/02.缓存/06.Http缓存.md","Http 缓存","/pages/30abaa/"]]},{title:"流量控制",collapsable:!0,children:[["14.中间件/03.流量控制/01.Hystrix.md","Hystrix 快速入门","/pages/364124/"]]},{title:"其他",collapsable:!0,children:[["14.中间件/99.其他/01.数据库连接池.md","数据库连接池","/pages/be5227/"]]}]}],catalogue:{}},sidebarOpen:!0,updateBar:{showToArticle:!0},category:!0,tag:!0,archive:!0,author:{name:"dunwu",href:"https://github.com/dunwu"},social:{icons:[{iconClass:"icon-youjian",title:"发邮件",link:"mailto:forbreak@163.com"},{iconClass:"icon-github",title:"GitHub",link:"https://github.com/dunwu"}]},footer:{createYear:2019,copyrightInfo:"钝悟（dunwu） | CC-BY-SA-4.0"},htmlModules:{windowRB:'\n    <div class="wwads-cn wwads-vertical windowRB" data-id="261" style="max-width:160px;\n    min-width: auto;min-height:auto;"></div>\n    <style>\n      .windowRB{ padding: 0;}\n      .windowRB .wwads-img{margin-top: 10px;}\n      .windowRB .wwads-content{margin: 0 10px 40px 10px;}\n      .custom-html-window-rb .close-but{\n        display: none;\n      }\n    </style>\n  '}}};var wl=t(120),jl=t(121),kl=t(20);var Tl={computed:{$filterPosts(){return this.$site.pages.filter(n=>{const{frontmatter:{pageComponent:e,article:t,home:a}}=n;return!(e||!1===t||!0===a)})},$sortPosts(){return(n=this.$filterPosts).sort((n,e)=>{const t=n.frontmatter.sticky,a=e.frontmatter.sticky;return t&&a?t==a?Object(kl.a)(n,e):t-a:t&&!a?-1:!t&&a?1:Object(kl.a)(n,e)}),n;var n},$sortPostsByDate(){return(n=this.$filterPosts).sort((n,e)=>Object(kl.a)(n,e)),n;var n},$groupPosts(){return function(n){const e={},t={};for(let a=0,r=n.length;a<r;a++){const{frontmatter:{categories:r,tags:i}}=n[a];"array"===Object(kl.n)(r)&&r.forEach(t=>{t&&(e[t]||(e[t]=[]),e[t].push(n[a]))}),"array"===Object(kl.n)(i)&&i.forEach(e=>{e&&(t[e]||(t[e]=[]),t[e].push(n[a]))})}return{categories:e,tags:t}}(this.$sortPosts)},$categoriesAndTags(){return function(n){const e=[],t=[];for(let t in n.categories)e.push({key:t,length:n.categories[t].length});for(let e in n.tags)t.push({key:e,length:n.tags[e].length});return{categories:e,tags:t}}(this.$groupPosts)}}};Vt.component(wl.default),Vt.component(jl.default);function Il(n){return n.toString().padStart(2,"0")}t(280);Vt.component("Badge",()=>Promise.all([t.e(0),t.e(3)]).then(t.bind(null,501))),Vt.component("CodeBlock",()=>Promise.resolve().then(t.bind(null,120))),Vt.component("CodeGroup",()=>Promise.resolve().then(t.bind(null,121)));t(281);var Cl=[({Vue:n,options:e,router:t,siteData:a,isServer:r})=>{r||t.afterEach(()=>{var n;n=function(){setTimeout((function(){void 0===window._AdBlockInit&&function(){const n=document.getElementsByClassName("wwads-cn"),e=document.querySelector(".wwads-content");n[0]&&!e&&(n[0].innerHTML="<style>.wwads-horizontal,.wwads-vertical{background-color:#f4f8fa;padding:5px;min-height:120px;margin-top:20px;box-sizing:border-box;border-radius:3px;font-family:sans-serif;display:flex;min-width:150px;position:relative;overflow:hidden;}.wwads-horizontal{flex-wrap:wrap;justify-content:center}.wwads-vertical{flex-direction:column;align-items:center;padding-bottom:32px}.wwads-horizontal a,.wwads-vertical a{text-decoration:none}.wwads-horizontal .wwads-img,.wwads-vertical .wwads-img{margin:5px}.wwads-horizontal .wwads-content,.wwads-vertical .wwads-content{margin:5px}.wwads-horizontal .wwads-content{flex:130px}.wwads-vertical .wwads-content{margin-top:10px}.wwads-horizontal .wwads-text,.wwads-content .wwads-text{font-size:14px;line-height:1.4;color:#0e1011;-webkit-font-smoothing:antialiased}.wwads-horizontal .wwads-poweredby,.wwads-vertical .wwads-poweredby{display:block;font-size:11px;color:#a6b7bf;margin-top:1em}.wwads-vertical .wwads-poweredby{position:absolute;left:10px;bottom:10px}.wwads-horizontal .wwads-poweredby span,.wwads-vertical .wwads-poweredby span{transition:all 0.2s ease-in-out;margin-left:-1em}.wwads-horizontal .wwads-poweredby span:first-child,.wwads-vertical .wwads-poweredby span:first-child{opacity:0}.wwads-horizontal:hover .wwads-poweredby span,.wwads-vertical:hover .wwads-poweredby span{opacity:1;margin-left:0}.wwads-horizontal .wwads-hide,.wwads-vertical .wwads-hide{position:absolute;right:-23px;bottom:-23px;width:46px;height:46px;border-radius:23px;transition:all 0.3s ease-in-out;cursor:pointer;}.wwads-horizontal .wwads-hide:hover,.wwads-vertical .wwads-hide:hover{background:rgb(0 0 0 /0.05)}.wwads-horizontal .wwads-hide svg,.wwads-vertical .wwads-hide svg{position:absolute;left:10px;top:10px;fill:#a6b7bf}.wwads-horizontal .wwads-hide:hover svg,.wwads-vertical .wwads-hide:hover svg{fill:#3E4546}</style><a href='https://wwads.cn/page/whitelist-wwads' class='wwads-img' target='_blank' rel='nofollow'><img src='https://fastly.jsdelivr.net/gh/xugaoyi/image_store@master/blog/wwads.2a3pidhlh4ys.webp' width='130'></a><div class='wwads-content'><a href='https://wwads.cn/page/whitelist-wwads' class='wwads-text' target='_blank' rel='nofollow'>为了本站的长期运营，请将我们的网站加入广告拦截器的白名单，感谢您的支持！<span style='color: #11a8cd'>如何添加白名单?</span></a><a href='https://wwads.cn/page/end-user-privacy' class='wwads-poweredby' title='万维广告 ～ 让广告更优雅，且有用' target='_blank'><span>广告</span></a></div><a class='wwads-hide' onclick='parentNode.remove()' title='隐藏广告'><svg xmlns='http://www.w3.org/2000/svg' width='6' height='7'><path d='M.879.672L3 2.793 5.121.672a.5.5 0 11.707.707L3.708 3.5l2.12 2.121a.5.5 0 11-.707.707l-2.12-2.12-2.122 2.12a.5.5 0 11-.707-.707l2.121-2.12L.172 1.378A.5.5 0 01.879.672z'></path></svg></a>")}()}),3e3)},"complete"===document.readyState||"interactive"===document.readyState?setTimeout(n,1):document.addEventListener("DOMContentLoaded",n),setTimeout(()=>{const n=document.querySelector(".page-wwads");if(!n)return;const e=n.querySelector(".wwads-hide");e&&(e.onclick=()=>{n.style.display="none"}),"none"===n.style.display&&(n.style.display="flex")},900)})},({Vue:n,options:e,router:t,siteData:a})=>{a.pages.map(n=>{const{frontmatter:{date:e,author:t}}=n;"string"==typeof e&&"Z"===e.charAt(e.length-1)&&(n.frontmatter.date=function(n){n instanceof Date||(n=new Date(n));return`${n.getUTCFullYear()}-${Il(n.getUTCMonth()+1)}-${Il(n.getUTCDate())} ${Il(n.getUTCHours())}:${Il(n.getUTCMinutes())}:${Il(n.getUTCSeconds())}`}(e)),t?n.author=t:a.themeConfig.author&&(n.author=a.themeConfig.author)}),n.mixin(Tl)},{},({Vue:n})=>{n.mixin({computed:{$dataBlock(){return this.$options.__data__block__}}})},{},{},()=>{"undefined"!=typeof window&&function(n,e,t){function a(n){var t=e.createElement("div");t.className="heart",r.push({el:t,x:n.clientX-5,y:n.clientY-5,scale:1,alpha:1,color:"#11a8cd"}),e.body.appendChild(t)}var r=[];n.requestAnimationFrame=n.requestAnimationFrame||n.webkitRequestAnimationFrame||n.mozRequestAnimationFrame||n.oRequestAnimationFrame||n.msRequestAnimationFrame||function(n){setTimeout(n,1e3/60)},function(n){var t=e.createElement("style");t.type="text/css";try{t.appendChild(e.createTextNode(n))}catch(e){t.styleSheet.cssText=n}e.getElementsByTagName("head")[0].appendChild(t)}(".heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}"),function(){var e="function"==typeof n.onclick&&n.onclick;n.onclick=function(n){let t=!0;n.path&&n.path.forEach(n=>{1===n.nodeType&&"string"==typeof n.className&&n.className.indexOf("theme-vdoing-content")>-1&&(t=!1)}),t&&(e&&e(),a(n))}}(),function n(){for(var t=0;t<r.length;t++)r[t].alpha<=0?(e.body.removeChild(r[t].el),r.splice(t,1)):(r[t].y--,r[t].scale+=.004,r[t].alpha-=.013,r[t].el.style.cssText="left:"+r[t].x+"px;top:"+r[t].y+"px;opacity:"+r[t].alpha+";transform:scale("+r[t].scale+","+r[t].scale+") rotate(45deg);background:"+r[t].color+";z-index:99999");requestAnimationFrame(n)}()}(window,document)}],El=[];class Al extends class{constructor(){this.store=new Vt({data:{state:{}}})}$get(n){return this.store.state[n]}$set(n,e){Vt.set(this.store.state,n,e)}$emit(...n){this.store.$emit(...n)}$on(...n){this.store.$on(...n)}}{}Object.assign(Al.prototype,{getPageAsyncComponent:ss,getLayoutAsyncComponent:ls,getAsyncComponent:cs,getVueComponent:ps});var Pl={install(n){const e=new Al;n.$vuepress=e,n.prototype.$vuepress=e}};function Bl(n,e){const t=e.toLowerCase();return n.options.routes.some(n=>n.path.toLowerCase()===t)}var Ml={props:{pageKey:String,slotKey:{type:String,default:"default"}},render(n){const e=this.pageKey||this.$parent.$page.key;return us("pageKey",e),Vt.component(e)||Vt.component(e,ss(e)),Vt.component(e)?n(e):n("")}},zl={functional:!0,props:{slotKey:String,required:!0},render:(n,{props:e,slots:t})=>n("div",{class:["content__"+e.slotKey]},t()[e.slotKey])},Jl={computed:{openInNewWindowTitle(){return this.$themeLocaleConfig.openNewWindowText||"(opens new window)"}}},Rl=(t(282),t(283),Object(fl.a)(Jl,(function(){var n=this._self._c;return n("span",[n("svg",{staticClass:"icon outbound",attrs:{xmlns:"http://www.w3.org/2000/svg","aria-hidden":"true",focusable:"false",x:"0px",y:"0px",viewBox:"0 0 100 100",width:"15",height:"15"}},[n("path",{attrs:{fill:"currentColor",d:"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"}}),this._v(" "),n("polygon",{attrs:{fill:"currentColor",points:"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"}})]),this._v(" "),n("span",{staticClass:"sr-only"},[this._v(this._s(this.openInNewWindowTitle))])])}),[],!1,null,null,null).exports),Ll={functional:!0,render(n,{parent:e,children:t}){if(e._isMounted)return t;e.$once("hook:mounted",()=>{e.$forceUpdate()})}};Vt.config.productionTip=!1,Vt.use($o),Vt.use(Pl),Vt.mixin(function(n,e,t=Vt){!function(n){n.locales&&Object.keys(n.locales).forEach(e=>{n.locales[e].path=e});Object.freeze(n)}(e),t.$vuepress.$set("siteData",e);const a=new(n(t.$vuepress.$get("siteData"))),r=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(a)),i={};return Object.keys(r).reduce((n,e)=>(e.startsWith("$")&&(n[e]=r[e].get),n),i),{computed:i}}(n=>class{setPage(n){this.__page=n}get $site(){return n}get $themeConfig(){return this.$site.themeConfig}get $frontmatter(){return this.$page.frontmatter}get $localeConfig(){const{locales:n={}}=this.$site;let e,t;for(const a in n)"/"===a?t=n[a]:0===this.$page.path.indexOf(a)&&(e=n[a]);return e||t||{}}get $siteTitle(){return this.$localeConfig.title||this.$site.title||""}get $canonicalUrl(){const{canonicalUrl:n}=this.$page.frontmatter;return"string"==typeof n&&n}get $title(){const n=this.$page,{metaTitle:e}=this.$page.frontmatter;if("string"==typeof e)return e;const t=this.$siteTitle,a=n.frontmatter.home?null:n.frontmatter.title||n.title;return t?a?a+" | "+t:t:a||"VuePress"}get $description(){const n=function(n){if(n){const e=n.filter(n=>"description"===n.name)[0];if(e)return e.content}}(this.$page.frontmatter.meta);return n||(this.$page.frontmatter.description||this.$localeConfig.description||this.$site.description||"")}get $lang(){return this.$page.frontmatter.lang||this.$localeConfig.lang||"en-US"}get $localePath(){return this.$localeConfig.path||"/"}get $themeLocaleConfig(){return(this.$site.themeConfig.locales||{})[this.$localePath]||{}}get $page(){return this.__page?this.__page:function(n,e){for(let t=0;t<n.length;t++){const a=n[t];if(a.path.toLowerCase()===e.toLowerCase())return a}return{path:"",frontmatter:{}}}(this.$site.pages,this.$route.path)}},Sl)),Vt.component("Content",Ml),Vt.component("ContentSlotsDistributor",zl),Vt.component("OutboundLink",Rl),Vt.component("ClientOnly",Ll),Vt.component("Layout",ls("Layout")),Vt.component("NotFound",ls("NotFound")),Vt.prototype.$withBase=function(n){const e=this.$site.base;return"/"===n.charAt(0)?e+n.slice(1):n},window.__VUEPRESS__={version:"1.9.9",hash:"973d07a"},async function(n){const e="undefined"!=typeof window&&window.__VUEPRESS_ROUTER_BASE__?window.__VUEPRESS_ROUTER_BASE__:Sl.routerBase||Sl.base,t=new $o({base:e,mode:"history",fallback:!1,routes:xl,scrollBehavior:(n,e,t)=>t||(n.hash?!Vt.$vuepress.$get("disableScrollBehavior")&&{selector:decodeURIComponent(n.hash)}:{x:0,y:0})});!function(n){n.beforeEach((e,t,a)=>{if(Bl(n,e.path))a();else if(/(\/|\.html)$/.test(e.path))if(/\/$/.test(e.path)){const t=e.path.replace(/\/$/,"")+".html";Bl(n,t)?a(t):a()}else a();else{const t=e.path+"/",r=e.path+".html";Bl(n,r)?a(r):Bl(n,t)?a(t):a()}})}(t);const a={};try{await Promise.all(Cl.filter(n=>"function"==typeof n).map(e=>e({Vue:Vt,options:a,router:t,siteData:Sl,isServer:n})))}catch(n){console.error(n)}return{app:new Vt(Object.assign(a,{router:t,render:n=>n("div",{attrs:{id:"app"}},[n("RouterView",{ref:"layout"}),n("div",{class:"global-ui"},El.map(e=>n(e)))])})),router:t}}(!1).then(({app:n,router:e})=>{e.onReady(()=>{n.$mount("#app")})})}]);