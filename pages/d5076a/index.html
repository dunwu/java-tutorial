<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Tomcat容器 | JAVA-TUTORIAL</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="icon" href="/java-tutorial/img/favicon.ico">
    <script src="https://cdn.wwads.cn/js/makemoney.js" type="text/javascript"></script>
    <meta name="description" content="☕ java-tutorial 是一个 Java 教程，汇集一个老司机在 Java 领域的十年积累。">
    <meta name="keywords" content="vuepress,theme,blog,vdoing">
    <meta name="theme-color" content="#11a8cd">
    <meta name="wwads-cn-verify" content="mxqWx62nfQQ9ocT4e5DzISHzOWyF4s">
    
    <link rel="preload" href="/java-tutorial/assets/css/0.styles.22aad9ca.css" as="style"><link rel="preload" href="/java-tutorial/assets/js/app.daf69751.js" as="script"><link rel="preload" href="/java-tutorial/assets/js/2.bc9223e0.js" as="script"><link rel="preload" href="/java-tutorial/assets/js/13.581f93fb.js" as="script"><link rel="prefetch" href="/java-tutorial/assets/js/10.9edf914b.js"><link rel="prefetch" href="/java-tutorial/assets/js/100.ccc9a903.js"><link rel="prefetch" href="/java-tutorial/assets/js/101.183df0d3.js"><link rel="prefetch" href="/java-tutorial/assets/js/102.72154a73.js"><link rel="prefetch" href="/java-tutorial/assets/js/103.e83801db.js"><link rel="prefetch" href="/java-tutorial/assets/js/104.37a7b1ee.js"><link rel="prefetch" href="/java-tutorial/assets/js/105.2f58df41.js"><link rel="prefetch" href="/java-tutorial/assets/js/106.a9afdc16.js"><link rel="prefetch" href="/java-tutorial/assets/js/107.a78ef136.js"><link rel="prefetch" href="/java-tutorial/assets/js/108.2b5c1e35.js"><link rel="prefetch" href="/java-tutorial/assets/js/109.3e36e9e8.js"><link rel="prefetch" href="/java-tutorial/assets/js/11.f9f5b03a.js"><link rel="prefetch" href="/java-tutorial/assets/js/110.38a5c579.js"><link rel="prefetch" href="/java-tutorial/assets/js/111.b42b4984.js"><link rel="prefetch" href="/java-tutorial/assets/js/112.a6fdaf7c.js"><link rel="prefetch" href="/java-tutorial/assets/js/113.977f8481.js"><link rel="prefetch" href="/java-tutorial/assets/js/114.c37d8374.js"><link rel="prefetch" href="/java-tutorial/assets/js/115.adbb31d7.js"><link rel="prefetch" href="/java-tutorial/assets/js/116.e53d9383.js"><link rel="prefetch" href="/java-tutorial/assets/js/117.bc43cd18.js"><link rel="prefetch" href="/java-tutorial/assets/js/118.80cf3c9b.js"><link rel="prefetch" href="/java-tutorial/assets/js/119.17d1d3ef.js"><link rel="prefetch" href="/java-tutorial/assets/js/12.5c15bdc6.js"><link rel="prefetch" href="/java-tutorial/assets/js/120.fb2ee254.js"><link rel="prefetch" href="/java-tutorial/assets/js/121.f36932f6.js"><link rel="prefetch" href="/java-tutorial/assets/js/122.cf1fe750.js"><link rel="prefetch" href="/java-tutorial/assets/js/123.7dd5179b.js"><link rel="prefetch" href="/java-tutorial/assets/js/124.b11f012a.js"><link rel="prefetch" href="/java-tutorial/assets/js/125.10278b2b.js"><link rel="prefetch" href="/java-tutorial/assets/js/126.ab14f44c.js"><link rel="prefetch" href="/java-tutorial/assets/js/127.5ba17976.js"><link rel="prefetch" href="/java-tutorial/assets/js/128.af3c1a70.js"><link rel="prefetch" href="/java-tutorial/assets/js/129.ace640fd.js"><link rel="prefetch" href="/java-tutorial/assets/js/130.f9a86620.js"><link rel="prefetch" href="/java-tutorial/assets/js/131.45c339b9.js"><link rel="prefetch" href="/java-tutorial/assets/js/132.4c2730f0.js"><link rel="prefetch" href="/java-tutorial/assets/js/133.c65beba5.js"><link rel="prefetch" href="/java-tutorial/assets/js/134.41643697.js"><link rel="prefetch" href="/java-tutorial/assets/js/135.4c938701.js"><link rel="prefetch" href="/java-tutorial/assets/js/136.f32614a8.js"><link rel="prefetch" href="/java-tutorial/assets/js/137.79410813.js"><link rel="prefetch" href="/java-tutorial/assets/js/14.67210f72.js"><link rel="prefetch" href="/java-tutorial/assets/js/15.f02a1ad1.js"><link rel="prefetch" href="/java-tutorial/assets/js/16.e64fab55.js"><link rel="prefetch" href="/java-tutorial/assets/js/17.e6ca686c.js"><link rel="prefetch" href="/java-tutorial/assets/js/18.8f0b0ab4.js"><link rel="prefetch" href="/java-tutorial/assets/js/19.091524f7.js"><link rel="prefetch" href="/java-tutorial/assets/js/20.b2650a4f.js"><link rel="prefetch" href="/java-tutorial/assets/js/21.1df4f842.js"><link rel="prefetch" href="/java-tutorial/assets/js/22.bbf93466.js"><link rel="prefetch" href="/java-tutorial/assets/js/23.e5a6c9e1.js"><link rel="prefetch" href="/java-tutorial/assets/js/24.7a6a1ab1.js"><link rel="prefetch" href="/java-tutorial/assets/js/25.05ce92da.js"><link rel="prefetch" href="/java-tutorial/assets/js/26.cc0a008a.js"><link rel="prefetch" href="/java-tutorial/assets/js/27.19032685.js"><link rel="prefetch" href="/java-tutorial/assets/js/28.b2bb31ab.js"><link rel="prefetch" href="/java-tutorial/assets/js/29.e89cf580.js"><link rel="prefetch" href="/java-tutorial/assets/js/3.1f5cc974.js"><link rel="prefetch" href="/java-tutorial/assets/js/30.e72522ac.js"><link rel="prefetch" href="/java-tutorial/assets/js/31.23bc8c03.js"><link rel="prefetch" href="/java-tutorial/assets/js/32.b536a066.js"><link rel="prefetch" href="/java-tutorial/assets/js/33.ebee4849.js"><link rel="prefetch" href="/java-tutorial/assets/js/34.c85865c5.js"><link rel="prefetch" href="/java-tutorial/assets/js/35.ebc1fb00.js"><link rel="prefetch" href="/java-tutorial/assets/js/36.68e02904.js"><link rel="prefetch" href="/java-tutorial/assets/js/37.674930ad.js"><link rel="prefetch" href="/java-tutorial/assets/js/38.8d6a8a9f.js"><link rel="prefetch" href="/java-tutorial/assets/js/39.797eb403.js"><link rel="prefetch" href="/java-tutorial/assets/js/4.d163695c.js"><link rel="prefetch" href="/java-tutorial/assets/js/40.d28b7496.js"><link rel="prefetch" href="/java-tutorial/assets/js/41.ce6ca6c6.js"><link rel="prefetch" href="/java-tutorial/assets/js/42.273291d5.js"><link rel="prefetch" href="/java-tutorial/assets/js/43.5e461285.js"><link rel="prefetch" href="/java-tutorial/assets/js/44.971cad76.js"><link rel="prefetch" href="/java-tutorial/assets/js/45.8e0c71aa.js"><link rel="prefetch" href="/java-tutorial/assets/js/46.f5577b26.js"><link rel="prefetch" href="/java-tutorial/assets/js/47.f71cc3c9.js"><link rel="prefetch" href="/java-tutorial/assets/js/48.a8578d32.js"><link rel="prefetch" href="/java-tutorial/assets/js/49.0e290971.js"><link rel="prefetch" href="/java-tutorial/assets/js/5.cf5cb583.js"><link rel="prefetch" href="/java-tutorial/assets/js/50.b5439840.js"><link rel="prefetch" href="/java-tutorial/assets/js/51.3afc4e67.js"><link rel="prefetch" href="/java-tutorial/assets/js/52.52ce1139.js"><link rel="prefetch" href="/java-tutorial/assets/js/53.e1cc5362.js"><link rel="prefetch" href="/java-tutorial/assets/js/54.fd9608e5.js"><link rel="prefetch" href="/java-tutorial/assets/js/55.632b6016.js"><link rel="prefetch" href="/java-tutorial/assets/js/56.e9aa4eea.js"><link rel="prefetch" href="/java-tutorial/assets/js/57.c0d1542e.js"><link rel="prefetch" href="/java-tutorial/assets/js/58.bc0f7c1c.js"><link rel="prefetch" href="/java-tutorial/assets/js/59.36b207a0.js"><link rel="prefetch" href="/java-tutorial/assets/js/6.d144eb92.js"><link rel="prefetch" href="/java-tutorial/assets/js/60.89446b88.js"><link rel="prefetch" href="/java-tutorial/assets/js/61.f110e04e.js"><link rel="prefetch" href="/java-tutorial/assets/js/62.62d349c4.js"><link rel="prefetch" href="/java-tutorial/assets/js/63.834fb95c.js"><link rel="prefetch" href="/java-tutorial/assets/js/64.e0fa19b4.js"><link rel="prefetch" href="/java-tutorial/assets/js/65.ff3773a7.js"><link rel="prefetch" href="/java-tutorial/assets/js/66.45b99ef4.js"><link rel="prefetch" href="/java-tutorial/assets/js/67.8ad9ddbe.js"><link rel="prefetch" href="/java-tutorial/assets/js/68.a0b09a76.js"><link rel="prefetch" href="/java-tutorial/assets/js/69.bc43b589.js"><link rel="prefetch" href="/java-tutorial/assets/js/7.f2dc074f.js"><link rel="prefetch" href="/java-tutorial/assets/js/70.38a10912.js"><link rel="prefetch" href="/java-tutorial/assets/js/71.fe10a220.js"><link rel="prefetch" href="/java-tutorial/assets/js/72.0c0ade29.js"><link rel="prefetch" href="/java-tutorial/assets/js/73.fbe5d03a.js"><link rel="prefetch" href="/java-tutorial/assets/js/74.f058f74c.js"><link rel="prefetch" href="/java-tutorial/assets/js/75.de33a550.js"><link rel="prefetch" href="/java-tutorial/assets/js/76.e3fbc3d6.js"><link rel="prefetch" href="/java-tutorial/assets/js/77.15bc7ae4.js"><link rel="prefetch" href="/java-tutorial/assets/js/78.c9176f76.js"><link rel="prefetch" href="/java-tutorial/assets/js/79.a8e94c89.js"><link rel="prefetch" href="/java-tutorial/assets/js/8.e2e9dd66.js"><link rel="prefetch" href="/java-tutorial/assets/js/80.88799756.js"><link rel="prefetch" href="/java-tutorial/assets/js/81.02a75d13.js"><link rel="prefetch" href="/java-tutorial/assets/js/82.26bfc230.js"><link rel="prefetch" href="/java-tutorial/assets/js/83.ef23783d.js"><link rel="prefetch" href="/java-tutorial/assets/js/84.7768ab87.js"><link rel="prefetch" href="/java-tutorial/assets/js/85.166bc923.js"><link rel="prefetch" href="/java-tutorial/assets/js/86.a0082b69.js"><link rel="prefetch" href="/java-tutorial/assets/js/87.f1a7edaf.js"><link rel="prefetch" href="/java-tutorial/assets/js/88.280451ae.js"><link rel="prefetch" href="/java-tutorial/assets/js/89.c22d4323.js"><link rel="prefetch" href="/java-tutorial/assets/js/9.9ce755cc.js"><link rel="prefetch" href="/java-tutorial/assets/js/90.c3ef04cb.js"><link rel="prefetch" href="/java-tutorial/assets/js/91.af01336c.js"><link rel="prefetch" href="/java-tutorial/assets/js/92.6459c6be.js"><link rel="prefetch" href="/java-tutorial/assets/js/93.366fa5d5.js"><link rel="prefetch" href="/java-tutorial/assets/js/94.29bb3af2.js"><link rel="prefetch" href="/java-tutorial/assets/js/95.c8acb7ef.js"><link rel="prefetch" href="/java-tutorial/assets/js/96.02c8387a.js"><link rel="prefetch" href="/java-tutorial/assets/js/97.f3fe9a9b.js"><link rel="prefetch" href="/java-tutorial/assets/js/98.0158ff39.js"><link rel="prefetch" href="/java-tutorial/assets/js/99.d9478ffd.js">
    <link rel="stylesheet" href="/java-tutorial/assets/css/0.styles.22aad9ca.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/java-tutorial/" class="home-link router-link-active"><img src="https://raw.githubusercontent.com/dunwu/images/master/common/dunwu-logo.png" alt="JAVA-TUTORIAL" class="logo"> <span class="site-name can-hide">JAVA-TUTORIAL</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/java-tutorial/" class="nav-link">首页</a></div><div class="nav-item"><a href="/java-tutorial/01.Java/02.JavaEE/" class="nav-link">JavaEE</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Java软件" class="dropdown-title"><a href="/java-tutorial/01.Java/11.软件/" class="link-title">Java软件</a> <span class="title" style="display:none;">Java软件</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/java-tutorial/01.Java/11.软件/01.构建/" class="nav-link">Java 构建</a></li><li class="dropdown-item"><!----> <a href="/java-tutorial/01.Java/11.软件/02.IDE/" class="nav-link">Java IDE</a></li><li class="dropdown-item"><!----> <a href="/java-tutorial/01.Java/11.软件/03.监控诊断/" class="nav-link">Java 监控诊断</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Java工具" class="dropdown-title"><a href="/java-tutorial/01.Java/12.工具/" class="link-title">Java工具</a> <span class="title" style="display:none;">Java工具</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/java-tutorial/01.Java/12.工具/01.IO/" class="nav-link">Java IO 工具</a></li><li class="dropdown-item"><!----> <a href="/java-tutorial/01.Java/12.工具/02.JavaBean/" class="nav-link">JavaBean 工具</a></li><li class="dropdown-item"><!----> <a href="/java-tutorial/01.Java/12.工具/03.模板引擎/" class="nav-link">Java 模板引擎</a></li><li class="dropdown-item"><!----> <a href="/java-tutorial/01.Java/12.工具/04.测试/" class="nav-link">Java 测试工具</a></li></ul></div></div><div class="nav-item"><a href="/java-tutorial/01.Java/13.框架/" class="nav-link">Java框架</a></div><div class="nav-item"><a href="/java-tutorial/01.Java/14.中间件/" class="nav-link">Java中间件</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Java" class="dropdown-title"><!----> <span class="title" style="display:;">✨ Java系列</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://dunwu.github.io/java-tutorial/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Java 教程 📚
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://dunwu.github.io/javacore/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  JavaCore 教程 📚
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <a href="https://github.com/dunwu/java-tutorial" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><!----> <nav class="nav-links"><div class="nav-item"><a href="/java-tutorial/" class="nav-link">首页</a></div><div class="nav-item"><a href="/java-tutorial/01.Java/02.JavaEE/" class="nav-link">JavaEE</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Java软件" class="dropdown-title"><a href="/java-tutorial/01.Java/11.软件/" class="link-title">Java软件</a> <span class="title" style="display:none;">Java软件</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/java-tutorial/01.Java/11.软件/01.构建/" class="nav-link">Java 构建</a></li><li class="dropdown-item"><!----> <a href="/java-tutorial/01.Java/11.软件/02.IDE/" class="nav-link">Java IDE</a></li><li class="dropdown-item"><!----> <a href="/java-tutorial/01.Java/11.软件/03.监控诊断/" class="nav-link">Java 监控诊断</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Java工具" class="dropdown-title"><a href="/java-tutorial/01.Java/12.工具/" class="link-title">Java工具</a> <span class="title" style="display:none;">Java工具</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/java-tutorial/01.Java/12.工具/01.IO/" class="nav-link">Java IO 工具</a></li><li class="dropdown-item"><!----> <a href="/java-tutorial/01.Java/12.工具/02.JavaBean/" class="nav-link">JavaBean 工具</a></li><li class="dropdown-item"><!----> <a href="/java-tutorial/01.Java/12.工具/03.模板引擎/" class="nav-link">Java 模板引擎</a></li><li class="dropdown-item"><!----> <a href="/java-tutorial/01.Java/12.工具/04.测试/" class="nav-link">Java 测试工具</a></li></ul></div></div><div class="nav-item"><a href="/java-tutorial/01.Java/13.框架/" class="nav-link">Java框架</a></div><div class="nav-item"><a href="/java-tutorial/01.Java/14.中间件/" class="nav-link">Java中间件</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Java" class="dropdown-title"><!----> <span class="title" style="display:;">✨ Java系列</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://dunwu.github.io/java-tutorial/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Java 教程 📚
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://dunwu.github.io/javacore/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  JavaCore 教程 📚
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <a href="https://github.com/dunwu/java-tutorial" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>JavaEE</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>JavaWeb</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading open"><span>服务器</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group collapsable is-sub-group depth-2"><p class="sidebar-heading open"><span>Tomcat</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/java-tutorial/pages/4a4c02/" class="sidebar-link">Tomcat 快速入门</a></li><li><a href="/java-tutorial/pages/13f070/" class="sidebar-link">Tomcat连接器</a></li><li><a href="/java-tutorial/pages/d5076a/" aria-current="page" class="active sidebar-link">Tomcat容器</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/java-tutorial/pages/d5076a/#tomcat-实现热部署和热加载" class="sidebar-link">Tomcat 实现热部署和热加载</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/java-tutorial/pages/d5076a/#containerbackgroundprocessor-实现" class="sidebar-link">ContainerBackgroundProcessor 实现</a></li><li class="sidebar-sub-header level3"><a href="/java-tutorial/pages/d5076a/#backgroundprocess-方法" class="sidebar-link">backgroundProcess 方法</a></li><li class="sidebar-sub-header level3"><a href="/java-tutorial/pages/d5076a/#tomcat-热加载" class="sidebar-link">Tomcat 热加载</a></li><li class="sidebar-sub-header level3"><a href="/java-tutorial/pages/d5076a/#tomcat-热部署" class="sidebar-link">Tomcat 热部署</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/java-tutorial/pages/d5076a/#tomcat-的类加载机制" class="sidebar-link">Tomcat 的类加载机制</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/java-tutorial/pages/d5076a/#findclass-方法" class="sidebar-link">findClass 方法</a></li><li class="sidebar-sub-header level3"><a href="/java-tutorial/pages/d5076a/#loadclass-方法" class="sidebar-link">loadClass 方法</a></li><li class="sidebar-sub-header level3"><a href="/java-tutorial/pages/d5076a/#tomcat-实现应用隔离" class="sidebar-link">Tomcat 实现应用隔离</a></li><li class="sidebar-sub-header level4"><a href="/java-tutorial/pages/d5076a/#webappclassloader" class="sidebar-link">WebAppClassLoader</a></li><li class="sidebar-sub-header level4"><a href="/java-tutorial/pages/d5076a/#sharedclassloader" class="sidebar-link">SharedClassLoader</a></li><li class="sidebar-sub-header level4"><a href="/java-tutorial/pages/d5076a/#catalinaclassloader" class="sidebar-link">CatalinaClassloader</a></li><li class="sidebar-sub-header level4"><a href="/java-tutorial/pages/d5076a/#commonclassloader" class="sidebar-link">CommonClassLoader</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/java-tutorial/pages/d5076a/#tomcat-实现-servlet-规范" class="sidebar-link">Tomcat 实现 Servlet 规范</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/java-tutorial/pages/d5076a/#servlet-管理" class="sidebar-link">Servlet 管理</a></li><li class="sidebar-sub-header level3"><a href="/java-tutorial/pages/d5076a/#filter-管理" class="sidebar-link">Filter 管理</a></li><li class="sidebar-sub-header level3"><a href="/java-tutorial/pages/d5076a/#listener-管理" class="sidebar-link">Listener 管理</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/java-tutorial/pages/d5076a/#tomcat-支持异步-servlet" class="sidebar-link">Tomcat 支持异步 Servlet</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/java-tutorial/pages/d5076a/#异步示例" class="sidebar-link">异步示例</a></li><li class="sidebar-sub-header level3"><a href="/java-tutorial/pages/d5076a/#异步-servlet-原理" class="sidebar-link">异步 Servlet 原理</a></li><li class="sidebar-sub-header level4"><a href="/java-tutorial/pages/d5076a/#startasync-方法" class="sidebar-link">startAsync 方法</a></li><li class="sidebar-sub-header level4"><a href="/java-tutorial/pages/d5076a/#complete-方法" class="sidebar-link">complete 方法</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/java-tutorial/pages/d5076a/#参考资料" class="sidebar-link">参考资料</a></li></ul></li><li><a href="/java-tutorial/pages/f9e1e6/" class="sidebar-link">Tomcat优化</a></li><li><a href="/java-tutorial/pages/f37326/" class="sidebar-link">Tomcat 和 Jetty</a></li></ul></section></li><li><a href="/java-tutorial/pages/ec364e/" class="sidebar-link">Jetty 快速入门</a></li></ul></section></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>软件</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>工具</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>框架</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>中间件</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06225672><div class="articleInfo" data-v-06225672><ul class="breadcrumbs" data-v-06225672><li data-v-06225672><a href="/java-tutorial/" title="首页" class="iconfont icon-home router-link-active" data-v-06225672></a></li> <li data-v-06225672><a href="/java-tutorial/categories/?category=Java" title="分类" data-v-06225672>Java</a></li><li data-v-06225672><a href="/java-tutorial/categories/?category=JavaEE" title="分类" data-v-06225672>JavaEE</a></li><li data-v-06225672><a href="/java-tutorial/categories/?category=%E6%9C%8D%E5%8A%A1%E5%99%A8" title="分类" data-v-06225672>服务器</a></li><li data-v-06225672><a href="/java-tutorial/categories/?category=Tomcat" title="分类" data-v-06225672>Tomcat</a></li></ul> <div class="info" data-v-06225672><div title="作者" class="author iconfont icon-touxiang" data-v-06225672><a href="https://github.com/dunwu" target="_blank" title="作者" class="beLink" data-v-06225672>dunwu</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06225672><a href="javascript:;" data-v-06225672>2022-02-17</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABH1JREFUSA3tVl1oHFUUPmdmd2ltklqbpJDiNnXFmgbFktho7YMPNiJSSZM0+CAYSkUELVhM6YuwIPpgoOKDqOBDC0XE2CQoNtQXBUFTTcCi+Wlh1V2TQExsUzcltd3M9Tt3ZjZzZ2fT+OJTL8yeM+eee757fmeJbq//KQL8X3DUSFOcfr7cRsRtxNQMWueeVzOkaITIGqQHNg5y8+jNW9ldM7A6nTpAjuolUikAwq7CE3WcM2RRDz+XGVgN3FptU/aUSlvq9Pa3iZ1+sgAqJyyAFqkipd9dqiwHF3P65YycLWc/6sqGrvoEoIp6DOFaX5h6+dnfjkWprwqsPk0dUGq5vySwDImC10KxFHgGL1SWoc92O3eVht09qdXNH11I2SsTsJYqMWzihqGMi+A+Garf3BAuuLI5oGlULyNfyB/HYNujwktOfRrMr5t77NmevqaUopx0grnKAyvVpmwUDB4x6FPXuGvYLTDwWsejwgtgkYKPqRJg8SV6xaiZ3ZTppGneS4yfH5/66fZSDHv+QZci/+h5c5UHtpy67JUqGppM0sh0Nc1dW6/N1W5Yoqat8/TU/VnadmdeW2PLLSyh0cvxBs3KbqTmwYPpxN4do/mzE8nEpvX/UMu2Wbp74zUAK5q6WkHns7V0eWkdPbPzd3rxkTGybadYySumVzhcaJFbs5UrEkQ/+CK8gF5dnh/6ciIZ73gwQ927L1IitoxKLXYP3SjYdOrHHfTZhRRlFyrorafPk20B3HPD1y2G3qKZME5Jcf3t/HUC13/8tSd++vqFveMUTwAUxSUFI1QekR1+bIze3D9MF2aq6cPvG72CgnldWCFqyRw3lwH8ZMerjTD9ElRO7Gv44wNpC90aASqGfVlz/Rx17srQ57/UU26hkhQqUB7dBR71WmzQhHUnblGmVOEw0jhbV1n9OlXUDCIRGaNV5Jp43N516fN7JmnTHdfp7Hgy0luO4aMhtkLL8Bi3bUWYvzh5Mn1dTxrL6QmGuRhGL/TiTTxRoEdTszSaq9GR0NGA3KdkOz3hqSV3MIDhQ5IVX/Ivx3umBti2es2h4eZby7x8br1rkf7Mo90AqC8aQ3sJeNzqFRu+vSANAQe3PL7l0HGOAdwDCeZYvNKeoZp1Qfs6Aipndh86HmFRi0LAnEO47wsqM6cdfjh3jBPUzhZy7nvlUfFsamED1VQt6aISHVymXZ/B2aCtIG8AI8xfobj2d3en1wWVhOeHELKmLQ1s211s88comkv4UCwWyF787mJdYXtNfhKAXVqnKTq8QZvGAGGOfaTo5pGZ/PwbUCr5+DPr/1J92JNHr9aOl/F3iI5+O1nfybsGxoimvZ3ViWSluDITw3P37mypheDIPY0tw7+O/5ApbkYw+zpfaUVu32Pi98+defdUhEpZkRFq0aqyNh9FuL9hpYbEm6iwi0z2REd09ZmyENEbuhjDWzKvZXTqKYaBIr3tt5kuPtQBZFvEUwHt60vfCNu41XsksH9Ij1BMMz1Y0OOunHNShFIP5868g5zeXmuLwL9T4b6Q2+KejgAAAABJRU5ErkJggg==">Tomcat容器<!----></h1>  <div class="theme-vdoing-content content__default"><h1 id="tomcat-容器"><a href="#tomcat-容器" class="header-anchor">#</a> Tomcat 容器</h1> <h2 id="tomcat-实现热部署和热加载"><a href="#tomcat-实现热部署和热加载" class="header-anchor">#</a> Tomcat 实现热部署和热加载</h2> <ul><li>热加载的实现方式是 Web 容器启动一个后台线程，定期检测类文件的变化，如果有变化，就重新加载类，在这个过程中不会清空 Session ，一般用在开发环境。</li> <li>热部署原理类似，也是由后台线程定时检测 Web 应用的变化，但它会重新加载整个 Web 应用。这种方式会清空 Session，比热加载更加干净、彻底，一般用在生产环境。</li></ul> <p>Tomcat 通过开启后台线程，使得各个层次的容器组件都有机会完成一些周期性任务。Tomcat 是基于 ScheduledThreadPoolExecutor 实现周期性任务的：</p> <div class="language-java extra-class"><pre class="language-java"><code>bgFuture <span class="token operator">=</span> exec<span class="token punctuation">.</span><span class="token function">scheduleWithFixedDelay</span><span class="token punctuation">(</span>
              <span class="token keyword">new</span> <span class="token class-name">ContainerBackgroundProcessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token comment">// 要执行的 Runnable</span>
              backgroundProcessorDelay<span class="token punctuation">,</span> <span class="token comment">// 第一次执行延迟多久</span>
              backgroundProcessorDelay<span class="token punctuation">,</span> <span class="token comment">// 之后每次执行间隔多久</span>
              <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 时间单位</span>
</code></pre></div><p>第一个参数就是要周期性执行的任务类 ContainerBackgroundProcessor，它是一个 Runnable，同时也是 ContainerBase 的内部类，ContainerBase 是所有容器组件的基类，我们来回忆一下容器组件有哪些，有 Engine、Host、Context 和 Wrapper 等，它们具有父子关系。</p> <h3 id="containerbackgroundprocessor-实现"><a href="#containerbackgroundprocessor-实现" class="header-anchor">#</a> ContainerBackgroundProcessor 实现</h3> <p>我们接来看 ContainerBackgroundProcessor 具体是如何实现的。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">protected</span> <span class="token keyword">class</span> <span class="token class-name">ContainerBackgroundProcessor</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 请注意这里传入的参数是 &quot; 宿主类 &quot; 的实例</span>
        <span class="token function">processChildren</span><span class="token punctuation">(</span><span class="token class-name">ContainerBase</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">processChildren</span><span class="token punctuation">(</span><span class="token class-name">Container</span> container<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token comment">//1. 调用当前容器的 backgroundProcess 方法。</span>
            container<span class="token punctuation">.</span><span class="token function">backgroundProcess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token comment">//2. 遍历所有的子容器，递归调用 processChildren，</span>
            <span class="token comment">// 这样当前容器的子孙都会被处理</span>
            <span class="token class-name">Container</span><span class="token punctuation">[</span><span class="token punctuation">]</span> children <span class="token operator">=</span> container<span class="token punctuation">.</span><span class="token function">findChildren</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> children<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 这里请你注意，容器基类有个变量叫做 backgroundProcessorDelay，如果大于 0，表明子容器有自己的后台线程，无需父容器来调用它的 processChildren 方法。</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>children<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">getBackgroundProcessorDelay</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token function">processChildren</span><span class="token punctuation">(</span>children<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
</code></pre></div><p>上面的代码逻辑也是比较清晰的，首先 ContainerBackgroundProcessor 是一个 Runnable，它需要实现 run 方法，它的 run 很简单，就是调用了 processChildren 方法。这里有个小技巧，它把“宿主类”，也就是<strong>ContainerBase 的类实例当成参数传给了 run 方法</strong>。</p> <p>而在 processChildren 方法里，就做了两步：调用当前容器的 backgroundProcess 方法，以及递归调用子孙的 backgroundProcess 方法。请你注意 backgroundProcess 是 Container 接口中的方法，也就是说所有类型的容器都可以实现这个方法，在这个方法里完成需要周期性执行的任务。</p> <p>这样的设计意味着什么呢？我们只需要在顶层容器，也就是 Engine 容器中启动一个后台线程，那么这个线程<strong>不但会执行 Engine 容器的周期性任务，它还会执行所有子容器的周期性任务</strong>。</p> <h3 id="backgroundprocess-方法"><a href="#backgroundprocess-方法" class="header-anchor">#</a> backgroundProcess 方法</h3> <p>上述代码都是在基类 ContainerBase 中实现的，那具体容器类需要做什么呢？其实很简单，如果有周期性任务要执行，就实现 backgroundProcess 方法；如果没有，就重用基类 ContainerBase 的方法。ContainerBase 的 backgroundProcess 方法实现如下：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">backgroundProcess</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token comment">//1. 执行容器中 Cluster 组件的周期性任务</span>
    <span class="token class-name">Cluster</span> cluster <span class="token operator">=</span> <span class="token function">getClusterInternal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>cluster <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cluster<span class="token punctuation">.</span><span class="token function">backgroundProcess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">//2. 执行容器中 Realm 组件的周期性任务</span>
    <span class="token class-name">Realm</span> realm <span class="token operator">=</span> <span class="token function">getRealmInternal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>realm <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        realm<span class="token punctuation">.</span><span class="token function">backgroundProcess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>

   <span class="token comment">//3. 执行容器中 Valve 组件的周期性任务</span>
    <span class="token class-name">Valve</span> current <span class="token operator">=</span> pipeline<span class="token punctuation">.</span><span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>current <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       current<span class="token punctuation">.</span><span class="token function">backgroundProcess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       current <span class="token operator">=</span> current<span class="token punctuation">.</span><span class="token function">getNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">//4. 触发容器的 &quot; 周期事件 &quot;，Host 容器的监听器 HostConfig 就靠它来调用</span>
    <span class="token function">fireLifecycleEvent</span><span class="token punctuation">(</span><span class="token class-name">Lifecycle</span><span class="token punctuation">.</span><span class="token constant">PERIODIC_EVENT</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>从上面的代码可以看到，不仅每个容器可以有周期性任务，每个容器中的其他通用组件，比如跟集群管理有关的 Cluster 组件、跟安全管理有关的 Realm 组件都可以有自己的周期性任务。</p> <p>我在前面的专栏里提到过，容器之间的链式调用是通过 Pipeline-Valve 机制来实现的，从上面的代码你可以看到容器中的 Valve 也可以有周期性任务，并且被 ContainerBase 统一处理。</p> <p>请你特别注意的是，在 backgroundProcess 方法的最后，还触发了容器的“周期事件”。我们知道容器的生命周期事件有初始化、启动和停止等，那“周期事件”又是什么呢？它跟生命周期事件一样，是一种扩展机制，你可以这样理解：</p> <p>又一段时间过去了，容器还活着，你想做点什么吗？如果你想做点什么，就创建一个监听器来监听这个“周期事件”，事件到了我负责调用你的方法。</p> <p>总之，有了 ContainerBase 中的后台线程和 backgroundProcess 方法，各种子容器和通用组件不需要各自弄一个后台线程来处理周期性任务，这样的设计显得优雅和整洁。</p> <h3 id="tomcat-热加载"><a href="#tomcat-热加载" class="header-anchor">#</a> Tomcat 热加载</h3> <p>有了 ContainerBase 的周期性任务处理“框架”，作为具体容器子类，只需要实现自己的周期性任务就行。而 Tomcat 的热加载，就是在 Context 容器中实现的。Context 容器的 backgroundProcess 方法是这样实现的：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">backgroundProcess</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token comment">//WebappLoader 周期性的检查 WEB-INF/classes 和 WEB-INF/lib 目录下的类文件</span>
    <span class="token class-name">Loader</span> loader <span class="token operator">=</span> <span class="token function">getLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>loader <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        loader<span class="token punctuation">.</span><span class="token function">backgroundProcess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">//Session 管理器周期性的检查是否有过期的 Session</span>
    <span class="token class-name">Manager</span> manager <span class="token operator">=</span> <span class="token function">getManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>manager <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        manager<span class="token punctuation">.</span><span class="token function">backgroundProcess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 周期性的检查静态资源是否有变化</span>
    <span class="token class-name">WebResourceRoot</span> resources <span class="token operator">=</span> <span class="token function">getResources</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>resources <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        resources<span class="token punctuation">.</span><span class="token function">backgroundProcess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 调用父类 ContainerBase 的 backgroundProcess 方法</span>
    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">backgroundProcess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>从上面的代码我们看到 Context 容器通过 WebappLoader 来检查类文件是否有更新，通过 Session 管理器来检查是否有 Session 过期，并且通过资源管理器来检查静态资源是否有更新，最后还调用了父类 ContainerBase 的 backgroundProcess 方法。</p> <p>这里我们要重点关注，WebappLoader 是如何实现热加载的，它主要是调用了 Context 容器的 reload 方法，而 Context 的 reload 方法比较复杂，总结起来，主要完成了下面这些任务：</p> <ol><li>停止和销毁 Context 容器及其所有子容器，子容器其实就是 Wrapper，也就是说 Wrapper 里面 Servlet 实例也被销毁了。</li> <li>停止和销毁 Context 容器关联的 Listener 和 Filter。</li> <li>停止和销毁 Context 下的 Pipeline 和各种 Valve。</li> <li>停止和销毁 Context 的类加载器，以及类加载器加载的类文件资源。</li> <li>启动 Context 容器，在这个过程中会重新创建前面四步被销毁的资源。</li></ol> <p>在这个过程中，类加载器发挥着关键作用。一个 Context 容器对应一个类加载器，类加载器在销毁的过程中会把它加载的所有类也全部销毁。Context 容器在启动过程中，会创建一个新的类加载器来加载新的类文件。</p> <p>在 Context 的 reload 方法里，并没有调用 Session 管理器的 distroy 方法，也就是说这个 Context 关联的 Session 是没有销毁的。你还需要注意的是，Tomcat 的热加载默认是关闭的，你需要在 conf 目录下的 Context.xml 文件中设置 reloadable 参数来开启这个功能，像下面这样：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;Context reloadable=&quot;true&quot;/&gt;
</code></pre></div><h3 id="tomcat-热部署"><a href="#tomcat-热部署" class="header-anchor">#</a> Tomcat 热部署</h3> <p>我们再来看看热部署，热部署跟热加载的本质区别是，热部署会重新部署 Web 应用，原来的 Context 对象会整个被销毁掉，因此这个 Context 所关联的一切资源都会被销毁，包括 Session。</p> <p>那么 Tomcat 热部署又是由哪个容器来实现的呢？应该不是由 Context，因为热部署过程中 Context 容器被销毁了，那么这个重担就落在 Host 身上了，因为它是 Context 的父容器。</p> <p>跟 Context 不一样，Host 容器并没有在 backgroundProcess 方法中实现周期性检测的任务，而是通过监听器 HostConfig 来实现的，HostConfig 就是前面提到的“周期事件”的监听器，那“周期事件”达到时，HostConfig 会做什么事呢？</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lifecycleEvent</span><span class="token punctuation">(</span><span class="token class-name">LifecycleEvent</span> event<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 执行 check 方法。</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>event<span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Lifecycle</span><span class="token punctuation">.</span><span class="token constant">PERIODIC_EVENT</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">check</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>它执行了 check 方法，我们接着来看 check 方法里做了什么。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">check</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>host<span class="token punctuation">.</span><span class="token function">getAutoDeploy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 检查这个 Host 下所有已经部署的 Web 应用</span>
        <span class="token class-name">DeployedApplication</span><span class="token punctuation">[</span><span class="token punctuation">]</span> apps <span class="token operator">=</span>
            deployed<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">DeployedApplication</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> apps<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 检查 Web 应用目录是否有变化</span>
            <span class="token function">checkResources</span><span class="token punctuation">(</span>apps<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 执行部署</span>
        <span class="token function">deployApps</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>其实 HostConfig 会检查 webapps 目录下的所有 Web 应用：</p> <ul><li>如果原来 Web 应用目录被删掉了，就把相应 Context 容器整个销毁掉。</li> <li>是否有新的 Web 应用目录放进来了，或者有新的 WAR 包放进来了，就部署相应的 Web 应用。</li></ul> <p>因此 HostConfig 做的事情都是比较“宏观”的，它不会去检查具体类文件或者资源文件是否有变化，而是检查 Web 应用目录级别的变化。</p> <h2 id="tomcat-的类加载机制"><a href="#tomcat-的类加载机制" class="header-anchor">#</a> Tomcat 的类加载机制</h2> <p>Tomcat 的自定义类加载器 <code>WebAppClassLoader</code> 打破了双亲委派机制，它<strong>首先自己尝试去加载某个类，如果找不到再代理给父类加载器</strong>，其目的是优先加载 Web 应用自己定义的类。具体实现就是重写 ClassLoader 的两个方法：findClass 和 loadClass。</p> <h3 id="findclass-方法"><a href="#findclass-方法" class="header-anchor">#</a> findClass 方法</h3> <p>我们先来看看 findClass 方法的实现，为了方便理解和阅读，我去掉了一些细节：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">findClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

    <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> clazz <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token comment">//1. 先在 Web 应用目录下查找类</span>
            clazz <span class="token operator">=</span> <span class="token function">findClassInternal</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>  <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">RuntimeException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token keyword">throw</span> e<span class="token punctuation">;</span>
       <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>clazz <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token comment">//2. 如果在本地目录没有找到，交给父加载器去查找</span>
            clazz <span class="token operator">=</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">findClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>  <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">RuntimeException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token keyword">throw</span> e<span class="token punctuation">;</span>
       <span class="token punctuation">}</span>

    <span class="token comment">//3. 如果父类也没找到，抛出 ClassNotFoundException</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>clazz <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ClassNotFoundException</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>

    <span class="token keyword">return</span> clazz<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在 findClass 方法里，主要有三个步骤：</p> <ol><li>先在 Web 应用本地目录下查找要加载的类。</li> <li>如果没有找到，交给父加载器去查找，它的父加载器就是上面提到的系统类加载器 AppClassLoader。</li> <li>如何父加载器也没找到这个类，抛出 ClassNotFound 异常。</li></ol> <h3 id="loadclass-方法"><a href="#loadclass-方法" class="header-anchor">#</a> loadClass 方法</h3> <p>接着我们再来看 Tomcat 类加载器的 loadClass 方法的实现，同样我也去掉了一些细节：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">boolean</span> resolve<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span> <span class="token punctuation">{</span>

    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token function">getClassLoadingLock</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

        <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> clazz <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

        <span class="token comment">//1. 先在本地 cache 查找该类是否已经加载过</span>
        clazz <span class="token operator">=</span> <span class="token function">findLoadedClass0</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>clazz <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">)</span>
                <span class="token function">resolveClass</span><span class="token punctuation">(</span>clazz<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> clazz<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">//2. 从系统类加载器的 cache 中查找是否加载过</span>
        clazz <span class="token operator">=</span> <span class="token function">findLoadedClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>clazz <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">)</span>
                <span class="token function">resolveClass</span><span class="token punctuation">(</span>clazz<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> clazz<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 3. 尝试用 ExtClassLoader 类加载器类加载，为什么？</span>
        <span class="token class-name">ClassLoader</span> javaseLoader <span class="token operator">=</span> <span class="token function">getJavaseClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            clazz <span class="token operator">=</span> javaseLoader<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>clazz <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">)</span>
                    <span class="token function">resolveClass</span><span class="token punctuation">(</span>clazz<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> clazz<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// Ignore</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 4. 尝试在本地目录搜索 class 并加载</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            clazz <span class="token operator">=</span> <span class="token function">findClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>clazz <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">)</span>
                    <span class="token function">resolveClass</span><span class="token punctuation">(</span>clazz<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> clazz<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// Ignore</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 5. 尝试用系统类加载器 (也就是 AppClassLoader) 来加载</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                clazz <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>clazz <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">)</span>
                        <span class="token function">resolveClass</span><span class="token punctuation">(</span>clazz<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">return</span> clazz<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// Ignore</span>
            <span class="token punctuation">}</span>
       <span class="token punctuation">}</span>

    <span class="token comment">//6. 上述过程都加载失败，抛出异常</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ClassNotFoundException</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>loadClass 方法稍微复杂一点，主要有六个步骤：</p> <ol><li>先在本地 Cache 查找该类是否已经加载过，也就是说 Tomcat 的类加载器是否已经加载过这个类。</li> <li>如果 Tomcat 类加载器没有加载过这个类，再看看系统类加载器是否加载过。</li> <li>如果都没有，就让<strong>ExtClassLoader</strong>去加载，这一步比较关键，目的<strong>防止 Web 应用自己的类覆盖 JRE 的核心类</strong>。因为 Tomcat 需要打破双亲委派机制，假如 Web 应用里自定义了一个叫 Object 的类，如果先加载这个 Object 类，就会覆盖 JRE 里面的那个 Object 类，这就是为什么 Tomcat 的类加载器会优先尝试用 ExtClassLoader 去加载，因为 ExtClassLoader 会委托给 BootstrapClassLoader 去加载，BootstrapClassLoader 发现自己已经加载了 Object 类，直接返回给 Tomcat 的类加载器，这样 Tomcat 的类加载器就不会去加载 Web 应用下的 Object 类了，也就避免了覆盖 JRE 核心类的问题。</li> <li>如果 ExtClassLoader 加载器加载失败，也就是说 JRE 核心类中没有这类，那么就在本地 Web 应用目录下查找并加载。</li> <li>如果本地目录下没有这个类，说明不是 Web 应用自己定义的类，那么由系统类加载器去加载。这里请你注意，Web 应用是通过<code>Class.forName</code>调用交给系统类加载器的，因为<code>Class.forName</code>的默认加载器就是系统类加载器。</li> <li>如果上述加载过程全部失败，抛出 ClassNotFound 异常。</li></ol> <p>从上面的过程我们可以看到，Tomcat 的类加载器打破了双亲委派机制，没有一上来就直接委托给父加载器，而是先在本地目录下加载，为了避免本地目录下的类覆盖 JRE 的核心类，先尝试用 JVM 扩展类加载器 ExtClassLoader 去加载。那为什么不先用系统类加载器 AppClassLoader 去加载？很显然，如果是这样的话，那就变成双亲委派机制了，这就是 Tomcat 类加载器的巧妙之处。</p> <h3 id="tomcat-实现应用隔离"><a href="#tomcat-实现应用隔离" class="header-anchor">#</a> Tomcat 实现应用隔离</h3> <p>Tomcat 作为 Web 容器，需要解决以下问题：</p> <ol><li>如果在 Tomcat 中运行了两个 Web 应用程序，两个 Web 应用中有同名的 Servlet，但是功能不同，Tomcat 需要同时加载和管理这两个同名的 Servlet 类，保证它们不会冲突，因此 Web 应用之间的类需要隔离。</li> <li>两个 Web 应用都依赖同一个第三方的 JAR 包，比如 Spring，那 Spring 的 JAR 包被加载到内存后，Tomcat 要保证这两个 Web 应用能够共享，也就是说 Spring 的 JAR 包只被加载一次，否则随着依赖的第三方 JAR 包增多，JVM 的内存会膨胀。</li> <li>需要隔离 Tomcat 本身的类和 Web 应用的类。</li></ol> <p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20201130141536.png" alt="img"></p> <h4 id="webappclassloader"><a href="#webappclassloader" class="header-anchor">#</a> WebAppClassLoader</h4> <p>针对第一个问题：</p> <p>如果使用 JVM 默认 AppClassLoader 来加载 Web 应用，AppClassLoader 只能加载一个 Servlet 类，在加载第二个同名 Servlet 类时，AppClassLoader 会返回第一个 Servlet 类的 Class 实例，这是因为在 AppClassLoader 看来，同名的 Servlet 类只被加载一次。</p> <p>Tomcat 的解决方案是自定义一个类加载器 WebAppClassLoader， 并且给每个 Web 应用创建一个类加载器实例。我们知道，Context 容器组件对应一个 Web 应用，因此，每个 Context 容器负责创建和维护一个 WebAppClassLoader 加载器实例。这背后的原理是，<strong>不同的加载器实例加载的类被认为是不同的类</strong>，即使它们的类名相同。这就相当于在 Java 虚拟机内部创建了一个个相互隔离的 Java 类空间，每一个 Web 应用都有自己的类空间，Web 应用之间通过各自的类加载器互相隔离。</p> <h4 id="sharedclassloader"><a href="#sharedclassloader" class="header-anchor">#</a> SharedClassLoader</h4> <p>针对第二个问题：</p> <p>本质需求是两个 Web 应用之间怎么共享库类，并且不能重复加载相同的类。我们知道，在双亲委派机制里，各个子加载器都可以通过父加载器去加载类，那么把需要共享的类放到父加载器的加载路径下不就行了吗，应用程序也正是通过这种方式共享 JRE 的核心类。因此 Tomcat 的设计者又加了一个类加载器 SharedClassLoader，作为 WebAppClassLoader 的父加载器，专门来加载 Web 应用之间共享的类。如果 WebAppClassLoader 自己没有加载到某个类，就会委托父加载器 SharedClassLoader 去加载这个类，SharedClassLoader 会在指定目录下加载共享类，之后返回给 WebAppClassLoader，这样共享的问题就解决了。</p> <h4 id="catalinaclassloader"><a href="#catalinaclassloader" class="header-anchor">#</a> CatalinaClassloader</h4> <p>如何隔离 Tomcat 本身的类和 Web 应用的类？</p> <p>要共享可以通过父子关系，要隔离那就需要兄弟关系了。兄弟关系就是指两个类加载器是平行的，它们可能拥有同一个父加载器，但是两个兄弟类加载器加载的类是隔离的。基于此 Tomcat 又设计一个类加载器 CatalinaClassloader，专门来加载 Tomcat 自身的类。这样设计有个问题，那 Tomcat 和各 Web 应用之间需要共享一些类时该怎么办呢？</p> <h4 id="commonclassloader"><a href="#commonclassloader" class="header-anchor">#</a> CommonClassLoader</h4> <p>老办法，还是再增加一个 CommonClassLoader，作为 CatalinaClassloader 和 SharedClassLoader 的父加载器。CommonClassLoader 能加载的类都可以被 CatalinaClassLoader 和 SharedClassLoader 使用，而 CatalinaClassLoader 和 SharedClassLoader 能加载的类则与对方相互隔离。WebAppClassLoader 可以使用 SharedClassLoader 加载到的类，但各个 WebAppClassLoader 实例之间相互隔离。</p> <h2 id="tomcat-实现-servlet-规范"><a href="#tomcat-实现-servlet-规范" class="header-anchor">#</a> Tomcat 实现 Servlet 规范</h2> <p>Servlet 容器最重要的任务就是创建 Servlet 的实例并且调用 Servlet。</p> <p>一个 Web 应用里往往有多个 Servlet，而在 Tomcat 中一个 Web 应用对应一个 Context 容器，也就是说一个 Context 容器需要管理多个 Servlet 实例。但 Context 容器并不直接持有 Servlet 实例，而是通过子容器 Wrapper 来管理 Servlet，你可以把 Wrapper 容器看作是 Servlet 的包装。</p> <p>为什么需要 Wrapper 呢？Context 容器直接维护一个 Servlet 数组不就行了吗？这是因为 Servlet 不仅仅是一个类实例，它还有相关的配置信息，比如它的 URL 映射、它的初始化参数，因此设计出了一个包装器，把 Servlet 本身和它相关的数据包起来，没错，这就是面向对象的思想。</p> <p>除此以外，Servlet 规范中还有两个重要特性：Listener 和 Filter，Tomcat 也需要创建它们的实例，并在合适的时机去调用它们的方法。</p> <h3 id="servlet-管理"><a href="#servlet-管理" class="header-anchor">#</a> Servlet 管理</h3> <p>Tomcat 是用 Wrapper 容器来管理 Servlet 的，那 Wrapper 容器具体长什么样子呢？我们先来看看它里面有哪些关键的成员变量：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">protected</span> <span class="token keyword">volatile</span> <span class="token class-name">Servlet</span> instance <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
</code></pre></div><p>它拥有一个 Servlet 实例，并且 Wrapper 通过 loadServlet 方法来实例化 Servlet。为了方便你阅读，我简化了代码：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token class-name">Servlet</span> <span class="token function">loadServlet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ServletException</span> <span class="token punctuation">{</span>
    <span class="token class-name">Servlet</span> servlet<span class="token punctuation">;</span>

    <span class="token comment">//1. 创建一个 Servlet 实例</span>
    servlet <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Servlet</span><span class="token punctuation">)</span> instanceManager<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span>servletClass<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">//2. 调用了 Servlet 的 init 方法，这是 Servlet 规范要求的</span>
    <span class="token function">initServlet</span><span class="token punctuation">(</span>servlet<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> servlet<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>其实 loadServlet 主要做了两件事：创建 Servlet 的实例，并且调用 Servlet 的 init 方法，因为这是 Servlet 规范要求的。</p> <p>那接下来的问题是，什么时候会调到这个 loadServlet 方法呢？为了加快系统的启动速度，我们往往会采取资源延迟加载的策略，Tomcat 也不例外，默认情况下 Tomcat 在启动时不会加载你的 Servlet，除非你把 Servlet 的<code>loadOnStartup</code>参数设置为<code>true</code>。</p> <p>这里还需要你注意的是，虽然 Tomcat 在启动时不会创建 Servlet 实例，但是会创建 Wrapper 容器，就好比尽管枪里面还没有子弹，先把枪造出来。那子弹什么时候造呢？是真正需要开枪的时候，也就是说有请求来访问某个 Servlet 时，这个 Servlet 的实例才会被创建。</p> <p>那 Servlet 是被谁调用的呢？我们回忆一下专栏前面提到过 Tomcat 的 Pipeline-Valve 机制，每个容器组件都有自己的 Pipeline，每个 Pipeline 中有一个 Valve 链，并且每个容器组件有一个 BasicValve（基础阀）。Wrapper 作为一个容器组件，它也有自己的 Pipeline 和 BasicValve，Wrapper 的 BasicValve 叫 <strong>StandardWrapperValve</strong>。</p> <p>你可以想到，当请求到来时，Context 容器的 BasicValve 会调用 Wrapper 容器中 Pipeline 中的第一个 Valve，然后会调用到 StandardWrapperValve。我们先来看看它的 invoke 方法是如何实现的，同样为了方便你阅读，我简化了代码：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">Request</span> request<span class="token punctuation">,</span> <span class="token class-name">Response</span> response<span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token comment">//1. 实例化 Servlet</span>
    servlet <span class="token operator">=</span> wrapper<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">//2. 给当前请求创建一个 Filter 链</span>
    <span class="token class-name">ApplicationFilterChain</span> filterChain <span class="token operator">=</span>
        <span class="token class-name">ApplicationFilterFactory</span><span class="token punctuation">.</span><span class="token function">createFilterChain</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> wrapper<span class="token punctuation">,</span> servlet<span class="token punctuation">)</span><span class="token punctuation">;</span>

   <span class="token comment">//3. 调用这个 Filter 链，Filter 链中的最后一个 Filter 会调用 Servlet</span>
   filterChain<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span><span class="token function">getRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> response<span class="token punctuation">.</span><span class="token function">getResponse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>
</code></pre></div><p>StandardWrapperValve 的 invoke 方法比较复杂，去掉其他异常处理的一些细节，本质上就是三步：</p> <ul><li>第一步，创建 Servlet 实例；</li> <li>第二步，给当前请求创建一个 Filter 链；</li> <li>第三步，调用这个 Filter 链。</li></ul> <p>你可能会问，为什么需要给每个请求创建一个 Filter 链？这是因为每个请求的请求路径都不一样，而 Filter 都有相应的路径映射，因此不是所有的 Filter 都需要来处理当前的请求，我们需要根据请求的路径来选择特定的一些 Filter 来处理。</p> <p>第二个问题是，为什么没有看到调到 Servlet 的 service 方法？这是因为 Filter 链的 doFilter 方法会负责调用 Servlet，具体来说就是 Filter 链中的最后一个 Filter 会负责调用 Servlet。</p> <p>接下来我们来看 Filter 的实现原理。</p> <h3 id="filter-管理"><a href="#filter-管理" class="header-anchor">#</a> Filter 管理</h3> <p>我们知道，跟 Servlet 一样，Filter 也可以在<code>web.xml</code>文件里进行配置，不同的是，Filter 的作用域是整个 Web 应用，因此 Filter 的实例是在 Context 容器中进行管理的，Context 容器用 Map 集合来保存 Filter。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">FilterDef</span><span class="token punctuation">&gt;</span></span> filterDefs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>那上面提到的 Filter 链又是什么呢？Filter 链的存活期很短，它是跟每个请求对应的。一个新的请求来了，就动态创建一个 FIlter 链，请求处理完了，Filter 链也就被回收了。理解它的原理也非常关键，我们还是来看看源码：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">ApplicationFilterChain</span> <span class="token keyword">implements</span> <span class="token class-name">FilterChain</span> <span class="token punctuation">{</span>

  <span class="token comment">//Filter 链中有 Filter 数组，这个好理解</span>
  <span class="token keyword">private</span> <span class="token class-name">ApplicationFilterConfig</span><span class="token punctuation">[</span><span class="token punctuation">]</span> filters <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ApplicationFilterConfig</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

  <span class="token comment">//Filter 链中的当前的调用位置</span>
  <span class="token keyword">private</span> <span class="token keyword">int</span> pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

  <span class="token comment">// 总共有多少了 Filter</span>
  <span class="token keyword">private</span> <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

  <span class="token comment">// 每个 Filter 链对应一个 Servlet，也就是它要调用的 Servlet</span>
  <span class="token keyword">private</span> <span class="token class-name">Servlet</span> servlet <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doFilter</span><span class="token punctuation">(</span><span class="token class-name">ServletRequest</span> req<span class="token punctuation">,</span> <span class="token class-name">ServletResponse</span> res<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">internalDoFilter</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">internalDoFilter</span><span class="token punctuation">(</span><span class="token class-name">ServletRequest</span> req<span class="token punctuation">,</span>
                                <span class="token class-name">ServletResponse</span> res<span class="token punctuation">)</span><span class="token punctuation">{</span>

    <span class="token comment">// 每个 Filter 链在内部维护了一个 Filter 数组</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>pos <span class="token operator">&lt;</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">ApplicationFilterConfig</span> filterConfig <span class="token operator">=</span> filters<span class="token punctuation">[</span>pos<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token class-name">Filter</span> filter <span class="token operator">=</span> filterConfig<span class="token punctuation">.</span><span class="token function">getFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        filter<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    servlet<span class="token punctuation">.</span><span class="token function">service</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>
</code></pre></div><p>从 ApplicationFilterChain 的源码我们可以看到几个关键信息：</p> <ul><li>Filter 链中除了有 Filter 对象的数组，还有一个整数变量 pos，这个变量用来记录当前被调用的 Filter 在数组中的位置。</li> <li>Filter 链中有个 Servlet 实例，这个好理解，因为上面提到了，每个 Filter 链最后都会调到一个 Servlet。</li> <li>Filter 链本身也实现了 doFilter 方法，直接调用了一个内部方法 internalDoFilter。</li> <li>internalDoFilter 方法的实现比较有意思，它做了一个判断，如果当前 Filter 的位置小于 Filter 数组的长度，也就是说 Filter 还没调完，就从 Filter 数组拿下一个 Filter，调用它的 doFilter 方法。否则，意味着所有 Filter 都调到了，就调用 Servlet 的 service 方法。</li></ul> <p>但问题是，方法体里没看到循环，谁在不停地调用 Filter 链的 doFIlter 方法呢？Filter 是怎么依次调到的呢？</p> <p>答案是<strong>Filter 本身的 doFilter 方法会调用 Filter 链的 doFilter 方法</strong>，我们还是来看看代码就明白了：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doFilter</span><span class="token punctuation">(</span><span class="token class-name">ServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">ServletResponse</span> response<span class="token punctuation">,</span>
        <span class="token class-name">FilterChain</span> chain<span class="token punctuation">)</span><span class="token punctuation">{</span>

          <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

          <span class="token comment">// 调用 Filter 的方法</span>
          chain<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">)</span><span class="token punctuation">;</span>

      <span class="token punctuation">}</span>
</code></pre></div><p>注意 Filter 的 doFilter 方法有个关键参数 FilterChain，就是 Filter 链。并且每个 Filter 在实现 doFilter 时，必须要调用 Filter 链的 doFilter 方法，而 Filter 链中保存当前 FIlter 的位置，会调用下一个 FIlter 的 doFilter 方法，这样链式调用就完成了。</p> <p>Filter 链跟 Tomcat 的 Pipeline-Valve 本质都是责任链模式，但是在具体实现上稍有不同，你可以细细体会一下。</p> <h3 id="listener-管理"><a href="#listener-管理" class="header-anchor">#</a> Listener 管理</h3> <p>我们接着聊 Servlet 规范里 Listener。跟 Filter 一样，Listener 也是一种扩展机制，你可以监听容器内部发生的事件，主要有两类事件：</p> <ul><li>第一类是生命状态的变化，比如 Context 容器启动和停止、Session 的创建和销毁。</li> <li>第二类是属性的变化，比如 Context 容器某个属性值变了、Session 的某个属性值变了以及新的请求来了等。</li></ul> <p>我们可以在<code>web.xml</code>配置或者通过注解的方式来添加监听器，在监听器里实现我们的业务逻辑。对于 Tomcat 来说，它需要读取配置文件，拿到监听器类的名字，实例化这些类，并且在合适的时机调用这些监听器的方法。</p> <p>Tomcat 是通过 Context 容器来管理这些监听器的。Context 容器将两类事件分开来管理，分别用不同的集合来存放不同类型事件的监听器：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 监听属性值变化的监听器</span>
<span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> applicationEventListenersList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CopyOnWriteArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 监听生命事件的监听器</span>
<span class="token keyword">private</span> <span class="token class-name">Object</span> applicationLifecycleListenersObjects<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><p>剩下的事情就是触发监听器了，比如在 Context 容器的启动方法里，就触发了所有的 ServletContextListener：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">//1. 拿到所有的生命周期监听器</span>
<span class="token class-name">Object</span> instances<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">getApplicationLifecycleListeners</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> instances<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">//2. 判断 Listener 的类型是不是 ServletContextListener</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>instances<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">instanceof</span> <span class="token class-name">ServletContextListener</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token keyword">continue</span><span class="token punctuation">;</span>

   <span class="token comment">//3. 触发 Listener 的方法</span>
   <span class="token class-name">ServletContextListener</span> lr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">ServletContextListener</span><span class="token punctuation">)</span> instances<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
   lr<span class="token punctuation">.</span><span class="token function">contextInitialized</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>需要注意的是，这里的 ServletContextListener 接口是一种留给用户的扩展机制，用户可以实现这个接口来定义自己的监听器，监听 Context 容器的启停事件。Spring 就是这么做的。ServletContextListener 跟 Tomcat 自己的生命周期事件 LifecycleListener 是不同的。LifecycleListener 定义在生命周期管理组件中，由基类 LifeCycleBase 统一管理。</p> <h2 id="tomcat-支持异步-servlet"><a href="#tomcat-支持异步-servlet" class="header-anchor">#</a> Tomcat 支持异步 Servlet</h2> <h3 id="异步示例"><a href="#异步示例" class="header-anchor">#</a> 异步示例</h3> <div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@WebServlet</span><span class="token punctuation">(</span>urlPatterns <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">&quot;/async&quot;</span><span class="token punctuation">}</span><span class="token punctuation">,</span> asyncSupported <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AsyncServlet</span> <span class="token keyword">extends</span> <span class="token class-name">HttpServlet</span> <span class="token punctuation">{</span>

    <span class="token comment">//Web 应用线程池，用来处理异步 Servlet</span>
    <span class="token class-name">ExecutorService</span> executor <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">service</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> req<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> resp<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//1. 调用 startAsync 或者异步上下文</span>
        <span class="token keyword">final</span> <span class="token class-name">AsyncContext</span> ctx <span class="token operator">=</span> req<span class="token punctuation">.</span><span class="token function">startAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

       <span class="token comment">// 用线程池来执行耗时操作</span>
        executor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

                <span class="token comment">// 在这里做耗时的操作</span>
                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    ctx<span class="token punctuation">.</span><span class="token function">getResponse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Handling Async Servlet&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

                <span class="token comment">//3. 异步 Servlet 处理完了调用异步上下文的 complete 方法</span>
                ctx<span class="token punctuation">.</span><span class="token function">complete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>有三个要点：</p> <ol><li>通过注解的方式来注册 Servlet，除了 @WebServlet 注解，还需要加上 asyncSupported=true 的属性，表明当前的 Servlet 是一个异步 Servlet。</li> <li>Web 应用程序需要调用 Request 对象的 startAsync 方法来拿到一个异步上下文 AsyncContext。这个上下文保存了请求和响应对象。</li> <li>Web 应用需要开启一个新线程来处理耗时的操作，处理完成后需要调用 AsyncContext 的 complete 方法。目的是告诉 Tomcat，请求已经处理完成。</li></ol> <p>这里请你注意，虽然异步 Servlet 允许用更长的时间来处理请求，但是也有超时限制的，默认是 30 秒，如果 30 秒内请求还没处理完，Tomcat 会触发超时机制，向浏览器返回超时错误，如果这个时候你的 Web 应用再调用<code>ctx.complete</code>方法，会得到一个 IllegalStateException 异常。</p> <h3 id="异步-servlet-原理"><a href="#异步-servlet-原理" class="header-anchor">#</a> 异步 Servlet 原理</h3> <p>通过上面的例子，相信你对 Servlet 的异步实现有了基本的理解。要理解 Tomcat 在这个过程都做了什么事情，关键就是要弄清楚<code>req.startAsync</code>方法和<code>ctx.complete</code>方法都做了什么。</p> <h4 id="startasync-方法"><a href="#startasync-方法" class="header-anchor">#</a> startAsync 方法</h4> <p>startAsync 方法其实就是创建了一个异步上下文 AsyncContext 对象，AsyncContext 对象的作用是保存请求的中间信息，比如 Request 和 Response 对象等上下文信息。你来思考一下为什么需要保存这些信息呢？</p> <p>这是因为 Tomcat 的工作线程在<code>Request.startAsync</code>调用之后，就直接结束回到线程池中了，线程本身不会保存任何信息。也就是说一个请求到服务端，执行到一半，你的 Web 应用正在处理，这个时候 Tomcat 的工作线程没了，这就需要有个缓存能够保存原始的 Request 和 Response 对象，而这个缓存就是 AsyncContext。</p> <p>有了 AsyncContext，你的 Web 应用通过它拿到 request 和 response 对象，拿到 Request 对象后就可以读取请求信息，请求处理完了还需要通过 Response 对象将 HTTP 响应发送给浏览器。</p> <p>除了创建 AsyncContext 对象，startAsync 还需要完成一个关键任务，那就是告诉 Tomcat 当前的 Servlet 处理方法返回时，不要把响应发到浏览器，因为这个时候，响应还没生成呢；并且不能把 Request 对象和 Response 对象销毁，因为后面 Web 应用还要用呢。</p> <p>在 Tomcat 中，负责 flush 响应数据的是 CoyoteAdaptor，它还会销毁 Request 对象和 Response 对象，因此需要通过某种机制通知 CoyoteAdaptor，具体来说是通过下面这行代码：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">this</span><span class="token punctuation">.</span>request<span class="token punctuation">.</span><span class="token function">getCoyoteRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">action</span><span class="token punctuation">(</span><span class="token class-name">ActionCode</span><span class="token punctuation">.</span><span class="token constant">ASYNC_START</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>你可以把它理解为一个 Callback，在这个 action 方法里设置了 Request 对象的状态，设置它为一个异步 Servlet 请求。</p> <p>我们知道连接器是调用 CoyoteAdapter 的 service 方法来处理请求的，而 CoyoteAdapter 会调用容器的 service 方法，当容器的 service 方法返回时，CoyoteAdapter 判断当前的请求是不是异步 Servlet 请求，如果是，就不会销毁 Request 和 Response 对象，也不会把响应信息发到浏览器。你可以通过下面的代码理解一下，这是 CoyoteAdapter 的 service 方法，我对它进行了简化：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">service</span><span class="token punctuation">(</span><span class="token class-name"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>coyote<span class="token punctuation">.</span></span>Request</span> req<span class="token punctuation">,</span> <span class="token class-name"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>coyote<span class="token punctuation">.</span></span>Response</span> res<span class="token punctuation">)</span> <span class="token punctuation">{</span>

   <span class="token comment">// 调用容器的 service 方法处理请求</span>
    connector<span class="token punctuation">.</span><span class="token function">getService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getContainer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getPipeline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>
           <span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">)</span><span class="token punctuation">;</span>

   <span class="token comment">// 如果是异步 Servlet 请求，仅仅设置一个标志，</span>
   <span class="token comment">// 否则说明是同步 Servlet 请求，就将响应数据刷到浏览器</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>request<span class="token punctuation">.</span><span class="token function">isAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        async <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        request<span class="token punctuation">.</span><span class="token function">finishRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        response<span class="token punctuation">.</span><span class="token function">finishResponse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

   <span class="token comment">// 如果不是异步 Servlet 请求，就销毁 Request 对象和 Response 对象</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>async<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        request<span class="token punctuation">.</span><span class="token function">recycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        response<span class="token punctuation">.</span><span class="token function">recycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>接下来，当 CoyoteAdaptor 的 service 方法返回到 ProtocolHandler 组件时，ProtocolHandler 判断返回值，如果当前请求是一个异步 Servlet 请求，它会把当前 Socket 的协议处理者 Processor 缓存起来，将 SocketWrapper 对象和相应的 Processor 存到一个 Map 数据结构里。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">S</span><span class="token punctuation">,</span><span class="token class-name">Processor</span><span class="token punctuation">&gt;</span></span> connections <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>之所以要缓存是因为这个请求接下来还要接着处理，还是由原来的 Processor 来处理，通过 SocketWrapper 就能从 Map 里找到相应的 Processor。</p> <h4 id="complete-方法"><a href="#complete-方法" class="header-anchor">#</a> complete 方法</h4> <p>接着我们再来看关键的<code>ctx.complete</code>方法，当请求处理完成时，Web 应用调用这个方法。那么这个方法做了些什么事情呢？最重要的就是把响应数据发送到浏览器。</p> <p>这件事情不能由 Web 应用线程来做，也就是说<code>ctx.complete</code>方法不能直接把响应数据发送到浏览器，因为这件事情应该由 Tomcat 线程来做，但具体怎么做呢？</p> <p>我们知道，连接器中的 Endpoint 组件检测到有请求数据达到时，会创建一个 SocketProcessor 对象交给线程池去处理，因此 Endpoint 的通信处理和具体请求处理在两个线程里运行。</p> <p>在异步 Servlet 的场景里，Web 应用通过调用<code>ctx.complete</code>方法时，也可以生成一个新的 SocketProcessor 任务类，交给线程池处理。对于异步 Servlet 请求来说，相应的 Socket 和协议处理组件 Processor 都被缓存起来了，并且这些对象都可以通过 Request 对象拿到。</p> <p>讲到这里，你可能已经猜到<code>ctx.complete</code>是如何实现的了：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">complete</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 检查状态合法性，我们先忽略这句</span>
    <span class="token function">check</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 调用 Request 对象的 action 方法，其实就是通知连接器，这个异步请求处理完了</span>
request<span class="token punctuation">.</span><span class="token function">getCoyoteRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">action</span><span class="token punctuation">(</span><span class="token class-name">ActionCode</span><span class="token punctuation">.</span><span class="token constant">ASYNC_COMPLETE</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>
</code></pre></div><p>我们可以看到 complete 方法调用了 Request 对象的 action 方法。而在 action 方法里，则是调用了 Processor 的 processSocketEvent 方法，并且传入了操作码 OPEN_READ。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">case</span> <span class="token constant">ASYNC_COMPLETE</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">clearDispatches</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>asyncStateMachine<span class="token punctuation">.</span><span class="token function">asyncComplete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">processSocketEvent</span><span class="token punctuation">(</span><span class="token class-name">SocketEvent</span><span class="token punctuation">.</span><span class="token constant">OPEN_READ</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">break</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们接着看 processSocketEvent 方法，它调用 SocketWrapper 的 processSocket 方法：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">processSocketEvent</span><span class="token punctuation">(</span><span class="token class-name">SocketEvent</span> event<span class="token punctuation">,</span> <span class="token keyword">boolean</span> dispatch<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">SocketWrapperBase</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> socketWrapper <span class="token operator">=</span> <span class="token function">getSocketWrapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>socketWrapper <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        socketWrapper<span class="token punctuation">.</span><span class="token function">processSocket</span><span class="token punctuation">(</span>event<span class="token punctuation">,</span> dispatch<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>而 SocketWrapper 的 processSocket 方法会创建 SocketProcessor 任务类，并通过 Tomcat 线程池来处理：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">processSocket</span><span class="token punctuation">(</span><span class="token class-name">SocketWrapperBase</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">S</span><span class="token punctuation">&gt;</span></span> socketWrapper<span class="token punctuation">,</span>
        <span class="token class-name">SocketEvent</span> event<span class="token punctuation">,</span> <span class="token keyword">boolean</span> dispatch<span class="token punctuation">)</span> <span class="token punctuation">{</span>

      <span class="token keyword">if</span> <span class="token punctuation">(</span>socketWrapper <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>

      <span class="token class-name">SocketProcessorBase</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">S</span><span class="token punctuation">&gt;</span></span> sc <span class="token operator">=</span> processorCache<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>sc <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          sc <span class="token operator">=</span> <span class="token function">createSocketProcessor</span><span class="token punctuation">(</span>socketWrapper<span class="token punctuation">,</span> event<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
          sc<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span>socketWrapper<span class="token punctuation">,</span> event<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// 线程池运行</span>
      <span class="token class-name">Executor</span> executor <span class="token operator">=</span> <span class="token function">getExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>dispatch <span class="token operator">&amp;&amp;</span> executor <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          executor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>sc<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
          sc<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>请你注意 createSocketProcessor 函数的第二个参数是 SocketEvent，这里我们传入的是 OPEN_READ。通过这个参数，我们就能控制 SocketProcessor 的行为，因为我们不需要再把请求发送到容器进行处理，只需要向浏览器端发送数据，并且重新在这个 Socket 上监听新的请求就行了。</p> <h2 id="参考资料"><a href="#参考资料" class="header-anchor">#</a> 参考资料</h2> <ul><li><strong>官方</strong> <ul><li><a href="http://tomcat.apache.org/" target="_blank" rel="noopener noreferrer">Tomcat 官方网站<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="http://wiki.apache.org/tomcat/FrontPage" target="_blank" rel="noopener noreferrer">Tomcat Wiki<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="http://tomee.apache.org/" target="_blank" rel="noopener noreferrer">Tomee 官方网站<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li> <li><strong>教程</strong> <ul><li><a href="https://time.geekbang.org/column/intro/100027701" target="_blank" rel="noopener noreferrer">深入拆解 Tomcat &amp; Jetty<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li></ul></div></div>  <div class="page-edit"><div class="edit-link"><a href="https://github.com/dunwu/java-tutorial/edit/master/docs/01.Java/02.JavaEE/02.服务器/01.Tomcat/03.Tomcat容器.md" target="_blank" rel="noopener noreferrer">📝 帮助改善此页面！</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <div class="tags"><a href="/java-tutorial/tags/?tag=Java" title="标签">#Java</a><a href="/java-tutorial/tags/?tag=JavaWeb" title="标签">#JavaWeb</a><a href="/java-tutorial/tags/?tag=%E6%9C%8D%E5%8A%A1%E5%99%A8" title="标签">#服务器</a><a href="/java-tutorial/tags/?tag=Tomcat" title="标签">#Tomcat</a></div> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2024/12/31, 08:02:35</span></div></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/java-tutorial/pages/13f070/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">Tomcat连接器</div></a> <a href="/java-tutorial/pages/f9e1e6/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">Tomcat优化</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/java-tutorial/pages/13f070/" class="prev">Tomcat连接器</a></span> <span class="next"><a href="/java-tutorial/pages/f9e1e6/">Tomcat优化</a>→
      </span></p></div></div></div> <div class="article-list"><div class="article-title"><a href="/java-tutorial/archives/" class="iconfont icon-bi">最近更新</a></div> <div class="article-wrapper"><dl><dd>01</dd> <dt><a href="/java-tutorial/pages/191cdb/"><div>
            Spring Data 综合
            <!----></div></a> <span class="date">02-08</span></dt></dl><dl><dd>02</dd> <dt><a href="/java-tutorial/pages/65e4a2/"><div>
            Spring 访问 Redis
            <!----></div></a> <span class="date">01-31</span></dt></dl><dl><dd>03</dd> <dt><a href="/java-tutorial/pages/1f743f/"><div>
            Spring EL 表达式
            <!----></div></a> <span class="date">01-12</span></dt></dl> <dl><dd></dd> <dt><a href="/java-tutorial/archives/" class="more">更多文章&gt;</a></dt></dl></div></div></main></div> <div class="footer"><div class="icons"><a href="mailto:forbreak@163.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/dunwu" title="GitHub" target="_blank" class="iconfont icon-github"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2019-2024
    <span>钝悟（dunwu） | CC-BY-SA-4.0</span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <div class="custom-html-window custom-html-window-rb" style="display:;"><div class="custom-wrapper"><span class="close-but">×</span> <div>
    <div class="wwads-cn wwads-vertical windowRB" data-id="261" style="max-width:160px;
    min-width: auto;min-height:auto;"></div>
    <style>
      .windowRB{ padding: 0;}
      .windowRB .wwads-img{margin-top: 10px;}
      .windowRB .wwads-content{margin: 0 10px 40px 10px;}
      .custom-html-window-rb .close-but{
        display: none;
      }
    </style>
  </div></div></div></div><div class="global-ui"></div></div>
    <script src="/java-tutorial/assets/js/app.daf69751.js" defer></script><script src="/java-tutorial/assets/js/2.bc9223e0.js" defer></script><script src="/java-tutorial/assets/js/13.581f93fb.js" defer></script>
  </body>
</html>
